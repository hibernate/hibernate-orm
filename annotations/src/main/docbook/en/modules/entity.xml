<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ Hibernate, Relational Persistence for Idiomatic Java
  ~
  ~ Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat Middleware LLC.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="entity">
  <title>Entity Beans</title>

  <sect1 id="entity-overview" revision="2">
    <title>Intro</title>

    <para>This section covers Java Persistence 2.0 mapping annotations as well
    as Hibernate-specific extensions.</para>
  </sect1>

  <sect1 id="entity-mapping" revision="2">
    <title>Mapping with EJB3/JPA Annotations</title>

    <para>EJB3 entities are plain POJOs. Actually they represent the exact
    same concept as the Hibernate persistent entities. Their mappings are
    defined through JDK 5.0 annotations (an XML descriptor syntax for
    overriding is defined in the EJB3 specification). Annotations can be split
    in two categories, the logical mapping annotations (allowing you to
    describe the object model, the class associations, etc.) and the physical
    mapping annotations (describing the physical schema, tables, columns,
    indexes, etc). We will mix annotations from both categories in the
    following code examples.</para>

    <para>EJB3 annotations are in the <literal>javax.persistence.*</literal>
    package. Most JDK 5 compliant IDE (like Eclipse, IntelliJ IDEA and
    Netbeans) can autocomplete annotation interfaces and attributes for you
    (even without a specific "EJB3" module, since EJB3 annotations are plain
    JDK 5 annotations).</para>

    <para>For more and runnable concrete examples read the JBoss EJB 3.0
    tutorial or review the Hibernate Annotations test suite. Most of the unit
    tests have been designed to represent a concrete example and be a
    inspiration source.</para>

    <sect2 id="entity-mapping-entity">
      <title>Declaring an entity bean</title>

      <para>Every bound persistent POJO class is an entity bean and is
      declared using the <literal>@Entity</literal> annotation (at the class
      level):</para>

      <programlisting>
@Entity
public class Flight implements Serializable {
    Long id;

    @Id
    public Long getId() { return id; }

    public void setId(Long id) { this.id = id; }
}
         </programlisting>

      <para><literal>@Entity</literal> declares the class as an entity bean
      (i.e. a persistent POJO class), <literal>@Id</literal> declares the
      identifier property of this entity bean. The other mapping declarations
      are implicit. This configuration by exception concept is central to the
      new EJB3 specification and a major improvement. The class Flight is
      mapped to the Flight table, using the column id as its primary key
      column.</para>

      <para>Depending on whether you annotate fields or methods, the access
      type used by Hibernate will be <literal>field</literal> or
      <literal>property</literal>. The EJB3 spec requires that you declare
      annotations on the element type that will be accessed, i.e. the getter
      method if you use <literal>property</literal> access, the field if you
      use <literal>field</literal> access. Mixing EJB3 annotations in both
      fields and methods should be avoided. Hibernate will guess the access
      type from the position of <literal>@Id</literal> or
      <literal>@EmbeddedId</literal>.</para>

      <sect3>
        <title>Defining the table</title>

        <para><literal>@Table</literal> is set at the class level; it allows
        you to define the table, catalog, and schema names for your entity
        bean mapping. If no <literal>@Table</literal> is defined the default
        values are used: the unqualified class name of the entity.</para>

        <programlisting>
@Entity
@Table(name="tbl_sky")
public class Sky implements Serializable {
...
            </programlisting>

        <para>The <literal>@Table</literal> element also contains a
        <literal>schema</literal> and a <literal>catalog</literal> attributes,
        if they need to be defined. You can also define unique constraints to
        the table using the <literal>@UniqueConstraint</literal> annotation in
        conjunction with <literal>@Table</literal> (for a unique constraint
        bound to a single column, refer to <literal>@Column</literal>).</para>

        <programlisting>@Table(name="tbl_sky",
    <emphasis role="bold">uniqueConstraints = {@UniqueConstraint(columnNames={"month", "day"})}</emphasis>
)</programlisting>

        <para>A unique constraint is applied to the tuple month, day. Note
        that the <literal>columnNames</literal> array refers to the logical
        column names.</para>

        <remark>The logical column name is defined by the Hibernate
        NamingStrategy implementation. The default EJB3 naming strategy use
        the physical column name as the logical column name. Note that this
        may be different than the property name (if the column name is
        explicit). Unless you override the NamingStrategy, you shouldn't worry
        about that.</remark>
      </sect3>

      <sect3 id="entity-mapping-entity-version" revision="1">
        <title>Versioning for optimistic locking</title>

        <para>You can add optimistic locking capability to an entity bean
        using the <literal>@Version</literal> annotation:</para>

        <programlisting>
@Entity
public class Flight implements Serializable {
...
    @Version
    @Column(name="OPTLOCK")
    public Integer getVersion() { ... }
}           </programlisting>

        <para>The version property will be mapped to the
        <literal>OPTLOCK</literal> column, and the entity manager will use it
        to detect conflicting updates (preventing lost updates you might
        otherwise see with the last-commit-wins strategy).</para>

        <para>The version column may be a numeric (the recommended solution)
        or a timestamp as per the EJB3 spec. Hibernate support any kind of
        type provided that you define and implement the appropriate
        <classname>UserVersionType</classname>.</para>

        <para>The application must not alter the version number set up by
        Hibernate in any way. To artificially increase the version number,
        check in Hibernate Entity Manager's reference documentation
        <literal>LockMode.WRITE</literal></para>
      </sect3>
    </sect2>

    <sect2 id="entity-mapping-property" revision="1">
      <title>Mapping simple properties</title>

      <sect3>
        <title>Declaring basic property mappings</title>

        <para>Every non static non transient property (field or method) of an
        entity bean is considered persistent, unless you annotate it as
        <literal>@Transient</literal>. Not having an annotation for your
        property is equivalent to the appropriate <literal>@Basic</literal>
        annotation. The <literal>@Basic</literal> annotation allows you to
        declare the fetching strategy for a property:</para>

        <programlisting>public transient int counter; //transient property

private String firstname; //persistent property

@Transient
String getLengthInMeter() { ... } //transient property

String getName() {... } // persistent property

@Basic
int getLength() { ... } // persistent property

@Basic(fetch = FetchType.LAZY)
String getDetailedComment() { ... } // persistent property

@Temporal(TemporalType.TIME)
java.util.Date getDepartureTime() { ... } // persistent property           

@Enumerated(EnumType.STRING)
Starred getNote() { ... } //enum persisted as String in database</programlisting>

        <para><literal>counter</literal>, a transient field, and
        <literal>lengthInMeter</literal>, a method annotated as
        <literal>@Transient</literal>, and will be ignored by the entity
        manager. <literal>name</literal>, <literal>length</literal>, and
        <literal>firstname</literal> properties are mapped persistent and
        eagerly fetched (the default for simple properties). The
        <literal>detailedComment</literal> property value will be lazily
        fetched from the database once a lazy property of the entity is
        accessed for the first time. Usually you don't need to lazy simple
        properties (not to be confused with lazy association fetching).</para>

        <note>
          <para>To enable property level lazy fetching, your classes have to
          be instrumented: bytecode is added to the original one to enable
          such feature, please refer to the Hibernate reference documentation.
          If your classes are not instrumented, property level lazy loading is
          silently ignored.</para>
        </note>

        <para>The recommended alternative is to use the projection capability
        of EJB-QL or Criteria queries.</para>

        <para>EJB3 support property mapping of all basic types supported by
        Hibernate (all basic Java types , their respective wrappers and
        serializable classes). Hibernate Annotations support out of the box
        Enum type mapping either into a ordinal column (saving the enum
        ordinal) or a string based column (saving the enum string
        representation): the persistence representation, defaulted to ordinal,
        can be overriden through the <literal>@Enumerated</literal> annotation
        as shown in the <literal>note</literal> property example.</para>

        <para>In core Java APIs, the temporal precision is not defined. When
        dealing with temporal data you might want to describe the expected
        precision in database. Temporal data can have <literal>DATE</literal>,
        <literal>TIME</literal>, or <literal>TIMESTAMP</literal> precision (ie
        the actual date, only the time, or both). Use the
        <literal>@Temporal</literal> annotation to fine tune that.</para>

        <para><literal>@Lob</literal> indicates that the property should be
        persisted in a Blob or a Clob depending on the property type:
        <classname>java.sql.Clob</classname>,
        <classname>Character[]</classname>, <classname>char[]</classname> and
        java.lang.<classname>String</classname> will be persisted in a Clob.
        <classname>java.sql.Blob</classname>, <classname>Byte[]</classname>,
        <classname>byte[] </classname>and serializable type will be persisted
        in a Blob.</para>

        <programlisting>
@Lob
public String getFullText() {
    return fullText;
}

@Lob 
public byte[] getFullCode() {
    return fullCode;
}
 </programlisting>

        <para>If the property type implements
        <classname>java.io.Serializable</classname> and is not a basic type,
        and if the property is not annotated with <literal>@Lob</literal>,
        then the Hibernate <literal>serializable</literal> type is
        used.</para>
      </sect3>

      <sect3 id="entity-mapping-property-column" revision="1">
        <title>Declaring column attributes</title>

        <para>The column(s) used for a property mapping can be defined using
        the <literal>@Column</literal> annotation. Use it to override default
        values (see the EJB3 specification for more information on the
        defaults). You can use this annotation at the property level for
        properties that are:</para>

        <itemizedlist>
          <listitem>
            <para>not annotated at all</para>
          </listitem>

          <listitem>
            <para>annotated with <literal>@Basic</literal></para>
          </listitem>

          <listitem>
            <para>annotated with <literal>@Version</literal></para>
          </listitem>

          <listitem>
            <para>annotated with <literal>@Lob</literal></para>
          </listitem>

          <listitem>
            <para>annotated with <literal>@Temporal</literal></para>
          </listitem>

          <listitem>
            <para>annotated with
            <literal>@org.hibernate.annotations.CollectionOfElements</literal>
            (for Hibernate only)</para>
          </listitem>
        </itemizedlist>

        <programlisting>
@Entity
public class Flight implements Serializable {
...
@Column(updatable = false, name = "flight_name", nullable = false, length=50)
public String getName() { ... }
            </programlisting>

        <para>The <literal>name</literal> property is mapped to the
        <literal>flight_name</literal> column, which is not nullable, has a
        length of 50 and is not updatable (making the property
        immutable).</para>

        <para>This annotation can be applied to regular properties as well as
        <literal>@Id</literal> or <literal>@Version</literal>
        properties.</para>

        <programlistingco>
          <areaspec>
            <area coords="2 55" id="hm1" />

            <area coords="3 55" id="hm2" />

            <area coords="4 55" id="hm3" />

            <area coords="5 55" id="hm4" />

            <area coords="6 55" id="hm5" />

            <area coords="7 55" id="hm6" />

            <area coords="8 55" id="hm7" />

            <area coords="9 55" id="hm8" />

            <area coords="10 55" id="hm9" />

            <area coords="11 55" id="hm10" />
          </areaspec>

          <programlisting>@Column(
    name="columnName";
    boolean unique() default false;
    boolean nullable() default true;
    boolean insertable() default true;
    boolean updatable() default true;
    String columnDefinition() default "";
    String table() default "";
    int length() default 255;
    int precision() default 0; // decimal precision
    int scale() default 0; // decimal scale</programlisting>

          <calloutlist>
            <callout arearefs="hm1">
              <para><literal>name</literal> (optional): the column name
              (default to the property name)</para>
            </callout>

            <callout arearefs="hm2">
              <para><literal>unique</literal> (optional): set a unique
              constraint on this column or not (default false)</para>
            </callout>

            <callout arearefs="hm3">
              <para><literal>nullable</literal> (optional): set the column as
              nullable (default true).</para>
            </callout>

            <callout arearefs="hm4">
              <para><literal>insertable</literal> (optional): whether or not
              the column will be part of the insert statement (default
              true)</para>
            </callout>

            <callout arearefs="hm5">
              <para><literal>updatable</literal> (optional): whether or not
              the column will be part of the update statement (default
              true)</para>
            </callout>

            <callout arearefs="hm6">
              <para><literal>columnDefinition</literal> (optional): override
              the sql DDL fragment for this particular column (non
              portable)</para>
            </callout>

            <callout arearefs="hm7">
              <para><literal>table</literal> (optional): define the targeted
              table (default primary table)</para>
            </callout>

            <callout arearefs="hm8">
              <para><literal><literal>length</literal></literal> (optional):
              column length (default 255)</para>
            </callout>

            <callout arearefs="hm8">
              <para><literal><literal>precision</literal></literal>
              (optional): column decimal precision (default 0)</para>
            </callout>

            <callout arearefs="hm10">
              <para><literal><literal>scale</literal></literal> (optional):
              column decimal scale if useful (default 0)</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </sect3>

      <sect3>
        <title>Embedded objects (aka components)</title>

        <para>It is possible to declare an embedded component inside an entity
        and even override its column mapping. Component classes have to be
        annotated at the class level with the <literal>@Embeddable</literal>
        annotation. It is possible to override the column mapping of an
        embedded object for a particular entity using the
        <literal>@Embedded</literal> and <literal>@AttributeOverride</literal>
        annotation in the associated property:</para>

        <programlisting>
@Entity
public class Person implements Serializable {

    // Persistent component using defaults
    Address homeAddress;

    @Embedded
    @AttributeOverrides( {
            @AttributeOverride(name="iso2", column = @Column(name="bornIso2") ),
            @AttributeOverride(name="name", column = @Column(name="bornCountryName") )
    } )
    Country bornIn;
    ...
}
            </programlisting>

        <programlisting>
@Embeddable
public class Address implements Serializable {
    String city;
    Country nationality; //no overriding here
}
            </programlisting>

        <programlisting>
@Embeddable
public class Country implements Serializable {
    private String iso2;
    @Column(name="countryName") private String name;

    public String getIso2() { return iso2; }
    public void setIso2(String iso2) { this.iso2 = iso2; }

    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    ...
}
            </programlisting>

        <para>An embeddable object inherits the access type of its owning
        entity (note that you can override that using
        <literal>@Access</literal> or the Hibernate specific
        <literal>@AccessType</literal> annotation.</para>

        <para>The <literal>Person</literal> entity bean has two component
        properties, <literal>homeAddress</literal> and
        <literal>bornIn</literal>. <literal>homeAddress</literal> property has
        not been annotated, but Hibernate will guess that it is a persistent
        component by looking for the <literal>@Embeddable</literal> annotation
        in the Address class. We also override the mapping of a column name
        (to <literal>bornCountryName</literal>) with the
        <literal>@Embedded</literal> and <literal>@AttributeOverride
        </literal>annotations for each mapped attribute of
        <literal>Country</literal>. As you can see, <literal>Country
        </literal>is also a nested component of <literal>Address</literal>,
        again using auto-detection by Hibernate and EJB3 defaults. Overriding
        columns of embedded objects of embedded objects is currently not
        supported in the EJB3 spec, however, Hibernate Annotations supports it
        through dotted expressions.</para>

        <para><programlisting>    @Embedded
    @AttributeOverrides( {
            @AttributeOverride(name="city", column = @Column(name="fld_city") ),
            @AttributeOverride(name="<emphasis role="bold">nationality.iso2</emphasis>", column = @Column(name="nat_Iso2") ),
            @AttributeOverride(name="<emphasis role="bold">nationality.name</emphasis>", column = @Column(name="nat_CountryName") )
            //nationality columns in homeAddress are overridden
    } )
    Address homeAddress;</programlisting>Hibernate Annotations supports one
        more feature that is not explicitly supported by the EJB3
        specification. You can annotate a embedded object with the
        <literal>@MappedSuperclass</literal> annotation to make the superclass
        properties persistent (see <literal>@MappedSuperclass</literal> for
        more informations).</para>

        <para>While not supported by the EJB3 specification, Hibernate
        Annotations allows you to use association annotations in an embeddable
        object (ie <literal>@*ToOne</literal> nor
        <literal>@*ToMany</literal>). To override the association columns you
        can use <literal>@AssociationOverride</literal>.</para>

        <para>If you want to have the same embeddable object type twice in the
        same entity, the column name defaulting will not work: at least one of
        the columns will have to be explicit. Hibernate goes beyond the EJB3
        spec and allows you to enhance the defaulting mechanism through the
        <classname>NamingStrategy</classname>.
        <classname>DefaultComponentSafeNamingStrategy</classname> is a small
        improvement over the default EJB3NamingStrategy that allows embedded
        objects to be defaulted even if used twice in the same entity.</para>
      </sect3>

      <sect3>
        <title>Non-annotated property defaults</title>

        <para>If a property is not annotated, the following rules
        apply:</para>

        <itemizedlist>
          <listitem>
             If the property is of a single type, it is mapped as @Basic 
          </listitem>

          <listitem>
             Otherwise, if the type of the property is annotated as @Embeddable, it is mapped as @Embedded 
          </listitem>

          <listitem>
             Otherwise, if the type of the property is Serializable, it is mapped as @Basic in a column holding the object in its serialized version 
          </listitem>

          <listitem>
             Otherwise, if the type of the property is java.sql.Clob or java.sql.Blob, it is mapped as @Lob with the appropriate LobType 
          </listitem>
        </itemizedlist>
      </sect3>
    </sect2>

    <sect2 id="entity-mapping-identifier" label=""
           xreflabel="Mapping identifier properties">
      <title>Mapping identifier properties</title>

      <para>The <literal>@Id</literal> annotation lets you define which
      property is the identifier of your entity bean. This property can be set
      by the application itself or be generated by Hibernate (preferred). You
      can define the identifier generation strategy thanks to the
      <literal>@GeneratedValue</literal> annotation:</para>

      <itemizedlist>
        <listitem>
           AUTO - either identity column, sequence or table depending on the underlying DB 
        </listitem>

        <listitem>
           TABLE - table holding the id 
        </listitem>

        <listitem>
           IDENTITY - identity column 
        </listitem>

        <listitem>
           SEQUENCE - sequence 
        </listitem>
      </itemizedlist>

      <para>Hibernate provides more id generators than the basic EJB3 ones.
      Check <xref linkend="entity-hibspec" /> for more informations.</para>

      <para>The following example shows a sequence generator using the
      SEQ_STORE configuration (see below)</para>

      <programlisting>
@Id @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="SEQ_STORE")
public Integer getId() { ... }
         </programlisting>

      <para>The next example uses the identity generator:</para>

      <programlisting>
@Id @GeneratedValue(strategy=GenerationType.IDENTITY)
public Long getId() { ... }
         </programlisting>

      <para>The <literal>AUTO</literal> generator is the preferred type for
      portable applications (across several DB vendors). The identifier
      generation configuration can be shared for several
      <literal>@Id</literal> mappings with the generator attribute. There are
      several configurations available through
      <literal>@SequenceGenerator</literal> and
      <literal>@TableGenerator</literal>. The scope of a generator can be the
      application or the class. Class-defined generators are not visible
      outside the class and can override application level generators.
      Application level generators are defined at XML level (see <xref
      linkend="xml-overriding" />):</para>

      <programlisting>&lt;table-generator name="EMP_GEN"
            table="GENERATOR_TABLE"
            pk-column-name="key"
            value-column-name="hi"
            pk-column-value="EMP"
            allocation-size="20"/&gt;

//and the annotation equivalent

@javax.persistence.TableGenerator(
    name="EMP_GEN",
    table="GENERATOR_TABLE",
    pkColumnName = "key",
    valueColumnName = "hi"
    pkColumnValue="EMP",
    allocationSize=20
)

&lt;sequence-generator name="SEQ_GEN" 
    sequence-name="my_sequence"
    allocation-size="20"/&gt;

//and the annotation equivalent

@javax.persistence.SequenceGenerator(
    name="SEQ_GEN",
    sequenceName="my_sequence",
    allocationSize=20
)
         </programlisting>

      <para>If JPA XML (like <filename>META-INF/orm.xml</filename>) is used to
      define thegenerators, <literal>EMP_GEN</literal> and
      <literal>SEQ_GEN</literal> are application level generators.
      <literal>EMP_GEN</literal> defines a table based id generator using the
      hilo algorithm with a <literal>max_lo</literal> of 20. The hi value is
      kept in a <literal>table</literal> "<literal>GENERATOR_TABLE</literal>".
      The information is kept in a row where <literal>pkColumnName</literal>
      "key" is equals to <literal>pkColumnValue</literal>
      "<literal>EMP</literal>" and column <literal>valueColumnName</literal>
      "<literal>hi</literal>" contains the the next high value used.</para>

      <para><literal>SEQ_GEN</literal> defines a sequence generator using a
      sequence named <literal>my_sequence</literal>. The allocation size used
      for this sequence based hilo algorithm is 20. Note that this version of
      Hibernate Annotations does not handle <literal>initialValue</literal> in
      the sequence generator. The default allocation size is 50, so if you
      want to use a sequence and pickup the value each time, you must set the
      allocation size to 1.</para>

      <note>
        <para>Package level definition is no longer supported by the EJB 3.0
        specification. However, you can use the
        <literal>@GenericGenerator</literal> at the package level (see <xref
        linkend="entity-hibspec-identifier" />).</para>
      </note>

      <para>The next example shows the definition of a sequence generator in a
      class scope:</para>

      <programlisting>
@Entity
@javax.persistence.SequenceGenerator(
    name="SEQ_STORE",
    sequenceName="my_sequence"
)
public class Store implements Serializable {
    private Long id;

    @Id @GeneratedValue(strategy=GenerationType.SEQUENCE, generator="SEQ_STORE")
    public Long getId() { return id; }
}
         </programlisting>

      <para>This class will use a sequence named my_sequence and the SEQ_STORE
      generator is not visible in other classes. Note that you can check the
      Hibernate Annotations tests in the
      <package>org.hibernate.test.annotations.id</package> package for more
      examples.</para>

      <para>You can define a composite primary key through several
      syntaxes:</para>

      <itemizedlist>
        <listitem>
           annotate the component property as @Id and make the component class @Embeddable 
        </listitem>

        <listitem>
           annotate the component property as @EmbeddedId 
        </listitem>

        <listitem>
           annotate the class as @IdClass and annotate each property of the entity involved in the primary key with @Id 
        </listitem>
      </itemizedlist>

      <para>While quite common to the EJB2 developer,
      <literal>@IdClass</literal> is likely new for Hibernate users. The
      composite primary key class corresponds to multiple fields or properties
      of the entity class, and the names of primary key fields or properties
      in the primary key class and those of the entity class must match and
      their types must be the same. Let's look at an example:</para>

      <programlisting>@Entity
<emphasis role="bold">@IdClass(FootballerPk.class)</emphasis>
public class Footballer {
    //part of the id key
    <emphasis role="bold">@Id</emphasis> public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    //part of the id key
    <emphasis role="bold">@Id</emphasis> public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }

    public String getClub() {
        return club;
    }

    public void setClub(String club) {
        this.club = club;
    }

    //appropriate equals() and hashCode() implementation
}

@Embeddable
public class FootballerPk implements Serializable {
    //same name and type as in Footballer
    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    //same name and type as in Footballer
    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }

    //appropriate equals() and hashCode() implementation
}
</programlisting>

      <para>As you may have seen, <literal>@IdClass</literal> points to the
      corresponding primary key class.</para>

      <para>While not supported by the EJB3 specification, Hibernate allows
      you to define associations inside a composite identifier. Simply use the
      regular annotations for that</para>

      <programlisting>@Entity
@AssociationOverride( name="id.channel", joinColumns = @JoinColumn(name="chan_id") )
public class TvMagazin {
    @EmbeddedId public TvMagazinPk id;
    @Temporal(TemporalType.TIME) Date time;
}

@Embeddable
public class TvMagazinPk implements Serializable {
    @ManyToOne
    public Channel channel;
    public String name;
    @ManyToOne
    public Presenter presenter;
}
</programlisting>
    </sect2>

    <sect2>
      <title>Mapping inheritance</title>

      <para>EJB3 supports the three types of inheritance:</para>

      <itemizedlist>
        <listitem>
           Table per Class Strategy: the &lt;union-class&gt; element in Hibernate 
        </listitem>

        <listitem>
           Single Table per Class Hierarchy Strategy: the &lt;subclass&gt; element in Hibernate 
        </listitem>

        <listitem>
           Joined Subclass Strategy: the &lt;joined-subclass&gt; element in Hibernate 
        </listitem>
      </itemizedlist>

      <para>The chosen strategy is declared at the class level of the top
      level entity in the hierarchy using the <literal>@Inheritance</literal>
      annotation.</para>

      <note>
        <para>Annotating interfaces is currently not supported.</para>
      </note>

      <sect3>
        <title>Table per class</title>

        <para>This strategy has many drawbacks (esp. with polymorphic queries
        and associations) explained in the EJB3 spec, the Hibernate reference
        documentation, Hibernate in Action, and many other places. Hibernate
        work around most of them implementing this strategy using <literal>SQL
        UNION</literal> queries. It is commonly used for the top level of an
        inheritance hierarchy:</para>

        <programlisting>
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class Flight implements Serializable {
            </programlisting>

        <para>This strategy support one to many associations provided that
        they are bidirectional. This strategy does not support the
        <literal>IDENTITY</literal> generator strategy: the id has to be
        shared across several tables. Consequently, when using this strategy,
        you should not use <literal>AUTO </literal>nor
        <literal>IDENTITY</literal>.</para>
      </sect3>

      <sect3>
        <title>Single table per class hierarchy</title>

        <para>All properties of all super- and subclasses are mapped into the
        same table, instances are distinguished by a special discriminator
        column:</para>

        <programlisting>
@Entity
@Inheritance(strategy=InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(
    name="planetype",
    discriminatorType=DiscriminatorType.STRING
)
@DiscriminatorValue("Plane")
public class Plane { ... }

@Entity
@DiscriminatorValue("A320")
public class A320 extends Plane { ... }
            </programlisting>

        <para><classname>Plane</classname> is the superclass, it defines the
        inheritance strategy <literal>InheritanceType.SINGLE_TABLE</literal>.
        It also defines the discriminator column through the
        <literal>@DiscriminatorColumn</literal> annotation, a discriminator
        column can also define the discriminator type. Finally, the
        <literal>@DiscriminatorValue</literal> annotation defines the value
        used to differentiate a class in the hierarchy. All of these
        attributes have sensible default values. The default name of the
        discriminator column is <literal>DTYPE</literal>. The default
        discriminator value is the entity name (as defined in
        <literal>@Entity.name</literal>) for DiscriminatorType.STRING.
        <classname>A320</classname> is a subclass; you only have to define
        discriminator value if you don't want to use the default value. The
        strategy and the discriminator type are implicit.</para>

        <para><literal>@Inheritance</literal> and
        <literal>@DiscriminatorColumn</literal> should only be defined at the
        top of the entity hierarchy.</para>
      </sect3>

      <sect3>
        <title>Joined subclasses</title>

        <para>The<literal> @PrimaryKeyJoinColumn</literal> and
        <literal>@PrimaryKeyJoinColumns</literal> annotations define the
        primary key(s) of the joined subclass table:</para>

        <programlisting>
@Entity
@Inheritance(strategy=InheritanceType.JOINED)
public class Boat implements Serializable { ... }

@Entity
public class Ferry extends Boat { ... }

@Entity
@PrimaryKeyJoinColumn(name="BOAT_ID")
public class AmericaCupClass  extends Boat { ... }
            </programlisting>

        <para>All of the above entities use the <literal>JOINED</literal>
        strategy, the <literal>Ferry</literal> table is joined with the
        <literal>Boat</literal> table using the same primary key names. The
        <literal>AmericaCupClass</literal> table is joined with
        <literal>Boat</literal> using the join condition <code>Boat.id =
        AmericaCupClass.BOAT_ID</code>.</para>
      </sect3>

      <sect3>
        <title>Inherit properties from superclasses</title>

        <para>This is sometimes useful to share common properties through a
        technical or a business superclass without including it as a regular
        mapped entity (ie no specific table for this entity). For that purpose
        you can map them as <literal>@MappedSuperclass</literal>.</para>

        <programlisting>@MappedSuperclass
public class BaseEntity {
    @Basic
    @Temporal(TemporalType.TIMESTAMP)
    public Date getLastUpdate() { ... }
    public String getLastUpdater() { ... }
    ...
}

@Entity class Order extends BaseEntity {
    @Id public Integer getId() { ... }
    ...
}</programlisting>

        <para>In database, this hierarchy will be represented as an
        <literal>Order</literal> table having the <literal>id</literal>,
        <literal>lastUpdate</literal> and <literal>lastUpdater</literal>
        columns. The embedded superclass property mappings are copied into
        their entity subclasses. Remember that the embeddable superclass is
        not the root of the hierarchy though.</para>

        <note>
          <para>Properties from superclasses not mapped as
          <literal>@MappedSuperclass</literal> are ignored.</para>
        </note>

        <note>
          <para>The default access type (field or methods) is used, unless you
          use the <literal>@Access</literal> or
          <literal>@AccessType</literal></para>
        </note>

        <note>
          <para>The same notion can be applied to
          <literal>@Embeddable</literal> objects to persist properties from
          their superclasses. You also need to use
          <literal>@MappedSuperclass</literal> to do that (this should not be
          considered as a standard EJB3 feature though)</para>
        </note>

        <note>
          <para>It is allowed to mark a class as
          <literal>@MappedSuperclass</literal> in the middle of the mapped
          inheritance hierarchy.</para>
        </note>

        <note>
          <para>Any class in the hierarchy non annotated with
          <literal>@MappedSuperclass</literal> nor <literal>@Entity</literal>
          will be ignored.</para>
        </note>

        <para>You can override columns defined in entity superclasses at the
        root entity level using the <literal>@AttributeOverride</literal>
        annotation.</para>

        <programlisting>@MappedSuperclass
public class FlyingObject implements Serializable {

    public int getAltitude() {
        return altitude;
    }

    @Transient
    public int getMetricAltitude() {
        return metricAltitude;
    }

    @ManyToOne
    public PropulsionType getPropulsion() {
        return metricAltitude;
    }
    ...
}

@Entity
@AttributeOverride( name="altitude", column = @Column(name="fld_altitude") )
@AssociationOverride( name="propulsion", joinColumns = @JoinColumn(name="fld_propulsion_fk") )
public class Plane extends FlyingObject {
    ...
}</programlisting>

        <para>The <literal>altitude</literal> property will be persisted in an
        <literal>fld_altitude</literal> column of table
        <literal>Plane</literal> and the propulsion association will be
        materialized in a <literal>fld_propulsion_fk</literal> foreign key
        column.</para>

        <para>You can define <literal>@AttributeOverride</literal>(s) and
        <literal>@AssociationOverride</literal>(s) on
        <literal>@Entity</literal> classes,
        <literal>@MappedSuperclass</literal> classes and properties pointing
        to an <literal>@Embeddable</literal> object.</para>
      </sect3>
    </sect2>

    <sect2 id="entity-mapping-association">
      <title>Mapping entity bean associations/relationships</title>

      <sect3>
        <title>One-to-one</title>

        <para>You can associate entity beans through a one-to-one relationship
        using <literal>@OneToOne</literal>. There are three cases for
        one-to-one associations: either the associated entities share the same
        primary keys values, a foreign key is held by one of the entities
        (note that this FK column in the database should be constrained unique
        to simulate one-to-one multiplicity), or a association table is used
        to store the link between the 2 entities (a unique constraint has to
        be defined on each fk to ensure the one to one multiplicity)</para>

        <para>First, we map a real one-to-one association using shared primary
        keys:</para>

        <programlisting>
@Entity
public class Body {
    @Id
    public Long getId() { return id; }

    @OneToOne(cascade = CascadeType.ALL)
    @PrimaryKeyJoinColumn
    public Heart getHeart() {
        return heart;
    }
    ...
}
            </programlisting>

        <programlisting>
@Entity
public class Heart {
    @Id
    public Long getId() { ...}
}
            </programlisting>

        <para>The one to one is marked as true by using the
        <literal>@PrimaryKeyJoinColumn</literal> annotation.</para>

        <para>In the following example, the associated entities are linked
        through a foreign key column:</para>

        <programlisting>
@Entity
public class Customer implements Serializable {
    @OneToOne(cascade = CascadeType.ALL)
    <emphasis role="bold">@JoinColumn(name="passport_fk")</emphasis>
    public Passport getPassport() {
        ...
    }

@Entity
public class Passport implements Serializable {
    @OneToOne(<emphasis role="bold">mappedBy = "passport"</emphasis>)
    public Customer getOwner() {
    ...
}
            </programlisting>

        <para>A <classname>Customer</classname> is linked to a
        <classname>Passport</classname>, with a foreign key column named
        <literal>passport_fk</literal> in the <literal>Customer</literal>
        table. The join column is declared with the
        <literal>@JoinColumn</literal> annotation which looks like the
        <literal>@Column</literal> annotation. It has one more parameters
        named <literal>referencedColumnName</literal>. This parameter declares
        the column in the targeted entity that will be used to the join. Note
        that when using
        <literal><literal>referencedColumnName</literal></literal> to a non
        primary key column, the associated class has to be
        <classname>Serializable</classname>. Also note that the
        <literal><literal>referencedColumnName</literal></literal> to a non
        primary key column has to be mapped to a property having a single
        column (other cases might not work).</para>

        <para>The association may be bidirectional. In a bidirectional
        relationship, one of the sides (and only one) has to be the owner: the
        owner is responsible for the association column(s) update. To declare
        a side as <emphasis>not</emphasis> responsible for the relationship,
        the attribute <literal>mappedBy</literal> is used.
        <literal>mappedBy</literal> refers to the property name of the
        association on the owner side. In our case, this is
        <literal>passport</literal>. As you can see, you don't have to (must
        not) declare the join column since it has already been declared on the
        owners side.</para>

        <para>If no <literal>@JoinColumn</literal> is declared on the owner
        side, the defaults apply. A join column(s) will be created in the
        owner table and its name will be the concatenation of the name of the
        relationship in the owner side, <keycap>_</keycap> (underscore), and
        the name of the primary key column(s) in the owned side. In this
        example <literal>passport_id</literal> because the property name is
        <literal>passport</literal> and the column id of <literal>Passport
        </literal>is <literal>id</literal>.</para>

        <para>The third possibility (using an association table) is very
        exotic.</para>

        <programlisting>
@Entity
public class Customer implements Serializable {
    @OneToOne(cascade = CascadeType.ALL)
    <emphasis role="bold">@JoinTable(name = "CustomerPassports",
        joinColumns = @JoinColumn(name="customer_fk"),
        inverseJoinColumns = @JoinColumn(name="passport_fk")</emphasis>
    )
    public Passport getPassport() {
        ...
    }

@Entity
public class Passport implements Serializable {
    @OneToOne(<emphasis role="bold">mappedBy = "passport"</emphasis>)
    public Customer getOwner() {
    ...
}
            </programlisting>

        <para>A <classname>Customer</classname> is linked to a
        <classname>Passport</classname> through a association table named
        <literal>CustomerPassports</literal> ; this association table has a
        foreign key column named <literal>passport_fk</literal> pointing to
        the <literal>Passport</literal> table (materialized by the
        <literal>inverseJoinColumn</literal>, and a foreign key column named
        <literal>customer_fk</literal> pointing to the
        <literal>Customer</literal> table materialized by the
        <literal>joinColumns</literal> attribute.</para>

        <para>You must declare the join table name and the join columns
        explicitly in such a mapping.</para>
      </sect3>

      <sect3>
        <title>Many-to-one</title>

        <para>Many-to-one associations are declared at the property level with
        the annotation <literal>@ManyToOne</literal>:</para>

        <programlisting>
@Entity()
public class Flight implements Serializable {
    <emphasis role="bold">@ManyToOne</emphasis>( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )
    @JoinColumn(name="COMP_ID")
    public Company getCompany() {
        return company;
    }
    ...
}
            </programlisting>

        <para>The <literal>@JoinColumn</literal> attribute is optional, the
        default value(s) is like in one to one, the concatenation of the name
        of the relationship in the owner side, <keycap>_</keycap>
        (underscore), and the name of the primary key column in the owned
        side. In this example <literal>company_id</literal> because the
        property name is <literal>company</literal> and the column id of
        Company is <literal>id</literal>.</para>

        <para><literal>@ManyToOne</literal> has a parameter named
        <literal>targetEntity</literal> which describes the target entity
        name. You usually don't need this parameter since the default value
        (the type of the property that stores the association) is good in
        almost all cases. However this is useful when you want to use
        interfaces as the return type instead of the regular entity.</para>

        <programlisting>
@Entity()
public class Flight implements Serializable {
    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE}, <emphasis
            role="bold">targetEntity=CompanyImpl.class</emphasis> )
    @JoinColumn(name="COMP_ID")
    public Company getCompany() {
        return company;
    }
    ...
}

public interface Company {
    ...
            </programlisting>

        <para>You can alse map a many to one association through an
        association table. This association table described by the
        <literal>@JoinTable</literal> annotation will contains a foreign key
        referencing back the entity table (through
        <literal>@JoinTable.joinColumns</literal>) and a a foreign key
        referencing the target entity table (through
        <literal>@JoinTable.inverseJoinColumns</literal>).</para>

        <programlisting>
@Entity()
public class Flight implements Serializable {
    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )
    <emphasis role="bold">@JoinTable(name="Flight_Company",
        joinColumns = @JoinColumn(name="FLIGHT_ID"),
        inverseJoinColumns = @JoinColumn(name="COMP_ID")
    )</emphasis>
    public Company getCompany() {
        return company;
    }
    ...
}
            </programlisting>
      </sect3>

      <sect3 id="entity-mapping-association-collections" revision="1">
        <title>Collections</title>

        <sect4 id="entity-mapping-association-collections-overview"
               revision="1">
          <title>Overview</title>

          <para>You can map <classname>Collection</classname>,
          <literal>List</literal> (ie ordered lists, not indexed lists),
          <literal>Map</literal> and <classname>Set</classname>. The EJB3
          specification describes how to map an ordered list (ie a list
          ordered at load time) using
          <literal>@javax.persistence.OrderBy</literal> annotation: this
          annotation takes into parameter a list of comma separated (target
          entity) properties to order the collection by (eg <code>firstname
          asc, age desc</code>), if the string is empty, the collection will
          be ordered by id. For true indexed collections, please refer to the
          <xref linkend="entity-hibspec" />. EJB3 allows you to map Maps using
          as a key one of the target entity property using
          <literal>@MapKey(name="myProperty")</literal> (myProperty is a
          property name in the target entity). When using
          <literal>@MapKey</literal> (without property name), the target
          entity primary key is used. The map key uses the same column as the
          property pointed out: there is no additional column defined to hold
          the map key, and it does make sense since the map key actually
          represent a target property. Be aware that once loaded, the key is
          no longer kept in sync with the property, in other words, if you
          change the property value, the key will not change automatically in
          your Java model (for true map support please refers to <xref
          linkend="entity-hibspec" />). Many people confuse
          <literal>&lt;map&gt;</literal> capabilities and
          <literal>@MapKey</literal> ones. These are two different features.
          <literal>@MapKey</literal> still has some limitations, please check
          the forum or the JIRA tracking system for more informations.</para>

          <para>Hibernate has several notions of collections.</para>

          <para></para>

          <table>
            <title>Collections semantics</title>

            <tgroup cols="3">
              <colspec colname="c1" />

              <colspec colname="c2" />

              <colspec colname="c3" colnum="2" />

              <thead>
                <row>
                  <entry>Semantic</entry>

                  <entry>java representation</entry>

                  <entry>annotations</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>Bag semantic</entry>

                  <entry>java.util.List, java.util.Collection</entry>

                  <entry>@org.hibernate.annotations.CollectionOfElements or
                  @OneToMany or @ManyToMany</entry>
                </row>

                <row>
                  <entry>Bag semantic with primary key (withtout the
                  limitations of Bag semantic)</entry>

                  <entry>java.util.List, java.util.Collection</entry>

                  <entry>(@org.hibernate.annotations.CollectionOfElements or
                  @OneToMany or @ManyToMany) and @CollectionId</entry>
                </row>

                <row>
                  <entry>List semantic</entry>

                  <entry>java.util.List</entry>

                  <entry>(@org.hibernate.annotations.CollectionOfElements or
                  @OneToMany or @ManyToMany) and
                  @org.hibernate.annotations.IndexColumn</entry>
                </row>

                <row>
                  <entry>Set semantic</entry>

                  <entry>java.util.Set</entry>

                  <entry>@org.hibernate.annotations.CollectionOfElements or
                  @OneToMany or @ManyToMany</entry>
                </row>

                <row>
                  <entry>Map semantic</entry>

                  <entry>java.util.Map</entry>

                  <entry>(@org.hibernate.annotations.CollectionOfElements or
                  @OneToMany or @ManyToMany) and (nothing or
                  @org.hibernate.annotations.MapKey/MapKeyManyToMany for true
                  map support, OR @javax.persistence.MapKey</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <remark>So specifically, java.util.List collections without
          @org.hibernate.annotations.IndexColumn are going to be considered as
          bags.</remark>

          <para>Collection of primitive, core type or embedded objects is not
          supported by the EJB3 specification. Hibernate Annotations allows
          them however (see <xref linkend="entity-hibspec" />).</para>

          <programlisting>@Entity public class City {
    @OneToMany(mappedBy="city")
    <emphasis role="bold">@OrderBy("streetName")</emphasis>
    public List&lt;Street&gt; getStreets() {
        return streets;
    }
...
}

@Entity public class Street {
    <emphasis role="bold">public String getStreetName()</emphasis> {
        return streetName;
    }

    @ManyToOne
    public City getCity() {
        return city;
    }
    ...
}


@Entity
public class Software {
    @OneToMany(mappedBy="software")
    <emphasis role="bold">@MapKey(name="codeName")</emphasis>
    public Map&lt;String, Version&gt; getVersions() {
        return versions;
    }
...
}

@Entity
@Table(name="tbl_version")
public class Version {
    <emphasis role="bold">public String getCodeName()</emphasis> {...}

    @ManyToOne
    public Software getSoftware() { ... }
...
}</programlisting>

          <para>So <literal>City</literal> has a collection of
          <literal>Street</literal>s that are ordered by
          <literal>streetName</literal> (of <literal>Street</literal>) when
          the collection is loaded. <literal>Software</literal> has a map of
          <literal>Version</literal>s which key is the
          <literal>Version</literal> <literal>codeName</literal>.</para>

          <para>Unless the collection is a generic, you will have to define
          <literal>targetEntity</literal>. This is a annotation attribute that
          take the target entity class as a value.</para>
        </sect4>

        <sect4 id="entity-mapping-association-collection-onetomany"
               revision="2">
          <title>One-to-many</title>

          <para>One-to-many associations are declared at the property level
          with the annotation <literal>@OneToMany</literal>. One to many
          associations may be bidirectional.</para>

          <sect5>
            <title>Bidirectional</title>

            <para>Since many to one are (almost) always the owner side of a
            bidirectional relationship in the EJB3 spec, the one to many
            association is annotated by <literal>@OneToMany( mappedBy=...
            )</literal></para>

            <programlisting>@Entity
public class Troop {
    @OneToMany(mappedBy="troop")
    public Set&lt;Soldier&gt; getSoldiers() {
    ...
}

@Entity
public class Soldier {
    @ManyToOne
    @JoinColumn(name="troop_fk")
    public Troop getTroop() {
    ...
}              </programlisting>

            <para><classname>Troop</classname> has a bidirectional one to many
            relationship with <literal>Soldier</literal> through the
            <literal>troop</literal> property. You don't have to (must not)
            define any physical mapping in the <literal>mappedBy</literal>
            side.</para>

            <para>To map a bidirectional one to many, with the one-to-many
            side as the owning side, you have to remove the
            <literal>mappedBy</literal> element and set the many to one
            <literal>@JoinColumn</literal> as insertable and updatable to
            false. This solution is obviously not optimized and will produce
            some additional UPDATE statements.</para>

            <programlisting>@Entity
public class Troop {
    @OneToMany
    @JoinColumn(name="troop_fk") //we need to duplicate the physical information
    public Set&lt;Soldier&gt; getSoldiers() {
    ...
}

@Entity
public class Soldier {
    @ManyToOne
    @JoinColumn(name="troop_fk", insertable=false, updatable=false)
    public Troop getTroop() {
    ...
}</programlisting>
          </sect5>

          <sect5>
            <title>Unidirectional</title>

            <para>A unidirectional one to many using a foreign key column in
            the owned entity is not that common and not really recommended. We
            strongly advise you to use a join table for this kind of
            association (as explained in the next section). This kind of
            association is described through a
            <literal>@JoinColumn</literal></para>

            <programlisting>
@Entity
public class Customer implements Serializable {
    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="CUST_ID")
    public Set&lt;Ticket&gt; getTickets() {
    ...
}

@Entity
public class Ticket implements Serializable {
    ... //no bidir
}
               </programlisting>

            <para><literal>Customer</literal> describes a unidirectional
            relationship with <literal>Ticket</literal> using the join column
            <literal>CUST_ID</literal>.</para>
          </sect5>

          <sect5>
            <title>Unidirectional with join table</title>

            <para>A unidirectional one to many with join table is much
            preferred. This association is described through an
            <literal>@JoinTable</literal>.</para>

            <programlisting>
@Entity
public class Trainer {
    @OneToMany
    @JoinTable(
            name="TrainedMonkeys",
            joinColumns = @JoinColumn( name="trainer_id"),
            inverseJoinColumns = @JoinColumn( name="monkey_id")
    )
    public Set&lt;Monkey&gt; getTrainedMonkeys() {
    ...
}

@Entity
public class Monkey {
    ... //no bidir
}
               </programlisting>

            <para><literal>Trainer</literal> describes a unidirectional
            relationship with <classname>Monkey</classname> using the join
            table <classname>TrainedMonkeys</classname>, with a foreign key
            <literal>trainer_id</literal> to <literal>Trainer</literal>
            (<literal>joinColumns</literal>) and a foreign key
            <literal>monkey_id</literal> to <literal>Monkey</literal>
            (<literal>inversejoinColumns</literal>).</para>
          </sect5>

          <sect5 id="entity-mapping-association-collection-manytomany-default"
                 revision="1">
            <title>Defaults</title>

            <para>Without describing any physical mapping, a unidirectional
            one to many with join table is used. The table name is the
            concatenation of the owner table name, <keycap>_</keycap>, and the
            other side table name. The foreign key name(s) referencing the
            owner table is the concatenation of the owner table,
            <keycap>_</keycap>, and the owner primary key column(s) name. The
            foreign key name(s) referencing the other side is the
            concatenation of the owner property name, <keycap>_</keycap>, and
            the other side primary key column(s) name. A unique constraint is
            added to the foreign key referencing the other side table to
            reflect the one to many.</para>

            <programlisting>
@Entity
public class Trainer {
    @OneToMany
    public Set&lt;Tiger&gt; getTrainedTigers() {
    ...
}

@Entity
public class Tiger {
    ... //no bidir
}
               </programlisting>

            <para><classname>Trainer</classname> describes a unidirectional
            relationship with <classname>Tiger</classname> using the join
            table <literal>Trainer_Tiger</literal>, with a foreign key
            <literal>trainer_id</literal> to <literal>Trainer</literal> (table
            name, <keycap>_</keycap>, trainer id) and a foreign key
            <literal>trainedTigers_id</literal> to <literal>Monkey</literal>
            (property name, <keycap>_</keycap>, Tiger primary column).</para>
          </sect5>
        </sect4>

        <sect4 id="eentity-mapping-association-collection-manytomany"
               revision="">
          <title>Many-to-many</title>

          <sect5>
            <title>Definition</title>

            <para>A many-to-many association is defined logically using the
            <literal>@ManyToMany</literal> annotation. You also have to
            describe the association table and the join conditions using the
            <literal>@JoinTable</literal> annotation. If the association is
            bidirectional, one side has to be the owner and one side has to be
            the inverse end (ie. it will be ignored when updating the
            relationship values in the association table):</para>

            <programlisting>
@Entity
public class Employer implements Serializable {
    @ManyToMany(
        targetEntity=org.hibernate.test.metadata.manytomany.Employee.class,
        cascade={CascadeType.PERSIST, CascadeType.MERGE}
    )
    @JoinTable(
        name="EMPLOYER_EMPLOYEE",
        joinColumns=@JoinColumn(name="EMPER_ID"),
        inverseJoinColumns=@JoinColumn(name="EMPEE_ID")
    )
    public Collection getEmployees() {
        return employees;
    }
    ...
}
               </programlisting>

            <programlisting>
@Entity
public class Employee implements Serializable {
    @ManyToMany(
        cascade = {CascadeType.PERSIST, CascadeType.MERGE},
        mappedBy = "employees",
        targetEntity = Employer.class
    )
    public Collection getEmployers() {
        return employers;
    }
}
               </programlisting>

            <para>We've already shown the many declarations and the detailed
            attributes for associations. We'll go deeper in the
            <literal>@JoinTable</literal> description, it defines a
            <literal>name</literal>, an array of join columns (an array in
            annotation is defined using { A, B, C }), and an array of inverse
            join columns. The latter ones are the columns of the association
            table which refer to the <classname>Employee</classname> primary
            key (the "other side").</para>

            <para>As seen previously, the other side don't have to (must not)
            describe the physical mapping: a simple
            <literal>mappedBy</literal> argument containing the owner side
            property name bind the two.</para>
          </sect5>

          <sect5>
            <title>Default values</title>

            <para>As any other annotations, most values are guessed in a many
            to many relationship. Without describing any physical mapping in a
            unidirectional many to many the following rules applied. The table
            name is the concatenation of the owner table name,
            <keycap>_</keycap> and the other side table name. The foreign key
            name(s) referencing the owner table is the concatenation of the
            owner table name, <keycap>_</keycap> and the owner primary key
            column(s). The foreign key name(s) referencing the other side is
            the concatenation of the owner property name, <keycap>_</keycap>,
            and the other side primary key column(s). These are the same rules
            used for a unidirectional one to many relationship.</para>

            <programlisting>
@Entity
public class Store {
    @ManyToMany(cascade = CascadeType.PERSIST)
    public Set&lt;City&gt; getImplantedIn() {
        ...
    }
}

@Entity
public class City {
    ... //no bidirectional relationship
}
               </programlisting>

            <para>A <literal>Store_City</literal> is used as the join table.
            The <literal>Store_id</literal> column is a foreign key to the
            <literal>Store</literal> table. The
            <literal>implantedIn_id</literal> column is a foreign key to the
            <literal>City</literal> table.</para>

            <para>Without describing any physical mapping in a bidirectional
            many to many the following rules applied. The table name is the
            concatenation of the owner table name, <keycap>_</keycap> and the
            other side table name. The foreign key name(s) referencing the
            owner table is the concatenation of the other side property name,
            <keycap>_</keycap>, and the owner primary key column(s). The
            foreign key name(s) referencing the other side is the
            concatenation of the owner property name, <keycap>_</keycap>, and
            the other side primary key column(s). These are the same rules
            used for a unidirectional one to many relationship.</para>

            <programlisting>
@Entity
public class Store {
    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
    public Set&lt;Customer&gt; getCustomers() {
        ...
    }
}

@Entity
public class Customer {
    @ManyToMany(mappedBy="customers")
    public Set&lt;Store&gt; getStores() {
        ...
    }
}
               </programlisting>

            <para>A <literal>Store_Customer</literal> is used as the join
            table. The <literal>stores_id</literal> column is a foreign key to
            the <literal>Store</literal> table. The
            <literal>customers_id</literal> column is a foreign key to the
            <literal>Customer</literal> table.</para>
          </sect5>
        </sect4>
      </sect3>

      <sect3 id="entity-mapping-association-cascade">
        <title>Transitive persistence with cascading</title>

        <para>You probably have noticed the <literal>cascade</literal>
        attribute taking an array of <classname>CascadeType</classname> as a
        value. The cascade concept in EJB3 is very is similar to the
        transitive persistence and cascading of operations in Hibernate, but
        with slightly different semantics and cascading types:</para>

        <itemizedlist>
          <listitem>
             CascadeType.PERSIST: cascades the persist (create) operation to associated entities persist() is called or if the entity is managed 
          </listitem>

          <listitem>
             CascadeType.MERGE: cascades the merge operation to associated entities if merge() is called or if the entity is managed 
          </listitem>

          <listitem>
             CascadeType.REMOVE: cascades the remove operation to associated entities if delete() is called 
          </listitem>

          <listitem>
             CascadeType.REFRESH: cascades the refresh operation to associated entities if refresh() is called 
          </listitem>

          <listitem>
             CascadeType.ALL: all of the above 
          </listitem>
        </itemizedlist>

        <note>
          <para>CascadeType.ALL also covers Hibernate specific operations like
          save-update, lock etc... Check <xref
          linkend="entity-hibspec-cascade" /> for more information</para>
        </note>

        <para>Please refer to the chapter 6.3 of the EJB3 specification for
        more information on cascading and create/merge semantics.</para>
      </sect3>

      <sect3 id="entity-mapping-association-fetching" revision="1">
        <title>Association fetching</title>

        <para>You have the ability to either eagerly or lazily fetch
        associated entities. The <literal>fetch</literal> parameter can be set
        to <literal>FetchType.LAZY</literal> or
        <literal>FetchType.EAGER</literal>. <literal>EAGER</literal> will try
        to use an outer join select to retrieve the associated object, while
        <literal>LAZY</literal> will only trigger a select when the associated
        object is accessed for the first time. <literal>@OneToMany</literal>
        and <literal>@ManyToMany</literal> associations are defaulted to
        <literal>LAZY</literal> and <literal>@OneToOne</literal> and
        <literal>@ManyToOne</literal> are defaulted to
        <literal>EAGER</literal>. For more information about static fetching,
        check <xref linkend="entity-hibspec-singleassoc-fetching" />.</para>

        <para>The recommanded approach is to use <literal>LAZY</literal> onn
        all static fetching definitions and override this choice dynamically
        through JPA-QL. JPA-QL has a <literal>fetch</literal> keyword that
        allows you to override laziness when doing a particular query. This is
        very useful to improve performance and is decided on a use case to use
        case basis.</para>
      </sect3>
    </sect2>

    <sect2>
      <title>Mapping composite primary and foreign keys</title>

      <para>Composite primary keys use a embedded class as the primary key
      representation, so you'd use the <literal>@Id</literal> and
      <literal>@Embeddable</literal> annotations. Alternatively, you can use
      the <literal>@EmbeddedId</literal> annotation. Note that the dependent
      class has to be serializable and implements
      <methodname>equals()</methodname>/<methodname>hashCode()</methodname>.
      You can also use <literal>@IdClass</literal> as described in <xref
      linkend="entity-mapping-identifier" />.</para>

      <programlisting>
@Entity
public class RegionalArticle implements Serializable {

    @Id
    public RegionalArticlePk getPk() { ... }
}

@Embeddable
public class RegionalArticlePk implements Serializable { ... }
         </programlisting>

      <para>or alternatively</para>

      <programlisting>
@Entity
public class RegionalArticle implements Serializable {

    @EmbeddedId
    public RegionalArticlePk getPk() { ... }
}

public class RegionalArticlePk implements Serializable { ... }
         </programlisting>

      <para><literal>@Embeddable</literal> inherit the access type of its
      owning entity unless <literal>@Access</literal> or the Hibernate
      specific annotation <literal>@AccessType</literal> is used. Composite
      foreign keys (if not using the default sensitive values) are defined on
      associations using the <literal>@JoinColumns</literal> element, which is
      basically an array of <literal>@JoinColumn</literal>. It is considered a
      good practice to express <literal>referencedColumnNames</literal>
      explicitly. Otherwise, Hibernate will suppose that you use the same
      order of columns as in the primary key declaration.</para>

      <programlisting>
@Entity
public class Parent implements Serializable {
    @Id
    public ParentPk id;
    public int age;

    @OneToMany(cascade=CascadeType.ALL)
    @JoinColumns ({
        @JoinColumn(name="parentCivility", referencedColumnName = "isMale"),
        @JoinColumn(name="parentLastName", referencedColumnName = "lastName"),
        @JoinColumn(name="parentFirstName", referencedColumnName = "firstName")
    })
    public Set&lt;Child&gt; children; //unidirectional
    ...
}
         </programlisting>

      <programlisting>
@Entity
public class Child implements Serializable {
    @Id @GeneratedValue
    public Integer id;

    @ManyToOne
    @JoinColumns ({
        @JoinColumn(name="parentCivility", referencedColumnName = "isMale"),
        @JoinColumn(name="parentLastName", referencedColumnName = "lastName"),
        @JoinColumn(name="parentFirstName", referencedColumnName = "firstName")
    })
    public Parent parent; //unidirectional
}
         </programlisting>

      <programlisting>
@Embeddable
public class ParentPk implements Serializable {
    String firstName;
    String lastName;
    ...
}
         </programlisting>

      <para>Note the explicit usage of the
      <literal>referencedColumnName</literal>.</para>
    </sect2>

    <sect2>
      <title>Mapping secondary tables</title>

      <para>You can map a single entity bean to several tables using the
      <literal>@SecondaryTable</literal> or
      <literal>@SecondaryTables</literal> class level annotations. To express
      that a column is in a particular table, use the <literal>table</literal>
      parameter of <literal>@Column</literal> or
      <literal>@JoinColumn</literal>.</para>

      <programlisting>
@Entity
@Table(name="MainCat")
<emphasis role="bold">@SecondaryTables({
    @SecondaryTable(name="Cat1", pkJoinColumns={
        @PrimaryKeyJoinColumn(name="cat_id", referencedColumnName="id")
    ),
    @SecondaryTable(name="Cat2", uniqueConstraints={@UniqueConstraint(columnNames={"storyPart2"})})
})</emphasis>
public class Cat implements Serializable {

    private Integer id;
    private String name;
    private String storyPart1;
    private String storyPart2;

    @Id @GeneratedValue
    public Integer getId() {
        return id;
    }

    public String getName() {
        return name;
    }
    
    <emphasis role="bold">@Column(table="Cat1")</emphasis>
    public String getStoryPart1() {
        return storyPart1;
    }

    <emphasis role="bold">@Column(table="Cat2")</emphasis>
    public String getStoryPart2() {
        return storyPart2;
    }
</programlisting>

      <para>In this example, <literal>name</literal> will be in
      <literal>MainCat</literal>. <literal>storyPart1</literal> will be in
      <literal>Cat1</literal> and <literal>storyPart2</literal> will be in
      <literal>Cat2</literal>. <literal>Cat1</literal> will be joined to
      <literal>MainCat</literal> using the <literal>cat_id</literal> as a
      foreign key, and <literal>Cat2</literal> using <literal>id</literal> (ie
      the same column name, the <literal>MainCat</literal> id column has).
      Plus a unique constraint on <literal>storyPart2</literal> has been
      set.</para>

      <para>Check out the JBoss EJB 3 tutorial or the Hibernate Annotations
      unit test suite for more examples.</para>
    </sect2>
  </sect1>

  <sect1 id="entity-mapping-query">
    <title>Mapping Queries</title>

    <sect2 id="entity-mapping-query-hql" label="Mapping JPAQL/HQL queries"
           revision="1">
      <title>Mapping JPAQL/HQL queries</title>

      <para>You can map EJBQL/HQL queries using annotations.
      <literal>@NamedQuery</literal> and <literal>@NamedQueries</literal> can
      be defined at the class level or in a JPA XML file. However their
      definitions are global to the session factory/entity manager factory
      scope. A named query is defined by its name and the actual query
      string.</para>

      <programlisting>&lt;entity-mappings&gt;
    &lt;named-query name="plane.getAll"&gt;
        &lt;query&gt;select p from Plane p&lt;/query&gt;
    &lt;/named-query&gt;
    ...
&lt;/entity-mappings&gt;
...

@Entity
@NamedQuery(name="night.moreRecentThan", query="select n from Night n where n.date &gt;= :date")
public class Night {
    ...
}

public class MyDao {
    doStuff() {
        Query q = s.getNamedQuery("night.moreRecentThan");
        q.setDate( "date", aMonthAgo );
        List results = q.list();
        ...
    }
    ...
}
        </programlisting>

      <para>You can also provide some hints to a query through an array of
      <literal>QueryHint</literal> through a <literal>hints</literal>
      attribute.</para>

      <para>The availabe Hibernate hints are</para>

      <para></para>

      <table>
        <title>Query hints</title>

        <tgroup cols="2">
          <thead>
            <colspec colname="c1" />

            <colspec colname="c2" colnum="2" />

            <row>
              <entry>hint</entry>

              <entry colname="c2">description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>org.hibernate.cacheable</entry>

              <entry>Whether the query should interact with the second level
              cache (defualt to false)</entry>
            </row>

            <row>
              <entry>org.hibernate.cacheRegion</entry>

              <entry>Cache region name (default used otherwise)</entry>
            </row>

            <row>
              <entry>org.hibernate.timeout</entry>

              <entry>Query timeout</entry>
            </row>

            <row>
              <entry>org.hibernate.fetchSize</entry>

              <entry>resultset fetch size</entry>
            </row>

            <row>
              <entry>org.hibernate.flushMode</entry>

              <entry>Flush mode used for this query</entry>
            </row>

            <row>
              <entry>org.hibernate.cacheMode</entry>

              <entry>Cache mode used for this query</entry>
            </row>

            <row>
              <entry>org.hibernate.readOnly</entry>

              <entry>Entities loaded by this query should be in read only mode
              or not (default to false)</entry>
            </row>

            <row>
              <entry>org.hibernate.comment</entry>

              <entry>Query comment added to the generated SQL</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect2>

    <sect2 id="entity-mapping-query-native" revision="2">
      <title>Mapping native queries</title>

      <para>You can also map a native query (ie a plain SQL query). To achieve
      that, you need to describe the SQL resultset structure using
      <literal>@SqlResultSetMapping</literal> (or
      <literal>@SqlResultSetMappings</literal> if you plan to define several
      resulset mappings). Like <literal>@NamedQuery</literal>, a
      <literal>@SqlResultSetMapping</literal> can be defined at class level or
      in a JPA XML file. However its scope is global to the
      application.</para>

      <para>As we will see, a <literal>resultSetMapping</literal> parameter is
      defined in <literal>@NamedNativeQuery</literal>, it represents the name
      of a defined <literal>@SqlResultSetMapping</literal>. The resultset
      mapping declares the entities retrieved by this native query. Each field
      of the entity is bound to an SQL alias (or column name). All fields of
      the entity including the ones of subclasses and the foreign key columns
      of related entities have to be present in the SQL query. Field
      definitions are optional provided that they map to the same column name
      as the one declared on the class property.</para>

      <para><programlisting>@NamedNativeQuery(name="night&amp;area", query="select night.id nid, night.night_duration, "
    + " night.night_date, area.id aid, night.area_id, area.name "
    + "from Night night, Area area where night.area_id = area.id", <emphasis
            role="bold">resultSetMapping="joinMapping"</emphasis>)
@SqlResultSetMapping(name="joinMapping", entities={
    @EntityResult(entityClass=org.hibernate.test.annotations.query.Night.class, fields = {
        @FieldResult(name="id", column="nid"),
        @FieldResult(name="duration", column="night_duration"),
        @FieldResult(name="date", column="night_date"),
        @FieldResult(name="area", column="area_id"),
        discriminatorColumn="disc"
    }),
    @EntityResult(entityClass=org.hibernate.test.annotations.query.Area.class, fields = {
        @FieldResult(name="id", column="aid"),
        @FieldResult(name="name", column="name")
    })
    }
)</programlisting></para>

      <para>In the above example, the <literal>night&amp;area</literal> named
      query use the <literal>joinMapping</literal> result set mapping. This
      mapping returns 2 entities, <literal>Night</literal> and
      <literal>Area</literal>, each property is declared and associated to a
      column name, actually the column name retrieved by the query. Let's now
      see an implicit declaration of the property / column.</para>

      <programlisting>@Entity
<emphasis role="bold">@SqlResultSetMapping(name="implicit", entities=@EntityResult(entityClass=org.hibernate.test.annotations.query.SpaceShip.class))
@NamedNativeQuery(name="implicitSample", query="select * from SpaceShip", resultSetMapping="implicit")</emphasis>
public class SpaceShip {
    private String name;
    private String model;
    private double speed;

    @Id
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Column(name="model_txt")
    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }
}</programlisting>

      <para>In this example, we only describe the entity member of the result
      set mapping. The property / column mappings is done using the entity
      mapping values. In this case the <literal>model</literal> property is
      bound to the <literal>model_txt </literal>column. If the association to
      a related entity involve a composite primary key, a
      <literal>@FieldResult</literal> element should be used for each foreign
      key column. The <literal>@FieldResult</literal> name is composed of the
      property name for the relationship, followed by a dot ("."), followed by
      the name or the field or property of the primary key.</para>

      <programlisting>@Entity
@SqlResultSetMapping(name="compositekey",
        entities=@EntityResult(entityClass=org.hibernate.test.annotations.query.SpaceShip.class,
            fields = {
                    @FieldResult(name="name", column = "name"),
                    @FieldResult(name="model", column = "model"),
                    @FieldResult(name="speed", column = "speed"),
<emphasis role="bold">                    @FieldResult(name="captain.firstname", column = "firstn"),
                    @FieldResult(name="captain.lastname", column = "lastn"),</emphasis>
                    @FieldResult(name="dimensions.length", column = "length"),
                    @FieldResult(name="dimensions.width", column = "width")
                    }),
        columns = { @ColumnResult(name = "surface"),
                    @ColumnResult(name = "volume") } )

@NamedNativeQuery(name="compositekey",
    query="select name, model, speed, lname as lastn, fname as firstn, length, width, length * width as surface from SpaceShip", 
    resultSetMapping="compositekey")
} )
public class SpaceShip {
    private String name;
    private String model;
    private double speed;
    private Captain captain;
    private Dimensions dimensions;

    @Id
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @ManyToOne(fetch= FetchType.LAZY)
    @JoinColumns( {
            @JoinColumn(name="fname", referencedColumnName = "firstname"),
            @JoinColumn(name="lname", referencedColumnName = "lastname")
            } )
    public Captain getCaptain() {
        return captain;
    }

    public void setCaptain(Captain captain) {
        this.captain = captain;
    }

    public String getModel() {
        return model;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public double getSpeed() {
        return speed;
    }

    public void setSpeed(double speed) {
        this.speed = speed;
    }

    public Dimensions getDimensions() {
        return dimensions;
    }

    public void setDimensions(Dimensions dimensions) {
        this.dimensions = dimensions;
    }
}

@Entity
@IdClass(Identity.class)
public class Captain implements Serializable {
    private String firstname;
    private String lastname;

    @Id
    public String getFirstname() {
        return firstname;
    }

    public void setFirstname(String firstname) {
        this.firstname = firstname;
    }

    @Id
    public String getLastname() {
        return lastname;
    }

    public void setLastname(String lastname) {
        this.lastname = lastname;
    }
}
</programlisting>

      <note>
        <para>If you look at the dimension property, you'll see that Hibernate
        supports the dotted notation for embedded objects (you can even have
        nested embedded objects). EJB3 implementations do not have to support
        this feature, we do :-)</para>
      </note>

      <para>If you retrieve a single entity and if you use the default
      mapping, you can use the <literal>resultClass</literal> attribute
      instead of <literal>resultSetMapping</literal>:</para>

      <programlisting><emphasis role="bold">@NamedNativeQuery(name="implicitSample", query="select * from SpaceShip", 
    resultClass=SpaceShip.class)</emphasis>
public class SpaceShip {</programlisting>

      <para>In some of your native queries, you'll have to return scalar
      values, for example when building report queries. You can map them in
      the <literal>@SqlResultsetMapping</literal> through
      <literal>@ColumnResult</literal>. You actually can even mix, entities
      and scalar returns in the same native query (this is probably not that
      common though).</para>

      <programlisting><emphasis role="bold">@SqlResultSetMapping(name="scalar", columns=@ColumnResult(name="dimension"))
@NamedNativeQuery(name="scalar", query="select length*width as dimension from SpaceShip", resultSetMapping="scalar")</emphasis></programlisting>

      <para>An other query hint specific to native queries has been
      introduced: <literal>org.hibernate.callable</literal> which can be true
      or false depending on whether the query is a stored procedure or
      not.</para>
    </sect2>
  </sect1>

  <sect1 id="entity-hibspec" xreflabel="Hibernate Annotation Extensions">
    <title>Hibernate Annotation Extensions</title>

    <para>Hibernate 3.1 offers a variety of additional annotations that you
    can mix/match with your EJB 3 entities. They have been designed as a
    natural extension of EJB3 annotations.</para>

    <para>To empower the EJB3 capabilities, hibernate provides specific
    annotations that match hibernate features. The
    <classname>org.hibernate.annotations</classname> package contains all
    these annotations extensions.</para>

    <sect2 id="entity-hibspec-entity" revision="4">
      <title>Entity</title>

      <para>You can fine tune some of the actions done by Hibernate on
      entities beyond what the EJB3 spec offers.</para>

      <para><classname>@org.hibernate.annotations.Entity</classname> adds
      additional metadata that may be needed beyond what is defined in the
      standard <literal>@Entity</literal> <itemizedlist>
          <listitem>
             mutable: whether this entity is mutable or not 
          </listitem>

          <listitem>
             dynamicInsert: allow dynamic SQL for inserts 
          </listitem>

          <listitem>
             dynamicUpdate: allow dynamic SQL for updates 
          </listitem>

          <listitem>
             selectBeforeUpdate: Specifies that Hibernate should never perform an SQL UPDATE unless it is certain that an object is actually modified. 
          </listitem>

          <listitem>
             polymorphism: whether the entity polymorphism is of PolymorphismType.IMPLICIT (default) or PolymorphismType.EXPLICIT 
          </listitem>

          <listitem>
             optimisticLock: optimistic locking strategy (OptimisticLockType.VERSION, OptimisticLockType.NONE, OptimisticLockType.DIRTY or OptimisticLockType.ALL) 
          </listitem>
        </itemizedlist></para>

      <para><note>
          <para>@javax.persistence.Entity is still mandatory,
          @org.hibernate.annotations.Entity is not a replacement.</para>
        </note></para>

      <para>Here are some additional Hibernate annotation extensions</para>

      <para><literal>@org.hibernate.annotations.BatchSize</literal> allows you
      to define the batch size when fetching instances of this entity ( eg.
      <literal>@BatchSize(size=4)</literal> ). When loading a given entity,
      Hibernate will then load all the uninitialized entities of the same type
      in the persistence context up to the batch size.</para>

      <para><literal>@org.hibernate.annotations.Proxy</literal> defines the
      laziness attributes of the entity. lazy (default to true) define whether
      the class is lazy or not. proxyClassName is the interface used to
      generate the proxy (default is the class itself).</para>

      <para><literal>@org.hibernate.annotations.Where</literal> defines an
      optional SQL WHERE clause used when instances of this class is
      retrieved.</para>

      <para><literal>@org.hibernate.annotations.Check</literal> defines an
      optional check constraints defined in the DDL statetement.</para>

      <para><literal>@OnDelete(action=OnDeleteAction.CASCADE)</literal> on
      joined subclasses: use a SQL cascade delete on deletion instead of the
      regular Hibernate mechanism.</para>

      <para><literal>@Table(appliesTo="tableName", indexes = {
      @Index(name="index1", columnNames={"column1", "column2"} ) } )</literal>
      creates the defined indexes on the columns of table
      <literal>tableName</literal>. This can be applied on the primary table
      or any secondary table. The <literal>@Tables</literal> annotation allows
      your to apply indexes on different tables. This annotation is expected
      where <literal>@javax.persistence.Table</literal> or
      <literal>@javax.persistence.SecondaryTable</literal>(s) occurs.</para>

      <note>
        <para><literal>@org.hibernate.annotations.Table</literal> is a
        complement, not a replacement to
        <literal>@javax.persistence.Table</literal>. Especially, if you want
        to change the default name of a table, you must use
        <literal>@javax.persistence.Table</literal>, not
        <literal>@org.hibernate.annotations.Table</literal>.</para>
      </note>

      <para><literal>@org.hibernate.annotations.Table</literal> can also be
      used to define the following elements of secondary tables:</para>

      <itemizedlist>
        <listitem>
          <para><literal>fetch</literal>: If set to JOIN, the default,
          Hibernate will use an inner join to retrieve a secondary table
          defined by a class or its superclasses and an outer join for a
          secondary table defined by a subclass. If set to select then
          Hibernate will use a sequential select for a secondary table defined
          on a subclass, which will be issued only if a row turns out to
          represent an instance of the subclass. Inner joins will still be
          used to retrieve a secondary defined by the class and its
          superclasses.</para>
        </listitem>

        <listitem>
          <para><literal>inverse</literal>: If true, Hibernate will not try to
          insert or update the properties defined by this join. Default to
          false.</para>
        </listitem>

        <listitem>
          <para><literal>optional</literal>: If enabled (the default),
          Hibernate will insert a row only if the properties defined by this
          join are non-null and will always use an outer join to retrieve the
          properties.</para>
        </listitem>

        <listitem>
          <para><literal>foreignKey</literal>: defines the Foreign Key name of
          a secondary table pointing back to the primary table.</para>
        </listitem>
      </itemizedlist>

      <para><literal>@Immutable</literal> marks an entity or collection as
      immutable. An immutable entity may not be updated by the application.
      This allows Hibernate to make some minor performance optimizations.
      Updates to an immutable entity will be ignored, but no exception is
      thrown. <literal>@Immutable</literal> must be used on root entities
      only. <literal>@Immutable</literal> placed on a collection makes the
      collection immutable, meaning additions and deletions to and from the
      collection are not allowed. A <literal>HibernateException</literal> is
      thrown in this case.</para>

      <para><literal>@Persister</literal> lets you define your own custom
      persistence strategy. You may, for example, specify your own subclass of
      <classname>org.hibernate.persister.EntityPersister</classname> or you
      might even provide a completely new implementation of the interface
      <literal>org.hibernate.persister.ClassPersister</literal> that
      implements persistence via, for example, stored procedure calls,
      serialization to flat files or LDAP.</para>

      <para><programlisting>@Entity
@BatchSize(size=5)
@org.hibernate.annotations.Entity(
        selectBeforeUpdate = true,
        dynamicInsert = true, dynamicUpdate = true,
        optimisticLock = OptimisticLockType.ALL,
        polymorphism = PolymorphismType.EXPLICIT)
@Where(clause="1=1")
@org.hibernate.annotations.Table(name="Forest", indexes = { @Index(name="idx", columnNames = { "name", "length" } ) } )
@Persister(impl=MyEntityPersister.class)
public class Forest { ... }</programlisting><programlisting>@Entity
@Inheritance(
    strategy=InheritanceType.JOINED
)
public class Vegetable { ... }

@Entity
@OnDelete(action=OnDeleteAction.CASCADE)
public class Carrot extends Vegetable { ... }</programlisting></para>
    </sect2>

    <sect2 id="entity-hibspec-identifier" label="Identifier" revision="2">
      <title>Identifier</title>

      <para>Hibernate Annotations goes beyond the Java Persistence
      specification when defining identifiers.</para>

      <sect3>
        <title>Generators</title>

        <para><literal><literal>@org.hibernate.annotations.GenericGenerator</literal>
        and <literal>@org.hibernate.annotations.GenericGenerators</literal>
        allows you to define an Hibernate specific id
        generator.</literal></para>

        <para><programlisting>@Id @GeneratedValue(generator="system-uuid")
@GenericGenerator(name="system-uuid", strategy = "uuid")
public String getId() {

@Id @GeneratedValue(generator="hibseq")
@GenericGenerator(name="hibseq", strategy = "seqhilo",
    parameters = {
        @Parameter(name="max_lo", value = "5"),
        @Parameter(name="sequence", value="heybabyhey")
    }
)
public Integer getId() {</programlisting></para>

        <para><literal>strategy</literal> is the short name of an Hibernate3
        generator strategy or the fully qualified class name of an
        <classname>IdentifierGenerator</classname> implementation. You can add
        some parameters through the <literal>parameters</literal>
        attribute.</para>

        <para>Contrary to their standard counterpart,
        <literal>@GenericGenerator</literal> and
        <literal>@GenericGenerators</literal> can be used in package level
        annotations, making them application level generators (just like if
        they were in a JPA XML file).</para>

        <programlisting>@GenericGenerators(
    {
    @GenericGenerator(
        name="hibseq",
        strategy = "seqhilo",
        parameters = {
            @Parameter(name="max_lo", value = "5"),
            @Parameter(name="sequence", value="heybabyhey")
        }
     ),
     @GenericGenerator(...)
     }
)
package org.hibernate.test.model</programlisting>
      </sect3>

      <sect3>
        <title>@NaturalId</title>

        <para>While not used as identifier property, some (group of)
        properties represent natural identifier of an entity. This is
        especially true when the schema uses the recommended approach of using
        surrogate primary key even if a natural business key exists. Hibernate
        allows to map such natural properties and reuse them in a
        <classname>Criteria</classname> query. The natural identifier is
        composed of all the properties marked
        <classname>@NaturalId</classname>.</para>

        <programlisting>@Entity
public class Citizen {
    @Id
    @GeneratedValue
    private Integer id;
    private String firstname;
    private String lastname;
    
    @NaturalId
    @ManyToOne
    private State state;

    @NaturalId
    private String ssn;
    ...
}



//and later on query
List results = s.createCriteria( Citizen.class )
                .add( Restrictions.naturalId().set( "ssn", "1234" ).set( "state", ste ) )
                .list();</programlisting>

        <para>Note that the group of properties representing the natural
        identifier have to be unique (Hibernate will generate a unique
        constraint if the database schema is generated).</para>
      </sect3>
    </sect2>

    <sect2 id="entity-hibspec-property" revision="2">
      <title>Property</title>

      <sect3>
        <title>Access type</title>

        <para>The default access type is determined from the position of the
        <literal>@Id</literal> or <literal>@EmbeddedId</literal> annotation in
        the entity hierarchy.</para>

        <note>
          <para>The placement of annotations within a class hierarchy has to
          be consistent (either field or on property) to be able to determine
          the default access type. It is recommended to stick to one single
          annotation placement strategy throughout your whole
          application.</para>
        </note>

        <para>To finetune the access strategy JPA 2 introduces the @Access
        annotation. With its help you can define the access type on:</para>

        <itemizedlist>
          <listitem>
            <para>an entity</para>
          </listitem>

          <listitem>
            <para>a superclass</para>
          </listitem>

          <listitem>
            <para>an embeddable object</para>
          </listitem>

          <listitem>
            <para>a property</para>
          </listitem>
        </itemizedlist>

        <para>Prior to JPA 2 Hibernate used the Hibernate specific annotation
        <literal>@org.hibernate.annotations.AccessType</literal> to change
        specific access types. @AccessType still exists to support legacy
        systems, but the usage of @Access is recommended for new applications.
        The behaviour of @Access and @AccessType are similar, but there are
        differences. For both annotations applies:</para>

        <itemizedlist>
          <listitem>
            <para>The access type is overriden for the annotated element, if
            overriden on a class, all the properties of the given class
            inherit the access type.</para>
          </listitem>

          <listitem>
            <para>If an entity is marked as
            <literal>@Access(AccessType.PROPERTY)</literal> or
            <literal>@AccessType("property")</literal> respectively, the
            getters are scanned for annotations, if the enitiy is marked as
            <literal>@Access(AccessType.FIELD)</literal> or
            <literal>@AccessType("field")</literal> respectively, the fields
            are scanned for annotations.</para>
          </listitem>
        </itemizedlist>

        <para>In the case where you want to override the access type for a
        property of an entity which already defines an explicit access type
        the annotation placement between @Access and @AccessType
        differs:</para>

        <programlisting><emphasis role="bold">@AccessType("property")</emphasis> // set access type for all properties in Country
public class Country implements Serializable {
    private String iso2;
    private String name;

    public String getIso2() {
        return iso2;
    }

    public void setIso2(String iso2) {
        this.iso2 = iso2;
    }

    @Column(name = "countryName")
    <emphasis role="bold">@AccessType("field")</emphasis> // set the access type for name to field
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</programlisting>

        <programlisting><emphasis role="bold">@Access(AccessType.PROPERTY)</emphasis> // set access type for all properties in Country
public class Country implements Serializable {
    private String iso2;

    <emphasis role="bold">@Access(AccessType.FIELD)</emphasis>  // set the access type for name to field
    private String name;

    public String getIso2() {
        return iso2;
    }

    public void setIso2(String iso2) {
        this.iso2 = iso2;
    }

    @Column(name = "countryName")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</programlisting>

        <note>
          <para>Watch out for the different annotation placement strategy. In
          the case of <literal>@Access</literal> the field has to be annotated
          with the overriding access strategy whereas with
          <literal>@AccessType</literal> the property gets annotated.</para>
        </note>

        <para>If a superclass or an embeddable object is not annotated, the
        default entity access type is used.</para>

        <programlisting>@Entity
public class Person implements Serializable {
    @Id  @GeneratedValue //access type field
    Integer id;

    @Embedded
    @AttributeOverrides({
    @AttributeOverride(name = "iso2", column = @Column(name = "bornIso2")),
    @AttributeOverride(name = "name", column = @Column(name = "bornCountryName"))
            })
    Country bornIn;
}

@Embeddable
<emphasis role="bold">@AccessType("property")</emphasis> //override access type for all properties in Country
public class Country implements Serializable {
    private String iso2;
    private String name;

    public String getIso2() {
        return iso2;
    }

    public void setIso2(String iso2) {
        this.iso2 = iso2;
    }

    @Column(name = "countryName")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
</programlisting>
      </sect3>

      <sect3>
        <title>Formula</title>

        <para>Sometimes, you want the Database to do some computation for you
        rather than in the JVM, you might also create some kind of virtual
        column. You can use a SQL fragment (aka formula) instead of mapping a
        property into a column. This kind of property is read only (its value
        is calculated by your formula fragment).</para>

        <programlisting>@Formula("obj_length * obj_height * obj_width")
public long getObjectVolume()</programlisting>

        <para>The SQL fragment can be as complex as you want and even include
        subselects.</para>
      </sect3>

      <sect3>
        <title>Type</title>

        <para><literal>@org.hibernate.annotations.Type</literal> overrides the
        default hibernate type used: this is generally not necessary since the
        type is correctly inferred by Hibernate. Please refer to the Hibernate
        reference guide for more informations on the Hibernate types.</para>

        <para><literal>@org.hibernate.annotations.TypeDef</literal> and
        <literal>@org.hibernate.annotations.TypeDefs</literal> allows you to
        declare type definitions. These annotations can be placed at the class
        or package level. Note that these definitions are global for the
        session factory (even when defined at the class level). If the type is
        used on a single entity, you can place the definition on the entity
        itself. Otherwise, it is recommended to place the definition at the
        package level. In the example below, when Hibernate encounters a
        property of class <literal>PhoneNumer</literal>, it delegates the
        persistence strategy to the custom mapping type
        <literal>PhoneNumberType</literal>. However, properties belonging to
        other classes, too, can delegate their persistence strategy to
        <literal>PhoneNumberType</literal>, by explicitly using the
        <literal>@Type</literal> annotation.</para>

        <note>
           Package level annotations are placed in a file named 

          <filename>package-info.java</filename>

           in the appropriate package. Place your annotations before the package declaration. 
        </note>

        <programlisting>
@TypeDef(
	name = "phoneNumber",
	defaultForType = PhoneNumber.class,
	typeClass = PhoneNumberType.class
)

@Entity
public class ContactDetails {
      ...
	private PhoneNumber localPhoneNumber;
	@Type(type="phoneNumber")
	private OverseasPhoneNumber overseasPhoneNumber;
      ...
}


</programlisting>

        <para>The following example shows the usage of the
        <literal>parameters</literal> attribute to customize the
        TypeDef.</para>

        <programlisting>//in org/hibernate/test/annotations/entity/package-info.java
@TypeDefs(
    {
    @TypeDef(
        name="caster",
        typeClass = CasterStringType.class,
        parameters = {
            @Parameter(name="cast", value="lower")
        }
    )
    }
)
package org.hibernate.test.annotations.entity;

//in org/hibernate/test/annotations/entity/Forest.java
public class Forest {
    @Type(type="caster")
    public String getSmallText() {
    ...
}
         </programlisting>

        <para>When using composite user type, you will have to express column
        definitions. The <literal>@Columns</literal> has been introduced for
        that purpose.</para>

        <programlisting>@Type(type="org.hibernate.test.annotations.entity.MonetaryAmountUserType")
@Columns(columns = {
    @Column(name="r_amount"),
    @Column(name="r_currency")
})
public MonetaryAmount getAmount() {
    return amount;
}


public class MonetaryAmount implements Serializable {
    private BigDecimal amount;
    private Currency currency;
    ...
}</programlisting>
      </sect3>

      <sect3>
        <title>Index</title>

        <para>You can define an index on a particular column using the
        <literal>@Index</literal> annotation on a one column property, the
        columnNames attribute will then be ignored</para>

        <programlisting>@Column(secondaryTable="Cat1")
@Index(name="story1index")
public String getStoryPart1() {
    return storyPart1;
}</programlisting>
      </sect3>

      <sect3>
        <title>@Parent</title>

        <para>When inside an embeddable object, you can define one of the
        properties as a pointer back to the owner element.</para>

        <programlisting>@Entity
public class Person {
    @Embeddable public Address address;
    ...
}

@Embeddable
public class Address {
    @Parent public Person owner;
    ...
}


person == person.address.owner</programlisting>
      </sect3>

      <sect3>
        <title>Generated properties</title>

        <para>Some properties are generated at insert or update time by your
        database. Hibernate can deal with such properties and triggers a
        subsequent select to read these properties.</para>

        <programlisting>@Entity
public class Antenna {
    @Id public Integer id;
    @Generated(GenerationTime.ALWAYS) @Column(insertable = false, updatable = false)
    public String longitude;

    @Generated(GenerationTime.INSERT) @Column(insertable = false)
    public String latitude;
}</programlisting>

        <para>Annotate your property as <literal>@Generated</literal> You have
        to make sure your insertability or updatability does not conflict with
        the generation strategy you have chosen. When GenerationTime.INSERT is
        chosen, the property must not contains insertable columns, when
        GenerationTime.ALWAYS is chosen, the property must not contains
        insertable nor updatable columns.</para>

        <para><literal>@Version</literal> properties cannot be
        <literal>@Generated(INSERT)</literal> by design, it has to be either
        <literal>NEVER</literal> or <literal>ALWAYS</literal>.</para>
      </sect3>

      <sect3>
        <title>@Target</title>

        <para>Sometimes, the type guessed by reflection is not the one you
        want Hibernate to use. This is especially true on components when an
        interface is used. You can use <literal>@Target</literal> to by pass
        the reflection guessing mechanism (very much like the
        <literal>targetEntity</literal> attribute available on
        associations.</para>

        <programlisting>    @Embedded
    <emphasis role="bold">@Target(OwnerImpl.class)</emphasis>
    public Owner getOwner() {
        return owner;
    }</programlisting>

        <para></para>
      </sect3>

      <sect3>
        <title>Optimistic lock</title>

        <para>It is sometimes useful to avoid increasing the version number
        even if a given property is dirty (particularly collections). You can
        do that by annotating the property (or collection) with
        <literal>@OptimisticLock(excluded=true)</literal>.</para>

        <para>More formally, specifies that updates to this property do not
        require acquisition of the optimistic lock.</para>
      </sect3>
    </sect2>

    <sect2 id="entity-hibspec-inheritance" revision="3">
      <title>Inheritance</title>

      <para>SINGLE_TABLE is a very powerful strategy but sometimes, and
      especially for legacy systems, you cannot add an additional
      discriminator column. For that purpose Hibernate has introduced the
      notion of discriminator formula:
      <literal>@DiscriminatorFormula</literal> is a replacement of
      <literal>@DiscriminatorColumn</literal> and use a SQL fragment as a
      formula for discriminator resolution (no need to have a dedicated
      column).</para>

      <programlisting>@Entity
<emphasis role="bold">@DiscriminatorFormula("case when forest_type is null then 0 else forest_type end")</emphasis>
public class Forest { ... }</programlisting>

      <para>By default, when querying the top entities, Hibernate does not put
      a restriction clause on the discriminator column. This can be
      inconvenient if this column contains values not mapped in your hierarchy
      (through <literal>@DiscriminatorValue</literal>). To work around that
      you can use <literal>@ForceDiscriminator</literal> (at the class level,
      next to <literal>@DiscriminatorColumn</literal>). Hibernate will then
      list the available values when loading the entities.</para>

      <para>You can define the foreign key name generated by Hibernate for
      subclass tables in the JOINED inheritance strategy.</para>

      <programlisting>@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class File { ... }

@Entity
@ForeignKey(name = "FK_DOCU_FILE")
public class Document extends File {</programlisting>

      <para>The foreign key from the <literal>Document</literal> table to the
      <literal>File</literal> table will be named
      <literal>FK_DOCU_FILE</literal>.</para>
    </sect2>

    <sect2 id="entity-hibspec-singleassoc">
      <title>Single Association related annotations</title>

      <para>By default, when Hibernate cannot resolve the association because
      the expected associated element is not in database (wrong id on the
      association column), an exception is raised by Hibernate. This might be
      inconvenient for legacy and badly maintained schemas. You can ask
      Hibernate to ignore such elements instead of raising an exception using
      the <literal>@NotFound</literal> annotation. This annotation can be used
      on a <literal>@OneToOne</literal> (with FK),
      <literal>@ManyToOne</literal>, <literal>@OneToMany</literal> or
      <literal>@ManyToMany</literal> association.</para>

      <programlisting>@Entity
public class Child {
    ...
    @ManyToOne
    @NotFound(action=NotFoundAction.IGNORE)
    public Parent getParent() { ... }
    ...
}</programlisting>

      <para>Sometimes you want to delegate to your database the deletion of
      cascade when a given entity is deleted.</para>

      <programlisting>@Entity
public class Child {
    ...
    @ManyToOne
    @OnDelete(action=OnDeleteAction.CASCADE)
    public Parent getParent() { ... }
    ...
}</programlisting>

      <para>In this case Hibernate generates a cascade delete constraint at
      the database level.</para>

      <para>Foreign key constraints, while generated by Hibernate, have a
      fairly unreadable name. You can override the constraint name by use
      <literal>@ForeignKey</literal>.</para>

      <programlisting>@Entity
public class Child {
    ...
    @ManyToOne
    <emphasis role="bold">@ForeignKey(name="FK_PARENT")</emphasis>
    public Parent getParent() { ... }
    ...
}

alter table Child add constraint FK_PARENT foreign key (parent_id) references Parent</programlisting>

      <sect3 id="entity-hibspec-singleassoc-fetching">
        <title>Lazy options and fetching modes</title>

        <para>EJB3 comes with the <literal>fetch</literal> option to define
        lazy loading and fetching modes, however Hibernate has a much more
        option set in this area. To fine tune the lazy loading and fetching
        strategies, some additional annotations have been introduced:</para>

        <itemizedlist>
          <listitem>
            <para><literal>@LazyToOne</literal>: defines the lazyness option
            on <literal>@ManyToOne</literal> and <literal>@OneToOne</literal>
            associations. <literal>LazyToOneOption</literal> can be
            <literal>PROXY</literal> (ie use a proxy based lazy loading),
            <literal>NO_PROXY</literal> (use a bytecode enhancement based lazy
            loading - note that build time bytecode processing is necessary)
            and <literal>FALSE</literal> (association not lazy)</para>
          </listitem>

          <listitem>
            <para><literal>@LazyCollection</literal>: defines the lazyness
            option on <literal>@ManyTo</literal>Many and
            <literal>@OneToMany</literal> associations. LazyCollectionOption
            can be <literal>TRUE</literal> (the collection is lazy and will be
            loaded when its state is accessed), <literal>EXTRA</literal> (the
            collection is lazy and all operations will try to avoid the
            collection loading, this is especially useful for huge collections
            when loading all the elements is not necessary) and FALSE
            (association not lazy)</para>
          </listitem>

          <listitem>
            <para><literal>@Fetch</literal>: defines the fetching strategy
            used to load the association. <literal>FetchMode</literal> can be
            <literal>SELECT</literal> (a select is triggered when the
            association needs to be loaded), <literal>SUBSELECT</literal>
            (only available for collections, use a subselect strategy - please
            refers to the Hibernate Reference Documentation for more
            information) or <literal>JOIN</literal> (use a SQL JOIN to load
            the association while loading the owner entity).
            <literal>JOIN</literal> overrides any lazy attribute (an
            association loaded through a <literal>JOIN</literal> strategy
            cannot be lazy).</para>
          </listitem>
        </itemizedlist>

        <para>The Hibernate annotations overrides the EJB3 fetching
        options.</para>

        <table>
          <title>Lazy and fetch options equivalent</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry>Annotations</entry>

                <entry>Lazy</entry>

                <entry>Fetch</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>@[One|Many]ToOne](fetch=FetchType.LAZY)</entry>

                <entry>@LazyToOne(PROXY)</entry>

                <entry>@Fetch(SELECT)</entry>
              </row>

              <row>
                <entry>@[One|Many]ToOne](fetch=FetchType.EAGER)</entry>

                <entry>@LazyToOne(FALSE)</entry>

                <entry>@Fetch(JOIN)</entry>
              </row>

              <row>
                <entry>@ManyTo[One|Many](fetch=FetchType.LAZY)</entry>

                <entry>@LazyCollection(TRUE)</entry>

                <entry>@Fetch(SELECT)</entry>
              </row>

              <row>
                <entry>@ManyTo[One|Many](fetch=FetchType.EAGER)</entry>

                <entry>@LazyCollection(FALSE)</entry>

                <entry>@Fetch(JOIN)</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect3>

      <sect3 id="entity-hibspec-singleassoc-any">
        <title>@Any</title>

        <para>The <classname>@Any</classname> annotation defines a polymorphic
        association to classes from multiple tables. This type of mapping
        always requires more than one column. The first column holds the type
        of the associated entity. The remaining columns hold the identifier.
        It is impossible to specify a foreign key constraint for this kind of
        association, so this is most certainly not meant as the usual way of
        mapping (polymorphic) associations. You should use this only in very
        special cases (eg. audit logs, user session data, etc).</para>

        <para>The @Any annotation describes the column holding the metadata
        information. To link the value of the metadata information and an
        actual entity type, The <classname>@AnyDef</classname> and
        <classname>@AnyDefs</classname> annotations are used.</para>

        <programlisting>    @Any( metaColumn = @Column( name = "property_type" ), fetch=FetchType.EAGER )
    @AnyMetaDef( 
        idType = "integer", 
        metaType = "string", 
        metaValues = {
            @MetaValue( value = "S", targetEntity = StringProperty.class ),
            @MetaValue( value = "I", targetEntity = IntegerProperty.class )
        } )
    @JoinColumn( name = "property_id" )
    public Property getMainProperty() {
        return mainProperty;
    }</programlisting>

        <para><methodname>idType</methodname> represents the target entities
        identifier property type and <methodname>metaType</methodname> the
        metadata type (usually String).</para>

        <para>Note that <classname>@AnyDef</classname> can be mutualized and
        reused. It is recommended to place it as a package metadata in this
        case.</para>

        <programlisting>//on a package
@AnyMetaDef( name="property" 
    idType = "integer", 
    metaType = "string", 
    metaValues = {
        @MetaValue( value = "S", targetEntity = StringProperty.class ),
        @MetaValue( value = "I", targetEntity = IntegerProperty.class )
    } )
package org.hibernate.test.annotations.any;


//in a class
    @Any( metaDef="property", metaColumn = @Column( name = "property_type" ), fetch=FetchType.EAGER )
    @JoinColumn( name = "property_id" )
    public Property getMainProperty() {
        return mainProperty;
    }</programlisting>
      </sect3>
    </sect2>

    <sect2 id="entity-hibspec-collection" revision="2">
      <title>Collection related annotations</title>

      <sect3 id="entity-hibspec-collection-enhance" revision="3">
        <title>Enhance collection settings</title>

        <para>It is possible to set <itemizedlist>
            <listitem>
               the batch size for collections using @BatchSize 
            </listitem>

            <listitem>
               the where clause, using @Where (applied on the target entity) or @WhereJoinTable (applied on the association table) 
            </listitem>

            <listitem>
               the check clause, using @Check 
            </listitem>

            <listitem>
               the SQL order by clause, using @OrderBy 
            </listitem>

            <listitem>
               the delete cascade strategy through @OnDelete(action=OnDeleteAction.CASCADE) 
            </listitem>

            <listitem>
               the collection immutability using @Immutable: if set specifies that the elements of the collection never change (a minor performance optimization in some cases) 
            </listitem>

            <listitem>
              <para>a custom collection persister (ie the persistence strategy
              used) using <literal>@Persister</literal>: the class must
              implement
              <classname>org.hibernate.persister.collectionCollectionPersister</classname></para>
            </listitem>
          </itemizedlist></para>

        <para>You can also declare a sort comparator. Use the
        <literal>@Sort</literal> annotation. Expressing the comparator type
        you want between unsorted, natural or custom comparator. If you want
        to use your own comparator implementation, you'll also have to express
        the implementation class using the <literal>comparator</literal>
        attribute. Note that you need to use either a
        <classname>SortedSet</classname> or a <classname>SortedMap</classname>
        interface.</para>

        <programlisting>    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="CUST_ID")
    @Sort(type = SortType.COMPARATOR, comparator = TicketComparator.class)
    @Where(clause="1=1")
    @OnDelete(action=OnDeleteAction.CASCADE)
    public SortedSet&lt;Ticket&gt; getTickets() {
        return tickets;
    }</programlisting>

        <para>Please refer to the previous descriptions of these annotations
        for more informations.</para>

        <para>Foreign key constraints, while generated by Hibernate, have a
        fairly unreadable name. You can override the constraint name by use
        <literal>@ForeignKey</literal>. Note that this annotation has to be
        placed on the owning side of the relationship,
        <literal>inverseName</literal> referencing to the other side
        constraint.</para>

        <programlisting>@Entity
public class Woman {
    ...
    @ManyToMany(cascade = {CascadeType.ALL})
    <emphasis role="bold">@ForeignKey(name = "TO_WOMAN_FK", inverseName = "TO_MAN_FK")</emphasis>
    public Set&lt;Man&gt; getMens() {
        return mens;
    }
}

alter table Man_Woman add constraint TO_WOMAN_FK foreign key (woman_id) references Woman
alter table Man_Woman add constraint TO_MAN_FK foreign key (man_id) references Man</programlisting>
      </sect3>

      <sect3 id="entity-hibspec-collection-extratype" revision="1">
        <title>Extra collection types</title>

        <sect4>
          <title>List</title>

          <para>Beyond EJB3, Hibernate Annotations supports true
          <classname>List</classname> and <classname>Array</classname>. Map
          your collection the same way as usual and add the
          @<literal>IndexColumn</literal>. This annotation allows you to
          describe the column that will hold the index. You can also declare
          the index value in DB that represent the first element (aka as base
          index). The usual value is <literal>0</literal> or
          <literal>1</literal>.</para>

          <programlisting>@OneToMany(cascade = CascadeType.ALL)
@IndexColumn(name = "drawer_position", base=1)
public List&lt;Drawer&gt; getDrawers() {
    return drawers;
}</programlisting>

          <note>
            <para>If you forgot to set <literal>@IndexColumn</literal>, the
            bag semantic is applied. If you want the bag semantic without the
            limitations of it, consider using
            <literal>@CollectionId</literal>.</para>
          </note>
        </sect4>

        <sect4 id="entity-hibspec-collection-extratype-map" revision="1">
          <title>Map</title>

          <para>Hibernate Annotations also supports true Map mappings, if
          <literal>@javax.persistence.MapKey</literal> is not set, hibernate
          will map the key element or embeddable object in its/their own
          columns. To override the default columns, you can use
          <literal>@org.hibernate.annotations.MapKey</literal> if your key is
          a basic type (defaulted to <literal>mapkey</literal>) or an
          embeddable object, or you can use
          <literal>@org.hibernate.annotations.MapKeyManyToMany</literal> if
          your key is an entity.</para>

          <para>Both <literal>@org.hibernate.annotations.MapKey</literal> and
          <literal>@org.hibernate.annotations.MapKeyManyToMany</literal>
          allows you to override the target element to be used. This is
          especially useful if your collection does not use generics (or if
          you use interfaces).</para>

          <programlisting>    @CollectionOfElements(targetElement = SizeImpl.class)
    @MapKeyManyToMany(<emphasis role="bold">targetEntity = LuggageImpl.class</emphasis>)
    private Map&lt;Luggage, Size&gt; sizePerLuggage = new HashMap&lt;Luggage, Size&gt;();</programlisting>

          <para></para>
        </sect4>

        <sect4 id="entity-hibspec-collection-extratype-indexbidir"
               revision="2">
          <title>Bidirectional association with indexed collections</title>

          <para>A bidirectional association where one end is an indexed
          collection (ie. represented as a <literal>@IndexColumn</literal>,
          <literal>@org.hibernate.annotations.MapKey</literal> or
          <classname>@org.hibernate.annotations.MapKeyManyToMany</classname>)
          requires special consideration. If a property on the associated
          class explicitly maps the indexed value, the use of
          <methodname>mappedBy</methodname> is permitted:</para>

          <programlisting>@Entity
public class Parent {
    @OneToMany(mappedBy="parent")
    @org.hibernate.annotations.IndexColumn(name="order")
    private List&lt;Child&gt; children;
    ...
}

@Entity
public class Child {
    ...
    //the index column is mapped as a property in the associated entity
    @Column(name="order")
    private int order;

    @ManyToOne
    @JoinColumn(name="parent_id", nullable=false)
    private Parent parent;
    ...
}</programlisting>

          <para>But, if there is no such property on the child class, we can't
          think of the association as truly bidirectional (there is
          information available at one end of the association that is not
          available at the other end: the index). In this case, we can't map
          the collection as <literal>mappedBy</literal>. Instead, we could use
          the following mapping:</para>

          <programlisting>@Entity
public class Parent {
    @OneToMany
    @org.hibernate.annotations.IndexColumn(name="order")
    @JoinColumn(name="parent_id", nullable=false)
    private List&lt;Child&gt; children;
    ...
}

@Entity
public class Child {
    ...
    @ManyToOne
    @JoinColumn(name="parent_id", insertable=false, updatable=false, nullable=false)
    private Parent parent;
    ...
}</programlisting>

          <para>Note that in this mapping, the collection-valued end of the
          association is responsible for updating the foreign key.</para>
        </sect4>

        <sect4>
          <title>Bag with primary key</title>

          <para>Another interesting feature is the ability to define a
          surrogate primary key to a bag collection. This remove pretty much
          all of the drawbacks of bags: update and removal are efficient, more
          than one <literal>EAGER</literal> bag per query or per entity. This
          primary key will be contained in a additional column of your
          collection table but will not be visible to the Java application.
          @CollectionId is used to mark a collection as id bag, it also allow
          to override the primary key column(s), the primary key type and the
          generator strategy. The strategy can be <literal>identity</literal>,
          or any defined generator name of your application.</para>

          <programlisting>@Entity
@TableGenerator(name="ids_generator", table="IDS")
public class Passport {
    ...

    @ManyToMany(cascade = CascadeType.ALL)
    @JoinTable(name="PASSPORT_VISASTAMP")
    <emphasis role="bold">@CollectionId(
        columns = @Column(name="COLLECTION_ID"), 
        type=@Type(type="long"), 
        generator = "ids_generator"
    )</emphasis>
    private Collection&lt;Stamp&gt; visaStamp = new ArrayList();
    ...
}</programlisting>
        </sect4>

        <sect4>
          <title>Collection of element or composite elements</title>

          <para>Hibernate Annotations also supports collections of core types
          (Integer, String, Enums, ...), collections of embeddable objects and
          even arrays of primitive types. This is known as collection of
          elements.</para>

          <para>A collection of elements has to be annotated as
          <literal>@CollectionOfElements</literal> (as a replacement of
          <literal>@OneToMany</literal>) To define the collection table, the
          <literal>@JoinTable</literal> annotation is used on the association
          property, <literal>joinColumns</literal> defines the join columns
          between the entity primary table and the collection table
          (inverseJoincolumn is useless and should be left empty). For
          collection of core types or array of primitive types, you can
          override the element column definition using a
          <literal>@Column</literal> on the association property. You can also
          override the columns of a collection of embeddable object using
          <literal>@AttributeOverride</literal>. To reach the collection
          element, you need to append "element" to the attribute override name
          (eg "element" for core types, or "element.serial" for the serial
          property of an embeddable element). To reach the index/key of a
          collection, append "key" instead.</para>

          <programlisting>@Entity
public class Boy {
    private Integer id;
    private Set&lt;String&gt; nickNames = new HashSet&lt;String&gt;();
    private int[] favoriteNumbers;
    private Set&lt;Toy&gt; favoriteToys = new HashSet&lt;Toy&gt;();
    private Set&lt;Character&gt; characters = new HashSet&lt;Character&gt;();

    @Id @GeneratedValue
    public Integer getId() {
        return id;
    }

    <emphasis role="bold">@CollectionOfElements
    public Set&lt;String&gt;</emphasis> getNickNames() {
        return nickNames;
    }

    <emphasis role="bold">@CollectionOfElements
    @JoinTable(
            table=@Table(name="BoyFavoriteNumbers"),
            joinColumns = @JoinColumn(name="BoyId")
    )
    @Column(name="favoriteNumber", nullable=false)</emphasis>
    @IndexColumn(name="nbr_index")
    public int[] getFavoriteNumbers() {
        return favoriteNumbers;
    }

    <emphasis role="bold">@CollectionOfElements
    @AttributeOverride( name="element.serial", column=@Column(name="serial_nbr") )</emphasis>
    public Set&lt;Toy&gt; getFavoriteToys() {
        return favoriteToys;
    }

    <emphasis role="bold">@CollectionOfElements
    public Set&lt;Character&gt;</emphasis> getCharacters() {
        return characters;
    }
    ...
}

public enum Character {
    GENTLE,
    NORMAL,
    AGGRESSIVE,
    ATTENTIVE,
    VIOLENT,
    CRAFTY
}

@Embeddable
public class Toy {
    public String name;
    public String serial;
    public Boy owner;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSerial() {
        return serial;
    }

    public void setSerial(String serial) {
        this.serial = serial;
    }

    <emphasis role="bold">@Parent</emphasis>
    public Boy getOwner() {
        return owner;
    }

    public void setOwner(Boy owner) {
        this.owner = owner;
    }

    public boolean equals(Object o) {
        if ( this == o ) return true;
        if ( o == null || getClass() != o.getClass() ) return false;

        final Toy toy = (Toy) o;

        if ( !name.equals( toy.name ) ) return false;
        if ( !serial.equals( toy.serial ) ) return false;

        return true;
    }

    public int hashCode() {
        int result;
        result = name.hashCode();
        result = 29 * result + serial.hashCode();
        return result;
    }
}</programlisting>

          <para>On a collection of embeddable objects, the embeddable object
          can have a property annotated with <literal>@Parent</literal>. This
          property will then point back to the entity containing the
          collection.</para>

          <note>
            <para>Previous versions of Hibernate Annotations used the
            <literal>@OneToMany</literal> to mark a collection of elements.
            Due to semantic inconsistencies, we've introduced the annotation
            <literal>@CollectionOfElements</literal>. Marking collections of
            elements the old way still work but is considered deprecated and
            is going to be unsupported in future releases</para>
          </note>
        </sect4>

        <sect4>
          <title>@ManyToAny</title>

          <para><classname>@ManyToAny</classname> allows polymorphic
          associations to classes from multiple tables. This type of mapping
          always requires more than one column. The first column holds the
          type of the associated entity. The remaining columns hold the
          identifier. It is impossible to specify a foreign key constraint for
          this kind of association, so this is most certainly not meant as the
          usual way of mapping (polymorphic) associations. You should use this
          only in very special cases (eg. audit logs, user session data,
          etc).</para>

          <programlisting>    @ManyToAny(
            metaColumn = @Column( name = "property_type" ) )
    @AnyMetaDef( 
        idType = "integer", 
        metaType = "string",
        metaValues = {
            @MetaValue( value = "S", targetEntity = StringProperty.class ),
            @MetaValue( value = "I", targetEntity = IntegerProperty.class ) } )
    @Cascade( { org.hibernate.annotations.CascadeType.ALL } )
    @JoinTable( name = "obj_properties", joinColumns = @JoinColumn( name = "obj_id" ),
            inverseJoinColumns = @JoinColumn( name = "property_id" ) )
    public List&lt;Property&gt; getGeneralProperties() {</programlisting>

          <para>Like <classname>@Any</classname>,
          <classname>@ManyToAny</classname> can use named
          <classname>@AnyDef</classname>s, see <xref
          linkend="entity-hibspec-singleassoc-any" /> for more info.</para>
        </sect4>
      </sect3>
    </sect2>

    <sect2 id="entity-hibspec-cascade" xreflabel="Cascade">
      <title>Cascade</title>

      <para>Hibernate offers more operations than the Java Persistence
      specification. You can use the <literal>@Cascade</literal> annotation to
      cascade the following operations:</para>

      <itemizedlist>
        <listitem>
          <para>PERSIST</para>
        </listitem>

        <listitem>
          <para>MERGE</para>
        </listitem>

        <listitem>
          <para>REMOVE</para>
        </listitem>

        <listitem>
          <para>REFRESH</para>
        </listitem>

        <listitem>
          <para>DELETE</para>
        </listitem>

        <listitem>
          <para>SAVE_UPDATE</para>
        </listitem>

        <listitem>
          <para>REPLICATE</para>
        </listitem>

        <listitem>
          <para>DELETE_ORPHAN</para>
        </listitem>

        <listitem>
          <para>LOCK</para>
        </listitem>

        <listitem>
          <para>EVICT</para>
        </listitem>
      </itemizedlist>

      <para>This is especially useful for <literal>SAVE_UPDATE</literal>
      (which is the operation cascaded at flush time if you use plain
      Hibernate Annotations - Hibernate EntityManager cascade
      <literal>PERSIST</literal> at flush time as per the specification).
      DELETE_ORPHAN applies only to <literal>@OneToMany</literal>
      associations, and indicates that the
      <methodname>delete()/remove()</methodname> operation should be applied
      to any child object that is removed from the association. In other
      words, if a child is dereferenced by a persistent parent and if
      <literal>DELETE_ORPHAN</literal> is used, the "orphaned" child is
      deleted.</para>

      <programlisting>@OneToMany( cascade = {CascadeType.PERSIST, CascadeType.MERGE} <emphasis
          role="bold">)
@Cascade({org.hibernate.annotations.CascadeType.SAVE_UPDATE,
          org.hibernate.annotations.CascadeType.DELETE_ORPHAN})</emphasis>
public Collection&lt;Employer&gt; getEmployers()</programlisting>

      <para>It is recommended to use @Cascade to compliment @*To*(cascade=...)
      as shown in the previous example.</para>
    </sect2>

    <sect2>
      <title>Cache</title>

      <para>In order to optimize your database accesses, you can activate the
      so called second level cache of Hibernate. This cache is configurable on
      a per entity and per collection basis.</para>

      <para><literal>@org.hibernate.annotations.Cache</literal> defines the
      caching strategy and region of a given second level cache. This
      annotation can be applied on the root entity (not the sub entities), and
      on the collections.</para>

      <programlisting>@Entity
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public class Forest { ... }</programlisting>

      <programlisting>    @OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
    @JoinColumn(name="CUST_ID")
    @Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
    public SortedSet&lt;Ticket&gt; getTickets() {
        return tickets;
    }</programlisting>

      <para></para>

      <programlistingco>
        <areaspec>
          <area coords="2 55" id="hm1" />

          <area coords="3 55" id="hm2" />

          <area coords="4 55" id="hm3" />
        </areaspec>

        <programlisting>@Cache(
    CacheConcurrencyStrategy usage();
    String region() default "";
    String include() default "all";
)</programlisting>

        <calloutlist>
          <callout arearefs="hm1">
            <para>usage: the given cache concurrency strategy (NONE,
            READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)</para>
          </callout>

          <callout arearefs="hm2">
            <para>region (optional): the cache region (default to the fqcn of
            the class or the fq role name of the collection)</para>
          </callout>

          <callout arearefs="hm3">
            <para><literal>include</literal> (optional): all to include all
            properties, non-lazy to only include non lazy properties (default
            all).</para>
          </callout>
        </calloutlist>
      </programlistingco>
    </sect2>

    <sect2 id="entity-hibspec-filters">
      <title>Filters</title>

      <para>Hibernate has the ability to apply arbitrary filters on top of
      your data. Those filters are applied at runtime on a given session.
      First, you need to define them.</para>

      <para><literal>@org.hibernate.annotations.FilterDef</literal> or
      <literal>@FilterDefs</literal> define filter definition(s) used by
      filter(s) using the same name. A filter definition has a name() and an
      array of parameters(). A parameter will allow you to adjust the behavior
      of the filter at runtime. Each parameter is defined by a
      <literal>@ParamDef</literal> which has a name and a type. You can also
      define a defaultCondition() parameter for a given
      <literal>@FilterDef</literal> to set the default condition to use when
      none are defined in each individual <literal>@Filter</literal>. A
      <literal>@FilterDef</literal>(s) can be defined at the class or package
      level.</para>

      <para>We now need to define the SQL filter clause applied to either the
      entity load or the collection load. <literal>@Filter</literal> is used
      and placed either on the entity or the collection element</para>

      <para><programlisting>@Entity
@FilterDef(name="minLength", parameters=@ParamDef( name="minLength", type="integer" ) )
@Filters( {
    @Filter(name="betweenLength", condition=":minLength &lt;= length and :maxLength &gt;= length"),
    @Filter(name="minLength", condition=":minLength &lt;= length")
} )
public class Forest { ... }</programlisting></para>

      <para>When the collection use an association table as a relational
      representation, you might want to apply the filter condition to the
      association table itself or to the target entity table. To apply the
      constraint on the target entity, use the regular
      <literal>@Filter</literal> annotation. However, if you wan to target the
      association table, use the <literal>@FilterJoinTable</literal>
      annotation.</para>

      <programlisting>    @OneToMany
    @JoinTable
    //filter on the target entity table
    @Filter(name="betweenLength", condition=":minLength &lt;= length and :maxLength &gt;= length")
    //filter on the association table
    @FilterJoinTable(name="security", condition=":userlevel &gt;= requredLevel")
    public Set&lt;Forest&gt; getForests() { ... }</programlisting>
    </sect2>

    <sect2 id="entity-hibspec-query">
      <title>Queries</title>

      <para>Since Hibernate has more features on named queries than the one
      defined in the EJB3 specification,
      <literal>@org.hibernate.annotations.NamedQuery</literal>,
      <literal>@org.hibernate.annotations.NamedQueries</literal>,
      <literal>@org.hibernate.annotations.NamedNativeQuery</literal> and
      <literal>@org.hibernate.annotations.NamedNativeQueries</literal> have
      been introduced. They add some attributes to the standard version and
      can be used as a replacement:</para>

      <itemizedlist>
        <listitem>
          <para>flushMode: define the query flush mode (Always, Auto, Commit
          or Manual)</para>
        </listitem>

        <listitem>
          <para>cacheable: whether the query should be cached or not</para>
        </listitem>

        <listitem>
          <para>cacheRegion: cache region used if the query is cached</para>
        </listitem>

        <listitem>
          <para>fetchSize: JDBC statement fetch size for this query</para>
        </listitem>

        <listitem>
          <para>timeout: query time out</para>
        </listitem>

        <listitem>
          <para>callable: for native queries only, to be set to true for
          stored procedures</para>
        </listitem>

        <listitem>
          <para>comment: if comments are activated, the comment seen when the
          query is sent to the database.</para>
        </listitem>

        <listitem>
          <para>cacheMode: Cache interaction mode (get, ignore, normal, put or
          refresh)</para>
        </listitem>

        <listitem>
          <para>readOnly: whether or not the elements retrievent from the
          query are in read only mode.</para>
        </listitem>
      </itemizedlist>

      <para>Those hints can be set in a standard
      <literal>@javax.persistence.NamedQuery</literal> annotations through the
      detyped <literal>@QueryHint</literal>. Another key advantage is the
      ability to set those annotations at a package level.</para>
    </sect2>

    <sect2 id="entity-hibspec-customsql" revision="1">
      <title>Custom SQL for CRUD operations</title>

      <para>Hibernate gives you the ability to override every single SQL
      statement generated. We have seen native SQL query usage already, but
      you can also override the SQL statement used to load or change the state
      of entities.</para>

      <programlisting>@Entity
@Table(name="CHAOS")
<emphasis role="bold">@SQLInsert( sql="INSERT INTO CHAOS(size, name, nickname, id) VALUES(?,upper(?),?,?)")
@SQLUpdate( sql="UPDATE CHAOS SET size = ?, name = upper(?), nickname = ? WHERE id = ?")
@SQLDelete( sql="DELETE CHAOS WHERE id = ?")
@SQLDeleteAll( sql="DELETE CHAOS")
</emphasis><emphasis role="bold">@Loader(namedQuery = "chaos")</emphasis>
@NamedNativeQuery(name="chaos", query="select id, size, name, lower( nickname ) as nickname from CHAOS where id= ?", resultClass = Chaos.class)
public class Chaos {
    @Id
    private Long id;
    private Long size;
    private String name;
    private String nickname;</programlisting>

      <para><literal>@SQLInsert</literal>, <literal>@SQLUpdate</literal>,
      <literal>@SQLDelete</literal>, <literal>@SQLDeleteAll</literal>
      respectively override the INSERT statement, UPDATE statement, DELETE
      statement, DELETE statement to remove all entities.</para>

      <para>If you expect to call a store procedure, be sure to set the
      <literal>callable</literal> attribute to true
      (<literal>@SQLInsert(callable=true, ...)</literal>).</para>

      <para>To check that the execution happens correctly, Hibernate allows
      you to define one of those three strategies:</para>

      <itemizedlist>
        <listitem>
          <para>NONE: no check is performed: the store procedure is expected
          to fail upon issues</para>
        </listitem>

        <listitem>
          <para>COUNT: use of rowcount to check that the update is
          successful</para>
        </listitem>

        <listitem>
          <para>PARAM: like COUNT but using an output parameter rather that
          the standard mechanism</para>
        </listitem>
      </itemizedlist>

      <para>To define the result check style, use the <literal>check</literal>
      parameter (<literal>@SQLUpdate(check=ResultCheckStyle.COUNT,
      ...)</literal>).</para>

      <para>You can also override the SQL load statement by a native SQL query
      or a HQL query. You just have to refer to a named query with the
      <literal><literal>@Loader</literal></literal> annotation.</para>

      <para>You can use the exact same set of annotations to override the
      collection related statements.</para>

      <programlisting>@OneToMany
@JoinColumn(name="chaos_fk")
<emphasis role="bold">@SQLInsert( sql="UPDATE CASIMIR_PARTICULE SET chaos_fk = ? where id = ?")
@SQLDelete( sql="UPDATE CASIMIR_PARTICULE SET chaos_fk = null where id = ?")</emphasis>
private Set&lt;CasimirParticle&gt; particles = new HashSet&lt;CasimirParticle&gt;();</programlisting>

      <para>The parameters order is important and is defined by the order
      Hibernate handle properties. You can see the expected order by enabling
      debug logging for the <literal>org.hibernate.persister.entity</literal>
      level. With this level enabled Hibernate will print out the static SQL
      that is used to create, update, delete etc. entities. (To see the
      expected sequence, remember to not include your custom SQL through
      annotations as that will override the Hibernate generated static
      sql.)</para>

      <para>Overriding SQL statements for secondary tables is also possible
      using <literal>@org.hibernate.annotations.Table</literal> and either (or
      all) attributes <literal>sqlInsert</literal>,
      <literal>sqlUpdate</literal>, <literal>sqlDelete</literal>:</para>

      <programlisting>@Entity
@SecondaryTables({
    @SecondaryTable(name = "`Cat nbr1`"),
    @SecondaryTable(name = "Cat2"})
@org.hibernate.annotations.Tables( {
    @Table(appliesTo = "Cat", comment = "My cat table" ),
    @Table(appliesTo = "Cat2", foreignKey = @ForeignKey(name="FK_CAT2_CAT"), fetch = FetchMode.SELECT,
        <emphasis role="bold">sqlInsert=@SQLInsert(sql="insert into Cat2(storyPart2, id) values(upper(?), ?)") )</emphasis>
} )
public class Cat implements Serializable {</programlisting>

      <para>The previous example also show that you can give a comment to a
      given table (promary or secondary): This comment will be used for DDL
      generation.</para>
    </sect2>

    <sect2>
      <title>Tuplizer</title>

      <para><classname>org.hibernate.tuple.Tuplizer</classname>, and its
      sub-interfaces, are responsible for managing a particular representation
      of a piece of data, given that representation's
      <literal>org.hibernate.EntityMode</literal>. If a given piece of data is
      thought of as a data structure, then a tuplizer is the thing which knows
      how to create such a data structure and how to extract values from and
      inject values into such a data structure. For example, for the POJO
      entity mode, the correpsonding tuplizer knows how create the POJO
      through its constructor and how to access the POJO properties using the
      defined property accessors. There are two high-level types of Tuplizers,
      represented by the
      <classname>org.hibernate.tuple.EntityTuplizer</classname> and
      <classname>org.hibernate.tuple.ComponentTuplizer</classname> interfaces.
      EntityTuplizers are responsible for managing the above mentioned
      contracts in regards to entities, while
      <classname>ComponentTuplizers</classname> do the same for components.
      Check the Hibernate reference documentation for more information.</para>

      <para>To define tuplixer in annotations, simply use the
      <literal>@Tuplizer</literal> annotation on the according element</para>

      <programlisting>@Entity
<emphasis role="bold">@Tuplizer(impl = DynamicEntityTuplizer.class)</emphasis>
public interface Cuisine {
    @Id
    @GeneratedValue
    public Long getId();
    public void setId(Long id);

    public String getName();
    public void setName(String name);

    <emphasis role="bold">@Tuplizer(impl = DynamicComponentTuplizer.class)</emphasis>
    public Country getCountry();
    public void setCountry(Country country);


}</programlisting>
    </sect2>
  </sect1>
</chapter>