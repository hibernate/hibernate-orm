#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"

#: index.docbook:5
msgid "Working with objects"
msgstr "Trabajando con objetos"

#: index.docbook:7
msgid ""
"Hibernate is a full object/relational mapping solution that not only shields "
"the developer from the details of the underlying database management system, "
"but also offers <emphasis>state management</emphasis> of objects. This is, "
"contrary to the management of SQL <literal>statements</literal> in common "
"JDBC/SQL persistence layers, a very natural object-oriented view of "
"persistence in Java applications."
msgstr ""
"Hibernate es una soluci&#x00f3;n completa de mapeo objeto/relacional que no "
"s&#x00f3;lo abstrae al desarrollador de los detalles del sistema de manejo "
"de base datos subyacente, sino que adem&#x00e1;s ofrece <emphasis>manejo de "
"estado</emphasis> de objetos. Esto es, al contrario del manejo de "
"<literal>sentencias</literal> SQL en capas comunes de persistencia JDBC/SQL, "
"una vista de la persistencia en aplicaciones Java muy natural y orientada a "
"objetos."

#: index.docbook:16
msgid ""
"In other words, Hibernate application developers should always think about "
"the <emphasis>state</emphasis> of their objects, and not necessarily about "
"the execution of SQL statements. This part is taken care of by Hibernate and "
"is only relevant for the application developer when tuning the performance "
"of the system."
msgstr ""
"En otras palabras, los desarroladores de aplicaciones Hibernate deben "
"siempre pensar en el <emphasis>estado</emphasis> de sus objetos, y no "
"necesariamente en la ejecuci&#x00f3;n de sentencias SQL. Esta parte es "
"cuidada por Hibernate y es s&#x00f3;lo relevante para el desarrollador de la "
"aplicaci&#x00f3;n al afinar el rendimiento del sistema."

#: index.docbook:24
msgid "Hibernate object states"
msgstr "Estados de objeto de Hibernate"

#: index.docbook:26
msgid "Hibernate defines and supports the following object states:"
msgstr "Hibernate define y soporta los siguientes estados de objeto:"

#: index.docbook:32
msgid ""
"<emphasis>Transient</emphasis> - an object is transient if it has just been "
"instantiated using the <literal>new</literal> operator, and it is not "
"associated with a Hibernate <literal>Session</literal>. It has no persistent "
"representation in the database and no identifier value has been assigned. "
"Transient instances will be destroyed by the garbage collector if the "
"application doesn't hold a reference anymore. Use the Hibernate "
"<literal>Session</literal> to make an object persistent (and let Hibernate "
"take care of the SQL statements that need to be executed for this "
"transition)."
msgstr ""
"<emphasis>Transitorio</emphasis> - un objeto es transitorio si ha sido "
"reci&#x00e9;n instanciado usando el operador <literal>new</literal>, y no "
"est&#x00e1; asociado a una <literal>Session</literal> de Hibernate. No tiene "
"una representaci&#x00f3;n persistente en la base de datos y no se le ha "
"asignado un valor identificador. Las instancias transitorias ser&#x00e1;n "
"destru&#x00ed;das por el recolector de basura si la aplicaci&#x00f3;n no "
"mantiene m&#x00e1;s una referencia. Usa la <literal>Session</literal> de "
"Hibernate para hacer un objeto persistente (y deja que Hibernate cuide de "
"las sentencias SQL que necesitan ejecutarse para esta transici&#x00f3;n)."

#: index.docbook:44
msgid ""
"<emphasis>Persistent</emphasis> - a persistent instance has a representation "
"in the database and an identifier value. It might just have been saved or "
"loaded, however, it is by definition in the scope of a <literal>Session</"
"literal>. Hibernate will detect any changes made to an object in persistent "
"state and synchronize the state with the database when the unit of work "
"completes. Developers don't execute manual <literal>UPDATE</literal> "
"statements, or <literal>DELETE</literal> statements when an object should be "
"made transient."
msgstr ""
"<emphasis>Persistente</emphasis> - una instancia persistente tiene una "
"representaci&#x00f3;n en la base de datos y un valor identificador. Puede "
"haber sido salvado o cargado, sin embargo, est&#x00e1; por definici&#x00f3;n "
"en el &#x00e1;mbito de una <literal>Session</literal>. Hibernate "
"detectar&#x00e1; cualquier cambio hecho a un objeto en estado persistentey "
"sincronizar&#x00e1; el estado con la base de datos cuando se complete la "
"unidad de trabajo. Los desarrolladores no ejecutan sentencias "
"<literal>UPDATE</literal> manuales, o sentencias <literal>DELETE</literal> "
"cuando un objeto debe ser hecho transitorio."

#: index.docbook:55
msgid ""
"<emphasis>Detached</emphasis> - a detached instance is an object that has "
"been persistent, but its <literal>Session</literal> has been closed. The "
"reference to the object is still valid, of course, and the detached instance "
"might even be modified in this state. A detached instance can be reattached "
"to a new <literal>Session</literal> at a later point in time, making it (and "
"all the modifications) persistent again. This feature enables a programming "
"model for long running units of work that require user think-time. We call "
"them <emphasis>application transactions</emphasis>, i.e. a unit of work from "
"the point of view of the user."
msgstr ""
"<emphasis>Separado (detached)</emphasis> - una instancia separada es un "
"objeto que ha sido hecho persistente, pero su <literal>Session</literal> ha "
"sido cerrada. La referencia al objeto todav&#x00ed;a es v&#x00e1;lida, por "
"supuesto, y la instancia separada podr&#x00ed;a incluso ser modificada en "
"este estado. Una instancia separada puede ser re-unida a una nueva "
"<literal>Session</literal> en un punto posterior en el tiempo, haci&#x00e9;"
"ndola persistente de nuevo (con todas las modificaciones). Este aspecto "
"habilita un modelo de programaci&#x00f3;n para unidades de trabajo de "
"ejecuci&#x00f3;n larga que requieren tiempo-para-pensar del usuario. Las "
"llamamos <emphasis>transaccciones de aplicaci&#x00f3;n</emphasis>, es decir, "
"una unidad de trabajo desde el punto de vista del usuario."

#: index.docbook:69
msgid ""
"We'll now discuss the states and state transitions (and the Hibernate "
"methods that trigger a transition) in more detail."
msgstr ""
"Discutiremos ahora los estados y transiciones de estados (y los m&#x00e9;"
"todos de Hibernate que disparan una transici&#x00f3;n) en m&#x00e1;s detalle:"

#: index.docbook:77
msgid "Making objects persistent"
msgstr "Haciendo los objetos persistentes"

#: index.docbook:79
msgid ""
"Newly instantiated instances of a a persistent class are considered "
"<emphasis>transient</emphasis> by Hibernate. We can make a transient "
"instance <emphasis>persistent</emphasis> by associating it with a session:"
msgstr ""
"Las instancias reci&#x00e9;n instanciadas de una clase persistente son "
"consideradas <emphasis>transitorias</emphasis> por Hibernate. Podemos hacer "
"una instancia transitoria <emphasis>persistente</emphasis> asoci&#x00e1;"
"ndola con una sesi&#x00f3;n:"

#: index.docbook:86
msgid ""
"<![CDATA[DomesticCat fritz = new DomesticCat();\n"
"fritz.setColor(Color.GINGER);\n"
"fritz.setSex('M');\n"
"fritz.setName(\"Fritz\");\n"
"Long generatedId = (Long) sess.save(fritz);]]>"
msgstr ""
"<![CDATA[DomesticCat fritz = new DomesticCat();\n"
"fritz.setColor(Color.GINGER);\n"
"fritz.setSex('M');\n"
"fritz.setName(\"Fritz\");\n"
"Long generatedId = (Long) sess.save(fritz);]]>"

#: index.docbook:88
msgid ""
"If <literal>Cat</literal> has a generated identifier, the identifier is "
"generated and assigned to the <literal>cat</literal> when <literal>save()</"
"literal> is called. If <literal>Cat</literal> has an <literal>assigned</"
"literal> identifier, or a composite key, the identifier should be assigned "
"to the <literal>cat</literal> instance before calling <literal>save()</"
"literal>. You may also use <literal>persist()</literal> instead of "
"<literal>save()</literal>, with the semantics defined in the EJB3 early "
"draft."
msgstr ""
"Si <literal>Cat</literal> tiene un identificador generado, el identificador "
"es generado y asignado al <literal>cat</literal> cuando se llama a "
"<literal>save()</literal>. Si <literal>Cat</literal> tiene un identificador "
"<literal>assigned</literal>, o una clave compuesta, el identificador debe "
"ser asignado a la instancia de <literal>cat</literal> antes de llamar a "
"<literal>save()</literal>. Puedes tambi&#x00e9;n usar <literal>persist()</"
"literal> en vez de <literal>save()</literal>, con la sem&#x00e1;ntica "
"definida en el temprano borrador de EJB3."

#: index.docbook:100
msgid ""
"<literal>persist()</literal> makes a transient instance persistent. However, "
"it doesn't guarantee that the identifier value will be assigned to the "
"persistent instance immediately, the assignment might happen at flush time. "
"<literal>persist()</literal> also guarantees that it will not execute an "
"<literal>INSERT</literal> statement if it is called outside of transaction "
"boundaries. This is useful in long-running conversations with an extended "
"Session/persistence context."
msgstr ""
"UNTRANSLATED!!! <literal>persist()</literal> makes a transient instance "
"persistent. However, it doesn't guarantee that the identifier value will be "
"assigned to the persistent instance immediately, the assignment might happen "
"at flush time. <literal>persist()</literal> also guarantees that it will not "
"execute an <literal>INSERT</literal> statement if it is called outside of "
"transaction boundaries. This is useful in long-running conversations with an "
"extended Session/persistence context."

#: index.docbook:111
msgid ""
"<literal>save()</literal> does guarantee to return an identifier. If an "
"INSERT has to be executed to get the identifier ( e.g. \"identity\" "
"generator, not \"sequence\"), this INSERT happens immediately, no matter if "
"you are inside or outside of a transaction. This is problematic in a long-"
"running conversation with an extended Session/persistence context."
msgstr ""
"<literal>save()</literal> does guarantee to return an identifier. If an "
"INSERT has to be executed to get the identifier ( e.g. \"identity\" "
"generator, not \"sequence\"), this INSERT happens immediately, no matter if "
"you are inside or outside of a transaction. This is problematic in a long-"
"running conversation with an extended Session/persistence context."

#: index.docbook:121
msgid ""
"Alternatively, you may assign the identifier using an overloaded version of "
"<literal>save()</literal>."
msgstr ""
"Alternativamente, puedes asignar el identificador usando una versi&#x00f3;n "
"sobrecargada de <literal>save()</literal>."

#: index.docbook:126
msgid ""
"<![CDATA[DomesticCat pk = new DomesticCat();\n"
"pk.setColor(Color.TABBY);\n"
"pk.setSex('F');\n"
"pk.setName(\"PK\");\n"
"pk.setKittens( new HashSet() );\n"
"pk.addKitten(fritz);\n"
"sess.save( pk, new Long(1234) );]]>"
msgstr ""
"<![CDATA[DomesticCat pk = new DomesticCat();\n"
"pk.setColor(Color.TABBY);\n"
"pk.setSex('F');\n"
"pk.setName(\"PK\");\n"
"pk.setKittens( new HashSet() );\n"
"pk.addKitten(fritz);\n"
"sess.save( pk, new Long(1234) );]]>"

#: index.docbook:128
msgid ""
"If the object you make persistent has associated objects (e.g. the "
"<literal>kittens</literal> collection in the previous example), these "
"objects may be made persistent in any order you like unless you have a "
"<literal>NOT NULL</literal> constraint upon a foreign key column. There is "
"never a risk of violating foreign key constraints. However, you might "
"violate a <literal>NOT NULL</literal> constraint if you <literal>save()</"
"literal> the objects in the wrong order."
msgstr ""
"Si el objeto que haces persistente tiene objetos asociados (por ejemplo, la "
"colecci&#x00f3;n <literal>kittens</literal> en el ejemplo anterior), estos "
"objetos pueden ser hechos persistentes en cualquier orden que quieras a "
"menos que tengas una restricci&#x00f3;n <literal>NOT NULL</literal> sobre "
"una columna clave for&#x00e1;nea. Nunca hay riesgo de violar restricciones "
"de clave for&#x00e1;nea. Sin embargo, podr&#x00ed;as violar una "
"restricci&#x00f3;n <literal>NOT NULL</literal> si llamas a <literal>save()</"
"literal> sobre objetos en orden err&#x00f3;neo."

#: index.docbook:138
msgid ""
"Usually you don't bother with this detail, as you'll very likely use "
"Hibernate's <emphasis>transitive persistence</emphasis> feature to save the "
"associated objects automatically. Then, even <literal>NOT NULL</literal> "
"constraint violations don't occur - Hibernate will take care of everything. "
"Transitive persistence is discussed later in this chapter."
msgstr ""
"Usualmente no te preocupas con este detalle, pues muy probablemente "
"usar&#x00e1;s la funcionalidad de <emphasis>persistencia transitiva</"
"emphasis> de Hibernate para salvar los objetos asociados autom&#x00e1;"
"ticamente. Entonces, ni siquiera ocurren violaciones de restricciones "
"<literal>NOT NULL</literal> - Hibernate cuidar&#x00e1; de todo. La "
"persistencia transitiva se discute m&#x00e1;s adelante en este cap&#x00ed;"
"tulo."

#: index.docbook:149
msgid "Loading an object"
msgstr "Cargando un objeto"

#: index.docbook:151
msgid ""
"The <literal>load()</literal> methods of <literal>Session</literal> gives "
"you a way to retrieve a persistent instance if you already know its "
"identifier. <literal>load()</literal> takes a class object and will load the "
"state into a newly instantiated instance of that class, in persistent state."
msgstr ""
"Los m&#x00e9;todos <literal>load()</literal> de <literal>Session</literal> "
"te brindan una forma de traer una instancia persistente si ya saves su "
"identificador. <literal>load()</literal> toma un objeto clase y "
"cargar&#x00e1; el estado dentro de una instancia reci&#x00e9;n instanciada "
"de esta clase, en estado persistente."

#: index.docbook:158
msgid "<![CDATA[Cat fritz = (Cat) sess.load(Cat.class, generatedId);]]>"
msgstr "<![CDATA[Cat fritz = (Cat) sess.load(Cat.class, generatedId);]]>"

#: index.docbook:160
msgid ""
"<![CDATA[// you need to wrap primitive identifiers\n"
"long id = 1234;\n"
"DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long"
"(id) );]]>"
msgstr ""
"<![CDATA[// you need to wrap primitive identifiers\n"
"long id = 1234;\n"
"DomesticCat pk = (DomesticCat) sess.load( DomesticCat.class, new Long"
"(id) );]]>"

#: index.docbook:162
msgid "Alternatively, you can load state into a given instance:"
msgstr "Alternativamente, puedes cargar estado dentro de una instancia dada:"

#: index.docbook:166
msgid ""
"<![CDATA[Cat cat = new DomesticCat();\n"
"// load pk's state into cat\n"
"sess.load( cat, new Long(pkId) );\n"
"Set kittens = cat.getKittens();]]>"
msgstr ""
"<![CDATA[Cat cat = new DomesticCat();\n"
"// load pk's state into cat\n"
"sess.load( cat, new Long(pkId) );\n"
"Set kittens = cat.getKittens();]]>"

#: index.docbook:168
msgid ""
"Note that <literal>load()</literal> will throw an unrecoverable exception if "
"there is no matching database row. If the class is mapped with a proxy, "
"<literal>load()</literal> just returns an uninitialized proxy and does not "
"actually hit the database until you invoke a method of the proxy. This "
"behaviour is very useful if you wish to create an association to an object "
"without actually loading it from the database. It also allows multiple "
"instances to be loaded as a batch if <literal>batch-size</literal> is "
"defined for the class mapping."
msgstr ""
"Nota que <literal>load()</literal> lanzar&#x00e1; una excepci&#x00f3;n "
"irrecuperable si no hay una fila correspondiente en base de datos. Si la "
"clase es mapeada con un proxy, <literal>load()</literal> s&#x00f3;lo "
"devuelve un proxy no inicializado y no llamar&#x00e1; realmente a la base de "
"datos hasta que invoques un m&#x00e9;todo del proxy. Este comportamiento es "
"muy &#x00fa;til si deseas crear una asociaci&#x00f3;n a un objeto sin "
"cargarlo realmente de la base de datos. Permite adem&#x00e1;s que m&#x00fa;"
"ltiples instancias sean cargadas como un lote si se define <literal>batch-"
"size</literal> para el mapeo de la clase."

#: index.docbook:179
msgid ""
"If you are not certain that a matching row exists, you should use the "
"<literal>get()</literal> method, which hits the database immediately and "
"returns null if there is no matching row."
msgstr ""
"Si no tienes certeza que exista una fila correspondiente, debes usar el "
"m&#x00e9;todo <literal>get()</literal>, que llama a la base de datos "
"inmediatamente y devuelve nulo si no existe una fila correspondiente."

#: index.docbook:185
msgid ""
"<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id);\n"
"if (cat==null) {\n"
"    cat = new Cat();\n"
"    sess.save(cat, id);\n"
"}\n"
"return cat;]]>"
msgstr ""
"<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id);\n"
"if (cat==null) {\n"
"    cat = new Cat();\n"
"    sess.save(cat, id);\n"
"}\n"
"return cat;]]>"

#: index.docbook:187
msgid ""
"You may even load an object using an SQL <literal>SELECT ... FOR UPDATE</"
"literal>, using a <literal>LockMode</literal>. See the API documentation for "
"more information."
msgstr ""
"Puedes incluso cargar un objeto usando un <literal>SELECT ... FOR UPDATE</"
"literal> de SQL, usando un <literal>LockMode</literal>. Ver la "
"documentaci&#x00f3;n de la API para m&#x00e1;s informaci&#x00f3;n."

#: index.docbook:192
msgid "<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);]]>"
msgstr "<![CDATA[Cat cat = (Cat) sess.get(Cat.class, id, LockMode.UPGRADE);]]>"

#: index.docbook:194
msgid ""
"Note that any associated instances or contained collections are "
"<emphasis>not</emphasis> selected <literal>FOR UPDATE</literal>, unless you "
"decide to specify <literal>lock</literal> or <literal>all</literal> as a "
"cascade style for the association."
msgstr ""
"Ten en cuenta que <emphasis>ninguna</emphasis> instancia asociada o "
"colecci&#x00f3;n contenida es selecciona <literal>FOR UPDATE</literal>, a "
"menos que decidas especificar <literal>lock</literal> o <literal>all</"
"literal> como un estilo de cascada para la asociaci&#x00f3;n."

#: index.docbook:201
msgid ""
"It is possible to re-load an object and all its collections at any time, "
"using the <literal>refresh()</literal> method. This is useful when database "
"triggers are used to initialize some of the properties of the object."
msgstr ""
"Es posible volver a cargar un objeto y todas sus colecciones en cualquier "
"momento, usando el m&#x00e9;todo <literal>refresh()</literal>. Esto es "
"&#x00fa;til cuando se usan disparadores de base de datos para inicializar "
"algunas de las propiedades del objeto."

#: index.docbook:207
msgid ""
"<![CDATA[sess.save(cat);\n"
"sess.flush(); //force the SQL INSERT\n"
"sess.refresh(cat); //re-read the state (after the trigger executes)]]>"
msgstr ""
"<![CDATA[sess.save(cat);\n"
"sess.flush(); //force the SQL INSERT\n"
"sess.refresh(cat); //re-read the state (after the trigger executes)]]>"

#: index.docbook:209
msgid ""
"An important question usually appears at this point: How much does Hibernate "
"load from the database and how many SQL <literal>SELECT</literal>s will it "
"use? This depends on the <emphasis>fetching strategy</emphasis> and is "
"explained in <xref linkend=\"performance-fetching\"/>."
msgstr ""
"Una cuesti&#x00f3;n importante aparece usualmente en este punto: Â¿Cu&#x00e1;"
"nto carga Hibernate de la base de datos y cu&#x00e1;ntos <literal>SELECT</"
"literal>s de SQL usar&#x00e1;? Esto depende de la <emphasis>estrategia de "
"recuperaci&#x00f3;n</emphasis> y se explica en <xref linkend=\"performance-"
"fetching\"/>."

#: index.docbook:219
msgid "Querying"
msgstr "Consultando"

#: index.docbook:221
msgid ""
"If you don't know the identifiers of the objects you are looking for, you "
"need a query. Hibernate supports an easy-to-use but powerful object oriented "
"query language (HQL). For programmatic query creation, Hibernate supports a "
"sophisticated Criteria and Example query feature (QBC and QBE). You may also "
"express your query in the native SQL of your database, with optional support "
"from Hibernate for result set conversion into objects."
msgstr ""
"Si no sabes los identificadores de los objetos que est&#x00e1;s buscando, "
"necesitas una consulta. Hibernate soporta un lenguaje de consulta orientado "
"a objetos (HQL) f&#x00e1;cil de usar pero potente. Para la creaci&#x00f3;n "
"de consultas program&#x00e1;ticas, Hibernate soporta una funcionalidad "
"sofisticada de consulta de Criteria y Example (QBC and QBE). Tambi&#x00e9;n "
"puedes expresar tu consulta en el SQL nativo de tu base de datos, con "
"soporte opcional de Hibernate para la conversi&#x00f3;n del conjunto "
"resultado en objetos."

#: index.docbook:231
msgid "Executing queries"
msgstr "Ejecutando consultas"

#: index.docbook:233
msgid ""
"HQL and native SQL queries are represented with an instance of <literal>org."
"hibernate.Query</literal>. This interface offers methods for parameter "
"binding, result set handling, and for the execution of the actual query. You "
"always obtain a <literal>Query</literal> using the current <literal>Session</"
"literal>:"
msgstr ""
"Las consultas HQL y SQL nativas son representadas con una instancia de "
"<literal>org.hibernate.Query</literal>. Esta interface ofrece m&#x00e9;todos "
"para la ligaci&#x00f3;n de par&#x00e1;metros, manejo del conjunto resultado, "
"y para la ejecuci&#x00f3;n de la consulta real. Siempre obtienes una "
"<literal>Query</literal> usando la <literal>Session</literal> actual:"

#: index.docbook:240
msgid ""
"<![CDATA[List cats = session.createQuery(\n"
"    \"from Cat as cat where cat.birthdate < ?\")\n"
"    .setDate(0, date)\n"
"    .list();\n"
"\n"
"List mothers = session.createQuery(\n"
"    \"select mother from Cat as cat join cat.mother as mother where cat.name "
"= ?\")\n"
"    .setString(0, name)\n"
"    .list();\n"
"\n"
"List kittens = session.createQuery(\n"
"    \"from Cat as cat where cat.mother = ?\")\n"
"    .setEntity(0, pk)\n"
"    .list();\n"
"\n"
"Cat mother = (Cat) session.createQuery(\n"
"    \"select cat.mother from Cat as cat where cat = ?\")\n"
"    .setEntity(0, izi)\n"
"    .uniqueResult();]]\n"
"\n"
"Query mothersWithKittens = (Cat) session.createQuery(\n"
"    \"select mother from Cat as mother left join fetch mother.kittens\");\n"
"Set uniqueMothers = new HashSet(mothersWithKittens.list());]]>"
msgstr ""
"<![CDATA[List cats = session.createQuery(\n"
"    \"from Cat as cat where cat.birthdate < ?\")\n"
"    .setDate(0, date)\n"
"    .list();\n"
"\n"
"List mothers = session.createQuery(\n"
"    \"select mother from Cat as cat join cat.mother as mother where cat.name "
"= ?\")\n"
"    .setString(0, name)\n"
"    .list();\n"
"\n"
"List kittens = session.createQuery(\n"
"    \"from Cat as cat where cat.mother = ?\")\n"
"    .setEntity(0, pk)\n"
"    .list();\n"
"\n"
"Cat mother = (Cat) session.createQuery(\n"
"    \"select cat.mother from Cat as cat where cat = ?\")\n"
"    .setEntity(0, izi)\n"
"    .uniqueResult();]]>"

#: index.docbook:242
msgid ""
"A query is usually executed by invoking <literal>list()</literal>, the "
"result of the query will be loaded completely into a collection in memory. "
"Entity instances retrieved by a query are in persistent state. The "
"<literal>uniqueResult()</literal> method offers a shortcut if you know your "
"query will only return a single object. Note that queries that make use of "
"eager fetching of collections usually return duplicates of the root objects "
"(but with their collections initialized). You can filter these duplicates "
"simply through a <literal>Set</literal>."
msgstr ""
"Una consulta se ejecuta usualmente invocando a <literal>list()</literal>, el "
"resultado de la consulta ser&#x00e1; cargado completamente dentro de una "
"colecci&#x00f3;n en memoria. Las instancias de entidad tra&#x00ed;das por "
"una consulta est&#x00e1;n en estado persistente. El m&#x00e9;todo "
"<literal>uniqueResult()</literal> ofrece un atajo si sabes que tu consulta "
"devolver&#x00e1; s&#x00f3;lo un objeto."

#: index.docbook:254
msgid "Iterating results"
msgstr "Iterando los resultados"

#: index.docbook:256
msgid ""
"Occasionally, you might be able to achieve better performance by executing "
"the query using the <literal>iterate()</literal> method. This will only "
"usually be the case if you expect that the actual entity instances returned "
"by the query will already be in the session or second-level cache. If they "
"are not already cached, <literal>iterate()</literal> will be slower than "
"<literal>list()</literal> and might require many database hits for a simple "
"query, usually <emphasis>1</emphasis> for the initial select which only "
"returns identifiers, and <emphasis>n</emphasis> additional selects to "
"initialize the actual instances."
msgstr ""
"Ocasionalmente, podr&#x00ed;as ser capaz de lograr mejor rendimiento al "
"ejecutar la consulta usando el m&#x00e9;todo <literal>iterate()</literal>. "
"Esto s&#x00f3;lo ser&#x00e1; en el caso que esperes que las instancias "
"reales de entidad devueltas por la consulta est&#x00e9;n ya en la "
"sesi&#x00f3;n o cach&#x00e9; de segundo nivel. Si todav&#x00ed;a no "
"est&#x00e1;n en cach&#x00e9;, <literal>iterate()</literal> ser&#x00e1; "
"m&#x00e1;s lento que <literal>list()</literal> y podr&#x00ed;a requerir "
"muchas llamadas a la base de datos para una consulta simple, usualmente "
"<emphasis>1</emphasis> para la selecci&#x00f3;n inicial que solamente "
"devuelve identificadores, y <emphasis>n</emphasis> selecciones adicionales "
"para inicializar las instancias reales."

#: index.docbook:268
msgid ""
"<![CDATA[// fetch ids\n"
"Iterator iter = sess.createQuery(\"from eg.Qux q order by q.likeliness\")."
"iterate();\n"
"while ( iter.hasNext() ) {\n"
"    Qux qux = (Qux) iter.next();  // fetch the object\n"
"    // something we couldnt express in the query\n"
"    if ( qux.calculateComplicatedAlgorithm() ) {\n"
"        // delete the current instance\n"
"        iter.remove();\n"
"        // dont need to process the rest\n"
"        break;\n"
"    }\n"
"}]]>"
msgstr ""
"<![CDATA[// fetch ids\n"
"Iterator iter = sess.createQuery(\"from eg.Qux q order by q.likeliness\")."
"iterate();\n"
"while ( iter.hasNext() ) {\n"
"    Qux qux = (Qux) iter.next();  // fetch the object\n"
"    // something we couldnt express in the query\n"
"    if ( qux.calculateComplicatedAlgorithm() ) {\n"
"        // delete the current instance\n"
"        iter.remove();\n"
"        // dont need to process the rest\n"
"        break;\n"
"    }\n"
"}]]>"

#: index.docbook:272
msgid "Queries that return tuples"
msgstr "Consultas que devuelven tuplas"

#: index.docbook:274
msgid ""
"Hibernate queries sometimes return tuples of objects, in which case each "
"tuple is returned as an array:"
msgstr ""
"Las consultas de Hibernate a veces devuelven tuplas de objetos, en cuyo caso "
"cada tupla se devuelve como un array:"

#: index.docbook:279
msgid ""
"<![CDATA[Iterator kittensAndMothers = sess.createQuery(\n"
"            \"select kitten, mother from Cat kitten join kitten.mother mother"
"\")\n"
"            .list()\n"
"            .iterator();\n"
"\n"
"while ( kittensAndMothers.hasNext() ) {\n"
"    Object[] tuple = (Object[]) kittensAndMothers.next();\n"
"    Cat kitten = (Cat) tuple[0];\n"
"    Cat mother = (Cat) tuple[1];\n"
"    ....\n"
"}]]>"
msgstr ""
"<![CDATA[Iterator kittensAndMothers = sess.createQuery(\n"
"            \"select kitten, mother from Cat kitten join kitten.mother mother"
"\")\n"
"            .list()\n"
"            .iterator();\n"
"\n"
"while ( kittensAndMothers.hasNext() ) {\n"
"    Object[] tuple = (Object[]) kittensAndMothers.next();\n"
"    Cat kitten = (Cat) tuple[0];\n"
"    Cat mother = (Cat) tuple[1];\n"
"    ....\n"
"}]]>"

#: index.docbook:284
msgid "Scalar results"
msgstr "Resultados escalares"

#: index.docbook:286
msgid ""
"Queries may specify a property of a class in the <literal>select</literal> "
"clause. They may even call SQL aggregate functions. Properties or aggregates "
"are considered \"scalar\" results (and not entities in persistent state)."
msgstr ""
"Las consultas pueden especificar una propiedad de una clase en la cl&#x00e1;"
"usula <literal>select</literal>. Pueden incluso llamar a funciones de "
"agregaci&#x00f3;n SQL. Las propiedades o agregaciones son considerados "
"resultados \"escalares\" (y no entidades en estado persistente)."

#: index.docbook:292
msgid ""
"<![CDATA[Iterator results = sess.createQuery(\n"
"        \"select cat.color, min(cat.birthdate), count(cat) from Cat cat \" "
"+\n"
"        \"group by cat.color\")\n"
"        .list()\n"
"        .iterator();\n"
"\n"
"while ( results.hasNext() ) {\n"
"    Object[] row = (Object[]) results.next();\n"
"    Color type = (Color) row[0];\n"
"    Date oldest = (Date) row[1];\n"
"    Integer count = (Integer) row[2];\n"
"    .....\n"
"}]]>"
msgstr ""
"<![CDATA[Iterator results = sess.createQuery(\n"
"        \"select cat.color, min(cat.birthdate), count(cat) from Cat cat \" "
"+\n"
"        \"group by cat.color\")\n"
"        .list()\n"
"        .iterator();\n"
"\n"
"while ( results.hasNext() ) {\n"
"    Object[] row = results.next();\n"
"    Color type = (Color) row[0];\n"
"    Date oldest = (Date) row[1];\n"
"    Integer count = (Integer) row[2];\n"
"    .....\n"
"}]]>"

#: index.docbook:297
msgid "Bind parameters"
msgstr "Ligaci&#x00f3;n de par&#x00e1;metros"

#: index.docbook:299
msgid ""
"Methods on <literal>Query</literal> are provided for binding values to named "
"parameters or JDBC-style <literal>?</literal> parameters. <emphasis>Contrary "
"to JDBC, Hibernate numbers parameters from zero.</emphasis> Named parameters "
"are identifiers of the form <literal>:name</literal> in the query string. "
"The advantages of named parameters are:"
msgstr ""
"Se proveen m&#x00e9;todos en <literal>Query</literal> para ligar valores a "
"par&#x00e1;metros con nombre o par&#x00e1;metros <literal>?</literal> de "
"estilo JDBC. <emphasis>Al contrario de JDBC, Hibernate numera los par&#x00e1;"
"metros desde cero.</emphasis> Los par&#x00e1;metros con nombre son "
"identificadores de la forma <literal>:name</literal> en la cadena de la "
"consulta. Las ventajas de los par&#x00e1;metros con nombre son:"

#: index.docbook:309
msgid ""
"named parameters are insensitive to the order they occur in the query string"
msgstr ""
"los par&#x00e1;metros con nombre son insensibles al orden en que aparecen en "
"la cadena de consulta"

#: index.docbook:315
msgid "they may occur multiple times in the same query"
msgstr "pueden aparecer m&#x00fa;ltiples veces en la misma consulta"

#: index.docbook:320
msgid "they are self-documenting"
msgstr "son auto-documentados"

#: index.docbook:326
msgid ""
"<![CDATA[//named parameter (preferred)\n"
"Query q = sess.createQuery(\"from DomesticCat cat where cat.name = :name"
"\");\n"
"q.setString(\"name\", \"Fritz\");\n"
"Iterator cats = q.iterate();]]>"
msgstr ""
"<![CDATA[//named parameter (preferred)\n"
"Query q = sess.createQuery(\"from DomesticCat cat where cat.name = :name"
"\");\n"
"q.setString(\"name\", \"Fritz\");\n"
"Iterator cats = q.iterate();]]>"

#: index.docbook:328
msgid ""
"<![CDATA[//positional parameter\n"
"Query q = sess.createQuery(\"from DomesticCat cat where cat.name = ?\");\n"
"q.setString(0, \"Izi\");\n"
"Iterator cats = q.iterate();]]>"
msgstr ""
"<![CDATA[//positional parameter\n"
"Query q = sess.createQuery(\"from DomesticCat cat where cat.name = ?\");\n"
"q.setString(0, \"Izi\");\n"
"Iterator cats = q.iterate();]]>"

#: index.docbook:330
msgid ""
"<![CDATA[//named parameter list\n"
"List names = new ArrayList();\n"
"names.add(\"Izi\");\n"
"names.add(\"Fritz\");\n"
"Query q = sess.createQuery(\"from DomesticCat cat where cat.name in (:"
"namesList)\");\n"
"q.setParameterList(\"namesList\", names);\n"
"List cats = q.list();]]>"
msgstr ""
"<![CDATA[//named parameter list\n"
"List names = new ArrayList();\n"
"names.add(\"Izi\");\n"
"names.add(\"Fritz\");\n"
"Query q = sess.createQuery(\"from DomesticCat cat where cat.name in (:"
"namesList)\");\n"
"q.setParameterList(\"namesList\", names);\n"
"List cats = q.list();]]>"

#: index.docbook:335
msgid "Pagination"
msgstr "Paginaci&#x00f3;n"

#: index.docbook:337
msgid ""
"If you need to specify bounds upon your result set (the maximum number of "
"rows you want to retrieve and / or the first row you want to retrieve) you "
"should use methods of the <literal>Query</literal> interface:"
msgstr ""
"Si necesitas especificar l&#x00ed;mites sobre tu conjunto resultado (el "
"n&#x00fa;mero m&#x00e1;ximo de filas que quieras traer y/o la primera fila "
"que quieras traer) debes usar los m&#x00e9;todos de la interface "
"<literal>Query</literal>:"

#: index.docbook:343
msgid ""
"<![CDATA[Query q = sess.createQuery(\"from DomesticCat cat\");\n"
"q.setFirstResult(20);\n"
"q.setMaxResults(10);\n"
"List cats = q.list();]]>"
msgstr ""
"<![CDATA[Query q = sess.createQuery(\"from DomesticCat cat\");\n"
"q.setFirstResult(20);\n"
"q.setMaxResults(10);\n"
"List cats = q.list();]]>"

#: index.docbook:345
msgid ""
"Hibernate knows how to translate this limit query into the native SQL of "
"your DBMS."
msgstr ""
"Hibernate sabe c&#x00f3;mo traducir este l&#x00ed;mite de consulta al SQL "
"nativo de tu DBMS."

#: index.docbook:353
msgid "Scrollable iteration"
msgstr "Iteraci&#x00f3;n scrollable"

#: index.docbook:355
msgid ""
"If your JDBC driver supports scrollable <literal>ResultSet</literal>s, the "
"<literal>Query</literal> interface may be used to obtain a "
"<literal>ScrollableResults</literal> object, which allows flexible "
"navigation of the query results."
msgstr ""
"Si tu driver JDBC soporta <literal>ResultSet</literal>s scrollables, la "
"interface <literal>Query</literal> puede ser usada para obtener un objeto "
"<literal>ScrollableResults</literal>, que permite una navegaci&#x00f3;n "
"flexible de los resultados de consulta."

#: index.docbook:362
msgid ""
"<![CDATA[Query q = sess.createQuery(\"select cat.name, cat from DomesticCat "
"cat \" +\n"
"                            \"order by cat.name\");\n"
"ScrollableResults cats = q.scroll();\n"
"if ( cats.first() ) {\n"
"\n"
"    // find the first name on each page of an alphabetical list of cats by "
"name\n"
"    firstNamesOfPages = new ArrayList();\n"
"    do {\n"
"        String name = cats.getString(0);\n"
"        firstNamesOfPages.add(name);\n"
"    }\n"
"    while ( cats.scroll(PAGE_SIZE) );\n"
"\n"
"    // Now get the first page of cats\n"
"    pageOfCats = new ArrayList();\n"
"    cats.beforeFirst();\n"
"    int i=0;\n"
"    while( ( PAGE_SIZE > i++ ) && cats.next() ) pageOfCats.add( cats.get"
"(1) );\n"
"\n"
"}\n"
"cats.close()]]>"
msgstr ""
"<![CDATA[Query q = sess.createQuery(\"select cat.name, cat from DomesticCat "
"cat \" +\n"
"                            \"order by cat.name\");\n"
"ScrollableResults cats = q.scroll();\n"
"if ( cats.first() ) {\n"
"\n"
"    // find the first name on each page of an alphabetical list of cats by "
"name\n"
"    firstNamesOfPages = new ArrayList();\n"
"    do {\n"
"        String name = cats.getString(0);\n"
"        firstNamesOfPages.add(name);\n"
"    }\n"
"    while ( cats.scroll(PAGE_SIZE) );\n"
"\n"
"    // Now get the first page of cats\n"
"    pageOfCats = new ArrayList();\n"
"    cats.beforeFirst();\n"
"    int i=0;\n"
"    while( ( PAGE_SIZE > i++ ) && cats.next() ) pageOfCats.add( cats.get"
"(1) );\n"
"\n"
"}\n"
"cats.close()]]>"

#: index.docbook:364
msgid ""
"Note that an open database connection (and cursor) is required for this "
"functionality, use <literal>setMaxResult()</literal>/<literal>setFirstResult"
"()</literal> if you need offline pagination functionality."
msgstr ""
"Nota que se requiere una conexi&#x00f3;n de base de datos abierta (y cursor) "
"para esta funcionalidad, usa <literal>setMaxResult()</literal>/"
"<literal>setFirstResult()</literal> si necesitas la funcionalidad de "
"paginaci&#x00f3;n fuera de l&#x00ed;nea."

#: index.docbook:373
msgid "Externalizing named queries"
msgstr "Externalizando consultas con nombre"

#: index.docbook:375
msgid ""
"You may also define named queries in the mapping document. (Remember to use "
"a <literal>CDATA</literal> section if your query contains characters that "
"could be interpreted as markup.)"
msgstr ""
"Puedes adem&#x00e1;s definir consultas con nombre en el documento de mapeo. "
"(Recuerda usar una secci&#x00f3;n <literal>CDATA</literal> si tu consulta "
"contiene caracteres que puedan ser interpretados como etiquetado.)"

#: index.docbook:381
msgid ""
"<![CDATA[<query name=\"ByNameAndMaximumWeight\"><![CDATA[\n"
"    from eg.DomesticCat as cat\n"
"        where cat.name = ?\n"
"        and cat.weight > ?\n"
"] ]></query>]]>"
msgstr ""
"<![CDATA[<query name=\"eg.DomesticCat.by.name.and.minimum.weight\"><![CDATA"
"[\n"
"    from eg.DomesticCat as cat\n"
"        where cat.name = ?\n"
"        and cat.weight > ?\n"
"] ]></query>]]>"

#: index.docbook:383
msgid "Parameter binding and executing is done programatically:"
msgstr ""
"La ligaci&#x00f3;n de par&#x00e1;metros y ejecuci&#x00f3;n se hace "
"program&#x00e1;ticamente:"

#: index.docbook:387
msgid ""
"<![CDATA[Query q = sess.getNamedQuery(\"ByNameAndMaximumWeight\");\n"
"q.setString(0, name);\n"
"q.setInt(1, minWeight);\n"
"List cats = q.list();]]>"
msgstr ""
"<![CDATA[Query q = sess.getNamedQuery(\"eg.DomesticCat.by.name.and.minimum."
"weight\");\n"
"q.setString(0, name);\n"
"q.setInt(1, minWeight);\n"
"List cats = q.list();]]>"

#: index.docbook:389
msgid ""
"Note that the actual program code is independent of the query language that "
"is used, you may also define native SQL queries in metadata, or migrate "
"existing queries to Hibernate by placing them in mapping files."
msgstr ""
"Nota que el c&#x00f3;digo real del programa es independiente del lenguaje de "
"consulta usado; puedes adem&#x00e1;s definir consultas SQL nativas en "
"metadatos, o migrar consultas existentes a Hibernate coloc&#x00e1;ndolas en "
"ficheros de mapeo."

#: index.docbook:395
msgid ""
"Also note that a query declaration inside a <literal>&lt;hibernate-"
"mapping&gt;</literal> element requires a global unique name for the query, "
"while a query declaration inside a <literal>&lt;class&gt;</literal> element "
"is made unique automatically by prepending the fully qualified name of the "
"class, for example <literal>eg.Cat.ByNameAndMaximumWeight</literal>."
msgstr ""
"UNTRANSLATED! Also note that a query declaration inside a <literal>&lt;"
"hibernate-mapping&gt;</literal> element requires a global unique name for "
"the query, while a query declaration inside a <literal>&lt;class&gt;</"
"literal> element is made unique automatically by prepending the fully "
"qualified name of the class, for example <literal>eg.Cat."
"ByNameAndMaximumWeight</literal>."

#: index.docbook:408
msgid "Filtering collections"
msgstr "Filtrando colecciones"

#: index.docbook:409
msgid ""
"A collection <emphasis>filter</emphasis> is a special type of query that may "
"be applied to a persistent collection or array. The query string may refer "
"to <literal>this</literal>, meaning the current collection element."
msgstr ""
"Un <emphasis>filtro</emphasis> de colecci&#x00f3;n es un tipo especial de "
"consulta que puede ser aplicado a una colecci&#x00f3;n persistente o array. "
"La cadena de consulta puede referirse a <literal>this</literal>, "
"significando el elemento de colecci&#x00f3;n actual."

#: index.docbook:415
msgid ""
"<![CDATA[Collection blackKittens = session.createFilter(\n"
"    pk.getKittens(), \n"
"    \"where this.color = ?\")\n"
"    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )\n"
"    .list()\n"
");]]>"
msgstr ""
"<![CDATA[Collection blackKittens = session.createFilter(\n"
"    pk.getKittens(), \n"
"    \"where this.color = ?\")\n"
"    .setParameter( Color.BLACK, Hibernate.custom(ColorUserType.class) )\n"
"    .list()\n"
");]]>"

#: index.docbook:417
msgid ""
"The returned collection is considered a bag, and it's a copy of the given "
"collection. The original collection is not modified (this is contrary to the "
"implication of the name \"filter\", but consistent with expected behavior)."
msgstr ""
"La colecci&#x00f3;n devuelta es considerada un bag, y es una copia de la "
"colecci&#x00f3;n dada. La colecci&#x00f3;n original no es modificada (esto "
"es contrario a la implicaci&#x00f3;n del nombre \"filtro\", pero consistente "
"con el comportamiento esperado)."

#: index.docbook:423
msgid ""
"Observe that filters do not require a <literal>from</literal> clause (though "
"they may have one if required). Filters are not limited to returning the "
"collection elements themselves."
msgstr ""
"Observa que los filtros no requieren una cl&#x00e1;usula <literal>from</"
"literal> (aunque pueden tener uno si se requiere). Los filtros no est&#x00e1;"
"n limitados a devolver los elementos de colecci&#x00f3;n por s&#x00ed; "
"mismos."

#: index.docbook:428
msgid ""
"<![CDATA[Collection blackKittenMates = session.createFilter(\n"
"    pk.getKittens(), \n"
"    \"select this.mate where this.color = eg.Color.BLACK.intValue\")\n"
"    .list();]]>"
msgstr ""
"<![CDATA[Collection blackKittenMates = session.createFilter(\n"
"    pk.getKittens(), \n"
"    \"select this.mate where this.color = eg.Color.BLACK.intValue\")\n"
"    .list();]]>"

#: index.docbook:430
msgid ""
"Even an empty filter query is useful, e.g. to load a subset of elements in a "
"huge collection:"
msgstr ""
"Incluso una consulta de filtro vac&#x00ed;o es &#x00fa;til, por ejemplo, "
"para cargar un subconjunto de elementos en una colecci&#x00f3;n enorme:"

#: index.docbook:435
msgid ""
"<![CDATA[Collection tenKittens = session.createFilter(\n"
"    mother.getKittens(), \"\")\n"
"    .setFirstResult(0).setMaxResults(10)\n"
"    .list();]]>"
msgstr ""
"<![CDATA[Collection tenKittens = session.createFilter(\n"
"    mother.getKittens(), \"\")\n"
"    .setFirstResult(0).setMaxResults(10)\n"
"    .list();]]>"

#: index.docbook:440
msgid "Criteria queries"
msgstr "Consultas de criterios"

#: index.docbook:442
msgid ""
"HQL is extremely powerful but some developers prefer to build queries "
"dynamically, using an object-oriented API, rather than building query "
"strings. Hibernate provides an intuitive <literal>Criteria</literal> query "
"API for these cases:"
msgstr ""
"HQL es extremadamente potente pero algunos desarrolladores prefieren "
"construir consultas din&#x00e1;micamente usando una API orientada a objetos, "
"en vez construir cadenas de consulta. Hibernate provee una API intuitiva de "
"consulta <literal>Criteria</literal> para estos casos:"

#: index.docbook:448
msgid ""
"<![CDATA[Criteria crit = session.createCriteria(Cat.class);\n"
"crit.add( Restrictions.eq( \"color\", eg.Color.BLACK ) );\n"
"crit.setMaxResults(10);\n"
"List cats = crit.list();]]>"
msgstr ""
"<![CDATA[Criteria crit = session.createCriteria(Cat.class);\n"
"crit.add( Restrictions.eq( \"color\", eg.Color.BLACK ) );\n"
"crit.setMaxResults(10);\n"
"List cats = crit.list();]]>"

#: index.docbook:450
msgid ""
"The <literal>Criteria</literal> and the associated <literal>Example</"
"literal> API are discussed in more detail in <xref linkend=\"querycriteria\"/"
">."
msgstr ""
"Las APIs de <literal>Criteria</literal> y la asociada <literal>Example</"
"literal> son discutidas en m&#x00e1;s detalle en <xref linkend="
"\"querycriteria\"/>."

#: index.docbook:458
msgid "Queries in native SQL"
msgstr "Consultas en SQL nativo"

#: index.docbook:460
msgid ""
"You may express a query in SQL, using <literal>createSQLQuery()</literal> "
"and let Hibernate take care of the mapping from result sets to objects. Note "
"that you may at any time call <literal>session.connection()</literal> and "
"use the JDBC <literal>Connection</literal> directly. If you chose to use the "
"Hibernate API, you must enclose SQL aliases in braces:"
msgstr ""
"Puedes expresar una consulta en SQL, usando <literal>createSQLQuery()</"
"literal> y dejando que Hibernate cuide del mapeo de los conjuntos resultado "
"a objetos. Nota que puedes llamar en cualquier momento a <literal>session."
"connection()</literal> y usar la <literal>Connection</literal> JDBC "
"directamente. Si eliges usar la API de Hibernate, debes encerrar los alias "
"de SQL entre llaves:"

#: index.docbook:468
msgid ""
"<![CDATA[List cats = session.createSQLQuery(\"SELECT {cat.*} FROM CAT {cat} "
"WHERE ROWNUM<10\")\n"
"    .addEntity(\"cat\", Cat.class)\n"
".list();]]>"
msgstr ""
"<![CDATA[List cats = session.createSQLQuery(\"SELECT {cat.*} FROM CAT {cat} "
"WHERE ROWNUM<10\")\n"
"    .addEntity(\"cat\", Cat.class)\n"
".list();]]>"

#: index.docbook:470
msgid ""
"<![CDATA[List cats = session.createSQLQuery(\n"
"    \"SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, \" +\n"
"           \"{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... \" "
"+\n"
"    \"FROM CAT {cat} WHERE ROWNUM<10\")\n"
"    .addEntity(\"cat\", Cat.class)\n"
".list()]]>"
msgstr ""
"<![CDATA[List cats = session.createSQLQuery(\n"
"    \"SELECT {cat}.ID AS {cat.id}, {cat}.SEX AS {cat.sex}, \" +\n"
"           \"{cat}.MATE AS {cat.mate}, {cat}.SUBCLASS AS {cat.class}, ... \" "
"+\n"
"    \"FROM CAT {cat} WHERE ROWNUM<10\")\n"
"    .addEntity(\"cat\", Cat.class)\n"
".list()]]>"

#: index.docbook:472
msgid ""
"SQL queries may contain named and positional parameters, just like Hibernate "
"queries. More information about native SQL queries in Hibernate can be found "
"in <xref linkend=\"querysql\"/>."
msgstr ""
"Las consultas SQL pueden contener par&#x00e1;metros con nombre y "
"posicionales, al igual que las consultas de Hibernate. Puede encontrarse "
"m&#x00e1;s informaci&#x00f3;n sobre consultas en SQL nativo en <xref linkend="
"\"querysql\"/>."

#: index.docbook:483
msgid "Modifying persistent objects"
msgstr "Modificando objetos persistentes"

#: index.docbook:485
msgid ""
"<emphasis>Transactional persistent instances</emphasis> (ie. objects loaded, "
"saved, created or queried by the <literal>Session</literal>) may be "
"manipulated by the application and any changes to persistent state will be "
"persisted when the <literal>Session</literal> is <emphasis>flushed</"
"emphasis> (discussed later in this chapter). There is no need to call a "
"particular method (like <literal>update()</literal>, which has a different "
"purpose) to make your modifications persistent. So the most straightforward "
"way to update the state of an object is to <literal>load()</literal> it, and "
"then manipulate it directly, while the <literal>Session</literal> is open:"
msgstr ""
"Las <emphasis>instancias persistentes transaccionales</emphasis> (es decir, "
"objetos cargados, creados o consultados por la <literal>Session</literal>) "
"pueden ser manipulados por la aplicaci&#x00f3;n y cualquier cambio al estado "
"persistente ser&#x00e1; persistido cuando la <literal>Session</literal> sea "
"<emphasis>limpiada (flushed)</emphasis> (discutido m&#x00e1;s adelante en "
"este cap&#x00ed;tulo). No hay necesidad de llamar un m&#x00e9;todo en "
"particular (como <literal>update()</literal>, que tiene un prop&#x00f3;sito "
"diferente) para hacer persistentes tus modificaciones. De modo que la forma "
"m&#x00e1;s directa de actualizar el estado de un objeto es cargarlo con "
"<literal>load()</literal>, y entonces manipularlo directamente, mientras la "
"<literal>Session</literal> est&#x00e1; abierta:"

#: index.docbook:496
msgid ""
"<![CDATA[DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long"
"(69) );\n"
"cat.setName(\"PK\");\n"
"sess.flush();  // changes to cat are automatically detected and persisted]]>"
msgstr ""
"<![CDATA[DomesticCat cat = (DomesticCat) sess.load( Cat.class, new Long"
"(69) );\n"
"cat.setName(\"PK\");\n"
"sess.flush();  // changes to cat are automatically detected and persisted]]>"

#: index.docbook:498
msgid ""
"Sometimes this programming model is inefficient since it would require both "
"an SQL <literal>SELECT</literal> (to load an object) and an SQL "
"<literal>UPDATE</literal> (to persist its updated state) in the same "
"session. Therefore Hibernate offers an alternate approach, using detached "
"instances."
msgstr ""
"A veces este modelo de programaci&#x00f3;n es ineficiente pues podr&#x00ed;a "
"requerir una <literal>SELECT</literal> de SQL (para cargar un objeto) y un "
"<literal>UPDATE</literal> de SQL (para hacer persistentes sus datos "
"actualizados) en la misma sesi&#x00f3;n. Por lo tanto, Hibernate ofrece un "
"enfoque alternativo, usando instancias separadas (detached)."

#: index.docbook:506
msgid ""
"Note that Hibernate does not offer its own API for direct execution of "
"<literal>UPDATE</literal> or <literal>DELETE</literal> statements. Hibernate "
"is a <emphasis>state management</emphasis> service, you don't have to think "
"in <emphasis>statements</emphasis> to use it. JDBC is a perfect API for "
"executing SQL statements, you can get a JDBC <literal>Connection</literal> "
"at any time by calling <literal>session.connection()</literal>. Furthermore, "
"the notion of mass operations conflicts with object/relational mapping for "
"online transaction processing-oriented applications. Future versions of "
"Hibernate may however provide special mass operation functions. See <xref "
"linkend=\"batch\"/> for some possible batch operation tricks."
msgstr ""
"Nota que Hibernate no ofreve su propia API para ejecuci&#x00f3;n directa de "
"sentencias <literal>UPDATE</literal> o <literal>DELETE</literal>. Hibernate "
"es un servicio de <emphasis>gesti&#x00f3;n de estado</emphasis>, no tienes "
"que pensar en <literal>sentencias</literal> para usarlo. JDBC es una API "
"perfecta para ejecutar sentencias SQL; puedes obtener una "
"<literal>Connection</literal> JDBC en cualquier momento llamando a "
"<literal>session.connection()</literal>. Adem&#x00e1;s, la noci&#x00f3;n de "
"operaciones masivas entra en conflicto con el mapeo objeto/relacional en "
"aplicaciones en l&#x00ed;nea orientadas al procesamiento de transacciones. "
"Versiones futuras de Hibernate pueden, sin embargo, proveer funciones de "
"operaci&#x00f3;n masiva especiales. Ver <xref linkend=\"batch\"/> por "
"algunos trucos de operaci&#x00f3;n en lote (batch) posibles."

#: index.docbook:521
msgid "Modifying detached objects"
msgstr "Modificando objetos separados"

#: index.docbook:523
msgid ""
"Many applications need to retrieve an object in one transaction, send it to "
"the UI layer for manipulation, then save the changes in a new transaction. "
"Applications that use this kind of approach in a high-concurrency "
"environment usually use versioned data to ensure isolation for the \"long\" "
"unit of work."
msgstr ""
"Muchas aplicaciones necesitan recuperar un objeto en una transacci&#x00f3;n, "
"enviarla a la capa de UI para su manipulaci&#x00f3;n, y entonces salvar los "
"cambios en una nueva transacci&#x00f3;n. Las aplicaciones que usan este tipo "
"de enfoque en un entorno de alta concurrencia usualmente usan datos "
"versionados para asegurar el aislamiento de la unidad de trabajo \"larga\"."

#: index.docbook:530
msgid ""
"Hibernate supports this model by providing for reattachment of detached "
"instances using the <literal>Session.update()</literal> or <literal>Session."
"merge()</literal> methods:"
msgstr ""
"Hibernate soporta este modelo al proveer re-uni&#x00f3;n de instancias "
"separadas usando los m&#x00e9;todos <literal>Session.update()</literal> o "
"<literal>Session.merge()</literal>:"

#: index.docbook:536
msgid ""
"<![CDATA[// in the first session\n"
"Cat cat = (Cat) firstSession.load(Cat.class, catId);\n"
"Cat potentialMate = new Cat();\n"
"firstSession.save(potentialMate);\n"
"\n"
"// in a higher layer of the application\n"
"cat.setMate(potentialMate);\n"
"\n"
"// later, in a new session\n"
"secondSession.update(cat);  // update cat\n"
"secondSession.update(mate); // update mate]]>"
msgstr ""
"<![CDATA[// in the first session\n"
"Cat cat = (Cat) firstSession.load(Cat.class, catId);\n"
"Cat potentialMate = new Cat();\n"
"firstSession.save(potentialMate);\n"
"\n"
"// in a higher layer of the application\n"
"cat.setMate(potentialMate);\n"
"\n"
"// later, in a new session\n"
"secondSession.update(cat);  // update cat\n"
"secondSession.update(mate); // update mate]]>"

#: index.docbook:538
msgid ""
"If the <literal>Cat</literal> with identifier <literal>catId</literal> had "
"already been loaded by <literal>secondSession</literal> when the application "
"tried to reattach it, an exception would have been thrown."
msgstr ""
"Si el <literal>Cat</literal> con identificador <literal>catId</literal> ya "
"hubiera sido cargado por <literal>secondSession</literal> cuando la "
"aplicaci&#x00f3;n intent&#x00f3; volver a unirlo, se habr&#x00ed;a lanzado "
"una excepci&#x00f3;n."

#: index.docbook:544
msgid ""
"Use <literal>update()</literal> if you are sure that the session does not "
"contain an already persistent instance with the same identifier, and "
"<literal>merge()</literal> if you want to merge your modifications at any "
"time without consideration of the state of the session. In other words, "
"<literal>update()</literal> is usually the first method you would call in a "
"fresh session, ensuring that reattachment of your detached instances is the "
"first operation that is executed."
msgstr ""
"Usa <literal>update()</literal> si no est&#x00e1;s seguro que la sesi&#x00f3;"
"n tenga una instancia ya persistente con el mismo identificador, y "
"<literal>merge()</literal> si quieres fusionar tus modificaciones en "
"cualquier momento sin consideraci&#x00f3;n del estado de la sesi&#x00f3;n. "
"En otras palabras, <literal>update()</literal> es usualmente el primer "
"m&#x00e9;todo que llamar&#x00ed;as en una sesi&#x00f3;n fresca, asegurando "
"que la re-uni&#x00f3;n de tus instancias separadas es la primera "
"operaci&#x00f3;n que se ejecuta."

#: index.docbook:553
msgid ""
"The application should individually <literal>update()</literal> detached "
"instances reachable from the given detached instance if and <emphasis>only</"
"emphasis> if it wants their state also updated. This can be automated of "
"course, using <emphasis>transitive persistence</emphasis>, see <xref linkend="
"\"objectstate-transitive\"/>."
msgstr ""
"La aplicaci&#x00f3;n debe actualizar individualmente las instancias "
"separadas alcanzables por la instancia separada dada llamando a "
"<literal>update()</literal>, si y <emphasis>s&#x00f3;lo</emphasis> si quiere "
"que sus estados sean tambi&#x00e9;n actualizados. Esto puede, por supuesto, "
"ser automatizado usando <emphasis>persistencia transitiva</emphasis>, ver "
"<xref linkend=\"objectstate-transitive\"/>."

#: index.docbook:560
msgid ""
"The <literal>lock()</literal> method also allows an application to "
"reassociate an object with a new session. However, the detached instance has "
"to be unmodified!"
msgstr ""
"El m&#x00e9;todo <literal>lock()</literal> tambi&#x00e9;n permite a una "
"aplicaci&#x00f3;n reasociar un objeto con una sesi&#x00f3;n nueva. Sin "
"embargo, la instancia separada no puede haber sido modificada!"

#: index.docbook:565
msgid ""
"<![CDATA[//just reassociate:\n"
"sess.lock(fritz, LockMode.NONE);\n"
"//do a version check, then reassociate:\n"
"sess.lock(izi, LockMode.READ);\n"
"//do a version check, using SELECT ... FOR UPDATE, then reassociate:\n"
"sess.lock(pk, LockMode.UPGRADE);]]>"
msgstr ""
"<![CDATA[//just reassociate:\n"
"sess.lock(fritz, LockMode.NONE);\n"
"//do a version check, then reassociate:\n"
"sess.lock(izi, LockMode.READ);\n"
"//do a version check, using SELECT ... FOR UPDATE, then reassociate:\n"
"sess.lock(pk, LockMode.UPGRADE);]]>"

#: index.docbook:567
msgid ""
"Note that <literal>lock()</literal> can be used with various "
"<literal>LockMode</literal>s, see the API documentation and the chapter on "
"transaction handling for more information. Reattachment is not the only "
"usecase for <literal>lock()</literal>."
msgstr ""
"Nota que <literal>lock()</literal> puede ser usado con varios "
"<literal>LockMode</literal>s, ver la documentaci&#x00f3;n de la API y el "
"cap&#x00ed;tulo sobre manejo de transacciones para m&#x00e1;s "
"informaci&#x00f3;n. La re-uni&#x00f3;n no es el &#x00fa;nico caso de uso "
"para <literal>lock()</literal>."

#: index.docbook:574
msgid ""
"Other models for long units of work are discussed in <xref linkend="
"\"transactions-optimistic\"/>."
msgstr ""
"Se discuten otros modelos para unidades de trabajo largas en <xref linkend="
"\"transactions-optimistic\"/>."

#: index.docbook:581
msgid "Automatic state detection"
msgstr "Detecci&#x00f3;n autom&#x00e1;tica de estado"

#: index.docbook:583
msgid ""
"Hibernate users have requested a general purpose method that either saves a "
"transient instance by generating a new identifier or updates/reattaches the "
"detached instances associated with its current identifier. The "
"<literal>saveOrUpdate()</literal> method implements this functionality."
msgstr ""
"Los usuarios de Hibernate han pedido un m&#x00e9;todo de prop&#x00f3;sito "
"general que bien salve una instancia transitoria generando un identificador "
"nuevo, o bien actualice/re&#x00fa;na las instancias separadas asociadas con "
"su identificador actual. El m&#x00e9;todo <literal>saveOrUpdate()</literal> "
"implementa esta funcionalidad."

#: index.docbook:590
msgid ""
"<![CDATA[// in the first session\n"
"Cat cat = (Cat) firstSession.load(Cat.class, catID);\n"
"\n"
"// in a higher tier of the application\n"
"Cat mate = new Cat();\n"
"cat.setMate(mate);\n"
"\n"
"// later, in a new session\n"
"secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-"
"null id)\n"
"secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null "
"id)]]>"
msgstr ""
"<![CDATA[// in the first session\n"
"Cat cat = (Cat) firstSession.load(Cat.class, catID);\n"
"\n"
"// in a higher tier of the application\n"
"Cat mate = new Cat();\n"
"cat.setMate(mate);\n"
"\n"
"// later, in a new session\n"
"secondSession.saveOrUpdate(cat);   // update existing state (cat has a non-"
"null id)\n"
"secondSession.saveOrUpdate(mate);  // save the new instance (mate has a null "
"id)]]>"

#: index.docbook:592
msgid ""
"The usage and semantics of <literal>saveOrUpdate()</literal> seems to be "
"confusing for new users. Firstly, so long as you are not trying to use "
"instances from one session in another new session, you should not need to "
"use <literal>update()</literal>, <literal>saveOrUpdate()</literal>, or "
"<literal>merge()</literal>. Some whole applications will never use either of "
"these methods."
msgstr ""
"El uso y sem&#x00e1;ntica de <literal>saveOrUpdate()</literal> parece ser "
"confuso para usuarios nuevos. Primeramente, en tanto no est&#x00e9;s "
"intentando usar instancias de una sesi&#x00f3;n en otra sesi&#x00f3;n nueva, "
"no debes necesitar usar <literal>update()</literal>, <literal>saveOrUpdate()"
"</literal>, o <literal>merge()</literal>. Algunas aplicaciones enteras nunca "
"usar&#x00e1;n ninguno de estos m&#x00e9;todos."

#: index.docbook:600
msgid ""
"Usually <literal>update()</literal> or <literal>saveOrUpdate()</literal> are "
"used in the following scenario:"
msgstr ""
"Usualmente <literal>update()</literal> o <literal>saveOrUpdate()</literal> "
"se usan en el siguiente escenario:"

#: index.docbook:607
msgid "the application loads an object in the first session"
msgstr "la aplicaci&#x00f3;n carga un objeto en la primera sesi&#x00f3;n"

#: index.docbook:612
msgid "the object is passed up to the UI tier"
msgstr "el objeto es pasado a la capa de UI"

#: index.docbook:617
msgid "some modifications are made to the object"
msgstr "se hacen algunas modificaciones al objeto"

#: index.docbook:622
msgid "the object is passed back down to the business logic tier"
msgstr "el objeto se pasa abajo de regreso a la capa de negocio"

#: index.docbook:627
msgid ""
"the application persists these modifications by calling <literal>update()</"
"literal> in a second session"
msgstr ""
"la aplicaci&#x00f3;n hace estas modificaciones persistentes llamando a "
"<literal>update()</literal> en una segunda sesi&#x00f3;n"

#: index.docbook:634
msgid "<literal>saveOrUpdate()</literal> does the following:"
msgstr "<literal>saveOrUpdate()</literal> hace lo siguiente:"

#: index.docbook:640
msgid "if the object is already persistent in this session, do nothing"
msgstr "si el objeto ya es persistente en esta sesi&#x00f3;n, no hace nada"

#: index.docbook:645
msgid ""
"if another object associated with the session has the same identifier, throw "
"an exception"
msgstr ""
"si otro objeto asociado con la sesi&#x00f3;n tiene el mismo identificador, "
"lanza una excepci&#x00f3;n"

#: index.docbook:651
msgid "if the object has no identifier property, <literal>save()</literal> it"
msgstr ""
"si el objeto no tiene ninguna propiedad identificadora, lo salva llamando a "
"<literal>save()</literal>"

#: index.docbook:656
msgid ""
"if the object's identifier has the value assigned to a newly instantiated "
"object, <literal>save()</literal> it"
msgstr ""
"si el identificador del objeto tiene el valor asignado a un objeto "
"reci&#x00e9;n instanciado, lo salva llamando a <literal>save()</literal>"

#: index.docbook:662
msgid ""
"if the object is versioned (by a <literal>&lt;version&gt;</literal> or "
"<literal>&lt;timestamp&gt;</literal>), and the version property value is the "
"same value assigned to a newly instantiated object, <literal>save()</"
"literal> it"
msgstr ""
"si el objeto est&#x00e1; versionado (por un <literal>&lt;version&gt;</"
"literal> o <literal>&lt;timestamp&gt;</literal>), y el valor de la propiedad "
"de versi&#x00f3;n es el mismo valor asignado a una objeto reci&#x00e9;n "
"instanciado, lo salva llamando a <literal>save()</literal>"

#: index.docbook:670
msgid "otherwise <literal>update()</literal> the object"
msgstr ""
"en cualquier otro caso se actualiza el objeto llamando a <literal>update()</"
"literal>"

#: index.docbook:676
msgid "and <literal>merge()</literal> is very different:"
msgstr "y <literal>merge()</literal> es muy diferente:"

#: index.docbook:682
msgid ""
"if there is a persistent instance with the same identifier currently "
"associated with the session, copy the state of the given object onto the "
"persistent instance"
msgstr ""
"si existe una instancia persistente con el mismo identificador asignado "
"actualmente con la sesi&#x00f3;n, copia el estado del objeto dado en la "
"instancia persistente"

#: index.docbook:689
msgid ""
"if there is no persistent instance currently associated with the session, "
"try to load it from the database, or create a new persistent instance"
msgstr ""
"si no existe ninguna instancia persistente actualmente asociada a la "
"sesi&#x00f3;n, intente cargarla de la base de datos, o crear una nueva "
"instancia persistente"

#: index.docbook:695
msgid "the persistent instance is returned"
msgstr "la instancia persistente es devuelta"

#: index.docbook:700
msgid ""
"the given instance does not become associated with the session, it remains "
"detached"
msgstr ""
"la instancia dada no resulta ser asociada a la sesi&#x00f3;n, permanece "
"separada"

#: index.docbook:710
msgid "Deleting persistent objects"
msgstr "Borrando objetos persistentes"

#: index.docbook:712
msgid ""
"<literal>Session.delete()</literal> will remove an object's state from the "
"database. Of course, your application might still hold a reference to a "
"deleted object. It's best to think of <literal>delete()</literal> as making "
"a persistent instance transient."
msgstr ""
"<literal>Session.delete()</literal> quitar&#x00e1; el estado de un objeto de "
"la base de datos. Por supuesto, tu aplicaci&#x00f3;n podr&#x00ed;a tener "
"a&#x00fa;n una referencia a un objeto borrado. Lo mejor es pensar en "
"<literal>delete()</literal> como hacer transitoria una instancia persistente."

#: index.docbook:719
msgid "<![CDATA[sess.delete(cat);]]>"
msgstr "<![CDATA[sess.delete(cat);]]>"

#: index.docbook:721
msgid ""
"You may delete objects in any order you like, without risk of foreign key "
"constraint violations. It is still possible to violate a <literal>NOT NULL</"
"literal> constraint on a foreign key column by deleting objects in the wrong "
"order, e.g. if you delete the parent, but forget to delete the children."
msgstr ""
"Puedes borrar los objetos en el orden que gustes, sin riesgo de violaciones "
"de restricci&#x00f3;n de clave for&#x00e1;nea. A&#x00fa;n es posible violar "
"una restricci&#x00f3;n <literal>NOT NULL</literal> sobre una columna clave "
"for&#x00e1;nea borrando objetos en un orden err&#x00f3;neo, por ejemplo, si "
"borras el padre, pero olvidas borrar los hijos."

#: index.docbook:732
msgid "Replicating object between two different datastores"
msgstr "Replicando objetos entre dos almac&#x00e9;nes de datos diferentes"

#: index.docbook:734
msgid ""
"It is occasionally useful to be able to take a graph of persistent instances "
"and make them persistent in a different datastore, without regenerating "
"identifier values."
msgstr ""
"Es ocasionalmente &#x00fa;til ser capaz de tomar un grafo de instancias "
"persistentes y hacerlas persistentes en un almac&#x00e9;n de datos "
"diferente, sin regenerar los valores identificadores."

#: index.docbook:740
msgid ""
"<![CDATA[//retrieve a cat from one database\n"
"Session session1 = factory1.openSession();\n"
"Transaction tx1 = session1.beginTransaction();\n"
"Cat cat = session1.get(Cat.class, catId);\n"
"tx1.commit();\n"
"session1.close();\n"
"\n"
"//reconcile with a second database\n"
"Session session2 = factory2.openSession();\n"
"Transaction tx2 = session2.beginTransaction();\n"
"session2.replicate(cat, ReplicationMode.LATEST_VERSION);\n"
"tx2.commit();\n"
"session2.close();]]>"
msgstr ""
"<![CDATA[//retrieve a cat from one database\n"
"Session session1 = factory1.openSession();\n"
"Transaction tx1 = session1.beginTransaction();\n"
"Cat cat = session1.get(Cat.class, catId);\n"
"tx1.commit();\n"
"session1.close();\n"
"\n"
"//reconcile with a second database\n"
"Session session2 = factory2.openSession();\n"
"Transaction tx2 = session2.beginTransaction();\n"
"session2.replicate(cat, ReplicationMode.LATEST_VERSION);\n"
"tx2.commit();\n"
"session2.close();]]>"

#: index.docbook:742
msgid ""
"The <literal>ReplicationMode</literal> determines how <literal>replicate()</"
"literal> will deal with conflicts with existing rows in the database."
msgstr ""
"El <literal>ReplicationMode</literal> determina c&#x00f3;mo "
"<literal>replicate()</literal> tratar&#x00e1; los conflictos con filas "
"existentes en la base de datos."

#: index.docbook:749
msgid ""
"<literal>ReplicationMode.IGNORE</literal> - ignore the object when there is "
"an existing database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.IGNORE</literal> - ignora el objeto cuando existe "
"una fila de base de datos con el mismo identificador"

#: index.docbook:755
msgid ""
"<literal>ReplicationMode.OVERWRITE</literal> - overwrite any existing "
"database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.OVERWRITE</literal> - sobrescribe cualquier fila de "
"base de datos existente con el mismo identificador"

#: index.docbook:761
msgid ""
"<literal>ReplicationMode.EXCEPTION</literal> - throw an exception if there "
"is an existing database row with the same identifier"
msgstr ""
"<literal>ReplicationMode.EXCEPTION</literal> - lanza una excepci&#x00f3;n si "
"existe una fila de base de datos con el mismo identificador"

#: index.docbook:767
msgid ""
"<literal>ReplicationMode.LATEST_VERSION</literal> - overwrite the row if its "
"version number is earlier than the version number of the object, or ignore "
"the object otherwise"
msgstr ""
"<literal>ReplicationMode.LATEST_VERSION</literal> - sobrescribe la fila si "
"su n&#x00fa;mero de versi&#x00f3;n es anterior al n&#x00fa;mero de "
"versi&#x00f3;n del objeto, o en caso contrario ignora el objeto"

#: index.docbook:775
msgid ""
"Usecases for this feature include reconciling data entered into different "
"database instances, upgrading system configuration information during "
"product upgrades, rolling back changes made during non-ACID transactions and "
"more."
msgstr ""
"Los casos de uso para esta funcionalidad incluyen reconciliar datos "
"ingresados en instancias diferentes de bases de datos, actualizar "
"informaci&#x00f3;n de configuraci&#x00f3;n de sistema durante "
"actualizaciones de producto, deshacer cambios producidos durante "
"transacciones no-ACID y m&#x00e1;s."

#: index.docbook:784
msgid "Flushing the Session"
msgstr "Limpiando (flushing) la sesi&#x00f3;n"

#: index.docbook:786
msgid ""
"From time to time the <literal>Session</literal> will execute the SQL "
"statements needed to synchronize the JDBC connection's state with the state "
"of objects held in memory. This process, <emphasis>flush</emphasis>, occurs "
"by default at the following points"
msgstr ""
"Cada tanto, la <literal>Session</literal> ejecutar&#x00e1; las sentencias "
"SQL necesarias para sincronizar el estado de la conexi&#x00f3;n JDBC con el "
"estado de los objetos mantenidos en menoria. Este proceso, "
"<emphasis>limpieza (flush)</emphasis>, ocurre por defecto en los siguientes "
"puntos"

#: index.docbook:795
msgid "before some query executions"
msgstr "antes de algunas ejecuciones de consulta"

#: index.docbook:800
msgid "from <literal>org.hibernate.Transaction.commit()</literal>"
msgstr "desde <literal>org.hibernate.Transaction.commit()</literal>"

#: index.docbook:805
msgid "from <literal>Session.flush()</literal>"
msgstr "desde <literal>Session.flush()</literal>"

#: index.docbook:811
msgid "The SQL statements are issued in the following order"
msgstr "Las sentencias SQL son liberadas en el siguiente orden"

#: index.docbook:817
msgid ""
"all entity insertions, in the same order the corresponding objects were "
"saved using <literal>Session.save()</literal>"
msgstr ""
"todas las inserciones de entidades, en el mismo orden que los objetos "
"correspondientes fueron salvados usando <literal>Session.save()</literal>"

#: index.docbook:823
msgid "all entity updates"
msgstr "todas las actualizaciones de entidades"

#: index.docbook:828
msgid "all collection deletions"
msgstr "todas los borrados de colecciones"

#: index.docbook:833
msgid "all collection element deletions, updates and insertions"
msgstr ""
"todos los borrados, actualizaciones e inserciones de elementos de "
"colecci&#x00f3;n"

#: index.docbook:838
msgid "all collection insertions"
msgstr "todas las inserciones de colecciones"

#: index.docbook:843
msgid ""
"all entity deletions, in the same order the corresponding objects were "
"deleted using <literal>Session.delete()</literal>"
msgstr ""
"todos los borrados de entidades, en el mismo orden que los objetos "
"correspondientes fueron borrados usando <literal>Session.delete()</literal>"

#: index.docbook:850
msgid ""
"(An exception is that objects using <literal>native</literal> ID generation "
"are inserted when they are saved.)"
msgstr ""
"(Una excepci&#x00f3;n es que los objetos que usan generaci&#x00f3;n de ID "
"<literal>native</literal> se insertan cuando son salvados.)"

#: index.docbook:855
msgid ""
"Except when you explicity <literal>flush()</literal>, there are absolutely "
"no guarantees about <emphasis>when</emphasis> the <literal>Session</literal> "
"executes the JDBC calls, only the <emphasis>order</emphasis> in which they "
"are executed. However, Hibernate does guarantee that the <literal>Query.list"
"(..)</literal> will never return stale data; nor will they return the wrong "
"data."
msgstr ""
"Excepto cuando llamas expl&#x00ed;citamente a <literal>flush()</literal>, no "
"hay en absoluto garant&#x00ed;as sobre <emphasis>cu&#x00e1;ndo</emphasis> la "
"<literal>Session</literal> ejecuta las llamadas JDBC. s&#x00f3;lo sobre el "
"<emphasis>orden</emphasis> en que son ejecutadas. Sin embargo, Hibernate "
"garantiza que los m&#x00e9;todos <literal>Query.list(..)</literal> nunca "
"devolver&#x00e1;n datos a&#x00f1;ejos o err&#x00f3;neos."

#: index.docbook:863
msgid ""
"It is possible to change the default behavior so that flush occurs less "
"frequently. The <literal>FlushMode</literal> class defines three different "
"modes: only flush at commit time (and only when the Hibernate "
"<literal>Transaction</literal> API is used), flush automatically using the "
"explained routine, or never flush unless <literal>flush()</literal> is "
"called explicitly. The last mode is useful for long running units of work, "
"where a <literal>Session</literal> is kept open and disconnected for a long "
"time (see <xref linkend=\"transactions-optimistic-longsession\"/>)."
msgstr ""
"Es posible cambiar el comportamiento por defecto de modo que la limpieza "
"(flush) ocurra menos frecuentemente. La clase <literal>FlushMode</literal> "
"tres modos diferentes: s&#x00f3;lo en tiempo de compromiso (y s&#x00f3;lo "
"cuando se use la API de <literal>Transaction</literal> de Hibernate), "
"limpieza autom&#x00e1;tica usando la rutina explicada, o nunca limpiar a "
"menos que se llame a <literal>flush()</literal> expl&#x00ed;citamente. El "
"&#x00fa;ltimo modo es &#x00fa;til para unidades de trabajo largas, donde una "
"<literal>Session</literal> se mantiene abierta y desconectada por largo "
"tiempo (ver <xref linkend=\"transactions-optimistic-longsession\"/>)."

#: index.docbook:873
msgid ""
"<![CDATA[sess = sf.openSession();\n"
"Transaction tx = sess.beginTransaction();\n"
"sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state\n"
"\n"
"Cat izi = (Cat) sess.load(Cat.class, id);\n"
"izi.setName(iznizi);\n"
"\n"
"// might return stale data\n"
"sess.find(\"from Cat as cat left outer join cat.kittens kitten\");\n"
"\n"
"// change to izi is not flushed!\n"
"...\n"
"tx.commit(); // flush occurs\n"
"sess.close();]]>"
msgstr ""
"<![CDATA[sess = sf.openSession();\n"
"Transaction tx = sess.beginTransaction();\n"
"sess.setFlushMode(FlushMode.COMMIT); // allow queries to return stale state\n"
"\n"
"Cat izi = (Cat) sess.load(Cat.class, id);\n"
"izi.setName(iznizi);\n"
"\n"
"// might return stale data\n"
"sess.find(\"from Cat as cat left outer join cat.kittens kitten\");\n"
"\n"
"// change to izi is not flushed!\n"
"...\n"
"tx.commit(); // flush occurs]]>"

#: index.docbook:875
msgid ""
"During flush, an exception might occur (e.g. if a DML operation violates a "
"constraint). Since handling exceptions involves some understanding of "
"Hibernate's transactional behavior, we discuss it in <xref linkend="
"\"transactions\"/>."
msgstr ""
"Durante la limpieza, puede ocurrir una excepci&#x00f3;n (por ejemplo, si una "
"operaci&#x00f3;n DML violase una restricci&#x00f3;n). Ya que el manejo de "
"excepciones implica alguna comprensi&#x00f3;n del comportamiento "
"transaccional de Hibernate, lo discutimos en <xref linkend=\"transactions\"/"
">."

#: index.docbook:884
msgid "Transitive persistence"
msgstr "Persistencia transitiva"

#: index.docbook:886
msgid ""
"It is quite cumbersome to save, delete, or reattach individual objects, "
"especially if you deal with a graph of associated objects. A common case is "
"a parent/child relationship. Consider the following example:"
msgstr ""
"Es absolutamente inc&#x00f3;modo dalvar, borrar, o reunir objetos "
"individuales, especialmente si tratas con un grafo de objetos asociados. Un "
"caso com&#x00fa;n es una relaci&#x00f3;n padre/hijo. Considera el siguiente "
"ejemplo:"

#: index.docbook:892
msgid ""
"If the children in a parent/child relationship would be value typed (e.g. a "
"collection of addresses or strings), their life cycle would depend on the "
"parent and no further action would be required for convenient \"cascading\" "
"of state changes. When the parent is saved, the value-typed child objects "
"are saved as well, when the parent is deleted, the children will be deleted, "
"etc. This even works for operations such as the removal of a child from the "
"collection; Hibernate will detect this and, since value-typed objects can't "
"have shared references, delete the child from the database."
msgstr ""
"Si los hijos en una relaci&#x00f3;n padre/hijo pudieran ser tipificados en "
"valor (por ejemplo, una colecci&#x00f3;n de direcciones o cadenas), sus "
"ciclos de vida depender&#x00ed;an del padre y se requerir&#x00ed;a ninguna "
"otra acci&#x00f3;n para el tratamiento en \"cascada\" de cambios de estado. "
"Cuando el padre es salvado, los objetos hijo tipificados en valor son "
"salvados tambi&#x00e9;n, cuando se borra el padre, se borran los hijos, etc. "
"Esto funciona incluso para operaciones como el retiro de un hijo de la "
"colecci&#x00f3;n. Hibernate detectar&#x00e1; esto y, ya que los objetos "
"tipificados en valor no pueden tener referencias compartidas, borrar&#x00e1; "
"el hijo de la base de datos."

#: index.docbook:903
msgid ""
"Now consider the same scenario with parent and child objects being entities, "
"not value-types (e.g. categories and items, or parent and child cats). "
"Entities have their own life cycle, support shared references (so removing "
"an entity from the collection does not mean it can be deleted), and there is "
"by default no cascading of state from one entity to any other associated "
"entities. Hibernate does not implement <emphasis>persistence by "
"reachability</emphasis> by default."
msgstr ""
"Ahora considera el mismo escenario con los objetos padre e hijos siendo "
"entidades, no tipos de valor (por ejemplo, categor&#x00ed;as e &#x00ed;tems, "
"o gatos padre e hijos). Las entidades tienen su propio ciclo de vida, "
"soportan referencias compartidas (de modo que quitar una entidad de una "
"colecci&#x00f3;n no significa que sea borrada), y no hay por defecto "
"ning&#x00fa;n tratamiento en \"cascada\" de estado de una entidad a otras "
"entidades asociadas. Hibernate no implementa <emphasis>persistencia por "
"alcance</emphasis>."

#: index.docbook:912
msgid ""
"For each basic operation of the Hibernate session - including "
"<literal>persist(), merge(), saveOrUpdate(), delete(), lock(), refresh(), "
"evict(), replicate()</literal> - there is a corresponding cascade style. "
"Respectively, the cascade styles are named <literal>create, merge, save-"
"update, delete, lock, refresh, evict, replicate</literal>. If you want an "
"operation to be cascaded along an association, you must indicate that in the "
"mapping document. For example:"
msgstr ""
"Para cada operaci&#x00f3;n b&#x00e1;sica de la sesi&#x00f3;n de Hibernate - "
"incluyendo <literal>persist(), merge(), saveOrUpdate(), delete(), lock(), "
"refresh(), evict(), replicate()</literal> - hay un estilo de cascada "
"correspondiente. Respectivamente, los estilos de cascada se llaman "
"<literal>create, merge, save-update, delete, lock, refresh, evict, "
"replicate</literal>. Si quieres que una operaci&#x00f3;n sea tratada en "
"cascada a lo largo de una asociaci&#x00f3;n, debes indicar eso en el "
"documento de mapeo. Por ejemplo:"

#: index.docbook:921
msgid "<![CDATA[<one-to-one name=\"person\" cascade=\"persist\"/>]]>"
msgstr "<![CDATA[<one-to-one name=\"person\" cascade=\"persist\"/>]]>"

#: index.docbook:923
msgid "Cascade styles my be combined:"
msgstr "Los estilos de cascada pueden combinarse:"

#: index.docbook:927
msgid ""
"<![CDATA[<one-to-one name=\"person\" cascade=\"persist,delete,lock\"/>]]>"
msgstr ""
"<![CDATA[<one-to-one name=\"person\" cascade=\"persist,delete,lock\"/>]]>"

#: index.docbook:929
msgid ""
"You may even use <literal>cascade=\"all\"</literal> to specify that "
"<emphasis>all</emphasis> operations should be cascaded along the "
"association. The default <literal>cascade=\"none\"</literal> specifies that "
"no operations are to be cascaded."
msgstr ""
"Puedes incluso usar <literal>cascade=\"all\"</literal> para especificar que "
"<emphasis>todas</emphasis> las operaciones deben ser tratadas en cascada a "
"lo largo de la asociaci&#x00f3;n. El por defecto <literal>cascade=\"none\"</"
"literal> especifica que ninguna operaci&#x00f3;n ser&#x00e1; tratada en "
"cascada."

#: index.docbook:935
msgid ""
"A special cascade style, <literal>delete-orphan</literal>, applies only to "
"one-to-many associations, and indicates that the <literal>delete()</literal> "
"operation should be applied to any child object that is removed from the "
"association."
msgstr ""
"Un estilo de cascada especial, <literal>delete-orphan</literal>, se aplica "
"s&#x00f3;lo a asociaciones uno-a-muchos, e indica que la operaci&#x00f3;n "
"<literal>delete()</literal> debe aplicarse a cualquier objeto hijo que sea "
"quitado de la asociaci&#x00f3;n."

#: index.docbook:942
msgid "Recommendations:"
msgstr "Recomendaciones:"

#: index.docbook:948
msgid ""
"It doesn't usually make sense to enable cascade on a <literal>&lt;many-to-"
"one&gt;</literal> or <literal>&lt;many-to-many&gt;</literal> association. "
"Cascade is often useful for <literal>&lt;one-to-one&gt;</literal> and "
"<literal>&lt;one-to-many&gt;</literal> associations."
msgstr ""
"Usualmente no tiene sentido habilitar el tratamiento en cascada a una "
"asociaci&#x00f3;n <literal>&lt;many-to-one&gt;</literal> o <literal>&lt;many-"
"to-many&gt;</literal>. El tratamiento en cascada es frecuentemente &#x00fa;"
"til para las asociaciones <literal>&lt;one-to-one&gt;</literal> y "
"<literal>&lt;one-to-many&gt;</literal>. associations."

#: index.docbook:956
msgid ""
"If the child object's lifespan is bounded by the lifespan of the parent "
"object, make it a <emphasis>life cycle object</emphasis> by specifying "
"<literal>cascade=\"all,delete-orphan\"</literal>."
msgstr ""
"Si la esperanza de vida de los objetos hijos est&#x00e1; ligada a la "
"eesperanza de vida del objeto padre, h&#x00e1;zlo un <emphasis>objeto de "
"ciclo de vida</emphasis> especificando <literal>cascade=\"all,delete-orphan"
"\"</literal>."

#: index.docbook:963
msgid ""
"Otherwise, you might not need cascade at all. But if you think that you will "
"often be working with the parent and children together in the same "
"transaction, and you want to save yourself some typing, consider using "
"<literal>cascade=\"persist,merge,save-update\"</literal>."
msgstr ""
"En otro caso, puede que no necesites tratamiento en cascada en absoluto. "
"Pero si piensas que estar&#x00e1;s trabajando frecuentemente con padre e "
"hijos juntos en la misma transacci&#x00f3;n, y quieres ahorrarte algo de "
"tipeo, considera usar <literal>cascade=\"persist,merge,save-update\"</"
"literal>."

#: index.docbook:971
msgid ""
"Mapping an association (either a single valued association, or a collection) "
"with <literal>cascade=\"all\"</literal> marks the association as a "
"<emphasis>parent/child</emphasis> style relationship where save/update/"
"delete of the parent results in save/update/delete of the child or children."
msgstr ""
"Mapear una asociaci&#x00f3;n (ya sea una asociaci&#x00f3;n monovaluada, o "
"una colecci&#x00f3;n) con <literal>cascade=\"all\"</literal> marca la "
"asociaci&#x00f3;n como una relaci&#x00f3;n del estilo <emphasis>padre/hijo</"
"emphasis> donde save/update/delete en el padre resulta en save/update/delete "
"del hijo o hijos."

#: index.docbook:977
msgid ""
"Futhermore, a mere reference to a child from a persistent parent will result "
"in save/update of the child. This metaphor is incomplete, however. A child "
"which becomes unreferenced by its parent is <emphasis>not</emphasis> "
"automatically deleted, except in the case of a <literal>&lt;one-to-many&gt;</"
"literal> association mapped with <literal>cascade=\"delete-orphan\"</"
"literal>. The precise semantics of cascading operations for a parent/child "
"relationship are as follows:"
msgstr ""
"Adem&#x00e1;s, una mera referencia a un hijo desde un padre persistente "
"resultar&#x00e1; en un save/update del hijo. Esta met&#x00e1;fora "
"est&#x00e1; incompleta, sin embargo. Un hijo que deje de ser referenciado "
"por su padre <emphasis>no</emphasis> es borrado autom&#x00e1;ticamente, "
"excepto en el caso de una asociaci&#x00f3;n <literal>&lt;one-to-many&gt;</"
"literal> mapeada con <literal>cascade=\"delete-orphan\"</literal>. La "
"sem&#x00e1;ntica precisa de las operaciones en cascada para una "
"relaci&#x00f3;n padre/hijo es:"

#: index.docbook:988
msgid ""
"If a parent is passed to <literal>persist()</literal>, all children are "
"passed to <literal>persist()</literal>"
msgstr ""
"Si un padre le es pasado a <literal>persist()</literal>, todos los hijos le "
"son pasados a <literal>persist()</literal>"

#: index.docbook:994
msgid ""
"If a parent is passed to <literal>merge()</literal>, all children are passed "
"to <literal>merge()</literal>"
msgstr ""
"Si un padre le es pasado a <literal>merge()</literal>, todos los hijos le "
"son pasados a <literal>merge()</literal>"

#: index.docbook:1000
msgid ""
"If a parent is passed to <literal>save()</literal>, <literal>update()</"
"literal> or <literal>saveOrUpdate()</literal>, all children are passed to "
"<literal>saveOrUpdate()</literal>"
msgstr ""
"Si un padre le es pasado a <literal>save()</literal>, <literal>update()</"
"literal> o <literal>saveOrUpdate()</literal>, todos los hijos le son pasados "
"a <literal>saveOrUpdate()</literal>"

#: index.docbook:1006
msgid ""
"If a transient or detached child becomes referenced by a persistent parent, "
"it is passed to <literal>saveOrUpdate()</literal>"
msgstr ""
"Si un hijo transitorio o separado se vuelve referenciado por un padre "
"persistente, le es pasado a <literal>saveOrUpdate()</literal>"

#: index.docbook:1012
msgid ""
"If a parent is deleted, all children are passed to <literal>delete()</"
"literal>"
msgstr ""
"Si un padre es borrado, todos los hijos le son pasados a <literal>delete()</"
"literal>"

#: index.docbook:1017
msgid ""
"If a child is dereferenced by a persistent parent, <emphasis>nothing special "
"happens</emphasis> - the application should explicitly delete the child if "
"necessary - unless <literal>cascade=\"delete-orphan\"</literal>, in which "
"case the \"orphaned\" child is deleted."
msgstr ""
"Si un hijo deja de ser referenciado por un padre persistente, <emphasis>no "
"ocurre nada especial</emphasis> - la aplicaci&#x00f3;n debe borrar "
"expl&#x00ed;citamente el hijo de ser necesario - a menos que "
"<literal>cascade=\"delete-orphan\"</literal>, en cuyo caso el hijo "
"\"hu&#x00e9;rfano\" es borrado."

#: index.docbook:1026
msgid ""
"Finally, note that cascading of operations can be applied to an object graph "
"at <emphasis>call time</emphasis> or at <emphasis>flush time</emphasis>. All "
"operations, if enabled, are cascaded to associated entities reachable when "
"the operation is executed. However, <literal>save-upate</literal> and "
"<literal>delete-orphan</literal> are transitive for all associated entities "
"reachable during flush of the <literal>Session</literal>."
msgstr ""
"UNTRANSLATED!!! Finally, note that cascading of operations can be applied to "
"an object graph at <emphasis>call time</emphasis> or at <emphasis>flush "
"time</emphasis>. All operations, if enabled, are cascaded to associated "
"entities reachable when the operation is executed. However, <literal>save-"
"upate</literal> and <literal>delete-orphan</literal> are transitive for all "
"associated entities reachable during flush of the <literal>Session</literal>."

#: index.docbook:1038
msgid "Using metadata"
msgstr "Usando metadatos"

#: index.docbook:1040
msgid ""
"Hibernate requires a very rich meta-level model of all entity and value "
"types. From time to time, this model is very useful to the application "
"itself. For example, the application might use Hibernate's metadata to "
"implement a \"smart\" deep-copy algorithm that understands which objects "
"should be copied (eg. mutable value types) and which should not (eg. "
"immutable value types and, possibly, associated entities)."
msgstr ""
"Hibernate requiere de un modelo de meta-nivel muy rico de todas las "
"entidades y tipos de valor. De vez en cuando, este modelo es muy &#x00fa;til "
"para la aplicaci&#x00f3;n misma. Por ejemplo, la aplicaci&#x00f3;n "
"podr&#x00ed;a usar los metadatos de Hibernate para implementar un algoritmo "
"\"inteligente\" de copia en profundidad que entienda qu&#x00e9; objetos "
"deben ser copiados (por ejemplo, tipo de valor mutables) y cu&#x00e1;les no "
"(por ejemplo, tipos de valor inmutables y, posiblemente, entidades "
"asociadas)."

#: index.docbook:1047
msgid ""
"Hibernate exposes metadata via the <literal>ClassMetadata</literal> and "
"<literal>CollectionMetadata</literal> interfaces and the <literal>Type</"
"literal> hierarchy. Instances of the metadata interfaces may be obtained "
"from the <literal>SessionFactory</literal>."
msgstr ""
"Hibernate expone los metadatos v&#x00ed;a las interfaces "
"<literal>ClassMetadata</literal> y <literal>CollectionMetadata</literal> y "
"la jerarqu&#x00ed;a <literal>Type</literal>. Las instancias de las "
"interfaces de metadatos pueden obtenerse de <literal>SessionFactory</"
"literal>."

#: index.docbook:1054
msgid ""
"<![CDATA[Cat fritz = ......;\n"
"ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);\n"
"\n"
"Object[] propertyValues = catMeta.getPropertyValues(fritz);\n"
"String[] propertyNames = catMeta.getPropertyNames();\n"
"Type[] propertyTypes = catMeta.getPropertyTypes();\n"
"\n"
"// get a Map of all properties which are not collections or associations\n"
"Map namedValues = new HashMap();\n"
"for ( int i=0; i<propertyNames.length; i++ ) {\n"
"    if ( !propertyTypes[i].isEntityType() && !propertyTypes[i]."
"isCollectionType() ) {\n"
"        namedValues.put( propertyNames[i], propertyValues[i] );\n"
"    }\n"
"}]]>"
msgstr ""
"<![CDATA[Cat fritz = ......;\n"
"ClassMetadata catMeta = sessionfactory.getClassMetadata(Cat.class);\n"
"\n"
"Object[] propertyValues = catMeta.getPropertyValues(fritz);\n"
"String[] propertyNames = catMeta.getPropertyNames();\n"
"Type[] propertyTypes = catMeta.getPropertyTypes();\n"
"\n"
"// get a Map of all properties which are not collections or associations\n"
"Map namedValues = new HashMap();\n"
"for ( int i=0; i<propertyNames.length; i++ ) {\n"
"    if ( !propertyTypes[i].isEntityType() && !propertyTypes[i]."
"isCollectionType() ) {\n"
"        namedValues.put( propertyNames[i], propertyValues[i] );\n"
"    }\n"
"}]]>"

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"
