msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2007-10-25 07:47+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: component_mapping.xml:5
#, no-c-format
msgid "Component Mapping"
msgstr "Mapeamento de Componentes"

#. Tag: para
#: component_mapping.xml:7
#, no-c-format
msgid ""
"The notion of a <emphasis>component</emphasis> is re-used in several "
"different contexts, for different purposes, throughout Hibernate."
msgstr ""
"A noção de <emphasis>componente</emphasis> é reusada em vários contextos "
"diferentes, para propósitos diferentes, pelo Hibernate."

#. Tag: title
#: component_mapping.xml:13
#, no-c-format
msgid "Dependent objects"
msgstr "Objetos dependentes"

#. Tag: para
#: component_mapping.xml:15
#, no-c-format
msgid ""
"A component is a contained object that is persisted as a value type, not an "
"entity reference. The term \"component\" refers to the object-oriented "
"notion of composition (not to architecture-level components). For example, "
"you might model a person like this:"
msgstr ""
"Um componente é um objeto contido que é persistido como um tipo de valor, "
"não uma referência de entidade. O termo \"componente\" refere-se à noção de "
"composição da orientação a objetos (não a componentes no nível de "
"arquitetura). Por exemplo, você pode modelar uma pessoa desta maneira:"

#. Tag: programlisting
#: component_mapping.xml:21
#, no-c-format
msgid ""
"<![CDATA[public class Person {\n"
"    private java.util.Date birthday;\n"
"    private Name name;\n"
"    private String key;\n"
"    public String getKey() {\n"
"        return key;\n"
"    }\n"
"    private void setKey(String key) {\n"
"        this.key=key;\n"
"    }\n"
"    public java.util.Date getBirthday() {\n"
"        return birthday;\n"
"    }\n"
"    public void setBirthday(java.util.Date birthday) {\n"
"        this.birthday = birthday;\n"
"    }\n"
"    public Name getName() {\n"
"        return name;\n"
"    }\n"
"    public void setName(Name name) {\n"
"        this.name = name;\n"
"    }\n"
"    ......\n"
"    ......\n"
"}]]>"
msgstr ""

#. Tag: programlisting
#: component_mapping.xml:23
#, no-c-format
msgid ""
"<![CDATA[public class Name {\n"
"    char initial;\n"
"    String first;\n"
"    String last;\n"
"    public String getFirst() {\n"
"        return first;\n"
"    }\n"
"    void setFirst(String first) {\n"
"        this.first = first;\n"
"    }\n"
"    public String getLast() {\n"
"        return last;\n"
"    }\n"
"    void setLast(String last) {\n"
"        this.last = last;\n"
"    }\n"
"    public char getInitial() {\n"
"        return initial;\n"
"    }\n"
"    void setInitial(char initial) {\n"
"        this.initial = initial;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: component_mapping.xml:25
#, no-c-format
msgid ""
"Now <literal>Name</literal> may be persisted as a component of "
"<literal>Person</literal>. Notice that <literal>Name</literal> defines "
"getter and setter methods for its persistent properties, but doesn't need to "
"declare any interfaces or identifier properties."
msgstr ""
"Agora <literal>Name</literal> pode ser persistido como um componente de "
"<literal>Person</literal>. Note que <literal>Name</literal> define métodos "
"getter e setter para suas propriedades persistentes, mas não necessita "
"declarar nenhuma interface ou propriedades identificadoras."

#. Tag: para
#: component_mapping.xml:32
#, no-c-format
msgid "Our Hibernate mapping would look like:"
msgstr "Nosso mapeamento do Hibernate seria semelhante a isso"

#. Tag: programlisting
#: component_mapping.xml:36
#, no-c-format
msgid ""
"<![CDATA[<class name=\"eg.Person\" table=\"person\">\n"
"    <id name=\"Key\" column=\"pid\" type=\"string\">\n"
"        <generator class=\"uuid\"/>\n"
"    </id>\n"
"    <property name=\"birthday\" type=\"date\"/>\n"
"    <component name=\"Name\" class=\"eg.Name\"> <!-- class attribute "
"optional -->\n"
"        <property name=\"initial\"/>\n"
"        <property name=\"first\"/>\n"
"        <property name=\"last\"/>\n"
"    </component>\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: component_mapping.xml:38
#, no-c-format
msgid ""
"The person table would have the columns <literal>pid</literal>, "
"<literal>birthday</literal>, <literal>initial</literal>, <literal>first</"
"literal> and <literal>last</literal>."
msgstr ""
"A tabela pessoa teria as seguintes colunas <literal>pid</literal>, "
"<literal>birthday</literal>, <literal>initial</literal>, <literal>first</"
"literal> and <literal>last</literal>."

#. Tag: para
#: component_mapping.xml:46
#, no-c-format
msgid ""
"Like all value types, components do not support shared references. In other "
"words, two persons could have the same name, but the two person objects "
"would contain two independent name objects, only \"the same\" by value. The "
"null value semantics of a component are <emphasis>ad hoc</emphasis>. When "
"reloading the containing object, Hibernate will assume that if all component "
"columns are null, then the entire component is null. This should be okay for "
"most purposes."
msgstr ""
"Assim como todos tipos por valor, componentes não suportam referencias "
"cruzadas. Em outras palavras, duas pessoas poderiam possuir o mesmo nome, "
"mas os dois objetos pessoa poderiam conter dois objetos nome independentes, "
"apenas com \"o mesmo\" por valor. A semântica dos valores null de um "
"componente são <emphasis>ad hoc</emphasis>. No recarregameno do conteúdo do "
"objeto, O Hibernate assumira que se todas as colunas do componente são null, "
"então todo o componente é null. Isto seria o certo para a maioria dos "
"propósitos."

#. Tag: para
#: component_mapping.xml:55
#, no-c-format
msgid ""
"The properties of a component may be of any Hibernate type (collections, "
"many-to-one associations, other components, etc). Nested components should "
"<emphasis>not</emphasis> be considered an exotic usage. Hibernate is "
"intended to support a very fine-grained object model."
msgstr ""
"As propriedades de um componente podem ser de qualquer tipo do Hibernate"
"(collections, associações muitos-para-um, outros componentes, etc). "
"Componentes agrupados <emphasis>não </emphasis> devem ser consideros um uso "
"exótico. O Hibernate tem a intenção de suportar um modelo de objetos muito "
"bem granulado."

#. Tag: para
#: component_mapping.xml:62
#, no-c-format
msgid ""
"The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;"
"parent&gt;</literal> subelement that maps a property of the component class "
"as a reference back to the containing entity."
msgstr ""
"O elemento <literal>&lt;component&gt;</literal> permite um subelemento "
"<literal>&lt;parent&gt;</literal> que mapeia uma propriedade da classe "
"componente como uma referência de volta para a entidade que a contém."

#. Tag: programlisting
#: component_mapping.xml:68
#, no-c-format
msgid ""
"<![CDATA[<class name=\"eg.Person\" table=\"person\">\n"
"    <id name=\"Key\" column=\"pid\" type=\"string\">\n"
"        <generator class=\"uuid\"/>\n"
"    </id>\n"
"    <property name=\"birthday\" type=\"date\"/>\n"
"    <component name=\"Name\" class=\"eg.Name\" unique=\"true\">\n"
"        <parent name=\"namedPerson\"/> <!-- reference back to the Person --"
">\n"
"        <property name=\"initial\"/>\n"
"        <property name=\"first\"/>\n"
"        <property name=\"last\"/>\n"
"    </component>\n"
"</class>]]>"
msgstr ""

#. Tag: title
#: component_mapping.xml:73
#, no-c-format
msgid "Collections of dependent objects"
msgstr "Collections de objetos dependentes"

#. Tag: para
#: component_mapping.xml:75
#, no-c-format
msgid ""
"Collections of components are supported (eg. an array of type <literal>Name</"
"literal>). Declare your component collection by replacing the <literal>&lt;"
"element&gt;</literal> tag with a <literal>&lt;composite-element&gt;</"
"literal> tag."
msgstr ""
"Collections de componentes são suportadadas(ex. uma array de tipo "
"<literal>Name</literal>). Declare a sua collection de componentes "
"substituindo a tag<literal>&lt;element&gt;</literal> pela tag <literal>&lt;"
"composite-element&gt;</literal>."

#. Tag: programlisting
#: component_mapping.xml:82
#, no-c-format
msgid ""
"<![CDATA[<set name=\"someNames\" table=\"some_names\" lazy=\"true\">\n"
"    <key column=\"id\"/>\n"
"    <composite-element class=\"eg.Name\"> <!-- class attribute required -->\n"
"        <property name=\"initial\"/>\n"
"        <property name=\"first\"/>\n"
"        <property name=\"last\"/>\n"
"    </composite-element>\n"
"</set>]]>"
msgstr ""

#. Tag: para
#: component_mapping.xml:84
#, no-c-format
msgid ""
"Note: if you define a <literal>Set</literal> of composite elements, it is "
"very important to implement <literal>equals()</literal> and <literal>hashCode"
"()</literal> correctly."
msgstr ""
"Nota: se você definir um <literal>Set</literal> de elementos compostos, é "
"muito importante implementar <literal>equals()</literal> e <literal>hashCode"
"()</literal> corretamente."

#. Tag: para
#: component_mapping.xml:90
#, no-c-format
msgid ""
"Composite elements may contain components but not collections. If your "
"composite element itself contains components, use the <literal>&lt;nested-"
"composite-element&gt;</literal> tag. This is a pretty exotic case - a "
"collection of components which themselves have components. By this stage you "
"should be asking yourself if a one-to-many association is more appropriate. "
"Try remodelling the composite element as an entity - but note that even "
"though the Java model is the same, the relational model and persistence "
"semantics are still slightly different."
msgstr ""
"Elementos compostos podem conter componentes mas não collections. Se o seu "
"elemento composto contiver componentes , use a tag <literal>&lt;nested-"
"composite-element&gt;</literal> . Este é um caso bastante exótico – uma "
"collections de componentes que por si própria possui componentes. Neste "
"momento você deve estar se perguntando se uma associação de um-para-muitos "
"seria mais apropriada. Tente remodelar o elemento composto como uma entidade "
"– mas note que mesmo pensando que o modelo Java é o mesmo, o modelo "
"relacional e a semântica de persistência ainda são diferentes."

#. Tag: para
#: component_mapping.xml:102
#, no-c-format
msgid ""
"Please note that a composite element mapping doesn't support null-able "
"properties if you're using a <literal>&lt;set&gt;</literal>. Hibernate has "
"to use each columns value to identify a record when deleting objects (there "
"is no separate primary key column in the composite element table), which is "
"not possible with null values. You have to either use only not-null "
"properties in a composite-element or choose a <literal>&lt;list&gt;</"
"literal>, <literal>&lt;map&gt;</literal>, <literal>&lt;bag&gt;</literal> or "
"<literal>&lt;idbag&gt;</literal>."
msgstr ""
"Por favor, note que um mapeamento de elemento composto não suporta "
"propriedades capazes de serem null se você estiver usando um <literal>&lt;"
"set&gt;</literal>. O Hibernate tem que usar cada valor das colunas para "
"identificar um registro quando estiver deletando objetos (não existe coluna "
"chave primária separada na tabela de elemento composto), que não é possível "
"com valores null. Você tem que usar um dos dois, ou apenas propriedades não "
"null em um elemento composto ou escolher uma <literal>&lt;list&gt;</"
"literal>, <literal>&lt;map&gt;</literal>, <literal>&lt;bag&gt;</literal> ou "
"<literal>&lt;idbag&gt;</literal>."

#. Tag: para
#: component_mapping.xml:113
#, no-c-format
msgid ""
"A special case of a composite element is a composite element with a nested "
"<literal>&lt;many-to-one&gt;</literal> element. A mapping like this allows "
"you to map extra columns of a many-to-many association table to the "
"composite element class. The following is a many-to-many association from "
"<literal>Order</literal> to <literal>Item</literal> where "
"<literal>purchaseDate</literal>, <literal>price</literal> and "
"<literal>quantity</literal> are properties of the association:"
msgstr ""
"Um caso especial de elemento composto é um elemento composto com um elemento "
"<literal>&lt;many-to-one&gt;</literal> aninhado. Um mapeamento como este "
"permite você a mapear colunas extras de uma tabela de associação de muitos-"
"para-muitos para a classe de elemento composto. A seguinte associação de "
"muitos-para-muitos de <literal>Order</literal> para um <literal>Item</"
"literal> onde <literal>purchaseDate</literal>, <literal>price</literal> e "
"<literal>quantity</literal> são propriedades da associação:"

#. Tag: programlisting
#: component_mapping.xml:123
#, no-c-format
msgid ""
"<![CDATA[<class name=\"eg.Order\" .... >\n"
"    ....\n"
"    <set name=\"purchasedItems\" table=\"purchase_items\" lazy=\"true\">\n"
"        <key column=\"order_id\">\n"
"        <composite-element class=\"eg.Purchase\">\n"
"            <property name=\"purchaseDate\"/>\n"
"            <property name=\"price\"/>\n"
"            <property name=\"quantity\"/>\n"
"            <many-to-one name=\"item\" class=\"eg.Item\"/> <!-- class "
"attribute is optional -->\n"
"        </composite-element>\n"
"    </set>\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: component_mapping.xml:125
#, no-c-format
msgid ""
"Of course, there can't be a reference to the purchae on the other side, for "
"bidirectional association navigation. Remember that components are value "
"types and don't allow shared references. A single <literal>Purchase</"
"literal> can be in the set of an <literal>Order</literal>, but it can't be "
"referenced by the <literal>Item</literal> at the same time."
msgstr ""
"Claro, que não pode ter uma referência para purchase no outro lado, para a "
"navegação da associação bidirecional. Lembre-se que componentes são tipos "
"por valor e não permitem referências compartilhadas. Uma classe "
"<literal>Purchase</literal> simples pode estar no set de uma classe "
"<literal>Order</literal>, mas ela não pode ser referenciada por "
"<literal>Item</literal> no mesmo momento."

#. Tag: para
#: component_mapping.xml:133
#, no-c-format
msgid "Even ternary (or quaternary, etc) associations are possible:"
msgstr "Até mesmo associações ternárias (ou quaternária, etc) são possíveis:"

#. Tag: programlisting
#: component_mapping.xml:135
#, no-c-format
msgid ""
"<![CDATA[<class name=\"eg.Order\" .... >\n"
"    ....\n"
"    <set name=\"purchasedItems\" table=\"purchase_items\" lazy=\"true\">\n"
"        <key column=\"order_id\">\n"
"        <composite-element class=\"eg.OrderLine\">\n"
"            <many-to-one name=\"purchaseDetails class=\"eg.Purchase\"/>\n"
"            <many-to-one name=\"item\" class=\"eg.Item\"/>\n"
"        </composite-element>\n"
"    </set>\n"
"</class>]]>"
msgstr ""

#. Tag: para
#: component_mapping.xml:137
#, no-c-format
msgid ""
"Composite elements may appear in queries using the same syntax as "
"associations to other entities."
msgstr ""
"Elementos compostos podem aparecer em pesquisas usando a mesma sintaxe assim "
"como associações para outras entidades."

#. Tag: title
#: component_mapping.xml:145
#, no-c-format
msgid "Components as Map indices"
msgstr "Componentes como índices de Map"

#. Tag: para
#: component_mapping.xml:147
#, no-c-format
msgid ""
"The <literal>&lt;composite-map-key&gt;</literal> element lets you map a "
"component class as the key of a <literal>Map</literal>. Make sure you "
"override <literal>hashCode()</literal> and <literal>equals()</literal> "
"correctly on the component class."
msgstr ""
"O elemento <literal>&lt;composite-map-key&gt;</literal> permite você mapear "
"uma classe componente como uma chave de um <literal>Map</literal>. Tenha "
"certeza que você sobrescreveu <literal>hashCode()</literal> e <literal>equals"
"()</literal> corretamente na classe componente."

#. Tag: title
#: component_mapping.xml:156
#, no-c-format
msgid "Components as composite identifiers"
msgstr ". Componentes como identificadores compostos"

#. Tag: para
#: component_mapping.xml:158
#, no-c-format
msgid ""
"You may use a component as an identifier of an entity class. Your component "
"class must satisfy certain requirements:"
msgstr ""
"Você pode usar um componente como um identificador de uma classe entidade. "
"Sua classe componente deve satisfazer certos requisitos:"

#. Tag: para
#: component_mapping.xml:165
#, no-c-format
msgid "It must implement <literal>java.io.Serializable</literal>."
msgstr "Ele deve implementar <literal>java.io.Serializable</literal>."

#. Tag: para
#: component_mapping.xml:170
#, no-c-format
msgid ""
"It must re-implement <literal>equals()</literal> and <literal>hashCode()</"
"literal>, consistently with the database's notion of composite key equality."
msgstr ""
"Ele deve re-implementar <literal>equals()</literal> e <literal>hashCode()</"
"literal>, consistentemente com a noção de igualdade de chave composta do "
"banco de dados."

#. Tag: emphasis
#: component_mapping.xml:179
#, no-c-format
msgid ""
"Note: in Hibernate3, the second requirement is not an absolutely hard "
"requirement of Hibernate. But do it anyway."
msgstr ""
"Nota: no Hibernate 3, o segundo requisito não é um requisito absolutamente "
"necessário. Mas atenda ele de qualquer forma."

#. Tag: para
#: component_mapping.xml:183
#, no-c-format
msgid ""
"You can't use an <literal>IdentifierGenerator</literal> to generate "
"composite keys. Instead the application must assign its own identifiers."
msgstr ""
"Você não pode usar um <literal>IdentifierGenerator</literal> para gerar "
"chaves compostas. Ao invés disso o aplicativo deve gerenciar seus próprios "
"identificadores."

#. Tag: para
#: component_mapping.xml:188
#, no-c-format
msgid ""
"Use the <literal>&lt;composite-id&gt;</literal> tag (with nested "
"<literal>&lt;key-property&gt;</literal> elements) in place of the usual "
"<literal>&lt;id&gt;</literal> declaration. For example, the "
"<literal>OrderLine</literal> class has a primary key that depends upon the "
"(composite) primary key of <literal>Order</literal>."
msgstr ""
"Use a tag <literal>&lt;composite-id&gt;</literal> (com elementos "
"<literal>&lt;key-property&gt;</literal> aninhados) no lugar da declaração "
"<literal>&lt;id&gt;</literal> de costume. Por exemplo, a classe "
"<literal>OrderLine</literal> possui uma chave primária que depende da chave "
"primária (composta) de <literal>Order</literal>."

#. Tag: programlisting
#: component_mapping.xml:196
#, no-c-format
msgid ""
"<![CDATA[<class name=\"OrderLine\">\n"
"    \n"
"    <composite-id name=\"id\" class=\"OrderLineId\">\n"
"        <key-property name=\"lineId\"/>\n"
"        <key-property name=\"orderId\"/>\n"
"        <key-property name=\"customerId\"/>\n"
"    </composite-id>\n"
"    \n"
"    <property name=\"name\"/>\n"
"    \n"
"    <many-to-one name=\"order\" class=\"Order\"\n"
"            insert=\"false\" update=\"false\">\n"
"        <column name=\"orderId\"/>\n"
"        <column name=\"customerId\"/>\n"
"    </many-to-one>\n"
"    ....\n"
"    \n"
"</class>]]>"
msgstr ""

#. Tag: para
#: component_mapping.xml:198
#, no-c-format
msgid ""
"Now, any foreign keys referencing the <literal>OrderLine</literal> table are "
"also composite. You must declare this in your mappings for other classes. An "
"association to <literal>OrderLine</literal> would be mapped like this:"
msgstr ""
"Agora, qualquer chave estrangeira referenciando a tabela <literal>OrderLine</"
"literal> também serão compostas. Você deve declarar isto em seus mapeamentos "
"para outras classes. Uma associação para <literal>OrderLine</literal> seria "
"mapeada dessa forma:"

#. Tag: programlisting
#: component_mapping.xml:204
#, no-c-format
msgid ""
"<![CDATA[<many-to-one name=\"orderLine\" class=\"OrderLine\">\n"
"<!-- the \"class\" attribute is optional, as usual -->\n"
"    <column name=\"lineId\"/>\n"
"    <column name=\"orderId\"/>\n"
"    <column name=\"customerId\"/>\n"
"</many-to-one>]]>"
msgstr ""

#. Tag: para
#: component_mapping.xml:206
#, no-c-format
msgid ""
"(Note that the <literal>&lt;column&gt;</literal> tag is an alternative to "
"the <literal>column</literal> attribute everywhere.)"
msgstr ""
"(Note que a tag <literal>&lt;column&gt;</literal> é uma alternativa para o "
"atributo <literal>column</literal> por toda a parte.)"

#. Tag: para
#: component_mapping.xml:211
#, no-c-format
msgid ""
"A <literal>many-to-many</literal> association to <literal>OrderLine</"
"literal> also uses the composite foreign key:"
msgstr ""
"Uma associação <literal>many-to-many</literal> para <literal>many-to-many</"
"literal> também usa a chave estrangeira composta:"

#. Tag: programlisting
#: component_mapping.xml:216
#, no-c-format
msgid ""
"<![CDATA[<set name=\"undeliveredOrderLines\">\n"
"    <key column name=\"warehouseId\"/>\n"
"    <many-to-many class=\"OrderLine\">\n"
"        <column name=\"lineId\"/>\n"
"        <column name=\"orderId\"/>\n"
"        <column name=\"customerId\"/>\n"
"    </many-to-many>\n"
"</set>]]>"
msgstr ""

#. Tag: para
#: component_mapping.xml:218
#, no-c-format
msgid ""
"The collection of <literal>OrderLine</literal>s in <literal>Order</literal> "
"would use:"
msgstr ""
"A collection de <literal>OrderLine</literal>s em <literal>Order</literal> "
"usaria:"

#. Tag: programlisting
#: component_mapping.xml:223
#, no-c-format
msgid ""
"<![CDATA[<set name=\"orderLines\" inverse=\"true\">\n"
"    <key>\n"
"        <column name=\"orderId\"/>\n"
"        <column name=\"customerId\"/>\n"
"    </key>\n"
"    <one-to-many class=\"OrderLine\"/>\n"
"</set>]]>"
msgstr ""

#. Tag: para
#: component_mapping.xml:225
#, no-c-format
msgid ""
"(The <literal>&lt;one-to-many&gt;</literal> element, as usual, declares no "
"columns.)"
msgstr ""
"(O elemento <literal>&lt;one-to-many&gt;</literal>, como de costume, não "
"declara colunas.)"

#. Tag: para
#: component_mapping.xml:229
#, no-c-format
msgid ""
"If <literal>OrderLine</literal> itself owns a collection, it also has a "
"composite foreign key."
msgstr ""
"Se <literal>OrderLine</literal> possui uma collection, ela também tem uma "
"chave estrangeira composta."

#. Tag: programlisting
#: component_mapping.xml:234
#, no-c-format
msgid ""
"<![CDATA[<class name=\"OrderLine\">\n"
"    ....\n"
"    ....\n"
"    <list name=\"deliveryAttempts\">\n"
"        <key>   <!-- a collection inherits the composite key type -->\n"
"            <column name=\"lineId\"/>\n"
"            <column name=\"orderId\"/>\n"
"            <column name=\"customerId\"/>\n"
"        </key>\n"
"        <list-index column=\"attemptId\" base=\"1\"/>\n"
"        <composite-element class=\"DeliveryAttempt\">\n"
"            ...\n"
"        </composite-element>\n"
"    </set>\n"
"</class>]]>"
msgstr ""

#. Tag: title
#: component_mapping.xml:239
#, no-c-format
msgid "Dynamic components"
msgstr "Componentes Dinâmicos"

#. Tag: para
#: component_mapping.xml:241
#, no-c-format
msgid "You may even map a property of type <literal>Map</literal>:"
msgstr ""
"Você pode até mesmo mapear uma propriedade do tipo <literal>Map</literal>:"

#. Tag: programlisting
#: component_mapping.xml:245
#, no-c-format
msgid ""
"<![CDATA[<dynamic-component name=\"userAttributes\">\n"
"    <property name=\"foo\" column=\"FOO\" type=\"string\"/>\n"
"    <property name=\"bar\" column=\"BAR\" type=\"integer\"/>\n"
"    <many-to-one name=\"baz\" class=\"Baz\" column=\"BAZ_ID\"/>\n"
"</dynamic-component>]]>"
msgstr ""

#. Tag: para
#: component_mapping.xml:247
#, no-c-format
msgid ""
"The semantics of a <literal>&lt;dynamic-component&gt;</literal> mapping are "
"identical to <literal>&lt;component&gt;</literal>. The advantage of this "
"kind of mapping is the ability to determine the actual properties of the "
"bean at deployment time, just by editing the mapping document. Runtime "
"manipulation of the mapping document is also possible, using a DOM parser. "
"Even better, you can access (and change) Hibernate's configuration-time "
"metamodel via the <literal>Configuration</literal> object."
msgstr ""
"A semântica de um mapeamento <literal>&lt;dynamic-component&gt;</literal> é "
"idêntica à <literal>&lt;component&gt;</literal>. A vantagem deste tipo de "
"mapeamento é a habilidade de determinar as propriedades atuais do bean no "
"momento de deploy, apenas editando o documento de mapeamento. A Manipulação "
"em tempo de execução do documento de mapeamento também é possível, usando o "
"parser DOM. Até melhor, você pode acessar (e mudar) o metamodelo "
"configuration-time do Hibernate através do objeto <literal>Configuration</"
"literal>."
