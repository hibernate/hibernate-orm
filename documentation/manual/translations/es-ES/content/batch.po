#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Batch processing"
msgstr "Procesamiento por lotes"

#: index.docbook:7
msgid "A naive approach to inserting 100 000 rows in the database using Hibernate might look like this:"
msgstr "Un enfoque ingenuo para insertar 100.000 filas en la base de datos usando Hibernate podría verse así:"

#: index.docbook:12
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "for ( int i=0; i<100000; i++ ) {\n"
      "    Customer customer = new Customer(.....);\n"
      "    session.save(customer);\n"
      "}\n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "for ( int i=0; i<100000; i++ ) {\n"
      "    Customer customer = new Customer(.....);\n"
      "    session.save(customer);\n"
      "}\n"
      "tx.commit();\n"
      "session.close();]]>"

#: index.docbook:14
msgid "This would fall over with an <literal>OutOfMemoryException</literal> somewhere around the 50 000th row. That's because Hibernate caches all the newly inserted <literal>Customer</literal> instances in the session-level cache."
msgstr "Esto podría caer sobre una <literal>OutOfMemoryException</literal> en algún sitio cerca de la fila 50.000. Esto es porque Hibernate tiene en caché todas las instancias de <literal>Customer</literal> recién instanciadas en el caché de nivel de sesión."

#: index.docbook:20
msgid "In this chapter we'll show you how to avoid this problem. First, however, if you are doing batch processing, it is absolutely critical that you enable the use of JDBC batching, if you intend to achieve reasonable performance. Set the JDBC batch size to a reasonable number (say, 10-50):"
msgstr "En este capítulo te mostraremos cómo evitar este problema. Primero, sin embargo, si estás haciendo procesamiento por lotes (batch processing), es absolutamente crítico que habilites el uso de loteo JDBC, si pretendes lograr un rendimiento razonable. Establece el tamaño de lote JDBC a un número razonable (digamos 10-50):"

#: index.docbook:27
msgid "<![CDATA[hibernate.jdbc.batch_size 20]]>"
msgstr "<![CDATA[hibernate.jdbc.batch_size 20]]>"

#: index.docbook:29
msgid "Note that Hibernate disables insert batching at the JDBC level transparently if you use an <literal>identiy</literal> identifier generator."
msgstr "Podrías además querer hacer este tipo de trabajo en un proceso donde la interacción con el caché de segundo nivel esté completamente deshabilitado:"

#: index.docbook:34
msgid "You also might like to do this kind of work in a process where interaction with the second-level cache is completely disabled:"
msgstr "<![CDATA[hibernate.cache.use_second_level_cache false]]>"

#: index.docbook:39
msgid "<![CDATA[hibernate.cache.use_second_level_cache false]]>"
msgstr "Inserciones en lote"

#: index.docbook:41
msgid "However, this is not absolutely necessary, since we can explicitly set the <literal>CacheMode</literal> to disable interaction with the second-level cache."
msgstr "Al hacer persistentes objetos nuevos, debes limpiar con <literal>flush()</literal> y llamar a <literal>clear()</literal> en la sesión regularmente, para controlar el tamaño del caché de primer nivel."

#: index.docbook:47
msgid "Batch inserts"
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "   \n"
      "for ( int i=0; i<100000; i++ ) {\n"
      "    Customer customer = new Customer(.....);\n"
      "    session.save(customer);\n"
      "    if ( i % 20 == 0 ) { //20, same as the JDBC batch size\n"
      "        //flush a batch of inserts and release memory:\n"
      "        session.flush();\n"
      "        session.clear();\n"
      "    }\n"
      "}\n"
      "   \n"
      "tx.commit();\n"
      "session.close();]]>"

#: index.docbook:49
msgid "When making new objects persistent, you must <literal>flush()</literal> and then <literal>clear()</literal> the session regularly, to control the size of the first-level cache."
msgstr "Actualizaciones en lote"

#: index.docbook:55
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "   \n"
      "for ( int i=0; i<100000; i++ ) {\n"
      "    Customer customer = new Customer(.....);\n"
      "    session.save(customer);\n"
      "    if ( i % 20 == 0 ) { //20, same as the JDBC batch size\n"
      "        //flush a batch of inserts and release memory:\n"
      "        session.flush();\n"
      "        session.clear();\n"
      "    }\n"
      "}\n"
      "   \n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr "Para recuperar y actualizar datos se aplican las mismas ideas. Adicionalmente, necesitas usar <literal>scroll()</literal> para sacar ventaja de los cursores del lado del servidor en consultas que devuelvan muchas filas de datos."

#: index.docbook:60
msgid "Batch updates"
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "   \n"
      "ScrollableResults customers = session.getNamedQuery(\"GetCustomers\")\n"
      "    .setCacheMode(CacheMode.IGNORE)\n"
      "    .scroll(ScrollMode.FORWARD_ONLY);\n"
      "int count=0;\n"
      "while ( customers.next() ) {\n"
      "    Customer customer = (Customer) customers.get(0);\n"
      "    customer.updateStuff(...);\n"
      "    if ( ++count % 20 == 0 ) {\n"
      "        //flush a batch of updates and release memory:\n"
      "        session.flush();\n"
      "        session.clear();\n"
      "    }\n"
      "}\n"
      "   \n"
      "tx.commit();\n"
      "session.close();]]>"

#: index.docbook:62
msgid "For retrieving and updating data the same ideas apply. In addition, you need to use <literal>scroll()</literal> to take advantage of server-side cursors for queries that return many rows of data."
msgstr "update/delete en masa"

#: index.docbook:68
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "   \n"
      "ScrollableResults customers = session.getNamedQuery(\"GetCustomers\")\n"
      "    .setCacheMode(CacheMode.IGNORE)\n"
      "    .scroll(ScrollMode.FORWARD_ONLY);\n"
      "int count=0;\n"
      "while ( customers.next() ) {\n"
      "    Customer customer = (Customer) customers.get(0);\n"
      "    customer.updateStuff(...);\n"
      "    if ( ++count % 20 == 0 ) {\n"
      "        //flush a batch of updates and release memory:\n"
      "        session.flush();\n"
      "        session.clear();\n"
      "    }\n"
      "}\n"
      "   \n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr "Como ya se ha discutido, el mapeo objeto/relacional automático y transparente se refiere al manejo de estado de objetos. Esto implica que el estado del objeto está disponible en memoria, por lo tanto actualizar o borrar (usando <literal>UPDATE</literal> y <literal>DELETE</literal> de SQL) datos directamente en la base de datos no afectará el estado en memoria. Sin embargo, Hibernate provee métodos para la ejecución de sentencias del estilo de <literal>UPDATE</literal> y <literal>DELETE</literal> de SQL que se realizan a través del Lenguaje de Consulta de Hibernate (Hibernate Query Language o <xref linkend=\"queryhql\"/>HQL)."

#: index.docbook:73
msgid "The StatelessSession interface"
msgstr "La pseudo-sintáxis para sentencias <literal>UPDATE</literal> y <literal>DELETE</literal> es: <literal>( UPDATE | DELETE ) FROM? ClassName (WHERE WHERE_CONDITIONS)?</literal>. Algunos puntos a tener en cuenta:"

#: index.docbook:74
msgid "Alternatively, Hibernate provides a command-oriented API that may be used for streaming data to and from the database in the form of detached objects. A <literal>StatelessSession</literal> has no persistence context associated with it and does not provide many of the higher-level life cycle semantics. In particular, a stateless session does not implement a first-level cache nor interact with any second-level or query cache. It does not implement transactional write-behind or automatic dirty checking. Operations performed using a stateless session do not ever cascade to associated instances. Collections are ignored by a stateless session. Operations performed via a stateless session bypass Hibernate's event model and interceptors. Stateless sessions are vulnerable to data aliasing effects, due to the lack of a first-level cache. A stateless session is a lower-level abstraction, much closer to the underlying JDBC."
msgstr "En la cláusula-from, la palabra clave FROM es opcional"

#: index.docbook:89
msgid ""
      "<![CDATA[StatelessSession session = sessionFactory.openStatelessSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "   \n"
      "ScrollableResults customers = session.getNamedQuery(\"GetCustomers\")\n"
      "    .scroll(ScrollMode.FORWARD_ONLY);\n"
      "while ( customers.next() ) {\n"
      "    Customer customer = (Customer) customers.get(0);\n"
      "    customer.updateStuff(...);\n"
      "    session.update(customer);\n"
      "}\n"
      "   \n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr "Puede haber sólo una clase mencionada en la cláusula-from, y <emphasis>no puede</emphasis> tener un alias."

#: index.docbook:91
msgid "Note that in this code example, the <literal>Customer</literal> instances returned by the query are immediately detached. They are never associated with any persistence context."
msgstr "No puede especificarse ningún join (bien implícito o explícito) en una consulta masiva de HQL. Pueden usarse subconsultas en la cláusula-where."

#: index.docbook:97
msgid "The <literal>insert(), update()</literal> and <literal>delete()</literal> operations defined by the <literal>StatelessSession</literal> interface are considered to be direct database row-level operations, which result in immediate execution of a SQL <literal>INSERT, UPDATE</literal> or <literal>DELETE</literal> respectively. Thus, they have very different semantics to the <literal>save(), saveOrUpdate()</literal> and <literal>delete()</literal> operations defined by the <literal>Session</literal> interface."
msgstr "La cláusula-where es también opcional."

#: index.docbook:110
msgid "DML-style operations"
msgstr "Como un ejemplo, para ejecutar un <literal>UPDATE</literal> HQL, usa el método <literal>Query.executeUpdate()</literal>:"

#: index.docbook:112
msgid "As already discussed, automatic and transparent object/relational mapping is concerned with the management of object state. This implies that the object state is available in memory, hence manipulating (using the SQL <literal>Data Manipulation Language</literal> (DML) statements: <literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</literal>) data directly in the database will not affect in-memory state. However, Hibernate provides methods for bulk SQL-style DML statement execution which are performed through the Hibernate Query Language (<xref linkend=\"queryhql\"/>HQL)."
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "        Transaction tx = session.beginTransaction();\n"
      "\n"
      "        String hqlUpdate = \"update Customer set name = :newName where name = :oldName\";\n"
      "        int updatedEntities = s.createQuery( hqlUpdate )\n"
      "                            .setString( \"newName\", newName )\n"
      "                            .setString( \"oldName\", oldName )\n"
      "                            .executeUpdate();\n"
      "        tx.commit();\n"
      "        session.close();]]>"

#: index.docbook:122
msgid "The pseudo-syntax for <literal>UPDATE</literal> and <literal>DELETE</literal> statements is: <literal>( UPDATE | DELETE ) FROM? EntityName (WHERE where_conditions)?</literal>. Some points to note:"
msgstr "Para ejecutar un <literal>DELETE</literal> HQL, usa el mismo método <literal>Query.executeUpdate()</literal> (el método está nombrado para aquellos familiarizados con <literal>PreparedStatement.executeUpdate()</literal> de JDBC):"

#: index.docbook:130
msgid "In the from-clause, the FROM keyword is optional"
msgstr ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "        Transaction tx = session.beginTransaction();\n"
      "\n"
      "        String hqlDelete = \"delete Customer where name = :oldName\";\n"
      "        int deletedEntities = s.createQuery( hqlDelete )\n"
      "                            .setString( \"oldName\", oldName )\n"
      "                            .executeUpdate();\n"
      "        tx.commit();\n"
      "        session.close();]]>"

#: index.docbook:135
msgid "There can only be a single entity named in the from-clause; it can optionally be aliased. If the entity name is aliased, then any property references must be qualified using that alias; if the entity name is not aliased, then it is illegal for any property references to be qualified."
msgstr "El valor <literal>int</literal> devuelto por el método <literal>Query.executeUpdate()</literal> indica el número de entidades afectadas por la operación. Considera que esto puede o no correlacionarse al número de filas afectadas en la base de datos. Una operación masiva HQL podría resultar en que se ejecuten múltiples sentencias de SQL reales, para joined-subclass, por ejemplo. El número devuelto indica el número de entidades reales afectadas por la sentencia. Volviendo al ejemplo de joined-subclass, un borrado contra una de las subclases puede resultar realmente en borrados contra no sólo la tabla a la que está mapeada esa subclase, sino también la tabla \"raíz\" y potencialmente tablas de joined-subclass más debajo en la jerarquía de herencia."

#: index.docbook:143
msgid "No <xref linkend=\"queryhql-joins-forms\"/>joins (either implicit or explicit) can be specified in a bulk HQL query. Sub-queries may be used in the where-clause; the subqueries, themselves, may contain joins."
msgstr "Ten en cuenta que existen actualmente unas pocas limitaciones con las operaciones HQL masivas, que serán atendidas en lanzamientos futuros; consulta la hoja de ruta de JIRA para más detalles."

#: index.docbook:150
msgid "The where-clause is also optional."
msgstr ""

#: index.docbook:156
msgid "As an example, to execute an HQL <literal>UPDATE</literal>, use the <literal>Query.executeUpdate()</literal> method (the method is named for those familiar with JDBC's <literal>PreparedStatement.executeUpdate()</literal>):"
msgstr ""

#: index.docbook:162
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "\n"
      "String hqlUpdate = \"update Customer c set c.name = :newName where c.name = :oldName\";\n"
      "// or String hqlUpdate = \"update Customer set name = :newName where name = :oldName\";\n"
      "int updatedEntities = s.createQuery( hqlUpdate )\n"
      "        .setString( \"newName\", newName )\n"
      "        .setString( \"oldName\", oldName )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr ""

#: index.docbook:164
msgid "HQL <literal>UPDATE</literal> statements, by default do not effect the <xref linkend=\"mapping-declaration-version\"/>version or the <xref linkend=\"mapping-declaration-timestamp\"/>timestamp property values for the affected entities; this is in keeping with the EJB3 specification. However, you can force Hibernate to properly reset the <literal>version</literal> or <literal>timestamp</literal> property values through the use of a <literal>versioned update</literal>. This is achieved by adding the <literal>VERSIONED</literal> keyword after the <literal>UPDATE</literal> keyword."
msgstr ""

#: index.docbook:174
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "String hqlVersionedUpdate = \"update versioned Customer set name = :newName where name = :oldName\";\n"
      "int updatedEntities = s.createQuery( hqlUpdate )\n"
      "        .setString( \"newName\", newName )\n"
      "        .setString( \"oldName\", oldName )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr ""

#: index.docbook:176
msgid "Note that custom version types (<literal>org.hibernate.usertype.UserVersionType</literal>) are not allowed in conjunction with a <literal>update versioned</literal> statement."
msgstr ""

#: index.docbook:181
msgid "To execute an HQL <literal>DELETE</literal>, use the same <literal>Query.executeUpdate()</literal> method:"
msgstr ""

#: index.docbook:186
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "\n"
      "String hqlDelete = \"delete Customer c where c.name = :oldName\";\n"
      "// or String hqlDelete = \"delete Customer where name = :oldName\";\n"
      "int deletedEntities = s.createQuery( hqlDelete )\n"
      "        .setString( \"oldName\", oldName )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr ""

#: index.docbook:188
msgid "The <literal>int</literal> value returned by the <literal>Query.executeUpdate()</literal> method indicate the number of entities effected by the operation. Consider this may or may not correlate to the number of rows effected in the database. An HQL bulk operation might result in multiple actual SQL statements being executed, for joined-subclass, for example. The returned number indicates the number of actual entities affected by the statement. Going back to the example of joined-subclass, a delete against one of the subclasses may actually result in deletes against not just the table to which that subclass is mapped, but also the \"root\" table and potentially joined-subclass tables further down the inheritence hierarchy."
msgstr ""

#: index.docbook:199
msgid "The pseudo-syntax for <literal>INSERT</literal> statements is: <literal>INSERT INTO EntityName properties_list select_statement</literal>. Some points to note:"
msgstr ""

#: index.docbook:207
msgid "Only the INSERT INTO ... SELECT ... form is supported; not the INSERT INTO ... VALUES ... form."
msgstr ""

#: index.docbook:210
msgid "The properties_list is analogous to the <literal>column speficiation</literal> in the SQL <literal>INSERT</literal> statement. For entities involved in mapped inheritence, only properties directly defined on that given class-level can be used in the properties_list. Superclass properties are not allowed; and subclass properties do not make sense. In other words, <literal>INSERT</literal> statements are inherently non-polymorphic."
msgstr ""

#: index.docbook:220
msgid "select_statement can be any valid HQL select query, with the caveat that the return types must match the types expected by the insert. Currently, this is checked during query compilation rather than allowing the check to relegate to the database. Note however that this might cause problems between Hibernate <literal>Type</literal>s which are <emphasis>equivalent</emphasis> as opposed to <emphasis>equal</emphasis>. This might cause issues with mismatches between a property defined as a <literal>org.hibernate.type.DateType</literal> and a property defined as a <literal>org.hibernate.type.TimestampType</literal>, even though the database might not make a distinction or might be able to handle the conversion."
msgstr ""

#: index.docbook:232
msgid "For the id property, the insert statement gives you two options. You can either explicitly specify the id property in the properties_list (in which case its value is taken from the corresponding select expression) or omit it from the properties_list (in which case a generated value is used). This later option is only available when using id generators that operate in the database; attempting to use this option with any \"in memory\" type generators will cause an exception during parsing. Note that for the purposes of this discussion, in-database generators are considered to be <literal>org.hibernate.id.SequenceGenerator</literal> (and its subclasses) and any implementors of <literal>org.hibernate.id.PostInsertIdentifierGenerator</literal>. The most notable exception here is <literal>org.hibernate.id.TableHiLoGenerator</literal>, which cannot be used because it does not expose a selectable way to get its values."
msgstr ""

#: index.docbook:247
msgid "For properties mapped as either <literal>version</literal> or <literal>timestamp</literal>, the insert statement gives you two options. You can either specify the property in the properties_list (in which case its value is taken from the corresponding select expressions) or omit it from the properties_list (in which case the <literal>seed value</literal> defined by the <literal>org.hibernate.type.VersionType</literal> is used)."
msgstr ""

#: index.docbook:257
msgid "An example HQL <literal>INSERT</literal> statement execution:"
msgstr ""

#: index.docbook:261
msgid ""
      "<![CDATA[Session session = sessionFactory.openSession();\n"
      "Transaction tx = session.beginTransaction();\n"
      "\n"
      "String hqlInsert = \"insert into DelinquentAccount (id, name) select c.id, c.name from Customer c where ...\";\n"
      "int createdEntities = s.createQuery( hqlInsert )\n"
      "        .executeUpdate();\n"
      "tx.commit();\n"
      "session.close();]]>"
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

