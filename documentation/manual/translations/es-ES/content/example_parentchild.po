#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Example: Parent/Child"
msgstr "Ejemplo: Padre/Hijo"

#: index.docbook:7
msgid "One of the very first things that new users try to do with Hibernate is to model a parent / child type relationship. There are two different approaches to this. For various reasons the most convenient approach, especially for new users, is to model both <literal>Parent</literal> and <literal>Child</literal> as entity classes with a <literal>&lt;one-to-many&gt;</literal> association from <literal>Parent</literal> to <literal>Child</literal>. (The alternative approach is to declare the <literal>Child</literal> as a <literal>&lt;composite-element&gt;</literal>.) Now, it turns out that default semantics of a one to many association (in Hibernate) are much less close to the usual semantics of a parent / child relationship than those of a composite element mapping. We will explain how to use a <emphasis>bidirectional one to many association with cascades</emphasis> to model a parent / child relationship efficiently and elegantly. It's not at all difficult!"
msgstr "Una de las primer&#x00ed;simas cosas que los usuarios nuevos intentan hacer con Hibernate es modelar una relaci&#x00f3;n de tipo padre / hijo. Para esto hay dos enfoques diferentes. Por varias razones, el enfoque m&#x00e1;s conveniente, especialmente para usuarios nuevos, es modelar tanto <literal>Parent</literal> como <literal>Child</literal> como clases de entidad con una asociaci&#x00f3;n <literal>&lt;one-to-many&gt;</literal> desde <literal>Parent</literal> a <literal>Child</literal>. (El enfoque alternativo es declarar el <literal>Child</literal> como un <literal>&lt;composite-element&gt;</literal>.) Ahora, resulta que la sem&#x00e1;ntica por defecto de una asociaci&#x00f3;n uno a muchos (en Hibernate) es mucho menos cercana a la sem&#x00e1;ntica usual de una relaci&#x00f3;n padre / hijo que aquellas de un mapeo de elementos compuestos. Explicaremos c&#x00f3;mo usar una <emphasis>asociaci&#x00f3;n uno a muchos bidireccional con tratamiento en cascada</emphasis> para modelar una relaci&#x00f3;n padre / hijo eficiente y elegantemente. &#x00a1;No es para nada dif&#x00ed;cil!"

#: index.docbook:21
msgid "A note about collections"
msgstr "Una nota sobre las colecciones"

#: index.docbook:23
msgid "Hibernate collections are considered to be a logical part of their owning entity; never of the contained entities. This is a crucial distinction! It has the following consequences:"
msgstr "Se considera que las colecciones de Hibernate son una parte l&#x00f3;gica de la entidad que las posee; nunca de las entidades contenidas. &#x00a1;Esta es una distinci&#x00f3;n crucial! Esto tiene las siguientes consecuencias:"

#: index.docbook:30
msgid "When we remove / add an object from / to a collection, the version number of the collection owner is incremented."
msgstr "Cuando se quita / a&#x00f1;ade un objeto desde / a una colecci&#x00f3;n, se incrementa el n&#x00fa;mero de versi&#x00f3;n del due&#x00f1;o de la colecci&#x00f3;n."

#: index.docbook:36
msgid "If an object that was removed from a collection is an instance of a value type (eg, a composite element), that object will cease to be persistent and its state will be completely removed from the database. Likewise, adding a value type instance to the collection will cause its state to be immediately persistent."
msgstr "Si un objeto que fue quitado de una colecci&#x00f3;n es una instancia de un tipo de valor (por ejemplo, un elemento compuesto), ese objeta cesar&#x00e1; de ser persistente y su estado ser&#x00e1; completamente quitado de la base de datos. Asimismo, a&#x00f1;adir una instancia de tipo de valor a la colecci&#x00f3;n causar&#x00e1; que su estado sea inmediatamente persistente."

#: index.docbook:44
msgid "On the other hand, if an entity is removed from a collection (a one-to-many or many-to-many association), it will not be deleted, by default. This behaviour is completely consistent - a change to the internal state of another entity should not cause the associated entity to vanish! Likewise, adding an entity to a collection does not cause that entity to become persistent, by default."
msgstr "Por otro lado, si se quita una entidad de una colecci&#x00f3;n (una asociaci&#x00f3;n uno-a-muchos o muchos-a-muchos), no ser&#x00e1; borrado, por defecto. Este comportamiento es completamente consistente. &#x00a1;Un cambio en el estado interno de otra entidad no hace desaparecer la entidad asociada! Asimismo, a&#x00f1;adir una entidad a una colecci&#x00f3;n no causa que la entidad se vuelva persistente, por defecto."

#: index.docbook:54
msgid "Instead, the default behaviour is that adding an entity to a collection merely creates a link between the two entities, while removing it removes the link. This is very appropriate for all sorts of cases. Where it is not appropriate at all is the case of a parent / child relationship, where the life of the child is bound to the life cycle of the parent."
msgstr "En cambio, el comportamiento por defecto es que al a&#x00f1;adir una entidad a una colecci&#x00f3;n se crea meramente un enlace entre las dos entidades, mientras que al quitarla se quita el enlace. Esto es muy apropiado para todos los tipos de casos. Donde no es para nada apropiado es en el caso de una relaci&#x00f3;n padre / hijo. donde la vida del hijo est&#x00e1; ligada al ciclo de vida del padre."

#: index.docbook:64
msgid "Bidirectional one-to-many"
msgstr "Uno-a-muchos bidirectional"

#: index.docbook:66
msgid "Suppose we start with a simple <literal>&lt;one-to-many&gt;</literal> association from <literal>Parent</literal> to <literal>Child</literal>."
msgstr "Sup&#x00f3;n que empezamos con una asociaci&#x00f3;n simple <literal>&lt;one-to-many&gt;</literal> desde <literal>Parent</literal> a <literal>Child</literal>."

#: index.docbook:71
msgid ""
      "<![CDATA[<set name=\"children\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"children\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"

#: index.docbook:73
msgid "If we were to execute the following code"
msgstr "Si ejecut&#x00e1;semos el siguiente c&#x00f3;digo"

#: index.docbook:77
msgid ""
      "<![CDATA[Parent p = .....;\n"
      "Child c = new Child();\n"
      "p.getChildren().add(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = .....;\n"
      "Child c = new Child();\n"
      "p.getChildren().add(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"

#: index.docbook:79
msgid "Hibernate would issue two SQL statements:"
msgstr "Hibernate publicar&#x00ed;a dos sentencias SQL:"

#: index.docbook:85
msgid "an <literal>INSERT</literal> to create the record for <literal>c</literal>"
msgstr "un <literal>INSERT</literal> para crear el registro de <literal>c</literal>"

#: index.docbook:88
msgid "an <literal>UPDATE</literal> to create the link from <literal>p</literal> to <literal>c</literal>"
msgstr "un <literal>UPDATE</literal> para crear el enlace desde <literal>p</literal> a <literal>c</literal>"

#: index.docbook:95
msgid "This is not only inefficient, but also violates any <literal>NOT NULL</literal> constraint on the <literal>parent_id</literal> column. We can fix the nullability constraint violation by specifying <literal>not-null=\"true\"</literal> in the collection mapping:"
msgstr "Esto no es s&#x00f3;lo ineficiente, sino que adem&#x00e1;s viola cualquier restricci&#x00f3;n <literal>NOT NULL</literal> en la columna <literal>parent_id</literal>. Podemos reparar la violaci&#x00f3;n de restricci&#x00f3;n de nulabilidad especificando <literal>not-null=\"true\"</literal> en el mapeo de la colecci&#x00f3;n:"

#: index.docbook:101
msgid ""
      "<![CDATA[<set name=\"children\">\n"
      "    <key column=\"parent_id\" not-null=\"true\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"children\">\n"
      "    <key column=\"parent_id\" not-null=\"true\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"

#: index.docbook:103
msgid "However, this is not the recommended solution."
msgstr "Sin embargo, esta no es la soluci&#x00f3;n recomendada."

#: index.docbook:106
msgid "The underlying cause of this behaviour is that the link (the foreign key <literal>parent_id</literal>) from <literal>p</literal> to <literal>c</literal> is not considered part of the state of the <literal>Child</literal> object and is therefore not created in the <literal>INSERT</literal>. So the solution is to make the link part of the <literal>Child</literal> mapping."
msgstr "El caso subyacente de este comportamiento es que el enlace (la clave for&#x00e1;nea <literal>parent_id</literal>) de <literal>p</literal> a <literal>c</literal> no es considerado parte del estado del objeto <literal>Child</literal> y por lo tanto no es creada en el <literal>INSERT</literal>. De modo que la soluci&#x00f3;n es hacer el enlace parte del mapeo del <literal>Child</literal>."

#: index.docbook:113
msgid "<![CDATA[<many-to-one name=\"parent\" column=\"parent_id\" not-null=\"true\"/>]]>"
msgstr "<![CDATA[<many-to-one name=\"parent\" column=\"parent_id\" not-null=\"true\"/>]]>"

#: index.docbook:115
msgid "(We also need to add the <literal>parent</literal> property to the <literal>Child</literal> class.)"
msgstr "(Necesitamos adem&#x00e1;s a&#x00f1;adir la propiedad <literal>parent</literal> a la clase <literal>Child</literal>.)"

#: index.docbook:119
msgid "Now that the <literal>Child</literal> entity is managing the state of the link, we tell the collection not to update the link. We use the <literal>inverse</literal> attribute."
msgstr "Ahora que la entidad <literal>Child</literal> est&#x00e1; gestionando el estado del enlace, le decimos a la colecci&#x00f3;n que no actualice el enlace. Usamos el atributo <literal>inverse</literal>."

#: index.docbook:124
msgid ""
      "<![CDATA[<set name=\"children\" inverse=\"true\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"children\" inverse=\"true\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"

#: index.docbook:126
msgid "The following code would be used to add a new <literal>Child</literal>"
msgstr "El siguiente c&#x00f3;digo podr&#x00ed;a ser usado para a&#x00f1;adir un nuevo <literal>Child</literal>"

#: index.docbook:130
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "c.setParent(p);\n"
      "p.getChildren().add(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "c.setParent(p);\n"
      "p.getChildren().add(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"

#: index.docbook:132
msgid "And now, only one SQL <literal>INSERT</literal> would be issued!"
msgstr "Y ahora, &#x00a1;S&#x00f3;lo se publicar&#x00ed;a un <literal>INSERT</literal> de SQL!"

#: index.docbook:136
msgid "To tighten things up a bit, we could create an <literal>addChild()</literal> method of <literal>Parent</literal>."
msgstr "Para ajustar un poco m&#x00e1;s las cosas, podr&#x00ed;amos crear un m&#x00e9;todo <literal>addChild()</literal> en <literal>Parent</literal>."

#: index.docbook:141
msgid ""
      "<![CDATA[public void addChild(Child c) {\n"
      "    c.setParent(this);\n"
      "    children.add(c);\n"
      "}]]>"
msgstr ""
      "<![CDATA[public void addChild(Child c) {\n"
      "    c.setParent(this);\n"
      "    children.add(c);\n"
      "}]]>"

#: index.docbook:143
msgid "Now, the code to add a <literal>Child</literal> looks like"
msgstr "Ahora, el c&#x00f3;digo para a&#x00f1;adir un <literal>Child</literal> se ve as&#x00ed;"

#: index.docbook:147
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "p.addChild(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "p.addChild(c);\n"
      "session.save(c);\n"
      "session.flush();]]>"

#: index.docbook:152
msgid "Cascading life cycle"
msgstr "Ciclo de vida en cascada"

#: index.docbook:154
msgid "The explicit call to <literal>save()</literal> is still annoying. We will address this by using cascades."
msgstr "La llamada expl&#x00ed;cita a <literal>save()</literal> es a&#x00fa;n molesta. Apuntaremos a esto usando tratamientos en cascada."

#: index.docbook:159
msgid ""
      "<![CDATA[<set name=\"children\" inverse=\"true\" cascade=\"all\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"children\" inverse=\"true\" cascade=\"all\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"

#: index.docbook:161
msgid "This simplifies the code above to"
msgstr "Esto simplifica el c&#x00f3;digo anterior a"

#: index.docbook:165
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "p.addChild(c);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = new Child();\n"
      "p.addChild(c);\n"
      "session.flush();]]>"

#: index.docbook:167
msgid "Similarly, we don't need to iterate over the children when saving or deleting a <literal>Parent</literal>. The following removes <literal>p</literal> and all its children from the database."
msgstr "Similarmente, no necesitamos iterar los hijos al salvar o borrar un <literal>Parent</literal>. Lo siguiente quita <literal>p</literal> y todos sus hijos de la base de datos."

#: index.docbook:172
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "session.delete(p);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "session.delete(p);\n"
      "session.flush();]]>"

#: index.docbook:174
msgid "However, this code"
msgstr "Sin embargo, este c&#x00f3;digo"

#: index.docbook:178
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = (Child) p.getChildren().iterator().next();\n"
      "p.getChildren().remove(c);\n"
      "c.setParent(null);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = (Child) p.getChildren().iterator().next();\n"
      "p.getChildren().remove(c);\n"
      "c.setParent(null);\n"
      "session.flush();]]>"

#: index.docbook:180
msgid "will not remove <literal>c</literal> from the database; it will ony remove the link to <literal>p</literal> (and cause a <literal>NOT NULL</literal> constraint violation, in this case). You need to explicitly <literal>delete()</literal> the <literal>Child</literal>."
msgstr "no quitar&#x00e1; <literal>c</literal> de la base de datos; s&#x00f3;lo quitar&#x00e1; el enlace a <literal>p</literal> (y causar&#x00e1; una violaci&#x00f3;n a una restricci&#x00f3;n <literal>NOT NULL</literal>). Necesitas borrar el hijo expl&#x00ed;citamente llamando a <literal>delete()</literal>."

#: index.docbook:186
msgid ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = (Child) p.getChildren().iterator().next();\n"
      "p.getChildren().remove(c);\n"
      "session.delete(c);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[Parent p = (Parent) session.load(Parent.class, pid);\n"
      "Child c = (Child) p.getChildren().iterator().next();\n"
      "p.getChildren().remove(c);\n"
      "session.delete(c);\n"
      "session.flush();]]>"

#: index.docbook:188
msgid "Now, in our case, a <literal>Child</literal> can't really exist without its parent. So if we remove a <literal>Child</literal> from the collection, we really do want it to be deleted. For this, we must use <literal>cascade=\"all-delete-orphan\"</literal>."
msgstr "Ahora, en nuestro caso, un <literal>Child</literal> no puede existir realmente sin su padre. De modo que si quitamos un <literal>Child</literal> de la colecci&#x00f3;n, realmente queremos que sea borrado. Para esto, debemos usar <literal>cascade=\"all-delete-orphan\"</literal>."

#: index.docbook:194
msgid ""
      "<![CDATA[<set name=\"children\" inverse=\"true\" cascade=\"all-delete-orphan\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"
msgstr ""
      "<![CDATA[<set name=\"children\" inverse=\"true\" cascade=\"all-delete-orphan\">\n"
      "    <key column=\"parent_id\"/>\n"
      "    <one-to-many class=\"Child\"/>\n"
      "</set>]]>"

#: index.docbook:196
msgid "Note: even though the collection mapping specifies <literal>inverse=\"true\"</literal>, cascades are still processed by iterating the collection elements. So if you require that an object be saved, deleted or updated by cascade, you must add it to the collection. It is not enough to simply call <literal>setParent()</literal>."
msgstr "Nota: aunque el mapeo de la colecci&#x00f3;n especifique <literal>inverse=\"true\"</literal>, el tratamiento en cascada se procesa a&#x00fa;n al iterar los elementos de colecci&#x00f3;n. De modo que si requieres que un objeto sea salvado, borrado o actualizado en cascada, debes a&#x00f1;adirlo a la colecci&#x00f3;n. No es suficiente con simplemente llamar a <literal>setParent()</literal>."

#: index.docbook:206
msgid "Cascades and <literal>unsaved-value</literal>"
msgstr "Tratamiento en cascada y <literal>unsaved-value</literal>"

#: index.docbook:208
msgid "Suppose we loaded up a <literal>Parent</literal> in one <literal>Session</literal>, made some changes in a UI action and wish to persist these changes in a new session by calling <literal>update()</literal>. The <literal>Parent</literal> will contain a collection of childen and, since cascading update is enabled, Hibernate needs to know which children are newly instantiated and which represent existing rows in the database. Lets assume that both <literal>Parent</literal> and <literal>Child</literal> have genenerated identifier properties of type <literal>Long</literal>. Hibernate will use the identifier and version/timestamp property value to determine which of the children are new. (See <xref linkend=\"objectstate-saveorupdate\"/>.) <emphasis>In Hibernate3, it is no longer necessary to specify an <literal>unsaved-value</literal> explicitly.</emphasis>"
msgstr "Sup&#x00f3;n que hemos cargado un <literal>Parent</literal> en una <literal>Session</literal>, hemos hecho algunos cambios en una acci&#x00f3;n de UI y deseamos hacer persistentes estos cambios en una nueva sesi&#x00f3;n llamando a <literal>update()</literal>. El <literal>Parent</literal> contendr&#x00e1; una colecci&#x00f3;n de hijos y, ya que est&#x00e1; habilitado el tratamiento en cascada, Hibernate necesita saber qu&#x00e9; hijos est&#x00e1;n reci&#x00e9;n instanciados y cu&#x00e1;les representan filas existentes en la base de datos. Asumamos que tanto <literal>Parent</literal> como <literal>Child</literal> tienen propiedades identificadoras generadas de tipo <literal>Long</literal>. Hibernate usar&#x00e1; el identificador y el valor de la propiedad de versi&#x00f3;n/timestamp para determinar cu&#x00e1;les de los hijos son nuevos. (Ver <xref linkend=\"objectstate-saveorupdate\"/>.) <emphasis>En Hibernate3, no es m&#x00e1;s necesario especificar un <literal>unsaved-value</literal> expl&#x00ed;citamente.</emphasis>"

#: index.docbook:220
msgid "The following code will update <literal>parent</literal> and <literal>child</literal> and insert <literal>newChild</literal>."
msgstr "The following code will update <literal>parent</literal> and <literal>child</literal> and insert <literal>newChild</literal>."

#: index.docbook:225
msgid ""
      "<![CDATA[//parent and child were both loaded in a previous session\n"
      "parent.addChild(child);\n"
      "Child newChild = new Child();\n"
      "parent.addChild(newChild);\n"
      "session.update(parent);\n"
      "session.flush();]]>"
msgstr ""
      "<![CDATA[//parent and child were both loaded in a previous session\n"
      "parent.addChild(child);\n"
      "Child newChild = new Child();\n"
      "parent.addChild(newChild);\n"
      "session.update(parent);\n"
      "session.flush();]]>"

#: index.docbook:227
msgid "Well, that's all very well for the case of a generated identifier, but what about assigned identifiers and composite identifiers? This is more difficult, since Hibernate can't use the identifier property to distinguish between a newly instantiated object (with an identifier assigned by the user) and an object loaded in a previous session. In this case, Hibernate will either use the timestamp or version property, or will actually query the second-level cache or, worst case, the database, to see if the row exists."
msgstr "Bueno, todo eso est&#x00e1; muy bien para el caso de un identificador generado, pero &#x00bf;qu&#x00e9; de los identificadores asignados y de los identificadores compuestos? Esto es m&#x00e1;s dif&#x00ed;cil, ya que Hibernate no puede usar la propiedad identificadora para distinguir entre un objeto reci&#x00e9;n instanciado (con un identificador asignado por el usuario) y un objeto cargado en una sesi&#x00f3;n previa. En este caso, Hibernate bien usar&#x00e1; la propiedad de versi&#x00f3;n o timestamp, o bien consultar&#x00e1; realmente el cach&#x00e9; de segundo nivel, o bien, en el peor de los casos, la base de datos, para ver si existe la fila."

#: index.docbook:260
msgid "Conclusion"
msgstr "Conclusi&#x00f3;n"

#: index.docbook:262
msgid "There is quite a bit to digest here and it might look confusing first time around. However, in practice, it all works out very nicely. Most Hibernate applications use the parent / child pattern in many places."
msgstr "Hay que resumir un poco aqu&#x00ed; y podr&#x00ed;a parecer confuso a la primera vez. Sin embargo, en la pr&#x00e1;ctica, todo funciona muy agradablemente. La mayor&#x00ed;a de las aplicaciones de Hibernate usan el patr&#x00f3;n padre / hijo en muchos sitios."

#: index.docbook:267
msgid "We mentioned an alternative in the first paragraph. None of the above issues exist in the case of <literal>&lt;composite-element&gt;</literal> mappings, which have exactly the semantics of a parent / child relationship. Unfortunately, there are two big limitations to composite element classes: composite elements may not own collections, and they should not be the child of any entity other than the unique parent."
msgstr "Hemos mencionado una alternativa en el primer p&#x00e1;rrafo. Ninguno de los temas anteriores existe en el caso de los mapeos <literal>&lt;composite-element&gt;</literal>, que tienen exactamente la sem&#x00e1;ntica de una relaci&#x00f3;n padre / hijo. Desafortunadamente, hay dos grandes limitaciones para las clases de elementos compuestos: los elementos compuestos no pueden poseer sus propias colecciones, y no deben ser el hijo de cualquier otra entidad que no sea su padre &#x00fa;nico."

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

