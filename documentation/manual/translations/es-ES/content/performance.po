#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Improving performance"
msgstr "Mejorando el rendimiento"

#: index.docbook:8
msgid "Fetching strategies"
msgstr "Estrategias de recuperaci&#x00f3;n"

#: index.docbook:10
msgid "A <emphasis>fetching strategy</emphasis> is the strategy Hibernate will use for retrieving associated objects if the application needs to navigate the association. Fetch strategies may be declared in the O/R mapping metadata, or over-ridden by a particular HQL or <literal>Criteria</literal> query."
msgstr "Una <emphasis>estrategia de recuperaci&#x00f3;n</emphasis> es la estrategia que usar&#x00e1; Hibernate para recuperar los objetos asociados cuando la aplicaci&#x00f3;n necesite navegar la asociaci&#x00f3;n. Las estrategias de recuperaci&#x00f3;n pueden ser declaradas en los metadatos de mapeo O/R, o sobrescritas por una consulta HQL o <literal>Criteria</literal> en particular."

#: index.docbook:17
msgid "Hibernate3 defines the following fetching strategies:"
msgstr "Hibernate3 define las siguientes estrategias de recuperaci&#x00f3;n:"

#: index.docbook:23
msgid "<emphasis>Join fetching</emphasis> - Hibernate retrieves the associated instance or collection in the same <literal>SELECT</literal>, using an <literal>OUTER JOIN</literal>."
msgstr "<emphasis>Recuperaci&#x00f3;n por uni&#x00f3;n (join fetching)</emphasis> - Hibernate recupera la instancia asociada o colecci&#x00f3;n en la misma <literal>SELECT</literal>, usando una <literal>OUTER JOIN</literal>."

#: index.docbook:30
msgid "<emphasis>Select fetching</emphasis> - a second <literal>SELECT</literal> is used to retrieve the associated entity or collection. Unless you explicitly disable lazy fetching by specifying <literal>lazy=\"false\"</literal>, this second select will only be executed when you actually access the association."
msgstr "<emphasis>Recuperaci&#x00f3;n por selecci&#x00f3;n (select fetching)</emphasis> - se usa una segunda <literal>SELECT</literal> para recuperar la entidad asociada o colecci&#x00f3;n. A menos que deshabilites expl&#x00ed;citamente la recuperaci&#x00f3;n perezosa especificando <literal>lazy=\"false\"</literal>, la segunda selecci&#x00f3;n s&#x00f3;lo ser&#x00e1; ejecutada cuando realmente accedas a la asociaci&#x00f3;n."

#: index.docbook:39
msgid "<emphasis>Subselect fetching</emphasis> - a second <literal>SELECT</literal> is used to retrieve the associated collections for all entities retrieved in a previous query or fetch. Unless you explicitly disable lazy fetching by specifying <literal>lazy=\"false\"</literal>, this second select will only be executed when you actually access the association."
msgstr "<emphasis>Recuperaci&#x00f3;n por subselecci&#x00f3;n (subselect fetching)</emphasis> - se usa una segunda <literal>SELECT</literal> para recuperar las colecciones asociadas de todas las entidades recuperadas en una consulta o recuperaci&#x00f3;n previa. A menos que deshabilites expl&#x00ed;citamente la recuperaci&#x00f3;n perezosa especificando <literal>lazy=\"false\"</literal>, esta segunda selecci&#x00f3;n s&#x00f3;lo ser&#x00e1; ejecutada cuando realmente accedas a la asociaci&#x00f3;n."

#: index.docbook:48
msgid "<emphasis>Batch fetching</emphasis> - an optimization strategy for select fetching - Hibernate retrieves a batch of entity instances or collections in a single <literal>SELECT</literal>, by specifying a list of primary keys or foreign keys."
msgstr "<emphasis>Recuperaci&#x00f3;n en lote</emphasis> - una estrategia de optimizaci&#x00f3;n para la recuperaci&#x00f3;n por selecci&#x00f3;n - Hibernate recupera un lote de instancias de entidad o colecciones en una sola <literal>SELECT</literal>, especificando una lista de claves primarias o de claves for&#x00e1;neas."

#: index.docbook:57
msgid "Hibernate also distinguishes between:"
msgstr "Hibernate tambi&#x00e9;n distingue entre:"

#: index.docbook:63
msgid "<emphasis>Immediate fetching</emphasis> - an association, collection or attribute is fetched immediately, when the owner is loaded."
msgstr "<emphasis>Recuperaci&#x00f3;n inmediata</emphasis> - una asociaci&#x00f3;n, colecci&#x00f3;n o atributo es recuperado inmediatamente, cuando el due&#x00f1;o es cargado."

#: index.docbook:69
msgid "<emphasis>Lazy collection fetching</emphasis> - a collection is fetched when the application invokes an operation upon that collection. (This is the default for collections.)"
msgstr "<emphasis>Recuperaci&#x00f3;n perezosa de colecciones</emphasis> - se recupera una colecci&#x00f3;n cuando la aplicaci&#x00f3;n invoca una operaci&#x00f3;n sobre la colecci&#x00f3;n. (Esto es por defecto para las colecciones.)"

#: index.docbook:76
msgid "<emphasis>\"Extra-lazy\" collection fetching</emphasis> - individual elements of the collection are accessed from the database as needed. Hibernate tries not to fetch the whole collection into memory unless absolutely needed (suitable for very large collections)"
msgstr "<emphasis>Recuperaci&#x00f3;n por proxy</emphasis> - se recupera una asociaci&#x00f3;n monovaluada cuando se invoca un m&#x00e9;todo que no sea el getter del identificador sobre el objeto asociado."

#: index.docbook:84
msgid "<emphasis>Proxy fetching</emphasis> - a single-valued association is fetched when a method other than the identifier getter is invoked upon the associated object."
msgstr "<emphasis>Recuperaci&#x00f3;n perezosa de atributos</emphasis> - se recupera un atributo o una asociaci&#x00f3;n monovaluada cuando se accede a la variable de instancia (requiere instrumentaci&#x00f3;n del bytecode en tiempo de ejecuci&#x00f3;n). Este enfoque es raramente necesario."

#: index.docbook:91
msgid "<emphasis>\"No-proxy\" fetching</emphasis> - a single-valued association is fetched when the instance variable is accessed. Compared to proxy fetching, this approach is less lazy (the association is fetched even when only the identifier is accessed) but more transparent, since no proxy is visible to the application. This approach requires buildtime bytecode instrumentation and is rarely necessary."
msgstr "Aqu&#x00ed; tenemos dos nociones ortogonales: <emphasis>cu&#x00e1;ndo</emphasis> se recupera la aplicaci&#x00f3;n, y <emphasis>c&#x00f3;mo</emphasis> es recuperada (qu&#x00e9; SQL es usado). &#x00a1;No las confundas! Usamos <literal>fetch</literal> para afinar el rendimiento. Podemos usar <literal>lazy</literal> para definir un contrato sobre qu&#x00e9; datos est&#x00e1;n siempre disponibles en cualquier instancia separada de una clase en particular."

#: index.docbook:101
msgid "<emphasis>Lazy attribute fetching</emphasis> - an attribute or single valued association is fetched when the instance variable is accessed. This approach requires buildtime bytecode instrumentation and is rarely necessary."
msgstr "Trabajando con asociaciones perezosas"

#: index.docbook:110
msgid "We have two orthogonal notions here: <emphasis>when</emphasis> is the association fetched, and <emphasis>how</emphasis> is it fetched (what SQL is used). Don't confuse them! We use <literal>fetch</literal> to tune performance. We may use <literal>lazy</literal> to define a contract for what data is always available in any detached instance of a particular class."
msgstr "Por defecto, Hibernate3 usa una recuperaci&#x00f3;n perezosa por selecci&#x00f3;n para colecciones y una recuperaci&#x00f3;n por proxy perezosa para asociaciones monovaluadas. Estas pol&#x00ed;ticas por defecto tienen sentido para casi todas las asociaciones en casi todas las aplicaciones."

#: index.docbook:119
msgid "Working with lazy associations"
msgstr "<emphasis>Nota:</emphasis> si estableces <literal>hibernate.default_batch_fetch_size</literal>, Hibernate usar&#x00e1; la optimizaci&#x00f3;n de recuperaci&#x00f3;n en lotes para recuperaci&#x00f3;n perezosa (esta optimizaci&#x00f3;n tambi&#x00e9;n puede ser habilitada a un nivel m&#x00e1;s granularizado)."

#: index.docbook:121
msgid "By default, Hibernate3 uses lazy select fetching for collections and lazy proxy fetching for single-valued associations. These defaults make sense for almost all associations in almost all applications."
msgstr "Sin embargo, la recuperaci&#x00f3;n perezosa plantea un problema del que tienes que estar al tanto. Acceder a una asociaci&#x00f3;n perezosa fuera del contexto de una sesi&#x00f3;n de Hibernate abierta resultar&#x00e1; en una excepci&#x00f3;n. Por ejemplo:"

#: index.docbook:127
msgid "<emphasis>Note:</emphasis> if you set <literal>hibernate.default_batch_fetch_size</literal>, Hibernate will use the batch fetch optimization for lazy fetching (this optimization may also be enabled at a more granular level)."
msgstr ""
      "<![CDATA[s = sessions.openSession();\n"
      "Transaction tx = s.beginTransaction();\n"
      "            \n"
      "User u = (User) s.createQuery(\"from User u where u.name=:userName\")\n"
      "    .setString(\"userName\", userName).uniqueResult();\n"
      "Map permissions = u.getPermissions();\n"
      "\n"
      "tx.commit();\n"
      "s.close();\n"
      "\n"
      "Integer accessLevel = (Integer) permissions.get(\"accounts\");  // Error!]]>"

#: index.docbook:134
msgid "However, lazy fetching poses one problem that you must be aware of. Access to a lazy association outside of the context of an open Hibernate session will result in an exception. For example:"
msgstr "Ya que la colecci&#x00f3;n de permisos no fue inicializada cuando se cerr&#x00f3; la <literal>Session</literal>, la colecci&#x00f3;n no ser&#x00e1; capaz de cargar su estado. <emphasis>Hibernate no soporta la inicializaci&#x00f3;n perezosa de objetos separados</emphasis>. La soluci&#x00f3;n es mover el c&#x00f3;digo que lee de la colecci&#x00f3;n a justo antes que la transacci&#x00f3;n sea comprometida."

#: index.docbook:140
msgid ""
      "<![CDATA[s = sessions.openSession();\n"
      "Transaction tx = s.beginTransaction();\n"
      "            \n"
      "User u = (User) s.createQuery(\"from User u where u.name=:userName\")\n"
      "    .setString(\"userName\", userName).uniqueResult();\n"
      "Map permissions = u.getPermissions();\n"
      "\n"
      "tx.commit();\n"
      "s.close();\n"
      "\n"
      "Integer accessLevel = (Integer) permissions.get(\"accounts\");  // Error!]]>"
msgstr "Alternativamente, podr&#x00ed;amos usar una colecci&#x00f3;n no perezosa o asociaci&#x00f3;n, especificando <literal>lazy=\"false\"</literal> para el mapeo de asociaci&#x00f3;n. Sin embargo, est&#x00e1; pensado que la inicializaci&#x00f3;n perezosa sea usada para casi todas las colecciones y asociaciones. &#x00a1;Si defines demasiadas asociaciones no perezosas en tu modelo de objetos, Hibernate terminar&#x00e1; necesitando recuperar la base de datos entera en cada transacci&#x00f3;n!"

#: index.docbook:142
msgid "Since the permissions collection was not initialized when the <literal>Session</literal> was closed, the collection will not be able to load its state. <emphasis>Hibernate does not support lazy initialization for detached objects</emphasis>. The fix is to move the code that reads from the collection to just before the transaction is committed."
msgstr "Por otro lado, frecuentemente necesitamos elegir la recuperaci&#x00f3;n por uni&#x00f3;n (que es no perezosa por naturaleza) en vez de la recuperaci&#x00f3;n por selecci&#x00f3;n en una transacci&#x00f3;n en particular. Veremos ahora c&#x00f3;mo personalizar la estrategia de recuperaci&#x00f3;n. En Hibernate3, los mecanismos para elegir una estrategia de recuperaci&#x00f3;n son id&#x00e9;nticas a las de las asociaciones monovaluadas y colecciones."

#: index.docbook:150
msgid "Alternatively, we could use a non-lazy collection or association, by specifying <literal>lazy=\"false\"</literal> for the association mapping. However, it is intended that lazy initialization be used for almost all collections and associations. If you define too many non-lazy associations in your object model, Hibernate will end up needing to fetch the entire database into memory in every transaction!"
msgstr "Afinando las estrategias de recuperaci&#x00f3;n"

#: index.docbook:159
msgid "On the other hand, we often want to choose join fetching (which is non-lazy by nature) instead of select fetching in a particular transaction. We'll now see how to customize the fetching strategy. In Hibernate3, the mechanisms for choosing a fetch strategy are identical for single-valued associations and collections."
msgstr "La recuperaci&#x00f3;n por selecci&#x00f3;n (la preestablecida) es extremadamente vulnerable a problemas de selecci&#x00f3;n N+1, de modo querr&#x00ed;amos habilitar la recuperaci&#x00f3;n por uni&#x00f3;n (join fetching) en el documento de mapeo:"

#: index.docbook:170
msgid "Tuning fetch strategies"
msgstr ""
      "<![CDATA[<set name=\"permissions\" \n"
      "            fetch=\"join\">\n"
      "    <key column=\"userId\"/>\n"
      "    <one-to-many class=\"Permission\"/>\n"
      "</set]]>"

#: index.docbook:172
msgid "Select fetching (the default) is extremely vulnerable to N+1 selects problems, so we might want to enable join fetching in the mapping document:"
msgstr "<![CDATA[<many-to-one name=\"mother\" class=\"Cat\" fetch=\"join\"/>]]>"

#: index.docbook:177
msgid ""
      "<![CDATA[<set name=\"permissions\" \n"
      "            fetch=\"join\">\n"
      "    <key column=\"userId\"/>\n"
      "    <one-to-many class=\"Permission\"/>\n"
      "</set]]>"
msgstr "La estrategia de recuperaci&#x00f3;n definida en el documento de mapeo afecta a:"

#: index.docbook:179
msgid "<![CDATA[<many-to-one name=\"mother\" class=\"Cat\" fetch=\"join\"/>]]>"
msgstr "las recuperaciones v&#x00ed;a <literal>get()</literal> o <literal>load()</literal>"

#: index.docbook:181
msgid "The <literal>fetch</literal> strategy defined in the mapping document affects:"
msgstr "las recuperaciones que ocurren impl&#x00ed;citamente cuando se navega una asociaci&#x00f3;n (recuperaci&#x00f3;n perezosa)"

#: index.docbook:187
msgid "retrieval via <literal>get()</literal> or <literal>load()</literal>"
msgstr "las consultas de <literal>Criteria</literal>"

#: index.docbook:192
msgid "retrieval that happens implicitly when an association is navigated"
msgstr "Usualmente, no usamos el documento de mapeo para personalizar la recuperaci&#x00f3;n. En cambio, mantenemos el comportamiento por defecto, y lo sobrescribimos para una transacci&#x00f3;n en particular, usando <literal>left join fetch</literal> en HQL. Esto le dice a Hibernate que recupere la asociaci&#x00f3;n tempranamente en la primera selecci&#x00f3;n, usando una uni&#x00f3;n externa. En la API de consulta de <literal>Criteria</literal>, usar&#x00ed;as <literal>setFetchMode(FetchMode.JOIN)</literal>."

#: index.docbook:197
msgid "<literal>Criteria</literal> queries"
msgstr "Si acaso lo deseases, podr&#x00ed;as cambiar la estrategia de recuperaci&#x00f3;n usada por <literal>get()</literal> or <literal>load()</literal>; simplemente usa una consulta <literal>Criteria</literal>, por ejemplo:"

#: index.docbook:202
msgid "HQL queries if <literal>subselect</literal> fetching is used"
msgstr ""
      "<![CDATA[User user = (User) session.createCriteria(User.class)\n"
      "                .setFetchMode(\"permissions\", FetchMode.JOIN)\n"
      "                .add( Restrictions.idEq(userId) )\n"
      "                .uniqueResult();]]>"

#: index.docbook:208
msgid "No matter what fetching strategy you use, the defined non-lazy graph is guaranteed to be loaded into memory. Note that this might result in several immediate selects being used to execute a particular HQL query."
msgstr "(Esto es el equivalente de Hibernate de lo que otras soluciones ORM llaman un \"plan de recuperaci&#x00f3;n\".)"

#: index.docbook:214
msgid "Usually, we don't use the mapping document to customize fetching. Instead, we keep the default behavior, and override it for a particular transaction, using <literal>left join fetch</literal> in HQL. This tells Hibernate to fetch the association eagerly in the first select, using an outer join. In the <literal>Criteria</literal> query API, you would use <literal>setFetchMode(FetchMode.JOIN)</literal>."
msgstr "Una forma completamente diferente de evitar problemas con selecciones N+1 es usar el cach&#x00e9; de segundo nivel."

#: index.docbook:223
msgid "If you ever feel like you wish you could change the fetching strategy used by <literal>get()</literal> or <literal>load()</literal>, simply use a <literal>Criteria</literal> query, for example:"
msgstr "Proxies de asociaciones de un solo extremo"

#: index.docbook:229
msgid ""
      "<![CDATA[User user = (User) session.createCriteria(User.class)\n"
      "                .setFetchMode(\"permissions\", FetchMode.JOIN)\n"
      "                .add( Restrictions.idEq(userId) )\n"
      "                .uniqueResult();]]>"
msgstr "La recuperaci&#x00f3;n perezosa de colecciones est&#x00e1; implementada usando la implementaci&#x00f3;n de colecciones persistentes propia de Hibernate. Sin embargo, se necesita un mecanismo diferente para un comportamiento perezoso en las asociaciones de un solo extremo. La entidad objetivo de la asociaci&#x00f3;n debe ser tratada con proxies. Hibernate implementa proxies de inicializaci&#x00f3;n perezosa para objetos persistentes usando mejora del bytecode en tiempo de ejecuci&#x00f3;n (por medio de la excelente biblioteca CGLIB)."

#: index.docbook:231
msgid "(This is Hibernate's equivalent of what some ORM solutions call a \"fetch plan\".)"
msgstr "Por defecto, Hibernate3 genera proxies (en el arranque) para todas las clases persistentes y los usa para habilitar la recuperaci&#x00f3;n perezosa de asociaciones <literal>muchos-a-uno</literal> y <literal>uno-a-uno</literal>."

#: index.docbook:235
msgid "A completely different way to avoid problems with N+1 selects is to use the second-level cache."
msgstr "El fichero de mapeo puede declarar una interface a usar como interface de proxy para esa clase, con el atributo <literal>proxy</literal>. Por defecto, Hibernate usa una subclase de la clase. <emphasis>Nota que la clase tratada con proxies debe implementar un constructor por defecto con al menos visibilidad de paquete. &#x00a1;Recomendamos este constructor para todas las clases persistentes!</emphasis>"

#: index.docbook:243
msgid "Single-ended association proxies"
msgstr "Hay algunos puntos a tener en cuenta al extender este enfoque a clases polim&#x00f3;rficas, por ejemplo."

#: index.docbook:245
msgid "Lazy fetching for collections is implemented using Hibernate's own implementation of persistent collections. However, a different mechanism is needed for lazy behavior in single-ended associations. The target entity of the association must be proxied. Hibernate implements lazy initializing proxies for persistent objects using runtime bytecode enhancement (via the excellent CGLIB library)."
msgstr ""
      "<![CDATA[<class name=\"Cat\" proxy=\"Cat\">\n"
      "    ......\n"
      "    <subclass name=\"DomesticCat\">\n"
      "        .....\n"
      "    </subclass>\n"
      "</class>]]>"

#: index.docbook:253
msgid "By default, Hibernate3 generates proxies (at startup) for all persistent classes and uses them to enable lazy fetching of <literal>many-to-one</literal> and <literal>one-to-one</literal> associations."
msgstr "Primero, las instancias de <literal>Cat</literal> nunca ser&#x00e1;n objeto de un cast a <literal>DomesticCat</literal>, incluso aunque la instancia subyacente sea instancia de <literal>DomesticCat</literal>:"

#: index.docbook:259
msgid "The mapping file may declare an interface to use as the proxy interface for that class, with the <literal>proxy</literal> attribute. By default, Hibernate uses a subclass of the class. <emphasis>Note that the proxied class must implement a default constructor with at least package visibility. We recommend this constructor for all persistent classes!</emphasis>"
msgstr ""
      "<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)\n"
      "if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy\n"
      "    DomesticCat dc = (DomesticCat) cat;       // Error!\n"
      "    ....\n"
      "}]]>"

#: index.docbook:266
msgid "There are some gotchas to be aware of when extending this approach to polymorphic classes, eg."
msgstr "Segundo, es posible romper con el operador <literal>==</literal> de un proxy."

#: index.docbook:271
msgid ""
      "<![CDATA[<class name=\"Cat\" proxy=\"Cat\">\n"
      "    ......\n"
      "    <subclass name=\"DomesticCat\">\n"
      "        .....\n"
      "    </subclass>\n"
      "</class>]]>"
msgstr ""
      "<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy\n"
      "DomesticCat dc = \n"
      "        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!\n"
      "System.out.println(cat==dc);                            // false]]>"

#: index.docbook:273
msgid "Firstly, instances of <literal>Cat</literal> will never be castable to <literal>DomesticCat</literal>, even if the underlying instance is an instance of <literal>DomesticCat</literal>:"
msgstr "Sin embargo, la situaci&#x00f3;n no en absoluta tan mala como parece. Aunque tenemos ahora dos referencias a objetos proxy diferentes, la instancia subyacente ser&#x00e1; a&#x00fa;n el mismo objeto:"

#: index.docbook:279
msgid ""
      "<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);  // instantiate a proxy (does not hit the db)\n"
      "if ( cat.isDomesticCat() ) {                  // hit the db to initialize the proxy\n"
      "    DomesticCat dc = (DomesticCat) cat;       // Error!\n"
      "    ....\n"
      "}]]>"
msgstr ""
      "<![CDATA[cat.setWeight(11.0);  // hit the db to initialize the proxy\n"
      "System.out.println( dc.getWeight() );  // 11.0]]>"

#: index.docbook:281
msgid "Secondly, it is possible to break proxy <literal>==</literal>."
msgstr "Tercero, no debes usar un proxy CGLIB para una clase <literal>final</literal> o una clase con alg&#x00fa;n m&#x00e9;todo <literal>final</literal>."

#: index.docbook:285
msgid ""
      "<![CDATA[Cat cat = (Cat) session.load(Cat.class, id);            // instantiate a Cat proxy\n"
      "DomesticCat dc = \n"
      "        (DomesticCat) session.load(DomesticCat.class, id);  // acquire new DomesticCat proxy!\n"
      "System.out.println(cat==dc);                            // false]]>"
msgstr "Finalmente, si tu objeto persistente adquiere cualquier recurso bajo instanciaci&#x00f3;n (por ejemplo, en inicializadores o constructores por defecto), entonces esos recursos ser&#x00e1;n adquiridos tambi&#x00e9;n por el proxy. La clase del proxy es una subclase real de la clase persistente."

#: index.docbook:287
msgid "However, the situation is not quite as bad as it looks. Even though we now have two references to different proxy objects, the underlying instance will still be the same object:"
msgstr "Estos problemas se deben a limitaciones fundamentales en el modelo de herencia &#x00fa;nica de Java. Si deseas evitar estos problemas cada una de tus clases persistentes deben implementar una interface que declare sus m&#x00e9;todos de negocio. Debes especificar estas interfaces en el fichero de mapeo. Por ejemplo:"

#: index.docbook:292
msgid ""
      "<![CDATA[cat.setWeight(11.0);  // hit the db to initialize the proxy\n"
      "System.out.println( dc.getWeight() );  // 11.0]]>"
msgstr ""
      "<![CDATA[<class name=\"CatImpl\" proxy=\"Cat\">\n"
      "    ......\n"
      "    <subclass name=\"DomesticCatImpl\" proxy=\"DomesticCat\">\n"
      "        .....\n"
      "    </subclass>\n"
      "</class>]]>"

#: index.docbook:294
msgid "Third, you may not use a CGLIB proxy for a <literal>final</literal> class or a class with any <literal>final</literal> methods."
msgstr "donde <literal>CatImpl</literal> implementa la interface <literal>Cat</literal> y <literal>DomesticCatImpl</literal> implementa la interface <literal>DomesticCat</literal>. Entonces <literal>load()</literal> o <literal>iterate()</literal> pueden devolver instancias de <literal>Cat</literal> y <literal>DomesticCat</literal>. (Nota que <literal>list()</literal> usualmente no devuelve proxies.)"

#: index.docbook:299
msgid "Finally, if your persistent object acquires any resources upon instantiation (eg. in initializers or default constructor), then those resources will also be acquired by the proxy. The proxy class is an actual subclass of the persistent class."
msgstr ""
      "<![CDATA[Cat cat = (Cat) session.load(CatImpl.class, catid);\n"
      "Iterator iter = session.createQuery(\"from CatImpl as cat where cat.name='fritz'\").iterate();\n"
      "Cat fritz = (Cat) iter.next();]]>"

#: index.docbook:305
msgid "These problems are all due to fundamental limitations in Java's single inheritance model. If you wish to avoid these problems your persistent classes must each implement an interface that declares its business methods. You should specify these interfaces in the mapping file. eg."
msgstr "Las relaciones tambi&#x00e9;n son inicializadas perezosamente. Esto significa que debes declarar cualquier propiedad como de tipo <literal>Cat</literal>, no <literal>CatImpl</literal>."

#: index.docbook:311
msgid ""
      "<![CDATA[<class name=\"CatImpl\" proxy=\"Cat\">\n"
      "    ......\n"
      "    <subclass name=\"DomesticCatImpl\" proxy=\"DomesticCat\">\n"
      "        .....\n"
      "    </subclass>\n"
      "</class>]]>"
msgstr "Ciertas operaciones <emphasis>no</emphasis> requieren inicializaci&#x00f3;n de proxies."

#: index.docbook:313
msgid "where <literal>CatImpl</literal> implements the interface <literal>Cat</literal> and <literal>DomesticCatImpl</literal> implements the interface <literal>DomesticCat</literal>. Then proxies for instances of <literal>Cat</literal> and <literal>DomesticCat</literal> may be returned by <literal>load()</literal> or <literal>iterate()</literal>. (Note that <literal>list()</literal> does not usually return proxies.)"
msgstr "<literal>equals()</literal>, si la clase persistente no sobrescribe <literal>equals()</literal>"

#: index.docbook:321
msgid ""
      "<![CDATA[Cat cat = (Cat) session.load(CatImpl.class, catid);\n"
      "Iterator iter = session.createQuery(\"from CatImpl as cat where cat.name='fritz'\").iterate();\n"
      "Cat fritz = (Cat) iter.next();]]>"
msgstr "<literal>hashCode()</literal>, si la clase persistente no sobrescribe <literal>hashCode()</literal>"

#: index.docbook:323
msgid "Relationships are also lazily initialized. This means you must declare any properties to be of type <literal>Cat</literal>, not <literal>CatImpl</literal>."
msgstr "El m&#x00e9;todo getter del identificador"

#: index.docbook:328
msgid "Certain operations do <emphasis>not</emphasis> require proxy initialization"
msgstr "Hibernate detectar&#x00e1; las clase persistentes que sobrescriban <literal>equals()</literal> o <literal>hashCode()</literal>."

#: index.docbook:334
msgid "<literal>equals()</literal>, if the persistent class does not override <literal>equals()</literal>"
msgstr "Inicializando colecciones y proxies"

#: index.docbook:340
msgid "<literal>hashCode()</literal>, if the persistent class does not override <literal>hashCode()</literal>"
msgstr "Una <literal>LazyInitializationException</literal> ser&#x00e1; lanzada por Hibernate si una colecci&#x00f3;n o proxy sin inicializar es accedido fuera del &#x00e1;mbito de la <literal>Session</literal>, es decir, cuando la entidad que posee la colecci&#x00f3;n o que tiene la referencia al proxy est&#x00e9; en el estado separada."

#: index.docbook:346
msgid "The identifier getter method"
msgstr "A veces necesitamos asegurarnos que un proxy o colecci&#x00f3;n est&#x00e9; inicializado antes de cerrar la <literal>Session</literal>. Por supuesto, siempre podemos forzar la inicializaci&#x00f3;n llamando a <literal>cat.getSex()</literal> o <literal>cat.getKittens().size()</literal>, por ejemplo. Pero esto es confuso a lectores del c&#x00f3;digo y no es conveniente para c&#x00f3;digo gen&#x00e9;rico."

#: index.docbook:352
msgid "Hibernate will detect persistent classes that override <literal>equals()</literal> or <literal>hashCode()</literal>."
msgstr "Los m&#x00e9;todos est&#x00e1;ticos <literal>Hibernate.initialize()</literal> y <literal>Hibernate.isInitialized()</literal> proveen a la aplicaci&#x00f3;n de una forma conveniente de trabajar con colecciones o proxies inicializados perezosamente. <literal>Hibernate.initialize(cat)</literal> forzar&#x00e1; la inicializaci&#x00f3;n de un proxy, <literal>cat</literal>, en tanto su <literal>Session</literal> est&#x00e9; todav&#x00ed;a abierta. <literal>Hibernate.initialize( cat.getKittens() )</literal> tiene un efecto similar para la colecci&#x00f3;n de gatitos."

#: index.docbook:357
msgid "By choosing <literal>lazy=\"no-proxy\"</literal> instead of the default <literal>lazy=\"proxy\"</literal>, we can avoid the problems associated with typecasting. However, we will require buildtime bytecode instrumentation, and all operations will result in immediate proxy initialization."
msgstr "Otra opci&#x00f3;n es mantener la <literal>Session</literal> abierta hasta que todas las colecciones y proxies necesarios hayan sido cargados. En algunas arquitecturas de aplicaci&#x00f3;n, particularmente en aquellas donde el c&#x00f3;digo que accede a los datos usando Hibernate, y el c&#x00f3;digo que los usa est&#x00e1;n en capas de aplicaci&#x00f3;n diferentes o procesos f&#x00ed;sicos diferentes, puede ser un problema asegurar que la <literal>Session</literal> est&#x00e9; abierta cuando se inicializa una colecci&#x00f3;n. Existen dos formas b&#x00e1;sicas de tratar este tema:"

#: index.docbook:367
msgid "Initializing collections and proxies"
msgstr "En una aplicaci&#x00f3;n basada web, puede usarse un filtro de servlets para cerrar la <literal>Session</literal> s&#x00f3;lo bien al final de una petici&#x00f3;n de usuario, una vez que el rendering de la vista est&#x00e9; completa (el patr&#x00f3;n <emphasis>Sesi&#x00f3;n Abierta en Vista (Open Session in View)</emphasis>). Por supuesto, estos sitios requieren una fuerte demanda de correcci&#x00f3;n del manejo de excepciones de tu infraestructura de aplicaci&#x00f3;n. Es de una importancia vital que la <literal>Session</literal> est&#x00e9; cerrada y la transacci&#x00f3;n terminada antes de volver al usuario, incluso cuando ocurra una excepci&#x00f3;n durante el rendering de la p&#x00e1;gina. Para este enfoque, el filtro de servlet tiene que ser capaz de accceder la <literal>Session</literal>. Recomendamos que se use una variable <literal>ThreadLocal</literal> para tener la <literal>Session</literal> actual (ver el cap&#x00ed;tulo 1, <xref linkend=\"quickstart-playingwithcats\"/>, para una implementaci&#x00f3;n de ejemplo)."

#: index.docbook:369
msgid "A <literal>LazyInitializationException</literal> will be thrown by Hibernate if an uninitialized collection or proxy is accessed outside of the scope of the <literal>Session</literal>, ie. when the entity owning the collection or having the reference to the proxy is in the detached state."
msgstr "En una aplciaci&#x00f3;n con una grada de negocios separada, la l&#x00f3;gica de negocio debe \"preparar\" todas las colecciones que se vayan a necesitar por la grada web antes de volver. Esto significa que la grada de negocios debe cargar todos los datos y devolver a la grada de presentaci&#x00f3;n web todos los datos que se requieran para un caso de uso en particular ya inicializados. Usualmente, la aplicaci&#x00f3;n llama a <literal>Hibernate.initialize()</literal> para cada colecci&#x00f3;n que se necesitar&#x00e1; en la grada web (esta llamada debe ocurrir antes que la sesi&#x00f3;n sea cerrada) o recupera la colecci&#x00f3;n tempranamente usando una consulta de Hibernate con una cl&#x00e1;usula <literal>FETCH</literal> o una <literal>FetchMode.JOIN</literal> en <literal>Criteria</literal>. Esto es usualmente m&#x00e1;s f&#x00e1;cil si adoptas el patr&#x00f3;n <emphasis>Comando</emphasis> en vez de un <emphasis>Fachada de Sesi&#x00f3;n</emphasis>."

#: index.docbook:375
msgid "Sometimes we need to ensure that a proxy or collection is initialized before closing the <literal>Session</literal>. Of course, we can alway force initialization by calling <literal>cat.getSex()</literal> or <literal>cat.getKittens().size()</literal>, for example. But that is confusing to readers of the code and is not convenient for generic code."
msgstr "Puedes tambi&#x00e9;n adjuntar un objeto cargado previamente a una nueva <literal>Session</literal> con <literal>merge()</literal> o <literal>lock()</literal> antes de acceder a colecciones no inicializadas (u otros proxies). &#x00a1;No, Hibernate no, y ciertamente <emphasis>no debe</emphasis> hacer esto autom&#x00e1;ticamente, ya que introducir&#x00ed;a sem&#x00e1;nticas de transacci&#x00f3;n ad hoc!"

#: index.docbook:382
msgid "The static methods <literal>Hibernate.initialize()</literal> and <literal>Hibernate.isInitialized()</literal> provide the application with a convenient way of working with lazily initialized collections or proxies. <literal>Hibernate.initialize(cat)</literal> will force the initialization of a proxy, <literal>cat</literal>, as long as its <literal>Session</literal> is still open. <literal>Hibernate.initialize( cat.getKittens() )</literal> has a similar effect for the collection of kittens."
msgstr "A veces no quieres inicializar una colecci&#x00f3;n grande, pero necesitas a&#x00fa;n alguna informacion sobre ella (como su tama&#x00f1;o) o un subconjunto de los datos."

#: index.docbook:391
msgid "Another option is to keep the <literal>Session</literal> open until all needed collections and proxies have been loaded. In some application architectures, particularly where the code that accesses data using Hibernate, and the code that uses it are in different application layers or different physical processes, it can be a problem to ensure that the <literal>Session</literal> is open when a collection is initialized. There are two basic ways to deal with this issue:"
msgstr "Puedes usar un filtro de colecciones para obtener el tama&#x00f1;o de una colecci&#x00f3;n sin inicializarla:"

#: index.docbook:402
msgid "In a web-based application, a servlet filter can be used to close the <literal>Session</literal> only at the very end of a user request, once the rendering of the view is complete (the <emphasis>Open Session in View</emphasis> pattern). Of course, this places heavy demands on the correctness of the exception handling of your application infrastructure. It is vitally important that the <literal>Session</literal> is closed and the transaction ended before returning to the user, even when an exception occurs during rendering of the view. See the Hibernate Wiki for examples of this \"Open Session in View\" pattern."
msgstr "<![CDATA[( (Integer) s.createFilter( collection, \"select count(*)\" ).list().get(0) ).intValue()]]>"

#: index.docbook:415
msgid "In an application with a separate business tier, the business logic must \"prepare\" all collections that will be needed by the web tier before returning. This means that the business tier should load all the data and return all the data already initialized to the presentation/web tier that is required for a particular use case. Usually, the application calls <literal>Hibernate.initialize()</literal> for each collection that will be needed in the web tier (this call must occur before the session is closed) or retrieves the collection eagerly using a Hibernate query with a <literal>FETCH</literal> clause or a <literal>FetchMode.JOIN</literal> in <literal>Criteria</literal>. This is usually easier if you adopt the <emphasis>Command</emphasis> pattern instead of a <emphasis>Session Facade</emphasis>."
msgstr "El m&#x00e9;todo <literal>createFilter()</literal> se usa tambi&#x00e9;n para recuperar eficientemente subconjuntos de una colecci&#x00f3;n sin necesidad de inicializar toda la colecci&#x00f3;n:"

#: index.docbook:430
msgid "You may also attach a previously loaded object to a new <literal>Session</literal> with <literal>merge()</literal> or <literal>lock()</literal> before accessing uninitialized collections (or other proxies). No, Hibernate does not, and certainly <emphasis>should</emphasis> not do this automatically, since it would introduce ad hoc transaction semantics!"
msgstr "<![CDATA[s.createFilter( lazyCollection, \"\").setFirstResult(0).setMaxResults(10).list();]]>"

#: index.docbook:440
msgid "Sometimes you don't want to initialize a large collection, but still need some information about it (like its size) or a subset of the data."
msgstr "Usando recuperaci&#x00f3;n en lotes"

#: index.docbook:445
msgid "You can use a collection filter to get the size of a collection without initializing it:"
msgstr "Hibernate puede hacer un uso eficiente de la recuperaci&#x00f3;n en lotes, esto es, Hibernate puede cargar muchos proxies sin inicializar si se accede a un proxy (o colecciones). La recuperaci&#x00f3;n en lotes es una optimizaci&#x00f3;n de la estrategia de recuperaci&#x00f3;n por selecci&#x00f3;n perezosa. Hay dos formas en que puedes afinar la recuperaci&#x00f3;n en lotes: a nivel de la clase o de la colecci&#x00f3;n."

#: index.docbook:449
msgid "<![CDATA[( (Integer) s.createFilter( collection, \"select count(*)\" ).list().get(0) ).intValue()]]>"
msgstr "La recuperaci&#x00f3;n en lotes para clases/entidades es m&#x00e1;s f&#x00e1;cil de entender. Imagina que tienes la siguiente situaci&#x00f3;n en tiempo de ejecuci&#x00f3;n: Tienes 25 instancias de <literal>Cat</literal> cargadas en una <literal>Session</literal>, cada <literal>Cat</literal> tiene una referencia a su <literal>owner</literal>, una <literal>Person</literal>. La clase <literal>Person</literal> est&#x00e1; mapeada con un proxy, <literal>lazy=\"true\"</literal>. Si ahora iteras a trav&#x00e9;s de todos los gatos y llamas a <literal>getOwner()</literal> para cada uno, Hibernate por defecto ejecutar&#x00e1; 25 sentencias <literal>SELECT</literal> para traer los due&#x00f1;os tratados con proxies. Puedes afinar este comportamiento especificando un <literal>batch-size</literal> en el mapeo de <literal>Person</literal>:"

#: index.docbook:451
msgid "The <literal>createFilter()</literal> method is also used to efficiently retrieve subsets of a collection without needing to initialize the whole collection:"
msgstr "<![CDATA[<class name=\"Person\" batch-size=\"10\">...</class>]]>"

#: index.docbook:456
msgid "<![CDATA[s.createFilter( lazyCollection, \"\").setFirstResult(0).setMaxResults(10).list();]]>"
msgstr "Hibernate ahora ejecutar&#x00e1; s&#x00f3;lo tres consultas, el patr&#x00f3;n es 10, 10, 5."

#: index.docbook:461
msgid "Using batch fetching"
msgstr "Tambi&#x00e9;n puedes habilitar la recuperaci&#x00f3;n en lotes para colecciones. Por ejemplo, si cada <literal>Person</literal> tiene una colecci&#x00f3;n perezosa de <literal>Cat</literal>s, y hay 10 personas actualmente cargadas en la <literal>Session</literal>, iterar a trav&#x00e9;s de las 10 personas generar&#x00e1; 10 <literal>SELECT</literal>s, una para cada llamada a <literal>getCats()</literal>. Si habilitas la recuperaci&#x00f3;n en lotes para la colecci&#x00f3;n de <literal>cats</literal> en el mapeo de <literal>Person</literal>, Hibernate puede recuperar por adelantado las colecciones:"

#: index.docbook:463
msgid "Hibernate can make efficient use of batch fetching, that is, Hibernate can load several uninitialized proxies if one proxy is accessed (or collections. Batch fetching is an optimization of the lazy select fetching strategy. There are two ways you can tune batch fetching: on the class and the collection level."
msgstr ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <set name=\"cats\" batch-size=\"3\">\n"
      "        ...\n"
      "    </set>\n"
      "</class>]]>"

#: index.docbook:469
msgid "Batch fetching for classes/entities is easier to understand. Imagine you have the following situation at runtime: You have 25 <literal>Cat</literal> instances loaded in a <literal>Session</literal>, each <literal>Cat</literal> has a reference to its <literal>owner</literal>, a <literal>Person</literal>. The <literal>Person</literal> class is mapped with a proxy, <literal>lazy=\"true\"</literal>. If you now iterate through all cats and call <literal>getOwner()</literal> on each, Hibernate will by default execute 25 <literal>SELECT</literal> statements, to retrieve the proxied owners. You can tune this behavior by specifying a <literal>batch-size</literal> in the mapping of <literal>Person</literal>:"
msgstr "Con un <literal>batch-size</literal> de 3, Hibernate cargar&#x00e1; 3, 3, 3, 1 colecciones en cuatro <literal>SELECT</literal>s. Una vez m&#x00e1;s, el valor del atributo depende del n&#x00fa;mero esperado de colecciones sin inicializar en una <literal>Session</literal> en particular."

#: index.docbook:479
msgid "<![CDATA[<class name=\"Person\" batch-size=\"10\">...</class>]]>"
msgstr "La recuperaci&#x00f3;n de coleccione en lotes es particularmente &#x00fa;til si tienes un &#x00e1;rbol anidado de &#x00ed;tems, es decir, el t&#x00ed;pico patr&#x00f3;n de cuenta de materiales. (Aunque un <emphasis>conjunto anidado</emphasis> o una <emphasis>ruta materializada</emphasis> podr&#x00ed;a ser una mejor opci&#x00f3;n para &#x00e1;rboles que sean de lectura en la mayor&#x00ed;a de los casos.)"

#: index.docbook:481
msgid "Hibernate will now execute only three queries, the pattern is 10, 10, 5."
msgstr "Usando recuperaci&#x00f3;n por subselecci&#x00f3;n"

#: index.docbook:485
msgid "You may also enable batch fetching of collections. For example, if each <literal>Person</literal> has a lazy collection of <literal>Cat</literal>s, and 10 persons are currently loaded in the <literal>Sesssion</literal>, iterating through all persons will generate 10 <literal>SELECT</literal>s, one for every call to <literal>getCats()</literal>. If you enable batch fetching for the <literal>cats</literal> collection in the mapping of <literal>Person</literal>, Hibernate can pre-fetch collections:"
msgstr "Si una colecci&#x00f3;n perezosa o proxy monovaluado tiene que ser recuperado, Hibernate los carga a todos, volviendo a ejecutar la consulta original en una subselecci&#x00f3;n. Esto funciona de la misma forma que la recuperaci&#x00f3;n en lotes, sin carga fragmentaria."

#: index.docbook:494
msgid ""
      "<![CDATA[<class name=\"Person\">\n"
      "    <set name=\"cats\" batch-size=\"3\">\n"
      "        ...\n"
      "    </set>\n"
      "</class>]]>"
msgstr "Usando recuperaci&#x00f3;n perezosa de propiedades"

#: index.docbook:496
msgid "With a <literal>batch-size</literal> of 3, Hibernate will load 3, 3, 3, 1 collections in four <literal>SELECT</literal>s. Again, the value of the attribute depends on the expected number of uninitialized collections in a particular <literal>Session</literal>."
msgstr "Hibernate3 soporta la recuperaci&#x00f3;n perezosa de propiedades individuales. Esta t&#x00e9;cnica de optimizaci&#x00f3;n es tambi&#x00e9;n conocida como <emphasis>grupos de recuperaci&#x00f3;n (fetch groups)</emphasis>. Por favor, nota que &#x00e9;ste es mayormente un aspecto de marketing, ya que en la pr&#x00e1;ctica, optimizar lecturas de filas es mucho m&#x00e1;s importante que la optimizaci&#x00f3;n de lectura de columnas. Sin embargo, cargar s&#x00f3;lo algunas propiedades de una clase podr&#x00ed;a ser &#x00fa;til en casos extremos, cuando tablas heredadas tienen cientos de columnas y el modelo de datos no puede ser mejorado."

#: index.docbook:502
msgid "Batch fetching of collections is particularly useful if you have a nested tree of items, ie. the typical bill-of-materials pattern. (Although a <emphasis>nested set</emphasis> or a <emphasis>materialized path</emphasis> might be a better option for read-mostly trees.)"
msgstr "Para habilitar la carga perezosa de propiedades, establece el atributo <literal>lazy</literal> en tus mapeos de propiedades:"

#: index.docbook:511
msgid "Using subselect fetching"
msgstr ""
      "<![CDATA[<class name=\"Document\">\n"
      "       <id name=\"id\">\n"
      "        <generator class=\"native\"/>\n"
      "    </id>\n"
      "    <property name=\"name\" not-null=\"true\" length=\"50\"/>\n"
      "    <property name=\"summary\" not-null=\"true\" length=\"200\" lazy=\"true\"/>\n"
      "    <property name=\"text\" not-null=\"true\" length=\"2000\" lazy=\"true\"/>\n"
      "</class>]]>"

#: index.docbook:513
msgid "If one lazy collection or single-valued proxy has to be fetched, Hibernate loads all of them, re-running the original query in a subselect. This works in the same way as batch-fetching, without the piecemeal loading."
msgstr "&#x00a1;La carga perezosa de propiedades requiere la instrumentaci&#x00f3;n del bytecode en tiempo de construcci&#x00f3;n! Si tus clases persistentes no son mejoradas, Hibernate ignorar&#x00e1; silenciosamente la configuraci&#x00f3;n perezosa de propiedades y caer&#x00e1; en recuperaci&#x00f3;n inmediata."

#: index.docbook:524
msgid "Using lazy property fetching"
msgstr "Para la instrumentaci&#x00f3;n del bytecode, usa la siguiente tarea Ant:"

#: index.docbook:526
msgid "Hibernate3 supports the lazy fetching of individual properties. This optimization technique is also known as <emphasis>fetch groups</emphasis>. Please note that this is mostly a marketing feature, as in practice, optimizing row reads is much more important than optimization of column reads. However, only loading some properties of a class might be useful in extreme cases, when legacy tables have hundreds of columns and the data model can not be improved."
msgstr ""
      "<![CDATA[<target name=\"instrument\" depends=\"compile\">\n"
      "    <taskdef name=\"instrument\" classname=\"org.hibernate.tool.instrument.InstrumentTask\">\n"
      "        <classpath path=\"${jar.path}\"/>\n"
      "        <classpath path=\"${classes.dir}\"/>\n"
      "        <classpath refid=\"lib.class.path\"/>\n"
      "    </taskdef>\n"
      "\n"
      "    <instrument verbose=\"true\">\n"
      "        <fileset dir=\"${testclasses.dir}/org/hibernate/auction/model\">\n"
      "            <include name=\"*.class\"/>\n"
      "        </fileset>\n"
      "    </instrument>\n"
      "</target>]]>"

#: index.docbook:535
msgid "To enable lazy property loading, set the <literal>lazy</literal> attribute on your particular property mappings:"
msgstr "Una forma diferente (&#x00bf;mejor?) de evitar lecturas innecesarias de columnas, al menos para transacciones de s&#x00f3;lo lectura es usar las funcionalidades de proyecci&#x00f3;n de consultas HQL o Criteria. Esto evita la necesidad de procesar el bytecode en tiempo de construcci&#x00f3;n y ciertamente es una soluci&#x00f3;n preferida."

#: index.docbook:540
msgid ""
      "<![CDATA[<class name=\"Document\">\n"
      "       <id name=\"id\">\n"
      "        <generator class=\"native\"/>\n"
      "    </id>\n"
      "    <property name=\"name\" not-null=\"true\" length=\"50\"/>\n"
      "    <property name=\"summary\" not-null=\"true\" length=\"200\" lazy=\"true\"/>\n"
      "    <property name=\"text\" not-null=\"true\" length=\"2000\" lazy=\"true\"/>\n"
      "</class>]]>"
msgstr "Puedes forzar la usual recuperaci&#x00f3;n temprana de propiedades usando <literal>fetch all properties</literal> en HQL."

#: index.docbook:542
msgid "Lazy property loading requires buildtime bytecode instrumentation! If your persistent classes are not enhanced, Hibernate will silently ignore lazy property settings and fall back to immediate fetching."
msgstr "El Cach&#x00e9; de Segundo Nivel"

#: index.docbook:548
msgid "For bytecode instrumentation, use the following Ant task:"
msgstr "Una <literal>Session</literal> de Hibernate es una cach&#x00e9; de datos persistentes a nivel de transacci&#x00f3;n. Es posible configurar un cluster o cach&#x00e9; a nivel de JVM (a nivel de <literal>SessionFactory</literal>) sobre una base de clase-a-clase o colecci&#x00f3;n-a-colecci&#x00f3;n. Puedes incluso enchufar una cach&#x00e9; en cluster. S&#x00e9; cuidadoso. Las cach&#x00e9;s nunca est&#x00e1;n al tanto de los cambios hechos por otra aplicaci&#x00f3;n al almac&#x00e9;n persistente (aunque pueden ser configurados para expirar regularmente los datos en cach&#x00e9;)."

#: index.docbook:552
msgid ""
      "<![CDATA[<target name=\"instrument\" depends=\"compile\">\n"
      "    <taskdef name=\"instrument\" classname=\"org.hibernate.tool.instrument.InstrumentTask\">\n"
      "        <classpath path=\"${jar.path}\"/>\n"
      "        <classpath path=\"${classes.dir}\"/>\n"
      "        <classpath refid=\"lib.class.path\"/>\n"
      "    </taskdef>\n"
      "\n"
      "    <instrument verbose=\"true\">\n"
      "        <fileset dir=\"${testclasses.dir}/org/hibernate/auction/model\">\n"
      "            <include name=\"*.class\"/>\n"
      "        </fileset>\n"
      "    </instrument>\n"
      "</target>]]>"
msgstr "Por defecto, Hibernate usa EHCache para caching a nivel de JVM. (El soporte a JCS ahora est&#x00e1; despreciado y ser&#x00e1; quitado en una futura versi&#x00f3;n de Hibernate.) Puedes elegir una implementaci&#x00f3;n diferente estableciendo el nombre de una clase que implemente <literal>org.hibernate.cache.CacheProvider</literal> usando la propiedad <literal>hibernate.cache.provider_class</literal>."

#: index.docbook:554
msgid "A different (better?) way to avoid unnecessary column reads, at least for read-only transactions is to use the projection features of HQL or Criteria queries. This avoids the need for buildtime bytecode processing and is certainly a prefered solution."
msgstr "Proveedores de Cach&#x00e9;"

#: index.docbook:561
msgid "You may force the usual eager fetching of properties using <literal>fetch all properties</literal> in HQL."
msgstr "Cach&#x00e9;"

#: index.docbook:571
msgid "The Second Level Cache"
msgstr "clase del Provedor"

#: index.docbook:573
msgid "A Hibernate <literal>Session</literal> is a transaction-level cache of persistent data. It is possible to configure a cluster or JVM-level (<literal>SessionFactory</literal>-level) cache on a class-by-class and collection-by-collection basis. You may even plug in a clustered cache. Be careful. Caches are never aware of changes made to the persistent store by another application (though they may be configured to regularly expire cached data)."
msgstr "Tipo"

#: index.docbook:581
msgid "You have the option to tell Hibernate which caching implementation to use by specifying the name of a class that implements <literal>org.hibernate.cache.CacheProvider</literal> using the property <literal>hibernate.cache.provider_class</literal>. Hibernate comes bundled with a number of built-in integrations with open-source cache providers (listed below); additionally, you could implement your own and plug it in as outlined above. Note that versions prior to 3.2 defaulted to use EhCache as the default cache provider; that is no longer the case as of 3.2."
msgstr "Cluster Seguro"

#: index.docbook:592
msgid "Cache Providers"
msgstr "Cach&#x00e9; de Consultas Soportado"

#: index.docbook:601, index.docbook:774
msgid "Cache"
msgstr "Hashtable (no pensado para uso en producci&#x00f3;n)"

#: index.docbook:602
msgid "Provider class"
msgstr "org.hibernate.cache.HashtableCacheProvider"

#: index.docbook:603
msgid "Type"
msgstr "memoria"

#: index.docbook:604
msgid "Cluster Safe"
msgstr "s&#x00ed;"

#: index.docbook:605
msgid "Query Cache Supported"
msgstr "EHCache"

#: index.docbook:610, index.docbook:783
msgid "Hashtable (not intended for production use)"
msgstr "org.hibernate.cache.EhCacheProvider"

#: index.docbook:611
msgid "org.hibernate.cache.HashtableCacheProvider"
msgstr "memoria, disco"

#: index.docbook:612
msgid "memory"
msgstr "s&#x00ed;"

#: index.docbook:614, index.docbook:621, index.docbook:628, index.docbook:784, index.docbook:785, index.docbook:786, index.docbook:791, index.docbook:792, index.docbook:793, index.docbook:798, index.docbook:799, index.docbook:800, index.docbook:805, index.docbook:806, index.docbook:812, index.docbook:815
msgid "<entry>yes</entry>"
msgstr "OSCache"

#: index.docbook:617, index.docbook:790
msgid "EHCache"
msgstr "org.hibernate.cache.OSCacheProvider"

#: index.docbook:618
msgid "org.hibernate.cache.EhCacheProvider"
msgstr "memoria, disco"

#: index.docbook:619, index.docbook:626
msgid "memory, disk"
msgstr "s&#x00ed;"

#: index.docbook:624, index.docbook:797
msgid "OSCache"
msgstr "org.hibernate.cache.SwarmCacheProvider"

#: index.docbook:625
msgid "org.hibernate.cache.OSCacheProvider"
msgstr "clusterizado (ip multicast)"

#: index.docbook:631, index.docbook:804
msgid "SwarmCache"
msgstr "org.hibernate.cache.TreeCacheProvider"

#: index.docbook:632
msgid "org.hibernate.cache.SwarmCacheProvider"
msgstr "clusterizado (ip multicast), transaccional"

#: index.docbook:633
msgid "clustered (ip multicast)"
msgstr "s&#x00ed; (replicaci&#x00f3;n)"

#: index.docbook:634
msgid "yes (clustered invalidation)"
msgstr "s&#x00ed; (requiere sincronizaci&#x00f3;n de reloj)"

#: index.docbook:638, index.docbook:811
msgid "JBoss TreeCache"
msgstr "Mapeos de cach&#x00e9;"

#: index.docbook:639
msgid "org.hibernate.cache.TreeCacheProvider"
msgstr "El elemento <literal>&lt;cache&gt;</literal> de una mapeo de clase o colecci&#x00f3;n tiene la siguiente forma:"

#: index.docbook:640
msgid "clustered (ip multicast), transactional"
msgstr ""
      "<![CDATA[<cache \n"
      "    usage=\"transactional|read-write|nonstrict-read-write|read-only\"\n"
      "/>]]>"

#: index.docbook:641
msgid "yes (replication)"
msgstr "<literal>usage</literal> especifica la estrategia de caching: <literal>transactional</literal>, <literal>read-write</literal>, <literal>nonstrict-read-write</literal> o <literal>read-only</literal>"

#: index.docbook:642
msgid "yes (clock sync req.)"
msgstr "Alternativamente (&#x00bf;preferiblemente?), puedes especificar los elementos <literal>&lt;class-cache&gt;</literal> y <literal>&lt;collection-cache&gt;</literal> en <literal>hibernate.cfg.xml</literal>."

#: index.docbook:649
msgid "Cache mappings"
msgstr "El atributo <literal>usage</literal> especifica una <emphasis>estrategia de concurrencia al cach&#x00e9;</emphasis>."

#: index.docbook:651
msgid "The <literal>&lt;cache&gt;</literal> element of a class or collection mapping has the following form:"
msgstr "Estrategia: s&#x00f3;lo lectura (read only)"

#: index.docbook:662
msgid ""
      "<![CDATA[<cache \n"
      "    usage=\"transactional|read-write|nonstrict-read-write|read-only\"\n"
      "    region=\"RegionName\"\n"
      "    include=\"all|non-lazy\"\n"
      "/>]]>"
msgstr "Si tu aplicaci&#x00f3;n necesita leer pero nunca modificar las instancias de una clase persistente, puede usarse un cach&#x00e9; <literal>read-only</literal>. Esta es la mejor y m&#x00e1;s simple estrategia. Es incluso perfectamente segura de usar en un cluster."

#: index.docbook:665
msgid "<literal>usage</literal> (required) specifies the caching strategy: <literal>transactional</literal>, <literal>read-write</literal>, <literal>nonstrict-read-write</literal> or <literal>read-only</literal>"
msgstr ""
      "<![CDATA[<class name=\"eg.Immutable\" mutable=\"false\">\n"
      "    <cache usage=\"read-only\"/>\n"
      "    ....\n"
      "</class>]]>"

#: index.docbook:674
msgid "<literal>region</literal> (optional, defaults to the class or collection role name) specifies the name of the second level cache region"
msgstr "Estrategia: lectura/escritura (read/write)"

#: index.docbook:681
msgid "<literal>include</literal> (optional, defaults to <literal>all</literal>) <literal>non-lazy</literal> specifies that properties of the entity mapped with <literal>lazy=\"true\"</literal> may not be cached when attribute-level lazy fetching is enabled"
msgstr "Si la aplicaci&#x00f3;n necesita actualizar datos, un cach&#x00e9; <literal>read-write</literal> podr&#x00ed;a ser apropiado. Esta estrategia de cach&#x00e9; nunca debe ser usada si se requiere nivel de aislamiento serializable de transacciones. Si el cach&#x00e9; es usado en un entorno JTA, debes especificar la propiedad <literal>hibernate.transaction.manager_lookup_class</literal>, mencionando una estrategia para obtener el <literal>TransactionManager</literal> de JTA. En otros entornos, debes asegurarte que la transacci&#x00f3;n est&#x00e9; completada cuando se llame a <literal>Session.close()</literal> o <literal>Session.disconnect()</literal>. Si deseas usar esta estrategia en un cluster, debes asegurarte que la implementaci&#x00f3;n de cach&#x00e9; subyacente soporta bloqueos. Los provedores de cach&#x00e9; internos predeterminados <emphasis>no</emphasis> no lo soportan."

#: index.docbook:691
msgid "Alternatively (preferrably?), you may specify <literal>&lt;class-cache&gt;</literal> and <literal>&lt;collection-cache&gt;</literal> elements in <literal>hibernate.cfg.xml</literal>."
msgstr ""
      "<![CDATA[<class name=\"eg.Cat\" .... >\n"
      "    <cache usage=\"read-write\"/>\n"
      "    ....\n"
      "    <set name=\"kittens\" ... >\n"
      "        <cache usage=\"read-write\"/>\n"
      "        ....\n"
      "    </set>\n"
      "</class>]]>"

#: index.docbook:696
msgid "The <literal>usage</literal> attribute specifies a <emphasis>cache concurrency strategy</emphasis>."
msgstr "Estrategia: lectura/escritura no estricta (nonstrict read/write)"

#: index.docbook:703
msgid "Strategy: read only"
msgstr "Si la aplicaci&#x00f3;n necesita s&#x00f3;lo ocasionalmente actualizar datos (es decir, es extremadamente inprobable que dos transacciones intenten actualizar el mismo &#x00ed;tem simult&#x00e1;neamente) y no se requiere de un aislamiento de transacciones estricto, un cach&#x00e9; <literal>nonstrict-read-write</literal> podr&#x00ed;a ser apropiado. Si se usa el cach&#x00e9; en un entorno JTA, debes especificar <literal>hibernate.transaction.manager_lookup_class</literal>. En otros entornos, debes asegurarte que la transacci&#x00f3;n se haya completado cuando se llame a <literal>Session.close()</literal> o <literal>Session.disconnect()</literal>."

#: index.docbook:705
msgid "If your application needs to read but never modify instances of a persistent class, a <literal>read-only</literal> cache may be used. This is the simplest and best performing strategy. It's even perfectly safe for use in a cluster."
msgstr "Estrategia: transaccional"

#: index.docbook:711
msgid ""
      "<![CDATA[<class name=\"eg.Immutable\" mutable=\"false\">\n"
      "    <cache usage=\"read-only\"/>\n"
      "    ....\n"
      "</class>]]>"
msgstr "La estrategia de cach&#x00e9; <literal>transactional</literal> brinda soporte a provedores de cach&#x00e9;s completamente transaccionales como TreeCache de JBoss. Un cach&#x00e9; as&#x00ed;, puede s&#x00f3;lo ser usado en un entorno JTA y debes especificar <literal>hibernate.transaction.manager_lookup_class</literal>."

#: index.docbook:717
msgid "Strategy: read/write"
msgstr "Ninguno de los provedores de cach&#x00e9; soporta todas las estrategias de concurrencia al cach&#x00e9;. La siguiente tabla muestra qu&#x00e9; provedores son compatibles con qu&#x00e9; estrategias de concurrencia."

#: index.docbook:719
msgid "If the application needs to update data, a <literal>read-write</literal> cache might be appropriate. This cache strategy should never be used if serializable transaction isolation level is required. If the cache is used in a JTA environment, you must specify the property <literal>hibernate.transaction.manager_lookup_class</literal>, naming a strategy for obtaining the JTA <literal>TransactionManager</literal>. In other environments, you should ensure that the transaction is completed when <literal>Session.close()</literal> or <literal>Session.disconnect()</literal> is called. If you wish to use this strategy in a cluster, you should ensure that the underlying cache implementation supports locking. The built-in cache providers do <emphasis>not</emphasis>."
msgstr "Soporte a Estrategia de Concurrencia a Cach&#x00e9;"

#: index.docbook:730
msgid ""
      "<![CDATA[<class name=\"eg.Cat\" .... >\n"
      "    <cache usage=\"read-write\"/>\n"
      "    ....\n"
      "    <set name=\"kittens\" ... >\n"
      "        <cache usage=\"read-write\"/>\n"
      "        ....\n"
      "    </set>\n"
      "</class>]]>"
msgstr "Cach&#x00e9;"

#: index.docbook:735
msgid "Strategy: nonstrict read/write"
msgstr "read-only"

#: index.docbook:737
msgid "If the application only occasionally needs to update data (ie. if it is extremely unlikely that two transactions would try to update the same item simultaneously) and strict transaction isolation is not required, a <literal>nonstrict-read-write</literal> cache might be appropriate. If the cache is used in a JTA environment, you must specify <literal>hibernate.transaction.manager_lookup_class</literal>. In other environments, you should ensure that the transaction is completed when <literal>Session.close()</literal> or <literal>Session.disconnect()</literal> is called."
msgstr "nonstrict-read-write"

#: index.docbook:749
msgid "Strategy: transactional"
msgstr "read-write"

#: index.docbook:751
msgid "The <literal>transactional</literal> cache strategy provides support for fully transactional cache providers such as JBoss TreeCache. Such a cache may only be used in a JTA environment and you must specify <literal>hibernate.transaction.manager_lookup_class</literal>."
msgstr "transactional"

#: index.docbook:759
msgid "None of the cache providers support all of the cache concurrency strategies. The following table shows which providers are compatible with which concurrency strategies."
msgstr "Hashtable (no pensado para uso en producci&#x00f3;n)"

#: index.docbook:765
msgid "Cache Concurrency Strategy Support"
msgstr "s&#x00ed;"

#: index.docbook:775
msgid "read-only"
msgstr "s&#x00ed;"

#: index.docbook:776
msgid "nonstrict-read-write"
msgstr "EHCache"

#: index.docbook:777
msgid "read-write"
msgstr "s&#x00ed;"

#: index.docbook:778
msgid "transactional"
msgstr "s&#x00ed;"

#: index.docbook:824
msgid "Managing the caches"
msgstr ""
      "<![CDATA[sessionFactory.evict(Cat.class, catId); //evict a particular Cat\n"
      "sessionFactory.evict(Cat.class);  //evict all Cats\n"
      "sessionFactory.evictCollection(\"Cat.kittens\", catId); //evict a particular collection of kittens\n"
      "sessionFactory.evictCollection(\"Cat.kittens\"); //evict all kitten collections]]>"

#: index.docbook:826
msgid "Whenever you pass an object to <literal>save()</literal>, <literal>update()</literal> or <literal>saveOrUpdate()</literal> and whenever you retrieve an object using <literal>load()</literal>, <literal>get()</literal>, <literal>list()</literal>, <literal>iterate()</literal> or <literal>scroll()</literal>, that object is added to the internal cache of the <literal>Session</literal>."
msgstr "El <literal>CacheMode</literal> controla c&#x00f3;mo una sesi&#x00f3;n en particular interact&#x00fa;a con el cach&#x00e9; de segundo nivel."

#: index.docbook:833
msgid "When <literal>flush()</literal> is subsequently called, the state of that object will be synchronized with the database. If you do not want this synchronization to occur or if you are processing a huge number of objects and need to manage memory efficiently, the <literal>evict()</literal> method may be used to remove the object and its collections from the first-level cache."
msgstr "<literal>CacheMode.NORMAL</literal> - lee &#x00ed;tems desde y escribe &#x00ed;tems hacia el cach&#x00e9; de segundo nivel"

#: index.docbook:841
msgid ""
      "<![CDATA[ScrollableResult cats = sess.createQuery(\"from Cat as cat\").scroll(); //a huge result set\n"
      "while ( cats.next() ) {\n"
      "    Cat cat = (Cat) cats.get(0);\n"
      "    doSomethingWithACat(cat);\n"
      "    sess.evict(cat);\n"
      "}]]>"
msgstr "<literal>CacheMode.GET</literal> - lee &#x00ed;tems del cach&#x00e9; de segundo nivel, pero no escribe al cach&#x00e9; de segundo nivel excepto al actualizar datos"

#: index.docbook:843
msgid "The <literal>Session</literal> also provides a <literal>contains()</literal> method to determine if an instance belongs to the session cache."
msgstr "<literal>CacheMode.PUT</literal> - escribe &#x00ed;tems al cach&#x00e9; de segundo nivel, pero no lee del cach&#x00e9; de segundo nivel"

#: index.docbook:848
msgid "To completely evict all objects from the session cache, call <literal>Session.clear()</literal>"
msgstr "<literal>CacheMode.REFRESH</literal> - escribe &#x00ed;tems al cach&#x00e9; de segundo nivel, pero no lee del cach&#x00e9; de segundo nivel, salt&#x00e1;ndose el efecto de <literal>hibernate.cache.use_minimal_puts</literal>, forzando un refresco del cach&#x00e9; de segundo nivel para todos los &#x00ed;tems le&#x00ed;dos de la base de datos"

#: index.docbook:852
msgid "For the second-level cache, there are methods defined on <literal>SessionFactory</literal> for evicting the cached state of an instance, entire class, collection instance or entire collection role."
msgstr "Para navegar por los contenidos de una regi&#x00f3;n de cach&#x00e9; de segundo nivel o de consultas, usa la API de <literal>Statistics</literal>:"

#: index.docbook:858
msgid ""
      "<![CDATA[sessionFactory.evict(Cat.class, catId); //evict a particular Cat\n"
      "sessionFactory.evict(Cat.class);  //evict all Cats\n"
      "sessionFactory.evictCollection(\"Cat.kittens\", catId); //evict a particular collection of kittens\n"
      "sessionFactory.evictCollection(\"Cat.kittens\"); //evict all kitten collections]]>"
msgstr ""
      "<![CDATA[Map cacheEntries = sessionFactory.getStatistics()\n"
      "        .getSecondLevelCacheStatistics(regionName)\n"
      "        .getEntries();]]>"

#: index.docbook:860
msgid "The <literal>CacheMode</literal> controls how a particular session interacts with the second-level cache."
msgstr "Necesitar&#x00e1;s habilitar las estad&#x00ed;sticas y, opcionalmente, forzar a Hibernate para que guarde las entradas del cach&#x00e9; en un formato m&#x00e1;s entendible por humanos:"

#: index.docbook:867
msgid "<literal>CacheMode.NORMAL</literal> - read items from and write items to the second-level cache"
msgstr ""
      "<![CDATA[hibernate.generate_statistics true\n"
      "hibernate.cache.use_structured_entries true]]>"

#: index.docbook:872
msgid "<literal>CacheMode.GET</literal> - read items from the second-level cache, but don't write to the second-level cache except when updating data"
msgstr "El Cach&#x00e9; de Consultas"

#: index.docbook:878
msgid "<literal>CacheMode.PUT</literal> - write items to the second-level cache, but don't read from the second-level cache"
msgstr "Los conjuntos resultado de consultas tambi&#x00e9;n pueden tratarse en cach&#x00e9;. Esto s&#x00f3;lo es &#x00fa;til para consultas que se ejecutan frecuentemente con los mismos par&#x00e1;metros. Para usar el cach&#x00e9; de consultas primero debes habilitarlo:"

#: index.docbook:884
msgid "<literal>CacheMode.REFRESH</literal> - write items to the second-level cache, but don't read from the second-level cache, bypass the effect of <literal>hibernate.cache.use_minimal_puts</literal>, forcing a refresh of the second-level cache for all items read from the database"
msgstr "<![CDATA[hibernate.cache.use_query_cache true]]>"

#: index.docbook:892
msgid "To browse the contents of a second-level or query cache region, use the <literal>Statistics</literal> API:"
msgstr "Esta configuraci&#x00f3;n causa la creaci&#x00f3;n de dos nuevas regiones de cach&#x00e9; - una teniendo en cach&#x00e9; conjuntos resultado de consulta (<literal>org.hibernate.cache.StandardQueryCache</literal>), el otro teniendo timestamps de las actualizaciones m&#x00e1;s recientes a tablas consultables (<literal>org.hibernate.cache.UpdateTimestampsCache</literal>). Nota que el cach&#x00e9; de consultas no pone en cach&#x00e9; el estado de las entidades reales en el conjunto resultado; s&#x00f3;lo tiene en cach&#x00e9; valores indentificadores y resultados de tipo de valor. De modo que el cach&#x00e9; de consultas siempre debe ser usado en conjunci&#x00f3;n con el cach&#x00e9; de segundo nivel."

#: index.docbook:897
msgid ""
      "<![CDATA[Map cacheEntries = sessionFactory.getStatistics()\n"
      "        .getSecondLevelCacheStatistics(regionName)\n"
      "        .getEntries();]]>"
msgstr "La mayor&#x00ed;a de consultas no se benefician del tratamiento en cach&#x00e9;, de modo que por defecto las consultas no son tratadas en cach&#x00e9;. Para habilitar el tratamiento en cach&#x00e9;, llama a <literal>Query.setCacheable(true)</literal>. Esta llamada permite a la consulta buscar resultados existentes en cach&#x00e9; o agregar sus resultados al cach&#x00e9; cuando se ejecuta."

#: index.docbook:899
msgid "You'll need to enable statistics, and, optionally, force Hibernate to keep the cache entries in a more human-understandable format:"
msgstr "Si requieres un control finamente granularizado sobre las pol&#x00ed;ticas de expiraci&#x00f3;n del cach&#x00e9; de consultas, puedes especificar una regi&#x00f3;n de cach&#x00e9; con nombre para una consulta en particular llamando a <literal>Query.setCacheRegion()</literal>."

#: index.docbook:904
msgid ""
      "<![CDATA[hibernate.generate_statistics true\n"
      "hibernate.cache.use_structured_entries true]]>"
msgstr ""
      "<![CDATA[List blogs = sess.createQuery(\"from Blog blog where blog.blogger = :blogger\")\n"
      "    .setEntity(\"blogger\", blogger)\n"
      "    .setMaxResults(15)\n"
      "    .setCacheable(true)\n"
      "    .setCacheRegion(\"frontpages\")\n"
      "    .list();]]>"

#: index.docbook:909
msgid "The Query Cache"
msgstr "Si la consulta debe forzar un refresco de si regi&#x00f3;n del cach&#x00e9; de consultas, debes llamar a <literal>Query.setCacheMode(CacheMode.REFRESH)</literal>. Esto es particularmente &#x00fa;til en casos donde los datos subyacentes pueden haber sido actualizados por medio de un proceso separado (es decir, no modificados a trav&#x00e9;s de Hibernate) y permite a la aplicaci&#x00f3;n refrescar selectivamente conjuntos resultado de consultas en particular. Esto es una alternativa m&#x00e1;s eficient al desahuciamiento de una regi&#x00f3;n del cach&#x00e9; de consultas v&#x00ed;a <literal>SessionFactory.evictQueries()</literal>."

#: index.docbook:911
msgid "Query result sets may also be cached. This is only useful for queries that are run frequently with the same parameters. To use the query cache you must first enable it:"
msgstr "Entendiendo el rendimiento de Colecciones"

#: index.docbook:916
msgid "<![CDATA[hibernate.cache.use_query_cache true]]>"
msgstr "Ya hemos llevado un buen tiempo hablando sobre colecciones. En esta secci&#x00f3;n resaltaremos un par de temas m&#x00e1;s sobre c&#x00f3;mo las colecciones se comportan en tiempo de ejecuci&#x00f3;n."

#: index.docbook:918
msgid "This setting causes the creation of two new cache regions - one holding cached query result sets (<literal>org.hibernate.cache.StandardQueryCache</literal>), the other holding timestamps of the most recent updates to queryable tables (<literal>org.hibernate.cache.UpdateTimestampsCache</literal>). Note that the query cache does not cache the state of the actual entities in the result set; it caches only identifier values and results of value type. So the query cache should always be used in conjunction with the second-level cache."
msgstr "Taxonomia"

#: index.docbook:928
msgid "Most queries do not benefit from caching, so by default queries are not cached. To enable caching, call <literal>Query.setCacheable(true)</literal>. This call allows the query to look for existing cache results or add its results to the cache when it is executed."
msgstr "Hibernate define tres tipos b&#x00e1;sicos de colecciones:"

#: index.docbook:935
msgid "If you require fine-grained control over query cache expiration policies, you may specify a named cache region for a particular query by calling <literal>Query.setCacheRegion()</literal>."
msgstr "colecciones de valores"

#: index.docbook:941
msgid ""
      "<![CDATA[List blogs = sess.createQuery(\"from Blog blog where blog.blogger = :blogger\")\n"
      "    .setEntity(\"blogger\", blogger)\n"
      "    .setMaxResults(15)\n"
      "    .setCacheable(true)\n"
      "    .setCacheRegion(\"frontpages\")\n"
      "    .list();]]>"
msgstr "asociaciones uno a muchos"

#: index.docbook:943
msgid "If the query should force a refresh of its query cache region, you should call <literal>Query.setCacheMode(CacheMode.REFRESH)</literal>. This is particularly useful in cases where underlying data may have been updated via a separate process (i.e., not modified through Hibernate) and allows the application to selectively refresh particular query result sets. This is a more efficient alternative to eviction of a query cache region via <literal>SessionFactory.evictQueries()</literal>."
msgstr "asociaciones muchos a muchos"

#: index.docbook:955
msgid "Understanding Collection performance"
msgstr "Esta clasificaci&#x00f3;n distingue las varias tablas y relaciones de clave for&#x00e1;nea pero no nos dice absolutamente todo lo que necesitamos saber sobre el modelo relacional. Para entender completamente la estructura relacional y las caracter&#x00ed;sticas de rendimiento, debemos considerar la estructura de la clave primaria que es usada por Hibernate para actualizar o borrar filas de colecci&#x00f3;n. Esto sugiere la siguiente clasificaci&#x00f3;n:"

#: index.docbook:957
msgid "We've already spent quite some time talking about collections. In this section we will highlight a couple more issues about how collections behave at runtime."
msgstr "colecciones indexadas"

#: index.docbook:964
msgid "Taxonomy"
msgstr "conjuntos (sets)"

#: index.docbook:966
msgid "Hibernate defines three basic kinds of collections:"
msgstr "bolsas (bags)"

#: index.docbook:970
msgid "collections of values"
msgstr "Todas las colecciones indexadas (mapas, listas, arrays) tienen una clave primaria consistente de las columnas <literal>&lt;key&gt;</literal> y <literal>&lt;index&gt;</literal>. En este caso las actualizaciones de colecciones son usualmente extremadamente eficientes. La clave primaria puede ser indexada f&#x00e1;cilmente y una fila en particular puede ser localizada cuando Hibernate intenta actualizarla o borrarla."

#: index.docbook:973
msgid "one to many associations"
msgstr "Los conjuntos (sets) tienen una clave primaria consistente en <literal>&lt;key&gt;</literal> y columnas de elemento. Esto puede ser menos eficiente para algunos tipos de elemento de colecci&#x00f3;n, particularmente elementos compuestos o texto largo, o campos binarios. La base de datos puede no ser capaz de indexar una clave primaria compleja eficientemente. Por otra parte, para asociaciones uno a muchos o muchos a muchos, particularmente en el caso de identificadores sint&#x00e9;ticos, es probable que s&#x00f3;lo sea tan eficiente. (Nota al m&#x00e1;rgen: si quieres que <literal>SchemaExport</literal> realmente cree la clave primaria de un <literal>&lt;set&gt;</literal> por ti, debes declarar todas las columnas como <literal>not-null=\"true\"</literal>.)"

#: index.docbook:976
msgid "many to many associations"
msgstr "Los mapeos de <literal>&lt;idbag&gt;</literal> definen una clave delegada, de modo que siempre resulten eficientes de actualizar. De hecho, son el mejor caso."

#: index.docbook:980
msgid "This classification distinguishes the various table and foreign key relationships but does not tell us quite everything we need to know about the relational model. To fully understand the relational structure and performance characteristics, we must also consider the structure of the primary key that is used by Hibernate to update or delete collection rows. This suggests the following classification:"
msgstr "Los bags son el peor caso. Ya que un bag permite valores de elementos duplicados y no tiene ninguna columna &#x00ed;ndice, no puede definirse ninguna clave primaria. Hibernate no tiene forma de distinguir entre filas duplicadas. Hibernate resuelve este problema quitando completamente (en un solo <literal>DELETE</literal>) y recreando la colecci&#x00f3;n siempre que cambia. Esto podr&#x00ed;a ser muy ineficiente."

#: index.docbook:991
msgid "indexed collections"
msgstr "Nota que para una asociaci&#x00f3;n uno-a-muchos, la \"clave primaria\" puede no ser la clave primaria f&#x00ed;sica de la tabla de base de datos; pero incluso en este caso, la clasificaci&#x00f3;n anterior es &#x00fa;til todav&#x00ed;a. (A&#x00fa;n refleja c&#x00f3;mo Hibernate \"localiza\" filas individuales de la colecci&#x00f3;n.)"

#: index.docbook:994
msgid "sets"
msgstr "Las listas, mapas, idbags y conjuntos son las colecciones m&#x00e1;s eficientes de actualizar"

#: index.docbook:997
msgid "bags"
msgstr "Desde la discusi&#x00f3;n anterior, debe quedar claro que las colecciones indexadas y (usualmente) los conjuntos permiten la operaci&#x00f3;n m&#x00e1;s eficiente en t&#x00e9;rminos de a&#x00f1;adir, quitar y actualizar elementos."

#: index.docbook:1001
msgid "All indexed collections (maps, lists, arrays) have a primary key consisting of the <literal>&lt;key&gt;</literal> and <literal>&lt;index&gt;</literal> columns. In this case collection updates are usually extremely efficient - the primary key may be efficiently indexed and a particular row may be efficiently located when Hibernate tries to update or delete it."
msgstr "Hay, discutiblemente, una ventaja m&#x00e1;s que las colecciones indexadas tienen sobre otros conjuntos para las asociaciones muchos a muchos o colecciones de valores. Debido a la estructura de un <literal>Set</literal>, Hibernate ni siquiera actualiza una fila con <literal>UPDATE</literal> cuando se \"cambia\" un elemento. Los cambios a un <literal>Set</literal> siempre funcionan por medio de <literal>INSERT</literal> y <literal>DELETE</literal> (de filas individuales). Una vez m&#x00e1;s, esta consideraci&#x00f3;n no se aplica a las asociaciones uno a muchos."

#: index.docbook:1009
msgid "Sets have a primary key consisting of <literal>&lt;key&gt;</literal> and element columns. This may be less efficient for some types of collection element, particularly composite elements or large text or binary fields; the database may not be able to index a complex primary key as efficently. On the other hand, for one to many or many to many associations, particularly in the case of synthetic identifiers, it is likely to be just as efficient. (Side-note: if you want <literal>SchemaExport</literal> to actually create the primary key of a <literal>&lt;set&gt;</literal> for you, you must declare all columns as <literal>not-null=\"true\"</literal>.)"
msgstr "Despu&#x00e9;s de observar que los arrays no pueden ser perezosos, podr&#x00ed;amos concluir que las listas, mapas e idbags son los tipos m&#x00e1;s eficientes de colecciones (no inversas), con los conjuntos (sets) no muy por detr&#x00e1;s. Se espera que los sets sean el tipo m&#x00e1;s com&#x00fa;n de colecci&#x00f3;n en las aplicaciones de Hibernate. Esto es debido a que la sem&#x00e1;ntica de los sets es la m&#x00e1;s natural en el modelo relacional."

#: index.docbook:1020
msgid "<literal>&lt;idbag&gt;</literal> mappings define a surrogate key, so they are always very efficient to update. In fact, they are the best case."
msgstr "Sin embargo, en modelos de dominio de Hibernate bien die&#x00f1;ados, usualmente vemos que la mayor&#x00ed;a de las colecciones son de hecho asociaciones uno-a-muchos con <literal>inverse=\"true\"</literal>. Para estas asociaciones, la actualizaci&#x00f3;n es manejada por el extremo muchos-a-uno de la asociaci&#x00f3;n, y las consideraciones de este tipo sobre el rendimiento de actualizaci&#x00f3;n de colecciones simplemente no se aplican."

#: index.docbook:1025
msgid "Bags are the worst case. Since a bag permits duplicate element values and has no index column, no primary key may be defined. Hibernate has no way of distinguishing between duplicate rows. Hibernate resolves this problem by completely removing (in a single <literal>DELETE</literal>) and recreating the collection whenever it changes. This might be very inefficient."
msgstr "Los Bags y las listas son las colecciones inversas m&#x00e1;s eficientes"

#: index.docbook:1033
msgid "Note that for a one-to-many association, the \"primary key\" may not be the physical primary key of the database table - but even in this case, the above classification is still useful. (It still reflects how Hibernate \"locates\" individual rows of the collection.)"
msgstr "Justo antes que tires a la zanja los bags para siempre, hay un caso en particular en el que los bags son muchos m&#x00e1;s eficientes que los conjuntos. Para una colecci&#x00f3;n con <literal>inverse=\"true\"</literal> (el idioma est&#x00e1;ndar de relaciones uno-a-muchos bidireccionales, por ejemplo) &#x00a1;podemos a&#x00f1;adir elementos a un bag o lista sin necesidad de inicializar (fetch) los elementos del bag! Esto se debe a que <literal>Collection.add()</literal> o <literal>Collection.addAll()</literal> siempre deben devolver true para un bag o <literal>List</literal> (no como un <literal>Set</literal>). Esto puede hacer el siguiente c&#x00f3;digo com&#x00fa;n mucho m&#x00e1;s r&#x00e1;pido."

#: index.docbook:1043
msgid "Lists, maps, idbags and sets are the most efficient collections to update"
msgstr ""
      "<![CDATA[Parent p = (Parent) sess.load(Parent.class, id);\n"
      "    Child c = new Child();\n"
      "    c.setParent(p);\n"
      "    p.getChildren().add(c);  //no need to fetch the collection!\n"
      "    sess.flush();]]>"

#: index.docbook:1045
msgid "From the discussion above, it should be clear that indexed collections and (usually) sets allow the most efficient operation in terms of adding, removing and updating elements."
msgstr "Borrado de un solo tiro"

#: index.docbook:1051
msgid "There is, arguably, one more advantage that indexed collections have over sets for many to many associations or collections of values. Because of the structure of a <literal>Set</literal>, Hibernate doesn't ever <literal>UPDATE</literal> a row when an element is \"changed\". Changes to a <literal>Set</literal> always work via <literal>INSERT</literal> and <literal>DELETE</literal> (of individual rows). Once again, this consideration does not apply to one to many associations."
msgstr "Ocasionalmente, borrar los elementos de una colecci&#x00f3;n uno a uno puede ser extremadamente ineficiente. Hibernate no es completamente est&#x00fa;pido, de modo que sabe no hacer eso, en el caso de una colecci&#x00f3;n nueva-vac&#x00ed;a (si has llamado a <literal>list.clear()</literal>, por ejemplo). En este caso, Hibernate publicar&#x00e1; una sola <literal>DELETE</literal>, &#x00a1;y listo!"

#: index.docbook:1060
msgid "After observing that arrays cannot be lazy, we would conclude that lists, maps and idbags are the most performant (non-inverse) collection types, with sets not far behind. Sets are expected to be the most common kind of collection in Hibernate applications. This is because the \"set\" semantics are most natural in the relational model."
msgstr "Sup&#x00f3;n que a&#x00f1;adimos un solo elemento a una colecci&#x00f3;n de tama&#x00f1;o veinte y luego quitamos dos elementos. Hibernate publicar&#x00e1; una sentencia <literal>INSERT</literal> y dos sentencias <literal>DELETE</literal> (a menos que la colecci&#x00f3;n sea un bag). Esto es ciertamente deseable."

#: index.docbook:1068
msgid "However, in well-designed Hibernate domain models, we usually see that most collections are in fact one-to-many associations with <literal>inverse=\"true\"</literal>. For these associations, the update is handled by the many-to-one end of the association, and so considerations of collection update performance simply do not apply."
msgstr "Sin embargo, sup&#x00f3;n que quitamos dieciocho elementos, dejando dos y luego a&#x00f1;adimos tres nuevos elementos. Hay dos formas posibles de proceder"

#: index.docbook:1078
msgid "Bags and lists are the most efficient inverse collections"
msgstr "borrar dieciocho filas una a una y luego insertar tres filas"

#: index.docbook:1080
msgid "Just before you ditch bags forever, there is a particular case in which bags (and also lists) are much more performant than sets. For a collection with <literal>inverse=\"true\"</literal> (the standard bidirectional one-to-many relationship idiom, for example) we can add elements to a bag or list without needing to initialize (fetch) the bag elements! This is because <literal>Collection.add()</literal> or <literal>Collection.addAll()</literal> must always return true for a bag or <literal>List</literal> (unlike a <literal>Set</literal>). This can make the following common code much faster."
msgstr "quitar toda la colecci&#x00f3;n (en un solo <literal>DELETE</literal> de SQL) e insertar todos los cinco elementos actuales (uno a uno)"

#: index.docbook:1090
msgid ""
      "<![CDATA[Parent p = (Parent) sess.load(Parent.class, id);\n"
      "Child c = new Child();\n"
      "c.setParent(p);\n"
      "p.getChildren().add(c);  //no need to fetch the collection!\n"
      "sess.flush();]]>"
msgstr "Hibernate no es lo suficientemente inteligente para saber que la segunda opci&#x00f3;n es probablemente m&#x00e1;s r&#x00e1;pida en este caso. (Y que ser&#x00ed;a probablemente indeseable para Hibernate ser tan inteligente; este comportamiento podr&#x00ed;a confundir a disparadores de base de datos, etc.)"

#: index.docbook:1095
msgid "One shot delete"
msgstr "Afortunadamente, puedes forzar este comportamiento (es decir, la segunda estrategia) en cualquier momento descartando (es decir, desreferenciando) la colecci&#x00f3;n original y devolviendo una colecci&#x00f3;n nuevamente instanciada con todos los elementos actuales. Esto puede ser muy &#x00fa;til y potente de vez en cuando."

#: index.docbook:1097
msgid "Occasionally, deleting collection elements one by one can be extremely inefficient. Hibernate isn't completely stupid, so it knows not to do that in the case of an newly-empty collection (if you called <literal>list.clear()</literal>, for example). In this case, Hibernate will issue a single <literal>DELETE</literal> and we are done!"
msgstr "Por supuesto, el borrado-de-un-solo-tiro no se aplica a colecciones mapeadas <literal>inverse=\"true\"</literal>."

#: index.docbook:1104
msgid "Suppose we add a single element to a collection of size twenty and then remove two elements. Hibernate will issue one <literal>INSERT</literal> statement and two <literal>DELETE</literal> statements (unless the collection is a bag). This is certainly desirable."
msgstr "Monitoreando el rendimiento"

#: index.docbook:1110
msgid "However, suppose that we remove eighteen elements, leaving two and then add thee new elements. There are two possible ways to proceed"
msgstr "La optimizaci&#x00f3;n no es de mucho uso sin el monitoreo y el acceso a n&#x00fa;meros de rendimiento. Hibernate provee un rango completo de figuras sobre sus operaciones internas. Las estad&#x00ed;sticas en Hibernate est&#x00e1;n disponibles por <literal>SessionFactory</literal>."

#: index.docbook:1117
msgid "delete eighteen rows one by one and then insert three rows"
msgstr "Monitoreando una SessionFactory"

#: index.docbook:1120
msgid "remove the whole collection (in one SQL <literal>DELETE</literal>) and insert all five current elements (one by one)"
msgstr "Puedes acceder a las m&#x00e9;tricas de <literal>SessionFactory</literal> de dos formas. Tu primera opci&#x00f3;n es llamar a <literal>sessionFactory.getStatistics()</literal> y leer o mostrar por pantalla la <literal>Statistics</literal> por ti mismo."

#: index.docbook:1125
msgid "Hibernate isn't smart enough to know that the second option is probably quicker in this case. (And it would probably be undesirable for Hibernate to be that smart; such behaviour might confuse database triggers, etc.)"
msgstr "Hibernate puede tambi&#x00e9;n usar JMX para publicar las m&#x00e9;tricas si habilitas el MBean <literal>StatisticsService</literal>. Puede habilitar un solo MBean para todas tus <literal>SessionFactory</literal> o una por f&#x00e1;brica. Mira el siguiente c&#x00f3;digo para ejemplos de configuraci&#x00f3;n minimalistas:"

#: index.docbook:1131
msgid "Fortunately, you can force this behaviour (ie. the second strategy) at any time by discarding (ie. dereferencing) the original collection and returning a newly instantiated collection with all the current elements. This can be very useful and powerful from time to time."
msgstr ""
      "<![CDATA[// MBean service registration for a specific SessionFactory\n"
      "Hashtable tb = new Hashtable();\n"
      "tb.put(\"type\", \"statistics\");\n"
      "tb.put(\"sessionFactory\", \"myFinancialApp\");\n"
      "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
      "\n"
      "StatisticsService stats = new StatisticsService(); // MBean implementation\n"
      "stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory\n"
      "server.registerMBean(stats, on); // Register the Mbean on the server]]>"

#: index.docbook:1137
msgid "Of course, one-shot-delete does not apply to collections mapped <literal>inverse=\"true\"</literal>."
msgstr ""
      "<![CDATA[// MBean service registration for all SessionFactory's\n"
      "Hashtable tb = new Hashtable();\n"
      "tb.put(\"type\", \"statistics\");\n"
      "tb.put(\"sessionFactory\", \"all\");\n"
      "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
      "\n"
      "StatisticsService stats = new StatisticsService(); // MBean implementation\n"
      "server.registerMBean(stats, on); // Register the MBean on the server]]>"

#: index.docbook:1146
msgid "Monitoring performance"
msgstr "POR HACER: Esto no tiene sentido: En el primer caso, recuperamos y usamos el MBean directamente. En el segundo, debemos proporcionar el nombre JNDI en el que se guarda la f&#x00e1;brica de sesiones antes de usarlo. Usa <literal>hibernateStatsBean.setSessionFactoryJNDIName(\"my/JNDI/Name\")</literal>"

#: index.docbook:1148
msgid "Optimization is not much use without monitoring and access to performance numbers. Hibernate provides a full range of figures about its internal operations. Statistics in Hibernate are available per <literal>SessionFactory</literal>."
msgstr "Puedes (des)activar el monitoreo de una <literal>SessionFactory</literal>"

#: index.docbook:1155
msgid "Monitoring a SessionFactory"
msgstr "en tiempo de configuraci&#x00f3;n, establece <literal>hibernate.generate_statistics</literal> a <literal>false</literal>"

#: index.docbook:1157
msgid "You can access <literal>SessionFactory</literal> metrics in two ways. Your first option is to call <literal>sessionFactory.getStatistics()</literal> and read or display the <literal>Statistics</literal> yourself."
msgstr "en tiempo de ejecuci&#x00f3;n: <literal>sf.getStatistics().setStatisticsEnabled(true)</literal> o <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal>"

#: index.docbook:1163
msgid "Hibernate can also use JMX to publish metrics if you enable the <literal>StatisticsService</literal> MBean. You may enable a single MBean for all your <literal>SessionFactory</literal> or one per factory. See the following code for minimalistic configuration examples:"
msgstr "Las estad&#x00ed;sticas pueden ser reajustadas program&#x00e1;ticamente usando el m&#x00e9;todo <literal>clear()</literal>. Puede enviarse un resumen a un logger (nivel info) usando el m&#x00e9;todo <literal>logSummary()</literal>."

#: index.docbook:1170
msgid ""
      "<![CDATA[// MBean service registration for a specific SessionFactory\n"
      "Hashtable tb = new Hashtable();\n"
      "tb.put(\"type\", \"statistics\");\n"
      "tb.put(\"sessionFactory\", \"myFinancialApp\");\n"
      "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
      "\n"
      "StatisticsService stats = new StatisticsService(); // MBean implementation\n"
      "stats.setSessionFactory(sessionFactory); // Bind the stats to a SessionFactory\n"
      "server.registerMBean(stats, on); // Register the Mbean on the server]]>"
msgstr "M&#x00e9;tricas"

#: index.docbook:1173
msgid ""
      "<![CDATA[// MBean service registration for all SessionFactory's\n"
      "Hashtable tb = new Hashtable();\n"
      "tb.put(\"type\", \"statistics\");\n"
      "tb.put(\"sessionFactory\", \"all\");\n"
      "ObjectName on = new ObjectName(\"hibernate\", tb); // MBean object name\n"
      "\n"
      "StatisticsService stats = new StatisticsService(); // MBean implementation\n"
      "server.registerMBean(stats, on); // Register the MBean on the server]]>"
msgstr "Hibernate provee un n&#x00fa;mero de m&#x00e9;tricas, desde informaci&#x00f3;n muy b&#x00e1;sica a la especializada s&#x00f3;lo relevante en ciertos escenarios. Todos los contadores disponibles se describen en la API de la interface <literal>Statistics</literal>, en tres categor&#x00ed;as:"

#: index.docbook:1175
msgid "TODO: This doesn't make sense: In the first case, we retrieve and use the MBean directly. In the second one, we must give the JNDI name in which the session factory is held before using it. Use <literal>hibernateStatsBean.setSessionFactoryJNDIName(\"my/JNDI/Name\")</literal>"
msgstr "M&#x00e9;tricas relacionadas al uso general de <literal>Session</literal> usage, tales como n&#x00fa;mero de sesiones abiertas, conexiones JDBC recuperadas, etc,"

#: index.docbook:1180
msgid "You can (de)activate the monitoring for a <literal>SessionFactory</literal>"
msgstr "M&#x00e9;tricas relacionadas a las entidades, colecciones, consultas, y cach&#x00e9;s como un todo. (tambi&#x00e9;n conocidas como m&#x00e9;tricas globales)."

#: index.docbook:1185
msgid "at configuration time, set <literal>hibernate.generate_statistics</literal> to <literal>false</literal>"
msgstr "M&#x00e9;tricas detalladas relacionadas a una entidad, colecci&#x00f3;n, consulta o regi&#x00f3;n de cach&#x00e9; en particular."

#: index.docbook:1192
msgid "at runtime: <literal>sf.getStatistics().setStatisticsEnabled(true)</literal> or <literal>hibernateStatsBean.setStatisticsEnabled(true)</literal>"
msgstr "Por ejemplo, puedes comprobar el acceso, p&#x00e9;rdida, y radio de colocaci&#x00f3;n de entidades, colecciones y consultas en el cach&#x00e9;, y el tiempo promedio que necesita una consulta. Ten en cuenta que el n&#x00fa;mero de milisegundos est&#x00e1; sujeto a aproximaci&#x00f3;n en Java. Hibernate est&#x00e1; pegado a la precisi&#x00f3;n de la JVM, en algunas plataformas esto podr&#x00ed;a incuso ser tener s&#x00f3;lo una exactitud de 10 segundos."

#: index.docbook:1199
msgid "Statistics can be reset programatically using the <literal>clear()</literal> method. A summary can be sent to a logger (info level) using the <literal>logSummary()</literal> method."
msgstr "Se usan getters simples para acceder a las m&#x00e9;tricas globales (es decir, no pegadas a una entidad, colecci&#x00f3;n, regi&#x00f3;n de cach&#x00e9;, etc, en particular). Puedes acceder a las m&#x00e9;tricas de una entidad, colecci&#x00f3;n, regi&#x00f3;n de cach&#x00e9; en particular a trav&#x00e9;s de su nombre, y a trav&#x00e9;s de su representaci&#x00f3;n HQL o SQL para las consultas. Por favor refi&#x00e9;rete al Javadoc de la API de <literal>Statistics</literal>, <literal>EntityStatistics</literal>, <literal>CollectionStatistics</literal>, <literal>SecondLevelCacheStatistics</literal>, y <literal>QueryStatistics</literal> para m&#x00e1;s informaci&#x00f3;n. El siguiente c&#x00f3;digo muestra un ejemplo sencillo:"

#: index.docbook:1208
msgid "Metrics"
msgstr ""
      "<![CDATA[Statistics stats = HibernateUtil.sessionFactory.getStatistics();\n"
      "\n"
      "double queryCacheHitCount  = stats.getQueryCacheHitCount();\n"
      "double queryCacheMissCount = stats.getQueryCacheMissCount();\n"
      "double queryCacheHitRatio =\n"
      "  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);\n"
      "\n"
      "log.info(\"Query Hit ratio:\" + queryCacheHitRatio);\n"
      "\n"
      "EntityStatistics entityStats =\n"
      "  stats.getEntityStatistics( Cat.class.getName() );\n"
      "long changes =\n"
      "        entityStats.getInsertCount()\n"
      "        + entityStats.getUpdateCount()\n"
      "        + entityStats.getDeleteCount();\n"
      "log.info(Cat.class.getName() + \" changed \" + changes + \"times\"  );]]>"

#: index.docbook:1210
msgid "Hibernate provides a number of metrics, from very basic to the specialized information only relevant in certain scenarios. All available counters are described in the <literal>Statistics</literal> interface API, in three categories:"
msgstr "Para trabajar sobre todas las entidades, colecciones, consultas y regiones de cach&#x00e9;s, puedes recuperar la lista de nombres de entidades, colecciones, consultas y regiones de cach&#x00e9;s con los siguientes m&#x00e9;todos: <literal>getQueries()</literal>, <literal>getEntityNames()</literal>, <literal>getCollectionRoleNames()</literal>, y <literal>getSecondLevelCacheRegionNames()</literal>."

#: index.docbook:1217
msgid "Metrics related to the general <literal>Session</literal> usage, such as number of open sessions, retrieved JDBC connections, etc."
msgstr ""

#: index.docbook:1223
msgid "Metrics related to he entities, collections, queries, and caches as a whole (aka global metrics),"
msgstr ""

#: index.docbook:1229
msgid "Detailed metrics related to a particular entity, collection, query or cache region."
msgstr ""

#: index.docbook:1236
msgid "For exampl,e you can check the cache hit, miss, and put ratio of entities, collections and queries, and the average time a query needs. Beware that the number of milliseconds is subject to approximation in Java. Hibernate is tied to the JVM precision, on some platforms this might even only be accurate to 10 seconds."
msgstr ""

#: index.docbook:1243
msgid "Simple getters are used to access the global metrics (i.e. not tied to a particular entity, collection, cache region, etc.). You can access the metrics of a particular entity, collection or cache region through its name, and through its HQL or SQL representation for queries. Please refer to the <literal>Statistics</literal>, <literal>EntityStatistics</literal>, <literal>CollectionStatistics</literal>, <literal>SecondLevelCacheStatistics</literal>, and <literal>QueryStatistics</literal> API Javadoc for more information. The following code shows a simple example:"
msgstr ""

#: index.docbook:1253
msgid ""
      "<![CDATA[Statistics stats = HibernateUtil.sessionFactory.getStatistics();\n"
      "\n"
      "double queryCacheHitCount  = stats.getQueryCacheHitCount();\n"
      "double queryCacheMissCount = stats.getQueryCacheMissCount();\n"
      "double queryCacheHitRatio =\n"
      "  queryCacheHitCount / (queryCacheHitCount + queryCacheMissCount);\n"
      "\n"
      "log.info(\"Query Hit ratio:\" + queryCacheHitRatio);\n"
      "\n"
      "EntityStatistics entityStats =\n"
      "  stats.getEntityStatistics( Cat.class.getName() );\n"
      "long changes =\n"
      "        entityStats.getInsertCount()\n"
      "        + entityStats.getUpdateCount()\n"
      "        + entityStats.getDeleteCount();\n"
      "log.info(Cat.class.getName() + \" changed \" + changes + \"times\"  );]]>"
msgstr ""

#: index.docbook:1255
msgid "To work on all entities, collections, queries and region caches, you can retrieve the list of names of entities, collections, queries and region caches with the following methods: <literal>getQueries()</literal>, <literal>getEntityNames()</literal>, <literal>getCollectionRoleNames()</literal>, and <literal>getSecondLevelCacheRegionNames()</literal>."
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

