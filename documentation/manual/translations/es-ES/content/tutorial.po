#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:7
msgid "Introduction to Hibernate"
msgstr "Introducci&#x00f3;n a Hibernate"

#: index.docbook:10
msgid "Preface"
msgstr "Prefacio"

#: index.docbook:12
msgid "This chapter is an introductory tutorial for new users of Hibernate. We start with a simple command line application using an in-memory database and develop it in easy to understand steps."
msgstr "Este cap&#x00ed;tulo es un tutorial introductorio de Hibernate. Comenzamos con una aplicaci&#x00f3;n simple de l&#x00ed;nea de comandos usando un base de datos en-memoria y desarroll&#x00e1;ndola en f&#x00e1;cil para entender los pasos."

#: index.docbook:18
msgid "This tutorial is intended for new users of Hibernate but requires Java and SQL knowledge. It is based on a tutorial by Michael Gloegl, the third-party libraries we name are for JDK 1.4 and 5.0. You might need others for JDK 1.3."
msgstr "Este tutorial est&#x00e1; concebido para usuarios nuevos de Hibernate pero requiere conocimiento en Java y SQL. Est&#x00e1; basado en un tutorial de Michael Gloegl. Las bibliotecas de terceros que mencionamos son para JDK 1.4 y 5.0. Podr&#x00ed;as necesitar otras para JDK 1.3."

#: index.docbook:24
msgid "The source code for the tutorial is included in the distribution in the <literal>doc/reference/tutorial/</literal> directory."
msgstr "Parte 1 - La primera Aplicaci&#x00f3;n Hibernate"

#: index.docbook:32
msgid "Part 1 - The first Hibernate Application"
msgstr "Primero, crearemos una aplicaci&#x00f3;n simple de Hibenate basada en consola. Usamos usamos una base de datos en-memoria (HSQL DB), de modo que no necesitamos instalar ning&#x00fa;n servidor de base de datos."

#: index.docbook:34
msgid "First, we'll create a simple console-based Hibernate application. We use an Java database (HSQL DB), so we do not have to install any database server."
msgstr "Asumamos que necesitamos una aplicaci&#x00f3;n peque&#x00f1;a de base de datos que pueda almacenar eventos que queremos atender, e informaci&#x00f3;n acerca de los hostales de estos eventos."

#: index.docbook:39
msgid "Let's assume we need a small database application that can store events we want to attend, and information about the hosts of these events."
msgstr "La primera cosa que hacemos, es armar nuestro directorio de desarrollo y poner en &#x00e9;l todas las bibliotecas Java que necesitamos. Descarga la distribuci&#x00f3;n de Hibernate del sitio web de Hibernate. Extrae el paquete y coloca todas las bibliotecas requeridas encontradas en <literal>/lib</literal> dentro del directorio <literal>/lib</literal> de nuestro nuevo directorio de desarrollo de trabajo. Debe asemejarse a esto:"

#: index.docbook:44
msgid "The first thing we do, is set up our development directory and put all the Java libraries we need into it. Download the Hibernate distribution from the Hibernate website. Extract the package and place all required libraries found in <literal>/lib</literal> into into the <literal>/lib</literal> directory of your new development working directory. It should look like this:"
msgstr ""
      "<![CDATA[.\n"
      "+lib\n"
      "  antlr.jar\n"
      "  cglib-full.jar\n"
      "  asm.jar\n"
      "  asm-attrs.jars\n"
      "  commons-collections.jar\n"
      "  commons-logging.jar\n"
      "  ehcache.jar\n"
      "  hibernate3.jar\n"
      "  jta.jar\n"
      "  dom4j.jar\n"
      "  log4j.jar ]]>"

#: index.docbook:52
msgid ""
      "<![CDATA[.\n"
      "+lib\n"
      "  antlr.jar\n"
      "  cglib.jar\n"
      "  asm.jar\n"
      "  asm-attrs.jars\n"
      "  commons-collections.jar\n"
      "  commons-logging.jar\n"
      "  hibernate3.jar\n"
      "  jta.jar\n"
      "  dom4j.jar\n"
      "  log4j.jar ]]>"
msgstr "Este es el conjunto m&#x00ed;nimo de bibliotecas requeridas para Hibernate (observa que tambi&#x00e9;n hemos copiado hibernate3.jar, el fichero principal). Ver el fichero <literal>README.txt</literal> en el directorio <literal>lib/</literal> de la distribuci&#x00f3;n de Hibernate para m&#x00e1;s informaci&#x00f3;n sobre bibliotecas de terceros requeridas y opcionales. (Realmente, Log4J no es requerida aunque preferida por muchos desarrolladores)."

#: index.docbook:54
msgid "This is the minimum set of required libraries (note that we also copied hibernate3.jar, the main archive) for Hibernate <emphasis>at the time of writing</emphasis>. The Hibernate release you are using might require more or less libraries. See the <literal>README.txt</literal> file in the <literal>lib/</literal> directory of the Hibernate distribution for more information about required and optional third-party libraries. (Actually, Log4j is not required but preferred by many developers.)"
msgstr "Por siguiente, creamos una clase que represente el evento que queremos almacenar en base de datos."

#: index.docbook:63
msgid "Next we create a class that represents the event we want to store in database."
msgstr "La primera clase"

#: index.docbook:68
msgid "The first class"
msgstr "Nuestra primera clase persistente es un JavaBean simple con algunas propiedades:"

#: index.docbook:70
msgid "Our first persistent class is a simple JavaBean class with some properties:"
msgstr ""
      "<![CDATA[import java.util.Date;\n"
      "\n"
      "public class Event {\n"
      "    private Long id;\n"
      "\n"
      "    private String title;\n"
      "    private Date date;\n"
      "\n"
      "    Event() {}\n"
      "\n"
      "    public Long getId() {\n"
      "        return id;\n"
      "    }\n"
      "\n"
      "    private void setId(Long id) {\n"
      "        this.id = id;\n"
      "    }\n"
      "\n"
      "    public Date getDate() {\n"
      "        return date;\n"
      "    }\n"
      "\n"
      "    public void setDate(Date date) {\n"
      "        this.date = date;\n"
      "    }\n"
      "\n"
      "    public String getTitle() {\n"
      "        return title;\n"
      "    }\n"
      "\n"
      "    public void setTitle(String title) {\n"
      "        this.title = title;\n"
      "    }\n"
      "}]]>"

#: index.docbook:74
msgid ""
      "<![CDATA[package events;\n"
      "\n"
      "import java.util.Date;\n"
      "\n"
      "public class Event {\n"
      "    private Long id;\n"
      "\n"
      "    private String title;\n"
      "    private Date date;\n"
      "\n"
      "    public Event() {}\n"
      "\n"
      "    public Long getId() {\n"
      "        return id;\n"
      "    }\n"
      "\n"
      "    private void setId(Long id) {\n"
      "        this.id = id;\n"
      "    }\n"
      "\n"
      "    public Date getDate() {\n"
      "        return date;\n"
      "    }\n"
      "\n"
      "    public void setDate(Date date) {\n"
      "        this.date = date;\n"
      "    }\n"
      "\n"
      "    public String getTitle() {\n"
      "        return title;\n"
      "    }\n"
      "\n"
      "    public void setTitle(String title) {\n"
      "        this.title = title;\n"
      "    }\n"
      "}]]>"
msgstr "Puedes ver que esta clase usa las convenciones de nombrado est&#x00e1;ndar de JavaBean para m&#x00e9;todos getter y setter de propiedad, as&#x00ed; como visibilidad privada para los campos. Esto es un dise&#x00f1;o recomendado, aunque no requerido. Hibernate tambi&#x00e9;n puede acceder a los campos directamente; el beneficio de los m&#x00e9;todos de acceso es la robustez para la refactorizaci&#x00f3;n."

#: index.docbook:76
msgid "You can see that this class uses standard JavaBean naming conventions for property getter and setter methods, as well as private visibility for the fields. This is a recommended design - but not required. Hibernate can also access fields directly, the benefit of accessor methods is robustness for refactoring. The no-argument constructor is required to instantiate an object of this class through reflection."
msgstr "La propiedad <literal>id</literal> tiene un valor &#x00fa;nico de identificador para un evento en particular. Todas las clase de entidad persistentes ( tambi&#x00e9;n hay clases dependientes menos importantes) necesitar&#x00e1;n una propiedad identificadora similar si queremos usar el conjunto completo de funcionalidades de Hibernate. De hecho, la mayor&#x00ed;a de las aplicaciones (esp. aplicaciones web) necesitan distinguir objetos por identificador, de modo que debes considerar esto como un aspecto en vez de una limitaci&#x00f3;n. Sin embargo, usualmente no manipulamos la identidad de un objeto, por lo tanto el m&#x00e9;todo setter debe ser privado. S&#x00f3;lo Hibernate asignar&#x00e1; identificadores cuando un objeto sea salvado. Puedes ver que Hibernate puede acceder a m&#x00e9;todos de acceso p&#x00fa;blicos, privados y protegidos, tanto como directamente a campos (p&#x00fa;blicos, privados y protegidos). La elecci&#x00f3;n est&#x00e1; en ti, y puedes ajustarla a tu dise&#x00f1;o de aplicaci&#x00f3;n."

#: index.docbook:84
msgid "The <literal>id</literal> property holds a unique identifier value for a particular event. All persistent entity classes (there are less important dependent classes as well) will need such an identifier property if we want to use the full feature set of Hibernate. In fact, most applications (esp. web applications) need to distinguish objects by identifier, so you should consider this a feature rather than a limitation. However, we usually don't manipulate the identity of an object, hence the setter method should be private. Only Hibernate will assign identifiers when an object is saved. You can see that Hibernate can access public, private, and protected accessor methods, as well as (public, private, protected) fields directly. The choice is up to you and you can match it to fit your application design."
msgstr "El constructor sin argumentos es un requerimiento para todas las clases persistentes. Hibernate tiene que crear objetos para ti, usando reflecci&#x00f3;n Java. El constructor puede ser privado, sin embargo, la visibilidad de paquete es requerida para la generaci&#x00f3;n de proxies en tiempo de ejecuci&#x00f3;n y la recuperaci&#x00f3;n de datos sin instrumentaci&#x00f3;n del bytecode."

#: index.docbook:96
msgid "The no-argument constructor is a requirement for all persistent classes; Hibernate has to create objects for you, using Java Reflection. The constructor can be private, however, package visibility is required for runtime proxy generation and efficient data retrieval without bytecode instrumentation."
msgstr "Coloca este fichero de c&#x00f3;digo Java en un directorio llamado <literal>src</literal> en la carpeta de desarrollo. El directorio ahora debe verse como esto:"

#: index.docbook:103
msgid "Place this Java source file in a directory called <literal>src</literal> in the development folder, and in its correct package. The directory should now look like this:"
msgstr ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  Event.java]]>"

#: index.docbook:108
msgid ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java]]>"
msgstr "En el pr&#x00f3;ximo paso, le decimos a Hibernate sobre esta clase persistente."

#: index.docbook:110
msgid "In the next step, we tell Hibernate about this persistent class."
msgstr "El fichero de mapeo"

#: index.docbook:117
msgid "The mapping file"
msgstr "Hibernate necesita saber c&#x00f3;mo cargar y almacenar objetos de la clase persistente. Aqu&#x00ed; es donde el fichero de mapeo de Hibernate entra en juego. El fichero de mapeo le dice a Hibernate a qu&#x00e9; tabla en la base de datos tiene que acceder, y qu&#x00e9; columnas en esta tabla debe usar."

#: index.docbook:119
msgid "Hibernate needs to know how to load and store objects of the persistent class. This is where the Hibernate mapping file comes into play. The mapping file tells Hibernate what table in the database it has to access, and what columns in that table it should use."
msgstr "La estructura b&#x00e1;sica de un fichero de mapeo se parece a esto:"

#: index.docbook:126
msgid "The basic structure of a mapping file looks like this:"
msgstr ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
      "\n"
      "<hibernate-mapping>\n"
      "[...]\n"
      "</hibernate-mapping>]]>"

#: index.docbook:130
msgid ""
      "<![CDATA[<?xml version=\"1.0\"?>\n"
      "<!DOCTYPE hibernate-mapping PUBLIC\n"
      "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
      "\n"
      "<hibernate-mapping>\n"
      "[...]\n"
      "</hibernate-mapping>]]>"
msgstr "Observa que el DTD de Hibernate es muy sofisticado. Puedes usarlo para autocompleci&#x00f3;n de los elementos y atributos XML de mapeo en tu editor o IDE. Debes tambi&#x00e9;n abrir el fichero DTD en tu editor de texto. Es la forma m&#x00e1;s f&#x00e1;cil para tener un panorama de todos los elementos y atributos y ver los valores por defectos, as&#x00ed; como algunos comentarios. Nota que Hibernate no cargar&#x00e1; el fichero DTD de la web, sino que primero buscar&#x00e1; en el classpath de la aplicaci&#x00f3;n. El fichero DTD est&#x00e1; inclu&#x00ed;do en <literal>hibernate3.jar</literal> as&#x00ed; como tambi&#x00e9;n en el directorio <literal>src/</literal> de la distribuci&#x00f3;n de Hibernate."

#: index.docbook:132
msgid "Note that the Hibernate DTD is very sophisticated. You can use it for auto-completion of XML mapping elements and attributes in your editor or IDE. You also should open up the DTD file in your text editor - it's the easiest way to get an overview of all elements and attributes and to see the defaults, as well as some comments. Note that Hibernate will not load the DTD file from the web, but first look it up from the classpath of the application. The DTD file is included in <literal>hibernate3.jar</literal> as well as in the <literal>src/</literal> directory of the Hibernate distribution."
msgstr "Omitiremos la declaraci&#x00f3;n de DTD en futuros ejemplos para acortar el c&#x00f3;digo. Por supuesto, no es opcional."

#: index.docbook:143
msgid "We will omit the DTD declaration in future examples to shorten the code. It is of course not optional."
msgstr "Entre las dos etiquetas <literal>hibernate-mapping</literal>, incluye un elemento <literal>class</literal>. Todas las clases de entidad persistentes (de nuevo, podr&#x00ed;a haber m&#x00e1;s adelante clases dependientes, que no sean entidades de-primera-clase) necesitan dicho mapeo a una tabla en la base de datos SQL:"

#: index.docbook:148
msgid "Between the two <literal>hibernate-mapping</literal> tags, include a <literal>class</literal> element. All persistent entity classes (again, there might be dependent classes later on, which are not first-class entities) need such a mapping, to a table in the SQL database:"
msgstr ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"Event\" table=\"EVENTS\">\n"
      "\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"

#: index.docbook:155
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr "Hasta ahora dijimos a Hibernate c&#x00f3;mo persistir y cargar el objeto de clase <literal>Event</literal> a la tabla <literal>EVENTS</literal>, cada instancia representada por una fila en esta tabla. Ahora continuamos con un mapeo de la propiedad de identificado &#x00fa;nico a la clave primaria de la tabla. Adem&#x00e1;s, como no queremos cuidar del manejo de este identificador, configuramos la estrategia de generaci&#x00f3;n de identificadores para una columna clave primaria delegada:"

#: index.docbook:157
msgid "So far we told Hibernate how to persist and load object of class <literal>Event</literal> to the table <literal>EVENTS</literal>, each instance represented by a row in that table. Now we continue with a mapping of the unique identifier property to the tables primary key. In addition, as we don't want to care about handling this identifier, we configure Hibernate's identifier generation strategy for a surrogate primary key column:"
msgstr ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"Event\" table=\"EVENTS\">\n"
      "        <id name=\"id\" column=\"EVENT_ID\">\n"
      "            <generator class=\"increment\"/>\n"
      "        </id>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"

#: index.docbook:165
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "        <id name=\"id\" column=\"EVENT_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr "El elemento <literal>id</literal> el la declaraci&#x00f3;n de la propiedad identificadora, <literal>name=\"id\"</literal> declara el nombre de la propiedad Java. Hibernate usar&#x00e1; los m&#x00e9;todos getter y setter para acceder a la propiedad. El attributo de columna dice a Hibernate cu&#x00e1;l columna de la tabla <literal>EVENTS</literal> usamos para esta clave primaria. El elemento anidado <literal>generator</literal> especifica la estrategia de generaci&#x00f3;n de identificadores, en este caso usamos <literal>increment</literal>, que es un m&#x00e9;todo muy simple de incremento de n&#x00fa;mero en-memoria &#x00fa;til mayormente para testeo (y tutoriales). Hibernate tambi&#x0e9;n soporta identificadores generados por base de datos, globalmente &#x00fa;nicos, as&#x00ed; como tambi&#x00e9;n asignados por aplicaci&#x00f3;n (o cualquier estrategia para la que hayas escrito una extensi&#x00f3;n)."

#: index.docbook:167
msgid "The <literal>id</literal> element is the declaration of the identifer property, <literal>name=\"id\"</literal> declares the name of the Java property - Hibernate will use the getter and setter methods to access the property. The column attribute tells Hibernate which column of the <literal>EVENTS</literal> table we use for this primary key. The nested <literal>generator</literal> element specifies the identifier generation strategy, in this case we used <literal>native</literal>, which picks the best strategy depending on the configured database (dialect). Hibernate supports database generated, globally unique, as well as application assigned identifiers (or any strategy you have written an extension for)."
msgstr "Finalmente inclu&#x00ed;mos declaraciones para las propiedades persistentes de la clases en el fichero de mapeo. Por defecto, ninguna propiedad de la clase se considera persistente:"

#: index.docbook:180
msgid "Finally we include declarations for the persistent properties of the class in the mapping file. By default, no properties of the class are considered persistent:"
msgstr ""
      "<![CDATA[\n"
      "<hibernate-mapping>\n"
      "\n"
      "    <class name=\"Event\" table=\"EVENTS\">\n"
      "        <id name=\"id\" column=\"EVENT_ID\">\n"
      "            <generator class=\"increment\"/>\n"
      "        </id>\n"
      "        <property name=\"date\" type=\"timestamp\" column=\"EVENT_DATE\"/>\n"
      "        <property name=\"title\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"

#: index.docbook:186
msgid ""
      "<![CDATA[\n"
      "<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Event\" table=\"EVENTS\">\n"
      "        <id name=\"id\" column=\"EVENT_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "        <property name=\"date\" type=\"timestamp\" column=\"EVENT_DATE\"/>\n"
      "        <property name=\"title\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr "Al igual que con el elemento <literal>id</literal>, el atributo <literal>name</literal> del elemento <literal>property</literal> dice a Hibernate c&#x00e1;les m&#x00e9;todos getter y setter usar."

#: index.docbook:188
msgid "Just as with the <literal>id</literal> element, the <literal>name</literal> attribute of the <literal>property</literal> element tells Hibernate which getter and setter methods to use. So, in this case, Hibernate will look for <literal>getDate()/setDate()</literal>, as well as <literal>getTitle()/setTitle()</literal>."
msgstr "Â¿Por qu&#x00e9; el mapeo de la propiedad <literal>date</literal> incluye el atributo <literal>column</literal>, pero el de la de <literal>title</literal> no? Sin el atributo <literal>column</literal> Hibernate usa por defecto el nombre de propiedad como nombre de columna. Esto funciona bien para <literal>title</literal>. Sin embargo, However, <literal>date</literal> es una palabra reservada en la mayor&#x00ed;a de las bases de datos, as&#x00ed; que mejor la mapeamos a un nombre diferente."

#: index.docbook:195
msgid "Why does the <literal>date</literal> property mapping include the <literal>column</literal> attribute, but the <literal>title</literal> doesn't? Without the <literal>column</literal> attribute Hibernate by default uses the property name as the column name. This works fine for <literal>title</literal>. However, <literal>date</literal> is a reserved keyword in most database, so we better map it to a different name."
msgstr "La pr&#x00f3;xima cosa interesante es que el mapeo de <literal>title</literal> carece de un atributo <literal>type</literal>. Los tipos que declaramos y usamos en el fichero de mapeo no son, como podr&#x00ed;as esperar, tipos de datos Java. Tampoco son tipos de base de datos SQL. Estos tipos son los llamados as&#x00ed; <emphasis>Tipos de mapeo de Hibernate</emphasis>, convertidores que pueden traducir de tipos Java a SQL y vice versa. De nuevo, Hibernate intentar&#x00e1; determinar la conversi&#x00f3;n y el mapeo mismo de tipo correctos si el atributo <literal>type</literal> no estuviese presente en el mapeo. En algunos casos esta detecci&#x00f3;n autom&#x00e1;tica (usando reflecci&#x00f3;n en la clase Java) puede no tener lo que esperas o necesitas. Este es el caso de la propiedad <literal>date</literal>. Hibernate no puede saber is la propiedad mapear&#x00e1; a una columna <literal>date</literal>, <literal>timestamp</literal> o <literal>time</literal>. Declaramos que queremos preservar la informaci&#x00f3;n completa de fecha y hora mapeando la propiedad con un <literal>timestamp</literal>."

#: index.docbook:204
msgid "The next interesting thing is that the <literal>title</literal> mapping also lacks a <literal>type</literal> attribute. The types we declare and use in the mapping files are not, as you might expect, Java data types. They are also not SQL database types. These types are so called <emphasis>Hibernate mapping types</emphasis>, converters which can translate from Java to SQL data types and vice versa. Again, Hibernate will try to determine the correct conversion and mapping type itself if the <literal>type</literal> attribute is not present in the mapping. In some cases this automatic detection (using Reflection on the Java class) might not have the default you expect or need. This is the case with the <literal>date</literal> property. Hibernate can't know if the property (which is of <literal>java.util.Date</literal>) should map to a SQL <literal>date</literal>, <literal>timestamp</literal>, or <literal>time</literal> column. We preserve full date and time information by mapping the property with a <literal>timestamp</literal> converter."
msgstr "Este fichero de mapeo debe ser salvado como <literal>Event.hbm.xml</literal>, justo en el directorio pr&#x00f3;ximo al fichero de c&#x00f3;digo fuente de la clase Java <literal>Event</literal>. El nombrado de los ficheros de mapeo puede ser arbitrario, sin embargo, el sufijo <literal>hbm.xml</literal> se ha vuelto una convenci&#x00f3;n el la comunidad de desarrolladores de Hibernate. La estructura de directorio debe ahora verse como esto:"

#: index.docbook:220
msgid "This mapping file should be saved as <literal>Event.hbm.xml</literal>, right in the directory next to the <literal>Event</literal> Java class source file. The naming of mapping files can be arbitrary, however the <literal>hbm.xml</literal> suffix is a convention in the Hibernate developer community. The directory structure should now look like this:"
msgstr ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  Event.java\n"
      "  Event.hbm.xml]]>"

#: index.docbook:228
msgid ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java\n"
      "    Event.hbm.xml]]>"
msgstr "Continuamos con la configuraci&#x00f3;n principal de Hibernate."

#: index.docbook:230
msgid "We continue with the main configuration of Hibernate."
msgstr "Configuraci&#x00f3;n de Hibernate"

#: index.docbook:237
msgid "Hibernate configuration"
msgstr "Tenemos ahora una clase persistente y su fichero de mapeo en su sitio. Es momento de configurar Hibernate. Antes que hagamos esto, necesitaremos una base de datos. HSQL DB, un DBMS SQL en-memoria basado en Java, puede ser descargado del sitio web de HSQL DB. Realmente, de esta descarga s&#x00f3;lo necesitas el <literal>hsqldb.jar</literal>. Coloca este fichero en el directorio <literal>lib/</literal> de la carpeta de desarrollo."

#: index.docbook:239
msgid "We now have a persistent class and its mapping file in place. It is time to configure Hibernate. Before we do this, we will need a database. HSQL DB, a java-based SQL DBMS, can be downloaded from the HSQL DB website(http://hsqldb.org/). Actually, you only need the <literal>hsqldb.jar</literal> from this download. Place this file in the <literal>lib/</literal> directory of the development folder."
msgstr "Crea un directorio llamado <literal>data</literal> en la ra&#x00ed;z del directorio de desarrollo. All&#x00ed; es donde HSQL DB almacenar&#x00e1; sus ficheros de datos."

#: index.docbook:247
msgid "Create a directory called <literal>data</literal> in the root of the development directory - this is where HSQL DB will store its data files. Now start the database by running <literal>java -classpath ../lib/hsqldb.jar org.hsqldb.Server</literal> in this data directory. You can see it start up and bind to a TCP/IP socket, this is where our application will connect later. If you want to start with a fresh database during this tutorial, shutdown HSQL DB (press <literal>CTRL + C</literal> in the window), delete all files in the <literal>data/</literal> directory, and start HSQL DB again."
msgstr "Hibernate es la capa en tu aplicaci&#x00f3;n que se conecta a esta base de datos, de modo que necesita informaci&#x00f3;n de conexi&#x00f3;n. Las conexiones se hacen a trav&#x00e9;s de un pool de conexiones JDBC, que tamb&#x00e9;n tenemos que configurar. La distribuci&#x00f3;n de Hibernate contiene muchas herramientas de pooling de conexiones JDBC de c&#x00f3;digo abierto, pero para este tutorial usaremos el pool de conexiones prefabricado dentro de Hibernate. Observa que tienes que copiar la biblioteca requerida en tu classpath y usar diferentes configuraciones de pooling de conexiones si quieres usar un software de pooling JDBC de terceros de calidad de producci&#x00f3;n."

#: index.docbook:257
msgid "Hibernate is the layer in your application which connects to this database, so it needs connection information. The connections are made through a JDBC connection pool, which we also have to configure. The Hibernate distribution contains several open source JDBC connection pooling tools, but will use the Hibernate built-in connection pool for this tutorial. Note that you have to copy the required library into your classpath and use different connection pooling settings if you want to use a production-quality third party JDBC pooling software."
msgstr "Para la configuraci&#x00f3;n de Hibernate, podemos usar un fichero <literal>hibernate.properties</literal> simple, un fichero <literal>hibernate.cfg.xml</literal> ligeramente m&#x00e1;s sofisticado, o incluso una configuraci&#x00f3;n completamente program&#x00e1;tica. La mayor&#x00ed;a de los usuarios prefieren el fichero de configuraci&#x00f3;n XML:"

#: index.docbook:267
msgid "For Hibernate's configuration, we can use a simple <literal>hibernate.properties</literal> file, a slightly more sophisticated <literal>hibernate.cfg.xml</literal> file, or even complete programmatic setup. Most users prefer the XML configuration file:"
msgstr ""
      "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
      "<!DOCTYPE hibernate-configuration PUBLIC\n"
      "        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n"
      "\n"
      "<hibernate-configuration>\n"
      "\n"
      "    <session-factory>\n"
      "\n"
      "        <!-- Database connection settings -->\n"
      "        <property name=\"connection.driver_class\">org.hsqldb.jdbcDriver</property>\n"
      "        <property name=\"connection.url\">jdbc:hsqldb:data/tutorial</property>\n"
      "        <property name=\"connection.username\">sa</property>\n"
      "        <property name=\"connection.password\"></property>\n"
      "\n"
      "        <!-- JDBC connection pool (use the built-in) -->\n"
      "        <property name=\"connection.pool_size\">1</property>\n"
      "\n"
      "        <!-- SQL dialect -->\n"
      "        <property name=\"dialect\">org.hibernate.dialect.HSQLDialect</property>\n"
      "\n"
      "        <!-- Echo all executed SQL to stdout -->\n"
      "        <property name=\"show_sql\">true</property>\n"
      "\n"
      "        <!-- Drop and re-create the database schema on startup -->\n"
      "        <property name=\"hbm2ddl.auto\">create</property>\n"
      "\n"
      "        <mapping resource=\"Event.hbm.xml\"/>\n"
      "\n"
      "    </session-factory>\n"
      "\n"
      "</hibernate-configuration>]]>"

#: index.docbook:273
msgid ""
      "<![CDATA[<?xml version='1.0' encoding='utf-8'?>\n"
      "<!DOCTYPE hibernate-configuration PUBLIC\n"
      "        \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\"\n"
      "        \"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd\">\n"
      "\n"
      "<hibernate-configuration>\n"
      "\n"
      "    <session-factory>\n"
      "\n"
      "        <!-- Database connection settings -->\n"
      "        <property name=\"connection.driver_class\">org.hsqldb.jdbcDriver</property>\n"
      "        <property name=\"connection.url\">jdbc:hsqldb:hsql://localhost</property>\n"
      "        <property name=\"connection.username\">sa</property>\n"
      "        <property name=\"connection.password\"></property>\n"
      "\n"
      "        <!-- JDBC connection pool (use the built-in) -->\n"
      "        <property name=\"connection.pool_size\">1</property>\n"
      "\n"
      "        <!-- SQL dialect -->\n"
      "        <property name=\"dialect\">org.hibernate.dialect.HSQLDialect</property>\n"
      "\n"
      "        <!-- Enable Hibernate's automatic session context management -->\n"
      "        <property name=\"current_session_context_class\">thread</property>\n"
      "\n"
      "        <!-- Disable the second-level cache  -->\n"
      "        <property name=\"cache.provider_class\">org.hibernate.cache.NoCacheProvider</property>\n"
      "\n"
      "        <!-- Echo all executed SQL to stdout -->\n"
      "        <property name=\"show_sql\">true</property>\n"
      "\n"
      "        <!-- Drop and re-create the database schema on startup -->\n"
      "        <property name=\"hbm2ddl.auto\">create</property>\n"
      "\n"
      "        <mapping resource=\"events/Event.hbm.xml\"/>\n"
      "\n"
      "    </session-factory>\n"
      "\n"
      "</hibernate-configuration>]]>"
msgstr "Observa que esta configuraci&#x00f3;n XML usa un DTD diferente. Configuramos la <literal>SessionFactory</literal> de Hibernate, una f&#x00e1;brica global responsable de una base de datos en particular. Si tienes varias bases de datos, usa varias configuraciones <literal>&lt;session-factory&gt;</literal> , usualmente en varios ficheros de configuraci&#x00f3;n (para un arranque m&#x00e1;s f&#x00e1;cil)."

#: index.docbook:275
msgid "Note that this XML configuration uses a different DTD. We configure Hibernate's <literal>SessionFactory</literal> - a global factory responsible for a particular database. If you have several databases, use several <literal>&lt;session-factory&gt;</literal> configurations, usually in several configuration files (for easier startup)."
msgstr "Los primeros cuatro elementos <literal>property</literal> contienen la configuraci&#x00f3;n necesaria para la conexi&#x00f3;n JDBC. El elemento de dialecto <literal>property</literal> especifica la variante de SQL en particular que genera Hibernate. La opci&#x00f3;n <literal>hbm2ddl.auto</literal> activa la generaci&#x00f3;n autom&#x00e1;tica de esquemas de base de datos, directamente en la base de datos. Esto, por supuesto, puede desactivarse (quitando la opci&#x00f3;n config) o redirigido a un fichero con la ayuda de la tarea de Ant <literal>SchemaExport</literal>. Finalmente, agregamos el(los) fichero(s) de mapeo para clases persistentes."

#: index.docbook:283
msgid "The first four <literal>property</literal> elements contain the necessary configuration for the JDBC connection. The dialect <literal>property</literal> element specifies the particular SQL variant Hibernate generates. Hibernate's automatic session management for persistence contexts will come in handy as you will soon see. The <literal>hbm2ddl.auto</literal> option turns on automatic generation of database schemas - directly into the database. This can of course also be turned off (by removing the config option) or redirected to a file with the help of the <literal>SchemaExport</literal> Ant task. Finally, we add the mapping file(s) for persistent classes to the configuration."
msgstr "Copia este fichero dentro del directorio de c&#x00f3;digo fuente, de modo que termine ubicado en la rai&#x00ed;z del classpath. Hibernate busca autom&#x00e1;ticamente un fichero llamado <literal>hibernate.cfg.xml</literal> en la ra&#x00ed;z del classpath al arrancar."

#: index.docbook:296
msgid "Copy this file into the source directory, so it will end up in the root of the classpath. Hibernate automatically looks for a file called <literal>hibernate.cfg.xml</literal> in the root of the classpath, on startup."
msgstr "Construyendo con Ant"

#: index.docbook:305
msgid "Building with Ant"
msgstr "Construiremos ahora el tutorial con Ant. Necesitar&#x00e1;s tener Ant instalado. Obt&#x00e9;nlo de <ulink url=\"http://ant.apache.org/bindownload.cgi\">P&#x00e1;gina de descarga de Ant</ulink>. No se cubrir&#x00e1; aqu&#x00ed; c&#x00f3;mo instalar Ant. Por favor refi&#x00e9;rete al <ulink url=\"http://ant.apache.org/manual/index.html\"> Manual de Ant</ulink>. Despu&#x00e9;s que hayas instalado Ant, podemos comenzar a crear el buildfile. Ser&#x00e1; llamado <literal>build.xml</literal> y colocado directamente en el directorio de desarrollo."

#: index.docbook:307
msgid "We'll now build the tutorial with Ant. You will need to have Ant installed - get it from the <ulink url=\"http://ant.apache.org/bindownload.cgi\">Ant download page</ulink>. How to install Ant will not be covered here. Please refer to the <ulink url=\"http://ant.apache.org/manual/index.html\">Ant manual</ulink>. After you have installed Ant, we can start to create the buildfile. It will be called <literal>build.xml</literal> and placed directly in the development directory."
msgstr "Reparar Ant"

#: index.docbook:316
msgid "A basic build file looks like this:"
msgstr "Observa que la distribuci&#x00f3;n de Ant est&#x00e1; por defecto rota (como se describe en el FAQ de Ant) y tiene que ser reparado por ti, por ejemplo, si quisieras usar JUnit desde dentro de tu fichero de construcci&#x00f3;n. Para hacer que funcione la tarea de JUnit (no lo necesitaremos en este tutorial), copia junit.jar a <literal>ANT_HOME/lib</literal> o quita el trozo de plugin <literal>ANT_HOME/lib/ant-junit.jar</literal>."

#: index.docbook:320
msgid ""
      "<![CDATA[<project name=\"hibernate-tutorial\" default=\"compile\">\n"
      "\n"
      "    <property name=\"sourcedir\" value=\"${basedir}/src\"/>\n"
      "    <property name=\"targetdir\" value=\"${basedir}/bin\"/>\n"
      "    <property name=\"librarydir\" value=\"${basedir}/lib\"/>\n"
      "\n"
      "    <path id=\"libraries\">\n"
      "        <fileset dir=\"${librarydir}\">\n"
      "            <include name=\"*.jar\"/>\n"
      "        </fileset>\n"
      "    </path>\n"
      "\n"
      "    <target name=\"clean\">\n"
      "        <delete dir=\"${targetdir}\"/>\n"
      "        <mkdir dir=\"${targetdir}\"/>\n"
      "    </target>\n"
      "\n"
      "    <target name=\"compile\" depends=\"clean, copy-resources\">\n"
      "      <javac srcdir=\"${sourcedir}\"\n"
      "             destdir=\"${targetdir}\"\n"
      "             classpathref=\"libraries\"/>\n"
      "    </target>\n"
      "\n"
      "    <target name=\"copy-resources\">\n"
      "        <copy todir=\"${targetdir}\">\n"
      "            <fileset dir=\"${sourcedir}\">\n"
      "                <exclude name=\"**/*.java\"/>\n"
      "            </fileset>\n"
      "        </copy>\n"
      "    </target>\n"
      "\n"
      "</project>]]>"
msgstr "Un fichero de construcci&#x00f3;n b&#x00e1;sico se ve como esto:"

#: index.docbook:322
msgid "This will tell Ant to add all files in the lib directory ending with <literal>.jar</literal> to the classpath used for compilation. It will also copy all non-Java source files to the target directory, e.g. configuration and Hibernate mapping files. If you now run Ant, you should get this output:"
msgstr ""
      "<![CDATA[<project name=\"hibernate-tutorial\" default=\"compile\">\n"
      "\n"
      "    <property name=\"sourcedir\" value=\"${basedir}/src\"/>\n"
      "    <property name=\"targetdir\" value=\"${basedir}/bin\"/>\n"
      "    <property name=\"librarydir\" value=\"${basedir}/lib\"/>\n"
      "\n"
      "    <path id=\"libraries\">\n"
      "        <fileset dir=\"${librarydir}\">\n"
      "            <include name=\"*.jar\"/>\n"
      "        </fileset>\n"
      "    </path>\n"
      "\n"
      "    <target name=\"clean\">\n"
      "        <delete dir=\"${targetdir}\"/>\n"
      "        <mkdir dir=\"${targetdir}\"/>\n"
      "    </target>\n"
      "\n"
      "    <target name=\"compile\" depends=\"clean, copy-resources\">\n"
      "      <javac srcdir=\"${sourcedir}\"\n"
      "             destdir=\"${targetdir}\"\n"
      "             classpathref=\"libraries\"/>\n"
      "    </target>\n"
      "\n"
      "    <target name=\"copy-resources\">\n"
      "        <copy todir=\"${targetdir}\">\n"
      "            <fileset dir=\"${sourcedir}\">\n"
      "                <exclude name=\"**/*.java\"/>\n"
      "            </fileset>\n"
      "        </copy>\n"
      "    </target>\n"
      "\n"
      "</project>]]>"

#: index.docbook:329
msgid ""
      "<![CDATA[C:\\hibernateTutorial\\>ant\n"
      "Buildfile: build.xml\n"
      "\n"
      "copy-resources:\n"
      "     [copy] Copying 2 files to C:\\hibernateTutorial\\bin\n"
      "\n"
      "compile:\n"
      "    [javac] Compiling 1 source file to C:\\hibernateTutorial\\bin\n"
      "\n"
      "BUILD SUCCESSFUL\n"
      "Total time: 1 second ]]>"
msgstr "Esto dir&#x00e1; a Ant que agregue todos los ficheros en el directorio lib que terminen con <literal>.jar</literal> al classpath usado para la compilaci&#x00f3;n. Tambi&#x00e9;n copiar&#x00e1; todos los ficheros que no sean c&#x00f3;digo Java al directorio objetivo, por ejemplo, ficheros de configuraci&#x00f3;n y mapeos de Hibernate. Si ahora corres Ant, debes obtener esta salida:"

#: index.docbook:334
msgid "Startup and helpers"
msgstr ""
      "<![CDATA[C:\\hibernateTutorial\\>ant\n"
      "Buildfile: build.xml\n"
      "\n"
      "copy-resources:\n"
      "     [copy] Copying 2 files to C:\\hibernateTutorial\\bin\n"
      "\n"
      "compile:\n"
      "    [javac] Compiling 1 source file to C:\\hibernateTutorial\\bin\n"
      "\n"
      "BUILD SUCCESSFUL\n"
      "Total time: 1 second ]]>"

#: index.docbook:336
msgid "It's time to load and store some <literal>Event</literal> objects, but first we have to complete the setup with some infrastructure code. We have to startup Hibernate. This startup includes building a global <literal>SessionFactory</literal> object and to store it somewhere for easy access in application code. A <literal>SessionFactory</literal> can open up new <literal>Session</literal>'s. A <literal>Session</literal> represents a single-threaded unit of work, the <literal>SessionFactory</literal> is a thread-safe global object, instantiated once."
msgstr "Arranque y ayudantes"

#: index.docbook:346
msgid "We'll create a <literal>HibernateUtil</literal> helper class which takes care of startup and makes accessing a <literal>SessionFactory</literal> convenient. Let's have a look at the implementation:"
msgstr "Es momento de cargar y almacenar algunos objetos <literal>Event</literal>, pero primero tenemos que completar la configuraci&#x00f3;n de alg&#x00fa;n c&#x00f3;digo de infraestructura. Tenemos que arrancar Hibernate. Este arranque incluye construir un objeto <literal>SessionFactory</literal> global y almacenarlo en alg&#x00fa;n sitio de f&#x00e1;cil acceso en el c&#x00f3;digo de aplicaci&#x00f3;n. Una <literal>SessionFactory</literal> puede abrir nuevas <literal>Session</literal>'s. Una <literal>Session</literal> representa un unidad de trabajo mono-hebra. La <literal>SessionFactory</literal> es un objeto global seguro entre hebras, instanciado una sola vez."

#: index.docbook:352
msgid ""
      "<![CDATA[package util;\n"
      "\n"
      "import org.hibernate.*;\n"
      "import org.hibernate.cfg.*;\n"
      "\n"
      "public class HibernateUtil {\n"
      "\n"
      "    private static final SessionFactory sessionFactory;\n"
      "\n"
      "    static {\n"
      "        try {\n"
      "            // Create the SessionFactory from hibernate.cfg.xml\n"
      "            sessionFactory = new Configuration().configure().buildSessionFactory();\n"
      "        } catch (Throwable ex) {\n"
      "            // Make sure you log the exception, as it might be swallowed\n"
      "            System.err.println(\"Initial SessionFactory creation failed.\" + ex);\n"
      "            throw new ExceptionInInitializerError(ex);\n"
      "        }\n"
      "    }\n"
      "\n"
      "    public static SessionFactory getSessionFactory() {\n"
      "        return sessionFactory;\n"
      "    }\n"
      "\n"
      "}]]>"
msgstr "Crearemos una clase de ayuda <literal>HibernateUtil</literal> que cuide del arranque y haga conveniente el manejo de <literal>Session</literal>. El as&#x00ed; llamado patr&#x00f3;n <emphasis>Sesi&#x00f3;n de Hebra Local (ThreadLocal Session)</emphasis> es &#x00fa;til aqu&#x00ed;; mantenemos la unidad de trabajo actual asociada a la hebra actual. Echemos una mirada a la implementaci&#x00f3;n:"

#: index.docbook:354
msgid "This class does not only produce the global <literal>SessionFactory</literal> in its static initializer (called once by the JVM when the class is loaded), but also hides the fact that it uses a static singleton. It might as well lookup the <literal>SessionFactory</literal> from JNDI in an application server."
msgstr ""
      "<![CDATA[import org.hibernate.*;\n"
      "import org.hibernate.cfg.*;\n"
      "\n"
      "public class HibernateUtil {\n"
      "\n"
      "    public static final SessionFactory sessionFactory;\n"
      "\n"
      "    static {\n"
      "        try {\n"
      "            // Create the SessionFactory from hibernate.cfg.xml\n"
      "            sessionFactory = new Configuration().configure().buildSessionFactory();\n"
      "        } catch (Throwable ex) {\n"
      "            // Make sure you log the exception, as it might be swallowed\n"
      "            System.err.println(\"Initial SessionFactory creation failed.\" + ex);\n"
      "            throw new ExceptionInInitializerError(ex);\n"
      "        }\n"
      "    }\n"
      "\n"
      "    public static final ThreadLocal session = new ThreadLocal();\n"
      "\n"
      "    public static Session currentSession() throws HibernateException {\n"
      "        Session s = (Session) session.get();\n"
      "        // Open a new Session, if this thread has none yet\n"
      "        if (s == null) {\n"
      "            s = sessionFactory.openSession();\n"
      "            // Store it in the ThreadLocal variable\n"
      "            session.set(s);\n"
      "        }\n"
      "        return s;\n"
      "    }\n"
      "\n"
      "    public static void closeSession() throws HibernateException {\n"
      "        Session s = (Session) session.get();\n"
      "        if (s != null)\n"
      "            s.close();\n"
      "        session.set(null);\n"
      "    }\n"
      "}]]>"

#: index.docbook:361
msgid "If you give the <literal>SessionFactory</literal> a name in your configuration file, Hibernate will in fact try to bind it to JNDI after it has been built. To avoid this code completely you could also use JMX deployment and let the JMX-capable container instantiate and bind a <literal>HibernateService</literal> to JNDI. These advanced options are discussed in the Hibernate reference documentation."
msgstr "Esta clase no &#x00f3;lo produce la <literal>SessionFactory</literal> global en su inicializador static (llamado s&#x00f3;lo una vez por la JVM al cargar la clase), sino que tambi&#x00e9;n tiene una variable <literal>ThreadLocal</literal> para tener la <literal>Session</literal> para la hebra actual. No importa cu&#x00e1;ndo llames a <literal>HibernateUtil.currentSession()</literal>, siempre devolver&#x00e1; la misma unidad de trabajo de Hibernate en la misma hebra. Una llamada a <literal>HibernateUtil.closeSession()</literal> termina la unidad de trabajo actualmente asociada a la hebra."

#: index.docbook:370
msgid "Place <literal>HibernateUtil.java</literal> in the development source directory, in a package next to <literal>events</literal>:"
msgstr "Aseg&#x00fa;rate de entender el concepto Java de una variable local a una hebra antes de usar esta ayuda. Una clase <literal>HibernateUtil</literal> m&#x00e1;s potente puede encontrarse en <literal>CaveatEmptor</literal>, http://caveatemptor.hibernate.org/, as&#x00ed; como en el libro \"Java Persistence with Hibernate\". Observa que esta clase no es necesaria si despliegas Hibernate en un servidor de aplicaciones J2EE: una <literal>Session</literal> ser&#x00e1; autom&#x00e1;ticamente ligada a la transacci&#x00f3;n JTA actual, y puedes buscar la <literal>SessionFactory</literal> a trav&#x00e9;s de JNDI. Si usas JBoss AS, Hibernate puede ser desplegado como un servicio de sistema manejado y autom&#x00e1;ticamente ligar&#x00e1; la <literal>SessionFactory</literal> a un nombre JNDI."

#: index.docbook:375
msgid ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  +events\n"
      "    Event.java\n"
      "    Event.hbm.xml\n"
      "  +util\n"
      "    HibernateUtil.java\n"
      "  hibernate.cfg.xml\n"
      "+data\n"
      "build.xml]]>"
msgstr "Coloca <literal>HibernateUtil.java</literal> en el directorio de fuentes de desarrollo, junto a <literal>Event.java</literal>:"

#: index.docbook:377
msgid "This should again compile without problems. We finally need to configure a logging system - Hibernate uses commons logging and leaves you the choice between Log4j and JDK 1.4 logging. Most developers prefer Log4j: copy <literal>log4j.properties</literal> from the Hibernate distribution (it's in the <literal>etc/</literal> directory) to your <literal>src</literal> directory, next to <literal>hibernate.cfg.xml</literal>. Have a look at the example configuration and change the settings if you like to have more verbose output. By default, only Hibernate startup message are shown on stdout."
msgstr ""
      "<![CDATA[.\n"
      "+lib\n"
      "  <Hibernate and third-party libraries>\n"
      "+src\n"
      "  Event.java\n"
      "  Event.hbm.xml\n"
      "  HibernateUtil.java\n"
      "  hibernate.cfg.xml\n"
      "+data\n"
      "build.xml]]>"

#: index.docbook:387
msgid "The tutorial infrastructure is complete - and we are ready to do some real work with Hibernate."
msgstr "Esto tambi&#x00e9;n debe compilar sin problemas. Finalmente necesitamos configurar un sistema de logging (registro). Hibernate usa commons logging y te deja la elecci&#x00f3;n entre Log4J y logging de JDK 1.4. La mayor&#x00ed;a de los desarrolladores prefieren Log4J: copia <literal>log4j.properties</literal> de la distribuci&#x00f3;n de Hibernate (est&#x00e1; en el directorio <literal>etc/</literal>) a tu directorio <literal>src</literal>, junto a <literal>hibernate.cfg.xml</literal>. Echa una mirada a la configuraci&#x00f3;n de ejemplo y cambia los ajustes si te gusta tener una salida m&#x00e1;s verborr&#x00e1;gica. Por defecto, s&#x00f3;lo se muestra el mensaje de arranque de Hibernate en la salida."

#: index.docbook:395
msgid "Loading and storing objects"
msgstr "La infraestructura del tutorial est&#x00e1; completa, y estamos listos para hacer alg&#x00fa;n trabajo real con Hibernate."

#: index.docbook:397
msgid "Finally, we can use Hibernate to load and store objects. We write an <literal>EventManager</literal> class with a <literal>main()</literal> method:"
msgstr "Cargando y almacenando objetos"

#: index.docbook:402
msgid ""
      "<![CDATA[package events;\n"
      "import org.hibernate.Session;\n"
      "\n"
      "import java.util.Date;\n"
      "\n"
      "import util.HibernateUtil;\n"
      "\n"
      "public class EventManager {\n"
      "\n"
      "    public static void main(String[] args) {\n"
      "        EventManager mgr = new EventManager();\n"
      "\n"
      "        if (args[0].equals(\"store\")) {\n"
      "            mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "        }\n"
      "\n"
      "        HibernateUtil.getSessionFactory().close();\n"
      "    }\n"
      "\n"
      "    private void createAndStoreEvent(String title, Date theDate) {\n"
      "\n"
      "        Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "\n"
      "        session.beginTransaction();\n"
      "\n"
      "        Event theEvent = new Event();\n"
      "        theEvent.setTitle(title);\n"
      "        theEvent.setDate(theDate);\n"
      "\n"
      "        session.save(theEvent);\n"
      "\n"
      "        session.getTransaction().commit();\n"
      "    }\n"
      "\n"
      "}]]>"
msgstr "Finalmente, podemos usar Hibernate para cargar y almacenar objetos. Escribimos una clase <literal>EventManager</literal> con un m&#x00e9;todo <literal>main()</literal>:"

#: index.docbook:404
msgid "We create a new <literal>Event</literal> object, and hand it over to Hibernate. Hibernate now takes care of the SQL and executes <literal>INSERT</literal>s on the database. Let's have a look at the <literal>Session</literal> and <literal>Transaction</literal>-handling code before we run this."
msgstr ""
      "<![CDATA[import org.hibernate.Transaction;\n"
      "import org.hibernate.Session;\n"
      "\n"
      "import java.util.Date;\n"
      "\n"
      "public class EventManager {\n"
      "\n"
      "    public static void main(String[] args) {\n"
      "        EventManager mgr = new EventManager();\n"
      "\n"
      "        if (args[0].equals(\"store\")) {\n"
      "            mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "        }\n"
      "\n"
      "        HibernateUtil.sessionFactory.close();\n"
      "    }\n"
      "\n"
      "}]]>"

#: index.docbook:411
msgid "A <literal>Session</literal> is a single unit of work. For now we'll keep things simple and assume a one-to-one granularity between a Hibernate <literal>Session</literal> and a database transaction. To shield our code from the actual underlying transaction system (in this case plain JDBC, but it could also run with JTA) we use the <literal>Transaction</literal> API that is available on the Hibernate <literal>Session</literal>."
msgstr "Leemos algunos argumentos de la l&#x00ed;nea de comandos, y si el primer argumento es \"store\", creamos y almacenamos un nuevo Event:"

#: index.docbook:419
msgid "What does <literal>sessionFactory.getCurrentSession()</literal> do? First, you can call it as many times and anywhere you like, once you get hold of your <literal>SessionFactory</literal> (easy thanks to <literal>HibernateUtil</literal>). The <literal>getCurrentSession()</literal> method always returns the \"current\" unit of work. Remember that we switched the configuration option for this mechanism to \"thread\" in <literal>hibernate.cfg.xml</literal>? Hence, the current unit of work is bound to the current Java thread that executes our application. However, this is not the full picture, you also have to consider scope, when a unit of work begins and when it ends."
msgstr ""
      "<![CDATA[private void createAndStoreEvent(String title, Date theDate) {\n"
      "    Session session = HibernateUtil.currentSession();\n"
      "    Transaction tx = session.beginTransaction();\n"
      "\n"
      "    Event theEvent = new Event();\n"
      "    theEvent.setTitle(title);\n"
      "    theEvent.setDate(theDate);\n"
      "\n"
      "    session.save(theEvent);\n"
      "\n"
      "    tx.commit();\n"
      "    HibernateUtil.closeSession();\n"
      "}]]>"

#: index.docbook:430
msgid "A <literal>Session</literal> begins when it is first needed, when the first call to <literal>getCurrentSession()</literal> is made. It is then bound by Hibernate to the current thread. When the transaction ends, either through commit or rollback, Hibernate automatically unbinds the <literal>Session</literal> from the thread and closes it for you. If you call <literal>getCurrentSession()</literal> again, you get a new <literal>Session</literal> and can start a new unit of work. This <emphasis>thread-bound</emphasis> programming model is the most popular way of using Hibernate, as it allows flexible layering of your code (transaction demarcation code can be separated from data access code, we'll do this later in this tutorial)."
msgstr "Creamos un nuevo objeto <literal>Event</literal>, y se lo damos a Hibernate. Hibernate cuida ahora del SQL y ejecuta <literal>INSERT</literal>s en la base de datos. Echemos una mirada al c&#x00f3;digo de manejo de <literal>Session</literal> y <literal>Transaction</literal> antes de ejecutar esto."

#: index.docbook:441
msgid "Related to the unit of work scope, should the Hibernate <literal>Session</literal> be used to execute one or several database operations? The above example uses one <literal>Session</literal> for one operation. This is pure coincidence, the example is just not complex enough to show any other approach. The scope of a Hibernate <literal>Session</literal> is flexible but you should never design your application to use a new Hibernate <literal>Session</literal> for <emphasis>every</emphasis> database operation. So even if you see it a few more times in the following (very trivial) examples, consider <emphasis>session-per-operation</emphasis> an anti-pattern. A real (web) application is shown later in this tutorial."
msgstr "Una <literal>Session</literal> es una sola unidad de trabajo. Podr&#x00ed;a sorprenderte que tengamos una API adicional, <literal>Transaction</literal>. Esto implica que una unidad de trabajo puede ser \"m&#x00e1;s larga\" que una sola transacci&#x00f3;n de base de datos; imagina una unidad de trabajo que se abarca varios ciclos petici&#x00f3;n/respuesta HTTP (por ejemplo, un di&#x00e1;logo asistente) en una aplicaci&#x00f3;n web. Separar las transacciones de base de datos de \"las unidades de trabajo de la aplicaci&#x00f3;n desde el punto de vista del usuario\" es uno de los conceptos b&#x00e1;sicos de dise&#x00f1;o de Hibernate. Llamamos una unidad de trabajo larga <emphasis>Transacci&#x00f3;n de Aplicaci&#x00f3;n</emphasis>, usualmente encapsulando varias transacciones de base de datos m&#x00e1;s cortas. Por ahora mantendremos las cosas simples y asumiremos una granularidad uno-a-uno entre una <literal>Session</literal> y una <literal>Transaction</literal>."

#: index.docbook:452
msgid "Have a look at <xref linkend=\"transactions\"/> for more information about transaction handling and demarcation. We also skipped any error handling and rollback in the previous example."
msgstr "Â¿Qu&#x00e9; es lo que hacen <literal>Transaction.begin()</literal> y <literal>commit()</literal>? Â¿D&#x00f3;nde est&#x00e1; el rollback en caso que algo vaya mal? La API de <literal>Transaction</literal> de Hibernate es opcional realmente, pero la usamos por conveniencia y portabilidad. Si manejases la transacci&#x00f3;n de base de datos por ti mismo (por ejemplo, llamando a <literal>session.connection.commit()</literal>), ligar&#x00ed;as el c&#x00f3;digo a un entorno de despliegue particular, en este JDBC directo no manejado. Estableciendo la f&#x00e1;brica de <literal>Transaction</literal> en tu configuraci&#x00f3;n de Hibernate puedes desplegar tu capa de persistencia en cualquier sitio. Echa una mirada al <xref linkend=\"transactions\"/> para m&#x00e1;s informaci&#x00f3;n sobre manejo y demarcaci&#x00f3;n de transacciones. Hemos saltado tambi&#x00e9;n cualquier manejo de excepciones y rollback en este ejemplo."

#: index.docbook:458
msgid "To run this first routine we have to add a callable target to the Ant build file:"
msgstr "Para ejecutar la primera rutina tenemos que agregar un objetivo llamable al fichero de construcci&#x00f3;n de Ant:"

#: index.docbook:462
msgid ""
      "<![CDATA[<target name=\"run\" depends=\"compile\">\n"
      "    <java fork=\"true\" classname=\"events.EventManager\" classpathref=\"libraries\">\n"
      "        <classpath path=\"${targetdir}\"/>\n"
      "        <arg value=\"${action}\"/>\n"
      "    </java>\n"
      "</target>]]>"
msgstr ""
      "<![CDATA[<target name=\"run\" depends=\"compile\">\n"
      "    <java fork=\"true\" classname=\"EventManager\" classpathref=\"libraries\">\n"
      "        <classpath path=\"${targetdir}\"/>\n"
      "        <arg value=\"${action}\"/>\n"
      "    </java>\n"
      "</target>]]>"

#: index.docbook:464
msgid "The value of the <literal>action</literal> argument is set on the command line when calling the target:"
msgstr "El valor del argumento <literal>action</literal> es establecido por l&#x00ed;nea de comandos al llamar al objetivo:"

#: index.docbook:469
msgid "<![CDATA[C:\\hibernateTutorial\\>ant run -Daction=store]]>"
msgstr "<![CDATA[C:\\hibernateTutorial\\>ant run -Daction=store]]>"

#: index.docbook:471
msgid "You should see, after compilation, Hibernate starting up and, depending on your configuration, lots of log output. At the end you will find the following line:"
msgstr "Debes ver, despu&#x00e9;s de la compilaci&#x00f3;n, a Hibernate arrancando y, dependiendo de tu configuraci&#x00f3;n mucha salida de registro (log). Al final encontrar&#x00e1;s la siguiente l&#x00ed;nea:"

#: index.docbook:476
msgid "<![CDATA[[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)]]>"
msgstr "<![CDATA[[java] Hibernate: insert into EVENTS (EVENT_DATE, title, EVENT_ID) values (?, ?, ?)]]>"

#: index.docbook:478
msgid "This is the <literal>INSERT</literal> executed by Hibernate, the question marks represent JDBC bind parameters. To see the values bound as arguments, or to reduce the verbosity of the log, check your <literal>log4j.properties</literal>."
msgstr "Esta es la <literal>INSERT</literal> ejecutada por Hibernate, los signos de preguntas representan par&#x00e1;metros de ligado JDBC. Para ver los valores ligados como argumentos, o para reducir la verborragia del registro, chequea tu <literal>log4j.properties</literal>."

#: index.docbook:484
msgid "Now we'd like to list stored events as well, so we add an option to the main method:"
msgstr "Ahora quisi&#x00e9;ramos listar acontecimientos almacenados tambi&#x00e9;n, as&#x00ed; que agregamos una opci&#x00f3;n al m&#x00e9;todo principal:"

#: index.docbook:488
msgid ""
      "<![CDATA[if (args[0].equals(\"store\")) {\n"
      "    mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "}\n"
      "else if (args[0].equals(\"list\")) {\n"
      "    List events = mgr.listEvents();\n"
      "    for (int i = 0; i < events.size(); i++) {\n"
      "        Event theEvent = (Event) events.get(i);\n"
      "        System.out.println(\"Event: \" + theEvent.getTitle() +\n"
      "                           \" Time: \" + theEvent.getDate());\n"
      "    }\n"
      "}]]>"
msgstr ""
      "<![CDATA[if (args[0].equals(\"store\")) {\n"
      "    mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "}\n"
      "else if (args[0].equals(\"list\")) {\n"
      "    List events = mgr.listEvents();\n"
      "    for (int i = 0; i < events.size(); i++) {\n"
      "        Event theEvent = (Event) events.get(i);\n"
      "        System.out.println(\"Event: \" + theEvent.getTitle() +\n"
      "                           \" Time: \" + theEvent.getDate());\n"
      "    }\n"
      "}]]>"

#: index.docbook:490
msgid "We also add a new <literal>listEvents() method</literal>:"
msgstr "Agregamos tambi&#x00e9;n un nuevo m&#x00e9;todo <literal>listEvents()</literal>:"

#: index.docbook:494
msgid ""
      "<![CDATA[private List listEvents() {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "\n"
      "    session.beginTransaction();\n"
      "\n"
      "    List result = session.createQuery(\"from Event\").list();\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "\n"
      "    return result;\n"
      "}]]>"
msgstr ""
      "<![CDATA[private List listEvents() {\n"
      "    Session session = HibernateUtil.currentSession();\n"
      "    Transaction tx = session.beginTransaction();\n"
      "\n"
      "    List result = session.createQuery(\"from Event\").list();\n"
      "\n"
      "    tx.commit();\n"
      "    session.close();\n"
      "\n"
      "    return result;\n"
      "}]]>"

#: index.docbook:496
msgid "What we do here is use an HQL (Hibernate Query Language) query to load all existing <literal>Event</literal> objects from the database. Hibernate will generate the appropriate SQL, send it to the database and populate <literal>Event</literal> objects with the data. You can create more complex queries with HQL, of course."
msgstr "Lo que hacemos aqu&#x00ed; es usar una consulta HQL (Lenguaje de Consulta de Hibernate o Hibernate Query Language) para cargar todos los objetos <literal>Event</literal> existentes de la base de datos. Hibernate generar&#x00e1; el SQL apropiado, lo enviar&#x00e1; a la base de datosy poblar&#x00e1; los objetos <literal>Event</literal> con datos. Puedes, por supuesto, crear consultas m&#x00e1;s complejas con HQL."

#: index.docbook:503
msgid "Now, to execute and test all of this, follow these steps:"
msgstr "Si ahora llamas a Ant con <literal>-Daction=list</literal>, debes ver los eventos que has almacenado hasta ahora. Puede sorprenderte que esto no funcione, al menos si has seguido este tutorial paso por paso; el resultado siempre estar&#x00e1; vac&#x00ed;o. La razon de esto es la opci&#x00f3;n <literal>hbm2ddl.auto</literal> en la configuraci&#x00f3;n de Hibernate: Hibernate recrear&#x00e1; la base de datos en cada ejecuci&#x00f3;n. Deshabil&#x00ed;tala quitando la opci&#x00f3;n, y ver&#x00e1;s resultados en tu listado despu&#x00e9;s que llames a la acci&#x00f3;n <literal>store</literal> unas cuantas veces. La generaci&#x00f3;n y exportaci&#x00f3;n de esquema es &#x00fa;til mayormente en testeo unitario."

#: index.docbook:509
msgid "Run <literal>ant run -Daction=store</literal> to store something into the database and, of course, to generate the database schema before through hbm2ddl."
msgstr "Part 2 - Mapeando asociaciones"

#: index.docbook:515
msgid "Now disable hbm2ddl by commenting out the property in your <literal>hibernate.cfg.xml</literal> file. Usually you only leave it turned on in continous unit testing, but another run of hbm2ddl would <emphasis>drop</emphasis> everything you have stored - the <literal>create</literal> configuration setting actually translates into \"drop all tables from the schema, then re-create all tables, when the SessionFactory is build\"."
msgstr "Hemos mapeado un clase de entidad persistente a una tabla. Construyamos sobre esto y agreguemos algunas asociaciones de clase. Primero agregaremos personas a nuestra aplicaci&#x00f3;n, y almacenaremos una lista de eventos en las que participan."

#: index.docbook:525
msgid "If you now call Ant with <literal>-Daction=list</literal>, you should see the events you have stored so far. You can of course also call the <literal>store</literal> action a few times more."
msgstr "Mapeando la clase Person"

#: index.docbook:531
msgid "Note: Most new Hibernate users fail at this point and we see questions about <emphasis>Table not found</emphasis> error messages regularly. However, if you follow the steps outlined above you will not have this problem, as hbm2ddl creates the database schema on the first run, and subsequent application restarts will use this schema. If you change the mapping and/or database schema, you have to re-enable hbm2ddl once again."
msgstr "El primer corte de la clase <literal>Person</literal> es simple:"

#: index.docbook:544
msgid "Part 2 - Mapping associations"
msgstr ""
      "<![CDATA[public class Person {\n"
      "\n"
      "    private Long id;\n"
      "    private int age;\n"
      "    private String firstname;\n"
      "    private String lastname;\n"
      "\n"
      "    Person() {}\n"
      "\n"
      "    // Accessor methods for all properties, private setter for 'id'\n"
      "\n"
      "}]]>"

#: index.docbook:546
msgid "We mapped a persistent entity class to a table. Let's build on this and add some class associations. First we'll add people to our application, and store a list of events they participate in."
msgstr "Crea un fichero de mapeo llamado <literal>Person.hbm.xml</literal>:"

#: index.docbook:552
msgid "Mapping the Person class"
msgstr ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"Person\" table=\"PERSON\">\n"
      "        <id name=\"id\" column=\"PERSON_ID\">\n"
      "            <generator class=\"increment\"/>\n"
      "        </id>\n"
      "        <property name=\"age\"/>\n"
      "        <property name=\"firstname\"/>\n"
      "        <property name=\"lastname\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"

#: index.docbook:554
msgid "The first cut of the <literal>Person</literal> class is simple:"
msgstr "Finalmente, agrega el nuevo mapeo a la configuraci&#x00f3;n de Hibernate:"

#: index.docbook:558
msgid ""
      "<![CDATA[package events;\n"
      "\n"
      "public class Person {\n"
      "\n"
      "    private Long id;\n"
      "    private int age;\n"
      "    private String firstname;\n"
      "    private String lastname;\n"
      "\n"
      "    public Person() {}\n"
      "\n"
      "    // Accessor methods for all properties, private setter for 'id'\n"
      "\n"
      "}]]>"
msgstr ""
      "<![CDATA[        <mapping resource=\"Event.hbm.xml\"/>\n"
      "        <mapping resource=\"Person.hbm.xml\"/>\n"
      "]]>"

#: index.docbook:560
msgid "Create a new mapping file called <literal>Person.hbm.xml</literal> (don't forget the DTD reference at the top):"
msgstr "Crearemos ahora una asociaci&#x00f3;n entre estas dos entidades. Obviamente, las personas pueden participar en eventos, y los eventos tienen participantes. Las cuestiones de dise&#x00f1;o con que tenemos que tratar son: direccionalidad, multiplicidad y comportamiento de colecci&#x00f3;n."

#: index.docbook:565
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class name=\"events.Person\" table=\"PERSON\">\n"
      "        <id name=\"id\" column=\"PERSON_ID\">\n"
      "            <generator class=\"native\"/>\n"
      "        </id>\n"
      "        <property name=\"age\"/>\n"
      "        <property name=\"firstname\"/>\n"
      "        <property name=\"lastname\"/>\n"
      "    </class>\n"
      "\n"
      "</hibernate-mapping>]]>"
msgstr "Una asociaci&#x00f3;n unidireccional basada en Set"

#: index.docbook:567
msgid "Finally, add the new mapping to Hibernate's configuration:"
msgstr "Agregaremos una colecci&#x00f3;n de eventos a la clase <literal>Person</literal>. De esta forma podemos navegar facilmente a los eventos de una persona en particular, sin ejecutar una consulta expl&#x00ed;cita, llamando a <literal>aPerson.getEvents()</literal>. Usamos una colecci&#x00f3;n Java, un <literal>Set</literal>, porque la colecci&#x00f3;n no contendr&#x00e1; elementos duplicados y el ordenamiento no nos es relevante."

#: index.docbook:571
msgid ""
      "<![CDATA[<mapping resource=\"events/Event.hbm.xml\"/>\n"
      "<mapping resource=\"events/Person.hbm.xml\"/>]]>"
msgstr "Hasta ahora hemos dise&#x00f1;ado asociaciones unidireccionales multivaluadas, implementadas con un <literal>Set</literal>. Escribamos el c&#x00f3;digo para esto en las clases Java y luego lo mapeemos:"

#: index.docbook:573
msgid "We'll now create an association between these two entities. Obviously, persons can participate in events, and events have participants. The design questions we have to deal with are: directionality, multiplicity, and collection behavior."
msgstr ""
      "<![CDATA[public class Person {\n"
      "\n"
      "    private Set events = new HashSet();\n"
      "\n"
      "    public Set getEvents() {\n"
      "        return events;\n"
      "    }\n"
      "\n"
      "    public void setEvents(Set events) {\n"
      "        this.events = events;\n"
      "    }\n"
      "}]]>"

#: index.docbook:583
msgid "A unidirectional Set-based association"
msgstr "Antes que mapeemos esta asociaci&#x00f3;n, piensa sobre el otro lado. Claramente, podemos mantener esto solamente unidireccional. O podemos crear otra colecci&#x00f3;n en el <literal>Event</literal>, si queremos ser capaces de navegarlos bidireccionalmente; por ejemplo, <literal>anEvent.getParticipants()</literal>. Esta es una elecci&#x00f3;n de dise&#x00f1;o que recae en ti, pero lo que est&#x00e1; claro de esta discusi&#x00f3;n es la multiplicidad de la asociaci&#x00f3;n: \"multi\" valuada a ambos lados, llamamos a esto una asociaci&#x00f3;n <emphasis>muchos-a-muchos</emphasis>. Por lo tanto, usamos un mapeo many-to-many de Hibernate:"

#: index.docbook:585
msgid "We'll add a collection of events to the <literal>Person</literal> class. That way we can easily navigate to the events for a particular person, without executing an explicit query - by calling <literal>aPerson.getEvents()</literal>. We use a Java collection, a <literal>Set</literal>, because the collection will not contain duplicate elements and the ordering is not relevant for us."
msgstr ""
      "<![CDATA[<class name=\"Person\" table=\"PERSON\">\n"
      "    <id name=\"id\" column=\"PERSON_ID\">\n"
      "        <generator class=\"increment\"/>\n"
      "    </id>\n"
      "    <property name=\"age\"/>\n"
      "    <property name=\"firstname\"/>\n"
      "    <property name=\"lastname\"/>\n"
      "\n"
      "    <set name=\"events\" table=\"PERSON_EVENT\">\n"
      "        <key column=\"PERSON_ID\"/>\n"
      "        <many-to-many column=\"EVENT_ID\" class=\"Event\"/>\n"
      "    </set>\n"
      "\n"
      "</class>]]>"

#: index.docbook:592
msgid "We need a unidirectional, many-valued associations, implemented with a <literal>Set</literal>. Let's write the code for this in the Java classes and then map it:"
msgstr "Hibernate soporta todo tipo de mapeos de colecci&#x00f3;n, siendo el m&#x00e1;s com&#x00fa;n un <literal>&lt;set&gt;</literal>. Para una asociaci&#x00f3;n muchos-a-muchos (o relaci&#x00f3;n de entidad <emphasis>n:m</emphasis>), se necesita una tabla de asociaci&#x00f3;n. Cada fila en esta tabla representa un enlace entre una persona y un evento. Esta tabla se configura con el atributo <literal>table</literal> del elemento <literal>set</literal>. El nombre de la columna identificadora en la asociaci&#x00f3;n, para el lado de la persona, se define con el elemento <literal>&lt;key&gt;</literal>. El nombre de columna para el lado del evento se define con el atributo <literal>column</literal> del <literal>&lt;many-to-many&gt;</literal>. Tambi&#x00e9;n tienes que decirle a Hibernate la clase de los objetos en tu colecci&#x00f3;n (correcto: la clase del otro lado de la colecci&#x00f3;n de referencias)."

#: index.docbook:597
msgid ""
      "<![CDATA[public class Person {\n"
      "\n"
      "    private Set events = new HashSet();\n"
      "\n"
      "    public Set getEvents() {\n"
      "        return events;\n"
      "    }\n"
      "\n"
      "    public void setEvents(Set events) {\n"
      "        this.events = events;\n"
      "    }\n"
      "}]]>"
msgstr "El esquema de base de datos para este mapeo es, por lo tanto:"

#: index.docbook:599
msgid "Before we map this association, think about the other side. Clearly, we could just keep this unidirectional. Or, we could create another collection on the <literal>Event</literal>, if we want to be able to navigate it bi-directional, i.e. <literal>anEvent.getParticipants()</literal>. This is not necessary, from a functional perspective. You could always execute an explicit query to retrieve the participants for a particular event. This is a design choice left to you, but what is clear from this discussion is the multiplicity of the association: \"many\" valued on both sides, we call this a <emphasis>many-to-many</emphasis> association. Hence, we use Hibernate's many-to-many mapping:"
msgstr ""
      "<![CDATA[\n"
      "    _____________        __________________\n"
      "   |             |      |                  |       _____________\n"
      "   |   EVENTS    |      |   PERSON_EVENT   |      |             |\n"
      "   |_____________|      |__________________|      |    PERSON   |\n"
      "   |             |      |                  |      |_____________|\n"
      "   | *EVENT_ID   | <--> | *EVENT_ID        |      |             |\n"
      "   |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  |\n"
      "   |  TITLE      |      |__________________|      |  AGE        |\n"
      "   |_____________|                                |  FIRSTNAME  |\n"
      "                                                  |  LASTNAME   |\n"
      "                                                  |_____________|\n"
      " ]]>"

#: index.docbook:610
msgid ""
      "<![CDATA[<class name=\"events.Person\" table=\"PERSON\">\n"
      "    <id name=\"id\" column=\"PERSON_ID\">\n"
      "        <generator class=\"native\"/>\n"
      "    </id>\n"
      "    <property name=\"age\"/>\n"
      "    <property name=\"firstname\"/>\n"
      "    <property name=\"lastname\"/>\n"
      "\n"
      "    <set name=\"events\" table=\"PERSON_EVENT\">\n"
      "        <key column=\"PERSON_ID\"/>\n"
      "        <many-to-many column=\"EVENT_ID\" class=\"events.Event\"/>\n"
      "    </set>\n"
      "\n"
      "</class>]]>"
msgstr "Trabajando la asociaci&#x00f3;n"

#: index.docbook:612
msgid "Hibernate supports all kinds of collection mappings, a <literal>&lt;set&gt;</literal> being most common. For a many-to-many association (or <emphasis>n:m</emphasis> entity relationship), an association table is needed. Each row in this table represents a link between a person and an event. The table name is configured with the <literal>table</literal> attribute of the <literal>set</literal> element. The identifier column name in the association, for the person's side, is defined with the <literal>&lt;key&gt;</literal> element, the column name for the event's side with the <literal>column</literal> attribute of the <literal>&lt;many-to-many&gt;</literal>. You also have to tell Hibernate the class of the objects in your collection (correct: the class on the other side of the collection of references)."
msgstr "Traigamos alguna gente y eventos juntos en un nuevo m&#x00e9;todo en <literal>EventManager</literal>:"

#: index.docbook:624
msgid "The database schema for this mapping is therefore:"
msgstr ""
      "<![CDATA[private void addPersonToEvent(Long personId, Long eventId) {\n"
      "    Session session = HibernateUtil.currentSession();\n"
      "    Transaction tx = session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session.load(Person.class, personId);\n"
      "    Event anEvent = (Event) session.load(Event.class, eventId);\n"
      "\n"
      "    aPerson.getEvents().add(anEvent);\n"
      "\n"
      "    tx.commit();\n"
      "    HibernateUtil.closeSession();\n"
      "}]]>"

#: index.docbook:628
msgid ""
      "<![CDATA[\n"
      "    _____________        __________________\n"
      "   |             |      |                  |       _____________\n"
      "   |   EVENTS    |      |   PERSON_EVENT   |      |             |\n"
      "   |_____________|      |__________________|      |    PERSON   |\n"
      "   |             |      |                  |      |_____________|\n"
      "   | *EVENT_ID   | <--> | *EVENT_ID        |      |             |\n"
      "   |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  |\n"
      "   |  TITLE      |      |__________________|      |  AGE        |\n"
      "   |_____________|                                |  FIRSTNAME  |\n"
      "                                                  |  LASTNAME   |\n"
      "                                                  |_____________|\n"
      " ]]>"
msgstr "Despu&#x00e9;s de cargar una <literal>Person</literal> y un <literal>Event</literal>, simplemente modifica la colecci&#x00f3;n usando sus m&#x00e9;todos normales. Como puedes ver, no hay una llamada expl&#x00ed;cita a <literal>update()</literal> o <literal>save()</literal>. Hibernate detecta autom&#x00e1;ticamente que la colecci&#x00f3;n ha sido modificada y necesita ser salvada. Esto es llamado <emphasis>chequeo sucio autom&#x00f3;tico (automatic dirty checking)</emphasis>, y tambi&#x00e9;n puedes intentarlo modificando el nombre de la propiedad de fecha de cualquiera de tus objetos. Mientras est&#x00e9;n en estado <emphasis>persistente</emphasis>, esto es, ligados a una <literal>Session</literal> de Hibernate particular (es decir, justo han sido cargados o almacenados en una unidad de trabajo), Hibernate monitoriza cualquier cambio y ejecuta SQL en estilo escribe-por-detr&#x00e1;s. El proceso de sincronizaci&#x00f3;n del estado de memoria con la base de datos, usualmente s&#x00f3;lo al final de una unidad de trabajo, es llamado <emphasis>limpieza (flushing)</emphasis>."

#: index.docbook:633
msgid "Working the association"
msgstr "Podr&#x00ed;as, por supuesto, cargar persona y evento en unidades de trabajo diferentes. O modificas un objeto fuera de una <literal>Session</literal>, cuando no est&#x00e1; en estado persistente (si antes era persistente llamamos a este estado <emphasis>separado (detached) </emphasis>). En c&#x00f3;digo (no muy realista), esto se ver&#x00ed;a como sigue:"

#: index.docbook:635
msgid "Let's bring some people and events together in a new method in <literal>EventManager</literal>:"
msgstr ""
      "<![CDATA[    private void addPersonToEvent(Long personId, Long eventId) {\n"
      "\n"
      "        Session session = HibernateUtil.currentSession();\n"
      "        Transaction tx = session.beginTransaction();\n"
      "\n"
      "        Person aPerson = (Person) session.load(Person.class, personId);\n"
      "        Event anEvent = (Event) session.load(Event.class, eventId);\n"
      "\n"
      "        tx.commit();\n"
      "        HibernateUtil.closeSession();\n"
      "\n"
      "        aPerson.getEvents().add(anEvent); // aPerson is detached\n"
      "\n"
      "        Session session2 = HibernateUtil.currentSession();\n"
      "        Transaction tx2 = session.beginTransaction();\n"
      "\n"
      "        session2.update(aPerson); // Reattachment of aPerson\n"
      "\n"
      "        tx2.commit();\n"
      "        HibernateUtil.closeSession();\n"
      "    }\n"
      "]]>"

#: index.docbook:639
msgid ""
      "<![CDATA[private void addPersonToEvent(Long personId, Long eventId) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session.load(Person.class, personId);\n"
      "    Event anEvent = (Event) session.load(Event.class, eventId);\n"
      "\n"
      "    aPerson.getEvents().add(anEvent);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "}]]>"
msgstr "La llamada a <literal>update</literal> hace a un objeto persistente de nuevo, podr&#x00ed;as decir que la liga a una nueva unidad de trabajo, de modo que cualquier modificaci&#x00f3;n que le hagas mientras est&#x00e9; separado puede ser salvada a base de datos."

#: index.docbook:641
msgid "After loading a <literal>Person</literal> and an <literal>Event</literal>, simply modify the collection using the normal collection methods. As you can see, there is no explicit call to <literal>update()</literal> or <literal>save()</literal>, Hibernate automatically detects that the collection has been modified and needs to be updated. This is called <emphasis>automatic dirty checking</emphasis>, and you can also try it by modifying the name or the date property of any of your objects. As long as they are in <emphasis>persistent</emphasis> state, that is, bound to a particular Hibernate <literal>Session</literal> (i.e. they have been just loaded or saved in a unit of work), Hibernate monitors any changes and executes SQL in a write-behind fashion. The process of synchronizing the memory state with the database, usually only at the end of a unit of work, is called <emphasis>flushing</emphasis>. In our code, the unit of work ends with a commit (or rollback) of the database transaction - as defined by the <literal>thread</literal> configuration option for the <literal>CurrentSessionContext</literal> class."
msgstr "Bueno, esto no es muy usado en nuestra situaci&#x00f3;n actual, pero es un concepto importante que puedes dise&#x00f1;ar en tu propia aplicaci&#x00f3;n. Por ahora, completa este ejercicio agregando una nueva acci&#x00f3;n al m&#x00e9;todo main de <literal>EventManager</literal> y ll&#x00e1;mala desde la l&#x00ed;nea de comandos. Si necesitas los identificadores de una persona o evento, el m&#x00e9;todo <literal>save()</literal> los devuelve."

#: index.docbook:656
msgid "You might of course load person and event in different units of work. Or you modify an object outside of a <literal>Session</literal>, when it is not in persistent state (if it was persistent before, we call this state <emphasis>detached</emphasis>). You can even modify a collection when it is detached:"
msgstr "Esto fue un ejemplo de una asociaci&#x00f3;n entre dos clases igualmente importantes, dos entidades. Como se ha mencionado anteriormente, hay otras clases y tipos en un modelo t&#x00ed;pico, usualmente \"menos importantes\". Algunos ya los habr&#x00e1;s visto, como un <literal>int</literal> o un <literal>String</literal>. Llamamos a estas clases <emphasis>tipos de valor (value types)</emphasis>, y sus instancias <emphasis>dependen</emphasis> de una entidad en particular. Las instancias de estos tipos no tienen su propia identidad, ni son compartidas entre entidades (dos personas no referencian el mismo objeto <literal>firstname</literal>, incluso si tuvieran el mismo primer nombre). Por supuesto, los tipos de valor no s&#x00f3;lo pueden encontrarse en el JDK (de hecho, en una aplicaci&#x00f3;n Hibernate todas las clases del JDK son consideradas tipos de valor), sino que adem&#x00e1;s puedes escribir por ti mismo clases dependientes, por ejemplo, <literal>Address</literal> o <literal>MonetaryAmount</literal>."

#: index.docbook:663
msgid ""
      "<![CDATA[private void addPersonToEvent(Long personId, Long eventId) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session\n"
      "            .createQuery(\"select p from Person p left join fetch p.events where p.id = :pid\")\n"
      "            .setParameter(\"pid\", personId)\n"
      "            .uniqueResult(); // Eager fetch the collection so we can use it detached\n"
      "\n"
      "    Event anEvent = (Event) session.load(Event.class, eventId);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "\n"
      "    // End of first unit of work\n"
      "\n"
      "    aPerson.getEvents().add(anEvent); // aPerson (and its collection) is detached\n"
      "\n"
      "    // Begin second unit of work\n"
      "\n"
      "    Session session2 = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session2.beginTransaction();\n"
      "\n"
      "    session2.update(aPerson); // Reattachment of aPerson\n"
      "\n"
      "    session2.getTransaction().commit();\n"
      "}]]>"
msgstr "Tambi&#x00e9;n puedes dise&#x00f1;ar una colecci&#x00f3;n de tipos de valor. Esto es conceptualmente muy diferente de una colecci&#x00f3;n de referencias a otras entidades, pero se ve casi lo mismo en Java."

#: index.docbook:665
msgid "The call to <literal>update</literal> makes a detached object persistent again, you could say it binds it to a new unit of work, so any modifications you made to it while detached can be saved to the database. This includes any modifications (additions/deletions) you made to a collection of that entity object."
msgstr "Colecci&#x00f3;n de valores"

#: index.docbook:672
msgid "Well, this is not much use in our current situation, but it's an important concept you can design into your own application. For now, complete this exercise by adding a new action to the <literal>EventManager</literal>'s main method and call it from the command line. If you need the identifiers of a person and an event - the <literal>save()</literal> method returns it (you might have to modify some of the previous methods to return that identifier):"
msgstr "Agregamos una colecci&#x00f3;n de objetos tipificados en valor a la entidad <literal>Person</literal>. Queremos almacenar direcciones de email, de modo que el tipo que usamos es <literal>String</literal>, y la colecci&#x00f3;n es nuevamente un <literal>Set</literal>:"

#: index.docbook:680
msgid ""
      "<![CDATA[else if (args[0].equals(\"addpersontoevent\")) {\n"
      "    Long eventId = mgr.createAndStoreEvent(\"My Event\", new Date());\n"
      "    Long personId = mgr.createAndStorePerson(\"Foo\", \"Bar\");\n"
      "    mgr.addPersonToEvent(personId, eventId);\n"
      "    System.out.println(\"Added person \" + personId + \" to event \" + eventId);\n"
      "}]]>"
msgstr ""
      "<![CDATA[private Set emailAddresses = new HashSet();\n"
      "\n"
      "public Set getEmailAddresses() {\n"
      "    return emailAddresses;\n"
      "}\n"
      "\n"
      "public void setEmailAddresses(Set emailAddresses) {\n"
      "    this.emailAddresses = emailAddresses;\n"
      "}]]>"

#: index.docbook:682
msgid "This was an example of an association between two equally important classes, two entities. As mentioned earlier, there are other classes and types in a typical model, usually \"less important\". Some you have already seen, like an <literal>int</literal> or a <literal>String</literal>. We call these classes <emphasis>value types</emphasis>, and their instances <emphasis>depend</emphasis> on a particular entity. Instances of these types don't have their own identity, nor are they shared between entities (two persons don't reference the same <literal>firstname</literal> object, even if they have the same first name). Of course, value types can not only be found in the JDK (in fact, in a Hibernate application all JDK classes are considered value types), but you can also write dependent classes yourself, <literal>Address</literal> or <literal>MonetaryAmount</literal>, for example."
msgstr "El mapeo de este <literal>Set</literal>:"

#: index.docbook:695
msgid "You can also design a collection of value types. This is conceptually very different from a collection of references to other entities, but looks almost the same in Java."
msgstr ""
      "<![CDATA[<set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR\">\n"
      "    <key column=\"PERSON_ID\"/>\n"
      "    <element type=\"string\" column=\"EMAIL_ADDR\"/>\n"
      "</set>]]>"

#: index.docbook:703
msgid "Collection of values"
msgstr "La diferencia comparada con el mapeo anterior es la parte <literal>element</literal>, que le dice a Hibernate que la colecci&#x00f3;n no contiene referencias a otra entidad, sino una colecci&#x00f3;n de elementos de tipo <literal>String</literal> (el nombre en min&#x00fa;sculas te dice que es un tipo/conversor de mapeo de Hibernate). Una vez m&#x00e1;s, el atributo <literal>table</literal> del elemento <literal>set</literal> determina el nombre de la tabla para la colecci&#x00f3;n. El elemento <literal>key</literal> define el nombre de la columna clave for&#x00e1;nea en la tabla de colecci&#x00f3;n. El atributo <literal>column</literal> en el elemento <literal>element</literal> define el nombre de columna donde realmente ser&#x00e1;n almacenados los valores <literal>String</literal>."

#: index.docbook:705
msgid "We add a collection of value typed objects to the <literal>Person</literal> entity. We want to store email addresses, so the type we use is <literal>String</literal>, and the collection is again a <literal>Set</literal>:"
msgstr "Echa una mirada al esquema actualizado:"

#: index.docbook:710
msgid ""
      "<![CDATA[private Set emailAddresses = new HashSet();\n"
      "\n"
      "public Set getEmailAddresses() {\n"
      "    return emailAddresses;\n"
      "}\n"
      "\n"
      "public void setEmailAddresses(Set emailAddresses) {\n"
      "    this.emailAddresses = emailAddresses;\n"
      "}]]>"
msgstr ""
      "<![CDATA[\n"
      "  _____________        __________________\n"
      " |             |      |                  |       _____________\n"
      " |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________\n"
      " |_____________|      |__________________|      |    PERSON   |      |                   |\n"
      " |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |\n"
      " | *EVENT_ID   | <--> | *EVENT_ID        |      |             |      |___________________|\n"
      " |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  | <--> |  *PERSON_ID       |\n"
      " |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |\n"
      " |_____________|                                |  FIRSTNAME  |      |___________________|\n"
      "                                                |  LASTNAME   |\n"
      "                                                |_____________|\n"
      " ]]>"

#: index.docbook:712
msgid "The mapping of this <literal>Set</literal>:"
msgstr "Puedes ver que la clave primaria de la tabla de colecci&#x00f3;n es de hecho una clave compuesta, usando ambas columnas. Esto implica tambi&#x00e9;n que no pueden haber direcciones de email duplicadas por persona, que es exactamente la sem&#x00e1;ntica que necesitamos para un conjunto en Java."

#: index.docbook:716
msgid ""
      "<![CDATA[<set name=\"emailAddresses\" table=\"PERSON_EMAIL_ADDR\">\n"
      "    <key column=\"PERSON_ID\"/>\n"
      "    <element type=\"string\" column=\"EMAIL_ADDR\"/>\n"
      "</set>]]>"
msgstr "Puedes ahora intentar y agregar elementos a esta colecci&#x00f3;n, al igual que hicimos antes enlazando personas y eventos. Es el mismo c&#x00f3;digo en Java."

#: index.docbook:718
msgid "The difference compared with the earlier mapping is the <literal>element</literal> part, which tells Hibernate that the collection does not contain references to another entity, but a collection of elements of type <literal>String</literal> (the lowercase name tells you it's a Hibernate mapping type/converter). Once again, the <literal>table</literal> attribute of the <literal>set</literal> element determines the table name for the collection. The <literal>key</literal> element defines the foreign-key column name in the collection table. The <literal>column</literal> attribute in the <literal>element</literal> element defines the column name where the <literal>String</literal> values will actually be stored."
msgstr "Asociaciones bidireccionales"

#: index.docbook:728
msgid "Have a look at the updated schema:"
msgstr "A continuacion vamos a mapear una asociaci&#x00f3;n bidireccional, haciendo que la asociaci&#x00f3;n entre persona y evento funcione desde ambos lados en Java. Por supuesto, el esquema de base de datos no cambia; todav&#x00ed;a necesitamos multiplicidad muchos-a-muchos. Una base de datos relacional es m&#x00e1;s flexible que un lenguaje de programaci&#x00f3;n de red, as&#x00ed; que no necesita nada parecido a una direcci&#x00f3;n de navegaci&#x00f3;n; los datos pueden ser vistos y recuperados en cualquier forma posible."

#: index.docbook:732
msgid ""
      "<![CDATA[\n"
      "  _____________        __________________\n"
      " |             |      |                  |       _____________\n"
      " |   EVENTS    |      |   PERSON_EVENT   |      |             |       ___________________\n"
      " |_____________|      |__________________|      |    PERSON   |      |                   |\n"
      " |             |      |                  |      |_____________|      | PERSON_EMAIL_ADDR |\n"
      " | *EVENT_ID   | <--> | *EVENT_ID        |      |             |      |___________________|\n"
      " |  EVENT_DATE |      | *PERSON_ID       | <--> | *PERSON_ID  | <--> |  *PERSON_ID       |\n"
      " |  TITLE      |      |__________________|      |  AGE        |      |  *EMAIL_ADDR      |\n"
      " |_____________|                                |  FIRSTNAME  |      |___________________|\n"
      "                                                |  LASTNAME   |\n"
      "                                                |_____________|\n"
      " ]]>"
msgstr "Primero agrega una colecci&#x00f3;n de participantes a la clase de eventos <literal>Event</literal>:"

#: index.docbook:734
msgid "You can see that the primary key of the collection table is in fact a composite key, using both columns. This also implies that there can't be duplicate email addresses per person, which is exactly the semantics we need for a set in Java."
msgstr ""
      "<![CDATA[private Set participants = new HashSet();\n"
      "\n"
      "public Set getParticipants() {\n"
      "    return participants;\n"
      "}\n"
      "\n"
      "public void setParticipants(Set participants) {\n"
      "    this.participants = participants;\n"
      "}]]>"

#: index.docbook:740
msgid "You can now try and add elements to this collection, just like we did before by linking persons and events. It's the same code in Java:"
msgstr "Ahora mapea este lado de la asociaci&#x00f3;n tambi&#x00e9;n, en <literal>Event.hbm.xml</literal>."

#: index.docbook:745
msgid ""
      "<![CDATA[private void addEmailToPerson(Long personId, String emailAddress) {\n"
      "\n"
      "    Session session = HibernateUtil.getSessionFactory().getCurrentSession();\n"
      "    session.beginTransaction();\n"
      "\n"
      "    Person aPerson = (Person) session.load(Person.class, personId);\n"
      "\n"
      "    // The getEmailAddresses() might trigger a lazy load of the collection\n"
      "    aPerson.getEmailAddresses().add(emailAddress);\n"
      "\n"
      "    session.getTransaction().commit();\n"
      "}]]>"
msgstr ""
      "<![CDATA[<set name=\"participants\" table=\"PERSON_EVENT\" inverse=\"true\">\n"
      "    <key column=\"EVENT_ID\"/>\n"
      "    <many-to-many column=\"PERSON_ID\" class=\"Person\"/>\n"
      "</set>]]>"

#: index.docbook:747
msgid "This time we didnt' use a <emphasis>fetch</emphasis> query to initialize the collection. Hence, the call to its getter method will trigger an additional select to initialize it, so we can add an element to it. Monitor the SQL log and try to optimize this with an eager fetch."
msgstr "Como ves, estos son mapeos normales de <literal>set</literal> en ambos documentos de mapeo. Nota que los nombres de columnas en <literal>key</literal> y <literal>many-to-many</literal> fueron permutados en ambos documentos de mapeo. Aqu&#x00ed; la adici&#x00f3;n m&#x00e1;s importante es el atributo <literal>inverse=\"true\"</literal> en el elemento <literal>set</literal> del mapeo de colecci&#x00f3;n de <literal>Event</literal>."

#: index.docbook:757
msgid "Bi-directional associations"
msgstr "Lo que esto significa es que Hibernate debe tomar el otro lado - la clase <literal>Person</literal> - cuando necesite descubrir informaci&#x00f3;n sobre el enlace entre las dos. Esto ser&#x00e1; mucho m&#x00e1;s f&#x00e1;cil de entender una vez que veas c&#x00f3;mo se crea el enlace bidireccional entre nuestras dos entidades."

#: index.docbook:759
msgid "Next we are going to map a bi-directional association - making the association between person and event work from both sides in Java. Of course, the database schema doesn't change, we still have many-to-many multiplicity. A relational database is more flexible than a network programming language, so it doesn't need anything like a navigation direction - data can be viewed and retrieved in any possible way."
msgstr "Trabajando enlaces bidireccionales"

#: index.docbook:767
msgid "First, add a collection of participants to the <literal>Event</literal> Event class:"
msgstr "Primero, ten en mente que Hhibernate no afecta la sem&#x00e1;ntica normal de Java. Â¿C&#x00f3;mo hemos creado un enlace entre una <literal>Person</literal> y un <literal>Event</literal> en el ejemplo unidireccional? Hemos agregado una instancia de <literal>Event</literal> a la colecci&#x00f3;n de referencias de eventos de una instancia de <literal>Person</literal>. De modo que, obviamente, si queremos que este enlace funcione bidireccionalmente, tenemos que hacer lo mismo del otro lado, agregando una referencia a <literal>Person</literal> a la colecci&#x00f3;n en un <literal>Event</literal>. Este \"establecer el enlace a ambos lados\" es absolutamente necesario y nunca debes olvidar hacerlo."

#: index.docbook:771
msgid ""
      "<![CDATA[private Set participants = new HashSet();\n"
      "\n"
      "public Set getParticipants() {\n"
      "    return participants;\n"
      "}\n"
      "\n"
      "public void setParticipants(Set participants) {\n"
      "    this.participants = participants;\n"
      "}]]>"
msgstr "Muchos desarrolladores programan a la defensiva y crean m&#x00e9;todos de manejo de un enlace para establecer correctamente ambos lados, por ejemplo en <literal>Person</literal>:"

#: index.docbook:773
msgid "Now map this side of the association too, in <literal>Event.hbm.xml</literal>."
msgstr ""
      "<![CDATA[protected Set getEvents() {\n"
      "    return events;\n"
      "}\n"
      "\n"
      "protected void setEvents(Set events) {\n"
      "    this.events = events;\n"
      "}\n"
      "\n"
      "public void addToEvent(Event event) {\n"
      "    this.getEvents().add(event);\n"
      "    event.getParticipants().add(this);\n"
      "}\n"
      "\n"
      "public void removeFromEvent(Event event) {\n"
      "    this.getEvents().remove(event);\n"
      "    event.getParticipants().remove(this);\n"
      "}]]>"

#: index.docbook:777
msgid ""
      "<![CDATA[<set name=\"participants\" table=\"PERSON_EVENT\" inverse=\"true\">\n"
      "    <key column=\"EVENT_ID\"/>\n"
      "    <many-to-many column=\"PERSON_ID\" class=\"events.Person\"/>\n"
      "</set>]]>"
msgstr "Nota que los m&#x00e9;todos get y set para esta colecci&#x00f3;n son ahora protegidos. Esto le permite a clases en el mismo paquete y a subclases acceder a&#x00fa;n a los m&#x00e9;todos, pero previene a cualquier otro de ensuciarse con la colecci&#x00f3;n directamente (bueno, casi). Probablemente debas hacer lo mismo con la colecci&#x00f3;n al otro lado."

#: index.docbook:779
msgid "As you see, these are normal <literal>set</literal> mappings in both mapping documents. Notice that the column names in <literal>key</literal> and <literal>many-to-many</literal> are swapped in both mapping documents. The most important addition here is the <literal>inverse=\"true\"</literal> attribute in the <literal>set</literal> element of the <literal>Event</literal>'s collection mapping."
msgstr "Y Â¿qu&#x00e9; del atributo de mapeo <literal>inverse</literal>? Para ti, y para Java, un enlace bidireccional es simplemente cuesti&#x00f3;n de establecer correctamente las referencias a ambos lados. Hibernate, sin embargo, no tiene suficiente informaci&#x00f3;n para arreglar correctamente sentencias <literal>INSERT</literal> y <literal>UPDATE</literal> de SQL (para evitar violaci&#x00f3;n de restricciones), y necesita alguna ayuda para manejar asociaciones bidireccionales apropiadamente. El hacer un lado de la asociaci&#x00f3;n <literal>inverse</literal> le dice a Hibernate que basicamente lo ignore, que lo considere un <emphasis>espejo</emphasis> del otro lado. Esto es todo lo necesario para que Hibernate resuelva todas las incidencias al transformar un modelo de navegaci&#x00f3;n direccional a un esquema SQL de base de datos. Las reglas que tienes que recordar son directas: Todas las asociaciones bidireccionales necesitan uno de los lados como <literal>inverse</literal>. En una asociaci&#x00f3;n uno-a-muchos debe ser el lado-de-muchos. En una asociaci&#x00f3;n muchos-a-muchos, puedes tomar cualquier lado, no hay diferencia."

#: index.docbook:787
msgid "What this means is that Hibernate should take the other side - the <literal>Person</literal> class - when it needs to find out information about the link between the two. This will be a lot easier to understand once you see how the bi-directional link between our two entities is created ."
msgstr "Summary"

#: index.docbook:796
msgid "Working bi-directional links"
msgstr "Este tutorial cubri&#x00f3; los fundamentos de escribir una simple aplicaci&#x00f3;n independiente de Hibernate."

#: index.docbook:798
msgid "First, keep in mind that Hibernate does not affect normal Java semantics. How did we create a link between a <literal>Person</literal> and an <literal>Event</literal> in the unidirectional example? We added an instance of <literal>Event</literal> to the collection of event references, of an instance of <literal>Person</literal>. So, obviously, if we want to make this link working bi-directional, we have to do the same on the other side - adding a <literal>Person</literal> reference to the collection in an <literal>Event</literal>. This \"setting the link on both sides\" is absolutely necessary and you should never forget doing it."
msgstr "Si ya te sientes confidente con Hibernate, contin&#x00fa;a navegando a trav&#x00e9;s de la tabla de contenidos de la documentaci&#x00f3;n de referencia para los temas que encuentres interesantes. Los m&#x00e1;s consultados son procesamiento transaccional (<xref linkend=\"transactions\"/>), rendimiento de recuperaci&#x00f3;n (<xref linkend=\"performance\"/>), o el uso de la API (<xref linkend=\"objectstate\"/>) y las funcionalidades de consulta (<xref linkend=\"objectstate-querying\"/>)."

#: index.docbook:808
msgid "Many developers program defensive and create link management methods to correctly set both sides, e.g. in <literal>Person</literal>:"
msgstr "No olvides chequear el sitio web de Hibernate por m&#x00e1;s (especializados) tutoriales."

#: index.docbook:813
msgid ""
      "<![CDATA[protected Set getEvents() {\n"
      "    return events;\n"
      "}\n"
      "\n"
      "protected void setEvents(Set events) {\n"
      "    this.events = events;\n"
      "}\n"
      "\n"
      "public void addToEvent(Event event) {\n"
      "    this.getEvents().add(event);\n"
      "    event.getParticipants().add(this);\n"
      "}\n"
      "\n"
      "public void removeFromEvent(Event event) {\n"
      "    this.getEvents().remove(event);\n"
      "    event.getParticipants().remove(this);\n"
      "}]]>"
msgstr ""

#: index.docbook:815
msgid "Notice that the get and set methods for the collection are now protected - this allows classes in the same package and subclasses to still access the methods, but prevents everybody else from messing with the collections directly (well, almost). You should probably do the same with the collection on the other side."
msgstr ""

#: index.docbook:822
msgid "What about the <literal>inverse</literal> mapping attribute? For you, and for Java, a bi-directional link is simply a matter of setting the references on both sides correctly. Hibernate however doesn't have enough information to correctly arrange SQL <literal>INSERT</literal> and <literal>UPDATE</literal> statements (to avoid constraint violations), and needs some help to handle bi-directional associations properly. Making one side of the association <literal>inverse</literal> tells Hibernate to basically ignore it, to consider it a <emphasis>mirror</emphasis> of the other side. That's all that is necessary for Hibernate to work out all of the issues when transformation a directional navigation model to a SQL database schema. The rules you have to remember are straightforward: All bi-directional associations need one side as <literal>inverse</literal>. In a one-to-many association it has to be the many-side, in many-to-many association you can pick either side, there is no difference."
msgstr ""

#: index.docbook:837
msgid "Let's turn this into a small web application."
msgstr ""

#: index.docbook:844
msgid "Part 3 - The EventManager web application"
msgstr ""

#: index.docbook:846
msgid "A Hibernate web application uses <literal>Session</literal> and <literal>Transaction</literal> almost like a standalone application. However, some common patterns are useful. We now write an <literal>EventManagerServlet</literal>. This servlet can list all events stored in the database, and it provides an HTML form to enter new events."
msgstr ""

#: index.docbook:854
msgid "Writing the basic servlet"
msgstr ""

#: index.docbook:856
msgid "Create a new class in your source directory, in the <literal>events</literal> package:"
msgstr ""

#: index.docbook:861
msgid ""
      "<![CDATA[package events;\n"
      "\n"
      "// Imports\n"
      "\n"
      "public class EventManagerServlet extends HttpServlet {\n"
      "\n"
      "    // Servlet code\n"
      "}]]>"
msgstr ""

#: index.docbook:863
msgid "The servlet handles HTTP <literal>GET</literal> requests only, hence, the method we implement is <literal>doGet()</literal>:"
msgstr ""

#: index.docbook:868
msgid ""
      "<![CDATA[protected void doGet(HttpServletRequest request,\n"
      "                     HttpServletResponse response)\n"
      "        throws ServletException, IOException {\n"
      "\n"
      "    SimpleDateFormat dateFormatter = new SimpleDateFormat(\"dd.MM.yyyy\");\n"
      "\n"
      "    try {\n"
      "        // Begin unit of work\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().beginTransaction();\n"
      "\n"
      "        // Process request and render page...\n"
      "\n"
      "        // End unit of work\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().getTransaction().commit();\n"
      "\n"
      "    } catch (Exception ex) {\n"
      "        HibernateUtil.getSessionFactory()\n"
      "                .getCurrentSession().getTransaction().rollback();\n"
      "        throw new ServletException(ex);\n"
      "    }\n"
      "\n"
      "}]]>"
msgstr ""

#: index.docbook:870
msgid "The pattern we are applying here is called <emphasis>session-per-request</emphasis>. When a request hits the servlet, a new Hibernate <literal>Session</literal> is opened through the first call to <literal>getCurrentSession()</literal> on the <literal>SessionFactory</literal>. Then a database transaction is started&mdash;all data access as to occur inside a transaction, no matter if data is read or written (we don't use the auto-commit mode in applications)."
msgstr ""

#: index.docbook:879
msgid "Do <emphasis>not</emphasis> use a new Hibernate <literal>Session</literal> for every database operation. Use one Hibernate <literal>Session</literal> that is scoped to the whole request. Use <literal>getCurrentSession()</literal>, so that it is automatically bound to the current Java thread."
msgstr ""

#: index.docbook:886
msgid "Next, the possible actions of the request are processed and the response HTML is rendered. We'll get to that part soon."
msgstr ""

#: index.docbook:891
msgid "Finally, the unit of work ends when processing and rendering is complete. If any problem occured during processing or rendering, an exception will be thrown and the database transaction rolled back. This completes the <literal>session-per-request</literal> pattern. Instead of the transaction demarcation code in every servlet you could also write a servlet filter. See the Hibernate website and Wiki for more information about this pattern, called <emphasis>Open Session in View</emphasis>&mdash;you'll need it as soon as you consider rendering your view in JSP, not in a servlet."
msgstr ""

#: index.docbook:905
msgid "Processing and rendering"
msgstr ""

#: index.docbook:907
msgid "Let's implement the processing of the request and rendering of the page."
msgstr ""

#: index.docbook:911
msgid ""
      "<![CDATA[// Write HTML header\n"
      "PrintWriter out = response.getWriter();\n"
      "out.println(\"<html><head><title>Event Manager</title></head><body>\");\n"
      "\n"
      "// Handle actions\n"
      "if ( \"store\".equals(request.getParameter(\"action\")) ) {\n"
      "\n"
      "    String eventTitle = request.getParameter(\"eventTitle\");\n"
      "    String eventDate = request.getParameter(\"eventDate\");\n"
      "\n"
      "    if ( \"\".equals(eventTitle) || \"\".equals(eventDate) ) {\n"
      "        out.println(\"<b><i>Please enter event title and date.</i></b>\");\n"
      "    } else {\n"
      "        createAndStoreEvent(eventTitle, dateFormatter.parse(eventDate));\n"
      "        out.println(\"<b><i>Added event.</i></b>\");\n"
      "    }\n"
      "}\n"
      "\n"
      "// Print page\n"
      "printEventForm(out);\n"
      "listEvents(out, dateFormatter);\n"
      "\n"
      "// Write HTML footer\n"
      "out.println(\"</body></html>\");\n"
      "out.flush();\n"
      "out.close();]]>"
msgstr ""

#: index.docbook:913
msgid "Granted, this coding style with a mix of Java and HTML would not scale in a more complex application&mdash;keep in mind that we are only illustrating basic Hibernate concepts in this tutorial. The code prints an HTML header and a footer. Inside this page, an HTML form for event entry and a list of all events in the database are printed. The first method is trivial and only outputs HTML:"
msgstr ""

#: index.docbook:922
msgid ""
      "<![CDATA[private void printEventForm(PrintWriter out) {\n"
      "    out.println(\"<h2>Add new event:</h2>\");\n"
      "    out.println(\"<form>\");\n"
      "    out.println(\"Title: <input name='eventTitle' length='50'/><br/>\");\n"
      "    out.println(\"Date (e.g. 24.12.2009): <input name='eventDate' length='10'/><br/>\");\n"
      "    out.println(\"<input type='submit' name='action' value='store'/>\");\n"
      "    out.println(\"</form>\");\n"
      "}]]>"
msgstr ""

#: index.docbook:924
msgid "The <literal>listEvents()</literal> method uses the Hibernate <literal>Session</literal> bound to the current thread to execute a query:"
msgstr ""

#: index.docbook:930
msgid ""
      "<![CDATA[private void listEvents(PrintWriter out, SimpleDateFormat dateFormatter) {\n"
      "\n"
      "    List result = HibernateUtil.getSessionFactory()\n"
      "                    .getCurrentSession().createCriteria(Event.class).list();\n"
      "    if (result.size() > 0) {\n"
      "        out.println(\"<h2>Events in database:</h2>\");\n"
      "        out.println(\"<table border='1'>\");\n"
      "        out.println(\"<tr>\");\n"
      "        out.println(\"<th>Event title</th>\");\n"
      "        out.println(\"<th>Event date</th>\");\n"
      "        out.println(\"</tr>\");\n"
      "        for (Iterator it = result.iterator(); it.hasNext();) {\n"
      "            Event event = (Event) it.next();\n"
      "            out.println(\"<tr>\");\n"
      "            out.println(\"<td>\" + event.getTitle() + \"</td>\");\n"
      "            out.println(\"<td>\" + dateFormatter.format(event.getDate()) + \"</td>\");\n"
      "            out.println(\"</tr>\");\n"
      "        }\n"
      "        out.println(\"</table>\");\n"
      "    }\n"
      "}]]>"
msgstr ""

#: index.docbook:932
msgid "Finally, the <literal>store</literal> action is dispatched to the <literal>createAndStoreEvent()</literal> method, which also uses the <literal>Session</literal> of the current thread:"
msgstr ""

#: index.docbook:938
msgid ""
      "<![CDATA[protected void createAndStoreEvent(String title, Date theDate) {\n"
      "    Event theEvent = new Event();\n"
      "    theEvent.setTitle(title);\n"
      "    theEvent.setDate(theDate);\n"
      "\n"
      "    HibernateUtil.getSessionFactory()\n"
      "                    .getCurrentSession().save(theEvent);\n"
      "}]]>"
msgstr ""

#: index.docbook:940
msgid "That's it, the servlet is complete. A request to the servlet will be processed in a single <literal>Session</literal> and <literal>Transaction</literal>. As earlier in the standalone application, Hibernate can automatically bind these ojects to the current thread of execution. This gives you the freedom to layer your code and access the <literal>SessionFactory</literal> in any way you like. Usually you'd use a more sophisticated design and move the data access code into data access objects (the DAO pattern). See the Hibernate Wiki for more examples."
msgstr ""

#: index.docbook:954
msgid "Deploying and testing"
msgstr ""

#: index.docbook:956
msgid "To deploy this application you have to create a web archive, a WAR. Add the following Ant target to your <literal>build.xml</literal>:"
msgstr ""

#: index.docbook:961
msgid ""
      "<![CDATA[<target name=\"war\" depends=\"compile\">\n"
      "    <war destfile=\"hibernate-tutorial.war\" webxml=\"web.xml\">\n"
      "        <lib dir=\"${librarydir}\">\n"
      "          <exclude name=\"jsdk*.jar\"/>\n"
      "        </lib>\n"
      "\n"
      "        <classes dir=\"${targetdir}\"/>\n"
      "    </war>\n"
      "</target>]]>"
msgstr ""

#: index.docbook:963
msgid "This target creates a file called <literal>hibernate-tutorial.war</literal> in your project directory. It packages all libraries and the <literal>web.xml</literal> descriptor, which is expected in the base directory of your project:"
msgstr ""

#: index.docbook:969
msgid ""
      "<![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
      "<web-app version=\"2.4\"\n"
      "    xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n"
      "    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
      "    xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\">\n"
      "\n"
      "    <servlet>\n"
      "        <servlet-name>Event Manager</servlet-name>\n"
      "        <servlet-class>events.EventManagerServlet</servlet-class>\n"
      "    </servlet>\n"
      "\n"
      "    <servlet-mapping>\n"
      "        <servlet-name>Event Manager</servlet-name>\n"
      "        <url-pattern>/eventmanager</url-pattern>\n"
      "    </servlet-mapping>\n"
      "</web-app>]]>"
msgstr ""

#: index.docbook:971
msgid "Before you compile and deploy the web application, note that an additional library is required: <literal>jsdk.jar</literal>. This is the Java servlet development kit, if you don't have this library already, get it from the Sun website and copy it to your library directory. However, it will be only used for compliation and excluded from the WAR package."
msgstr ""

#: index.docbook:979
msgid "To build and deploy call <literal>ant war</literal> in your project directory and copy the <literal>hibernate-tutorial.war</literal> file into your Tomcat <literal>webapp</literal> directory. If you don't have Tomcat installed, download it and follow the installation instructions. You don't have to change any Tomcat configuration to deploy this application though."
msgstr ""

#: index.docbook:987
msgid "Once deployed and Tomcat is running, access the application at <literal>http://localhost:8080/hibernate-tutorial/eventmanager</literal>. Make sure you watch the Tomcat log to see Hibernate initialize when the first request hits your servlet (the static initializer in <literal>HibernateUtil</literal> is called) and to get the detailed output if any exceptions occurs."
msgstr ""

#: index.docbook:1000
msgid "Summary"
msgstr ""

#: index.docbook:1002
msgid "This tutorial covered the basics of writing a simple standalone Hibernate application and a small web application."
msgstr ""

#: index.docbook:1007
msgid "If you already feel confident with Hibernate, continue browsing through the reference documentation table of contents for topics you find interesting - most asked are transactional processing (<xref linkend=\"transactions\"/>), fetch performance (<xref linkend=\"performance\"/>), or the usage of the API (<xref linkend=\"objectstate\"/>) and the query features (<xref linkend=\"objectstate-querying\"/>)."
msgstr ""

#: index.docbook:1015
msgid "Don't forget to check the Hibernate website for more (specialized) tutorials."
msgstr ""

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

