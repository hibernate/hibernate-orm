#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Best Practices"
msgstr "Meilleures pratiques"

#: index.docbook:9
msgid "Write fine-grained classes and map them using <literal>&lt;component&gt;</literal>."
msgstr "Découpez finement vos classes et mappez les en utilisant <literal>&lt;component&gt;</literal>."

#: index.docbook:11
msgid "Use an <literal>Address</literal> class to encapsulate <literal>street</literal>, <literal>suburb</literal>, <literal>state</literal>, <literal>postcode</literal>. This encourages code reuse and simplifies refactoring."
msgstr "Utilisez une classe <literal>Adresse</literal> pour encapsuler <literal>Rue</literal>, <literal>Region</literal>, <literal>CodePostal</literal>. Ceci permet la réutilisation du code et simplifie la maintenance."

#: index.docbook:19
msgid "Declare identifier properties on persistent classes."
msgstr "Déclarez des propriétés d'identifiants dans les classes persistantes."

#: index.docbook:21
msgid "Hibernate makes identifier properties optional. There are all sorts of reasons why you should use them. We recommend that identifiers be 'synthetic' (generated, with no business meaning)."
msgstr "Hibernate rend les propriétés d'identifiants optionnelles. Il existe beaucoup de raisons pour lesquelles vous devriez les utiliser. Nous recommandons que vous utilisiez des identifiants techniques (générés, et sans connotation métier)."

#: index.docbook:29
msgid "Identify natural keys."
msgstr "Identifiez les clefs naturelles."

#: index.docbook:31
msgid "Identify natural keys for all entities, and map them using <literal>&lt;natural-id&gt;</literal>. Implement <literal>equals()</literal> and <literal>hashCode()</literal> to compare the properties that make up the natural key."
msgstr "Identifiez les clefs naturelles pour toutes les entités, et mappez les avec <literal>&lt;natural-id&gt;</literal>. Implémentez <literal>equals()</literal> et <literal>hashCode()</literal> pour comparer les propriétés qui composent la clef naturelle."

#: index.docbook:39
msgid "Place each class mapping in its own file."
msgstr "Placez chaque mapping de classe dans son propre fichier."

#: index.docbook:41
msgid "Don't use a single monolithic mapping document. Map <literal>com.eg.Foo</literal> in the file <literal>com/eg/Foo.hbm.xml</literal>. This makes particularly good sense in a team environment."
msgstr "N'utilisez pas un unique document de mapping. Mappez <literal>com.eg.Foo</literal> dans le fichier <literal>com/eg/Foo.hbm.xml</literal>. Cela prend tout son sens lors d'un travail en équipe."

#: index.docbook:49
msgid "Load mappings as resources."
msgstr "Chargez les mappings comme des ressources."

#: index.docbook:51
msgid "Deploy the mappings along with the classes they map."
msgstr "Déployez les mappings en même temps que les classes qu'ils mappent."

#: index.docbook:57
msgid "Consider externalising query strings."
msgstr "Pensez à externaliser les chaînes de caractères."

#: index.docbook:59
msgid "This is a good practice if your queries call non-ANSI-standard SQL functions. Externalising the query strings to mapping files will make the application more portable."
msgstr "Ceci est une bonne habitude si vos requêtes appellent des fonctions SQL qui ne sont pas au standard ANSI. Cette externalisation dans les fichiers de mapping rendra votre application plus portable."

#: index.docbook:67
msgid "Use bind variables."
msgstr "Utilisez les variables \"bindées\"."

#: index.docbook:69
msgid "As in JDBC, always replace non-constant values by \"?\". Never use string manipulation to bind a non-constant value in a query! Even better, consider using named parameters in queries."
msgstr "Comme en JDBC, remplacez toujours les valeurs non constantes par \"?\". N'utilisez jamais la manipulation des chaînes de caractères pour remplacer des valeurs non constantes dans une requête ! Encore mieux, utilisez les paramètres nommés dans les requêtes."

#: index.docbook:77
msgid "Don't manage your own JDBC connections."
msgstr "Ne gérez pas vous même les connexions JDBC."

#: index.docbook:79
msgid "Hibernate lets the application manage JDBC connections. This approach should be considered a last-resort. If you can't use the built-in connections providers, consider providing your own implementation of <literal>org.hibernate.connection.ConnectionProvider</literal>."
msgstr "Hibernate laisse l'application gérer les connexions JDBC. Vous ne devriez gérer vos connexions qu'en dernier recours. Si vous ne pouvez pas utiliser les systèmes de connexions livrés, réfléchissez à l'idée de fournir votre propre implémentation de <literal>org.hibernate.connection.ConnectionProvider</literal>."

#: index.docbook:87
msgid "Consider using a custom type."
msgstr "Pensez à utiliser les types utilisateurs."

#: index.docbook:89
msgid "Suppose you have a Java type, say from some library, that needs to be persisted but doesn't provide the accessors needed to map it as a component. You should consider implementing <literal>org.hibernate.UserType</literal>. This approach frees the application code from implementing transformations to / from a Hibernate type."
msgstr "Supposez que vous ayez une type Java, de telle bibliothèque, qui a besoin d'être persisté mais qui ne fournit pas les accesseurs nécessaires pour le mapper comme composant. Vous devriez implémenter <literal>org.hibernate.UserType</literal>.Cette approche libère le code de l'application de l'implémentation des transformations vers / depuis les types Hibernate."

#: index.docbook:98
msgid "Use hand-coded JDBC in bottlenecks."
msgstr "Utilisez du JDBC pur dans les goulets d'étranglement."

#: index.docbook:100
msgid "In performance-critical areas of the system, some kinds of operations might benefit from direct JDBC. But please, wait until you <emphasis>know</emphasis> something is a bottleneck. And don't assume that direct JDBC is necessarily faster. If you need to use direct JDBC, it might be worth opening a Hibernate <literal>Session</literal> and using that JDBC connection. That way you can still use the same transaction strategy and underlying connection provider."
msgstr "Dans certaines parties critiques de votre système d'un point de vue performance, quelques opérations peuvent tirer partie d'un appel JDBC natif. Mais attendez de <emphasis>savoir</emphasis> que c'est un goulet d'étranglement. Ne supposez jamais qu'un appel JDBC sera forcément plus rapide. Si vous avez besoin d'utiliser JDBC directement, ouvrez une <literal>Session</literal> Hibernate et utilisez la connexion SQL sous-jacente. Ainsi vous pourrez utiliser la même stratégie de transation et la même gestion des connexions."

#: index.docbook:110
msgid "Understand <literal>Session</literal> flushing."
msgstr "Comprendre le flush de <literal>Session</literal>."

#: index.docbook:112
msgid "From time to time the Session synchronizes its persistent state with the database. Performance will be affected if this process occurs too often. You may sometimes minimize unnecessary flushing by disabling automatic flushing or even by changing the order of queries and other operations within a particular transaction."
msgstr "De temps en temps la Session synchronise ses états persistants avec la base de données. Les performances seront affectées si ce processus arrive trop souvent. Vous pouvez parfois minimiser les flush non nécessaires en désactivant le flush automatique ou même en changeant l'ordre des opérations menées dans une transaction particulière."

#: index.docbook:121
msgid "In a three tiered architecture, consider using detached objects."
msgstr "Dans une architecture à trois couches, pensez à utiliser <literal>saveOrUpdate()</literal>."

#: index.docbook:123
msgid "When using a servlet / session bean architecture, you could pass persistent objects loaded in the session bean to and from the servlet / JSP layer. Use a new session to service each request. Use <literal>Session.merge()</literal> or <literal>Session.saveOrUpdate()</literal> to synchronize objects with the database."
msgstr "Quand vous utilisez une architecture à base de servlet / session bean, vous pourriez passer des objets chargés dans le bean session vers et depuis la couche servlet / JSP. Utilisez une nouvelle session pour traiter chaque requête. Utilisez <literal>Session.merge()</literal> ou <literal>Session.saveOrUpdate()</literal> pour synchroniser les objets avec la base de données."

#: index.docbook:132
msgid "In a two tiered architecture, consider using long persistence contexts."
msgstr "Dans une architecture à deux couches, pensez à utiliser la déconnexion de session."

#: index.docbook:134
msgid "Database Transactions have to be as short as possible for best scalability. However, it is often neccessary to implement long running <emphasis>application transactions</emphasis>, a single unit-of-work from the point of view of a user. An application transaction might span several client request/response cycles. It is common to use detached objects to implement application transactions. An alternative, extremely appropriate in two tiered architecture, is to maintain a single open persistence contact (session) for the whole life cycle of the application transaction and simply disconnect from the JDBC connection at the end of each request and reconnect at the beginning of the subsequent request. Never share a single session across more than one application transaction, or you will be working with stale data."
msgstr "Les transactions de bases de données doivent être aussi courtes que possible pour une meilleure montée en charge.Cependant, il est souvent nécessaire d'implémenter de longues <emphasis>transactions applicatives</emphasis>, une simple unité de travail du point de vue de l'utilisateur. Une transaction applicative peut s'étaler sur plusieurs cycles de requêtes/réponses du client. Il est commun d'utiliser des objets détachés pour implémenter des transactions applicatives. Une alternative, extrêmement appropriée dans une architecture à 2 couches, est de maintenir un seul contact de persistance ouvert (session) pour toute la durée de vie de la transaction applicative et simplement se déconnecter de la connexion JDBC à la fin de chaque requête, et se reconnecter au début de la requête suivante. Ne partagez jamais une seule session avec plus d'une transaction applicative, ou vous travaillerez avec des données périmées."

#: index.docbook:148
msgid "Don't treat exceptions as recoverable."
msgstr "Considérez que les exceptions ne sont pas rattrapables."

#: index.docbook:150
msgid "This is more of a necessary practice than a \"best\" practice. When an exception occurs, roll back the <literal>Transaction</literal> and close the <literal>Session</literal>. If you don't, Hibernate can't guarantee that in-memory state accurately represents persistent state. As a special case of this, do not use <literal>Session.load()</literal> to determine if an instance with the given identifier exists on the database; use <literal>Session.get()</literal> or a query instead."
msgstr "Il s'agit plus d'une pratique obligatoire que d'une \"meilleure pratique\". Quand une exception intervient, il faut faire un rollback de la <literal>Transaction</literal> et fermer la <literal>Session</literal>. Sinon, Hibernate ne peut garantir l'intégrité des états persistants en mémoire. En particulier, n'utilisez pas <literal>Session.load()</literal> pour déterminer si une instance avec un identifiant donné existe en base de données, utilisez <literal>Session.get()</literal> ou un requête."

#: index.docbook:160
msgid "Prefer lazy fetching for associations."
msgstr "Préférez le chargement tardif des associations."

#: index.docbook:162
msgid "Use eager fetching sparingly. Use proxies and lazy collections for most associations to classes that are not likely to be completely held in the second-level cache. For associations to cached classes, where there is an a extremely high probability of a cache hit, explicitly disable eager fetching using <literal>lazy=\"false\"</literal>. When an join fetching is appropriate to a particular use case, use a query with a <literal>left join fetch</literal>."
msgstr "Utilisez le chargement complet avec modération. Utilisez les proxies et les collections chargées tardivement pour la plupart des associations vers des classes qui ne sont pas susceptibles d'être complètement retenues dans le cache de second niveau. Pour les assocations de classes en cache, où il y a une extrêmement forte probabilité que l'élément soit en cache, désactivez explicitement le chargement par jointures ouvertes en utilisant <literal>outer-join=\"false\"</literal>. Lorsqu'un chargement par jointure ouverte est approprié pour un cas d'utilisation particulier, utilisez une requête avec un <literal>left join fetch</literal>."

#: index.docbook:172
msgid "Use the <emphasis>open session in view</emphasis> pattern, or a disciplined <emphasis>assembly phase</emphasis> to avoid problems with unfetched data."
msgstr "Utilisez le pattern <emphasis>d'une ouverture de session dans une vue</emphasis>, ou une <emphasis>phase d'assemblage</emphasis> disciplinée pour éviter des problèmes avec des données non rapatriées."

#: index.docbook:177
msgid "Hibernate frees the developer from writing tedious <emphasis>Data Transfer Objects</emphasis> (DTO). In a traditional EJB architecture, DTOs serve dual purposes: first, they work around the problem that entity beans are not serializable; second, they implicitly define an assembly phase where all data to be used by the view is fetched and marshalled into the DTOs before returning control to the presentation tier. Hibernate eliminates the first purpose. However, you will still need an assembly phase (think of your business methods as having a strict contract with the presentation tier about what data is available in the detached objects) unless you are prepared to hold the persistence context (the session) open across the view rendering process. This is not a limitation of Hibernate! It is a fundamental requirement of safe transactional data access."
msgstr "Hibernate libère les développeurs de l'écriture fastidieuse des <emphasis>objets de transfert de données (NdT : Data Transfer Objects)</emphasis> (DTO). Dans une architecture EJB traditionnelle, les DTOs ont deux buts : premièrement, ils contournent le problème des \"entity bean\" qui ne sont pas sérialisables ; deuxièmement, ils définissent implicitement une phase d'assemblage où toutes les données utilisées par la vue sont rapatriées et organisées dans les DTOs avant de retourner sous le contrôle de la couche de présentation. Hibernate élimine le premier but. Pourtant, vous aurez encore besoin d'une phase d'assemblage (pensez vos méthodes métier comme ayant un contrat strict avec la couche de présentation à propos de quelles données sont disponibles dans les objets détachés) à moins que vous soyez préparés à garder le contexte de persistance (la session) ouvert à travers tout le processus de rendu de la vue."

#: index.docbook:191
msgid "Consider abstracting your business logic from Hibernate."
msgstr "Pensez à abstraite votre logique métier d'Hibernate."

#: index.docbook:193
msgid "Hide (Hibernate) data-access code behind an interface. Combine the <emphasis>DAO</emphasis> and <emphasis>Thread Local Session</emphasis> patterns. You can even have some classes persisted by handcoded JDBC, associated to Hibernate via a <literal>UserType</literal>. (This advice is intended for \"sufficiently large\" applications; it is not appropriate for an application with five tables!)"
msgstr "Cachez le mécanisme d'accès aux données (Hibernate) derrière une interface. Combinez les patterns <emphasis>DAO</emphasis> et <emphasis>Thread Local Session</emphasis>. Vous pouvez même avoir quelques classes persistées par du JDBC pur, associées à Hibernate via un <literal>UserType</literal> (ce conseil est valable pour des applications de taille respectables ; il n'est pas valable pour une application avec cinq tables)."

#: index.docbook:203
msgid "Don't use exotic association mappings."
msgstr "N'utilisez pas d'associations de mapping exotiques."

#: index.docbook:205
msgid "Good usecases for a real many-to-many associations are rare. Most of the time you need additional information stored in the \"link table\". In this case, it is much better to use two one-to-many associations to an intermediate link class. In fact, we think that most associations are one-to-many and many-to-one, you should be careful when using any other association style and ask yourself if it is really neccessary."
msgstr "De bons cas d'utilisation pour de vraies associations plusieurs-vers-plusieurs sont rares. La plupart du temps vous avez besoin d'informations additionnelles stockées dans la table d'association. Dans ce cas, il est préférable d'utiliser deux associations un-vers-plusieurs vers une classe de liaisons intermédiaire. En fait, nous pensons que la plupart des associations sont de type un-vers-plusieurs ou plusieurs-vers-un, vous devez être très attentifs lorsque vous utilisez autre chose et vous demander si c'est vraiment nécessaire."

#: index.docbook:215
msgid "Prefer bidirectional associations."
msgstr "Préférez les associations bidirectionnelles."

#: index.docbook:217
msgid "Unidirectional associations are more difficult to query. In a large application, almost all associations must be navigable in both directions in queries."
msgstr "Les associations unidirectionnelles sont plus difficiles à questionner. Dans une grande application, la plupart des associations devraient être navigables dans les deux directions dans les requêtes."

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

