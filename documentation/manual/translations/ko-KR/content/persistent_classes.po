#, fuzzy
msgid ""
msgstr ""
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Content-Type: text/plain; charset=utf-8\n"
#: index.docbook:5
msgid "Persistent Classes"
msgstr "영속 클래스들"

#: index.docbook:7
msgid "Persistent classes are classes in an application that implement the entities of the business problem (e.g. Customer and Order in an E-commerce application). Not all instances of a persistent class are considered to be in the persistent state - an instance may instead be transient or detached."
msgstr "영속 클래스들은 비지니스 문제의 엔티티들(예를 들어 E-Commerce 어플리케이션에서 고객이나 주문)을 구현하는 어플리케이션 내의 클래스들이다. 영속 클래스들의 인스턴스들은 영속 상태에 있는 것으로 전혀 간주되지 않는다 - 대신에 하나의 인스턴스는 transient 또는 detached 상태일 수 있다."

#: index.docbook:14
msgid "Hibernate works best if these classes follow some simple rules, also known as the Plain Old Java Object (POJO) programming model. However, none of these rules are hard requirements. Indeed, Hibernate3 assumes very little about the nature of your persistent objects. You may express a domain model in other ways: using trees of <literal>Map</literal> instances, for example."
msgstr "Hibernate는 이들 클래스들이 Plain Old Java Object (POJO) 프로그래밍 모형으로서 알려진, 몇몇 간단한 규칙들을 따를 경우에 가장 잘 동작한다. 하지만 이들 규칙들 중 어떤 것도 어려운 사양들이 아니다. 진정 Hibernate3는 당신의 영속 객체들의 특징에 대해 매우 적은 것을 가정한다. 당신은 다른 방법들로 도메인 모형을 표현할 수 있다 : 예를 들어 <literal>Map</literal> 인스턴스의 트리들을 사용하기."

#: index.docbook:23
msgid "A simple POJO example"
msgstr "간단한 POJO 예제"

#: index.docbook:25
msgid "Most Java applications require a persistent class representing felines."
msgstr "대부분의 자바 어플리케이션들은 고양이과들을 표현하는 영속 클래스를 필요로 한다."

#: index.docbook:29
msgid ""
      "<![CDATA[package eg;\n"
      "import java.util.Set;\n"
      "import java.util.Date;\n"
      "\n"
      "public class Cat {\n"
      "    private Long id; // identifier\n"
      "\n"
      "    private Date birthdate;\n"
      "    private Color color;\n"
      "    private char sex;\n"
      "    private float weight;\n"
      "    private int litterId;\n"
      "\n"
      "    private Cat mother;\n"
      "    private Set kittens = new HashSet();\n"
      "\n"
      "    private void setId(Long id) {\n"
      "        this.id=id;\n"
      "    }\n"
      "    public Long getId() {\n"
      "        return id;\n"
      "    }\n"
      "\n"
      "    void setBirthdate(Date date) {\n"
      "        birthdate = date;\n"
      "    }\n"
      "    public Date getBirthdate() {\n"
      "        return birthdate;\n"
      "    }\n"
      "\n"
      "    void setWeight(float weight) {\n"
      "        this.weight = weight;\n"
      "    }\n"
      "    public float getWeight() {\n"
      "        return weight;\n"
      "    }\n"
      "\n"
      "    public Color getColor() {\n"
      "        return color;\n"
      "    }\n"
      "    void setColor(Color color) {\n"
      "        this.color = color;\n"
      "    }\n"
      "\n"
      "    void setSex(char sex) {\n"
      "        this.sex=sex;\n"
      "    }\n"
      "    public char getSex() {\n"
      "        return sex;\n"
      "    }\n"
      "\n"
      "    void setLitterId(int id) {\n"
      "        this.litterId = id;\n"
      "    }\n"
      "    public int getLitterId() {\n"
      "        return litterId;\n"
      "    }\n"
      "\n"
      "    void setMother(Cat mother) {\n"
      "        this.mother = mother;\n"
      "    }\n"
      "    public Cat getMother() {\n"
      "        return mother;\n"
      "    }\n"
      "    void setKittens(Set kittens) {\n"
      "        this.kittens = kittens;\n"
      "    }\n"
      "    public Set getKittens() {\n"
      "        return kittens;\n"
      "    }\n"
      "    \n"
      "    // addKitten not needed by Hibernate\n"
      "    public void addKitten(Cat kitten) {\n"
      "            kitten.setMother(this);\n"
      "        kitten.setLitterId( kittens.size() ); \n"
      "        kittens.add(kitten);\n"
      "    }\n"
      "}]]>"
msgstr ""
      "<![CDATA[package eg;\n"
      "import java.util.Set;\n"
      "import java.util.Date;\n"
      "\n"
      "public class Cat {\n"
      "    private Long id; // identifier\n"
      "\n"
      "    private Date birthdate;\n"
      "    private Color color;\n"
      "    private char sex;\n"
      "    private float weight;\n"
      "    private int litterId;\n"
      "\n"
      "    private Cat mother;\n"
      "    private Set kittens = new HashSet();\n"
      "\n"
      "    private void setId(Long id) {\n"
      "        this.id=id;\n"
      "    }\n"
      "    public Long getId() {\n"
      "        return id;\n"
      "    }\n"
      "\n"
      "    void setBirthdate(Date date) {\n"
      "        birthdate = date;\n"
      "    }\n"
      "    public Date getBirthdate() {\n"
      "        return birthdate;\n"
      "    }\n"
      "\n"
      "    void setWeight(float weight) {\n"
      "        this.weight = weight;\n"
      "    }\n"
      "    public float getWeight() {\n"
      "        return weight;\n"
      "    }\n"
      "\n"
      "    public Color getColor() {\n"
      "        return color;\n"
      "    }\n"
      "    void setColor(Color color) {\n"
      "        this.color = color;\n"
      "    }\n"
      "\n"
      "    void setSex(char sex) {\n"
      "        this.sex=sex;\n"
      "    }\n"
      "    public char getSex() {\n"
      "        return sex;\n"
      "    }\n"
      "\n"
      "    void setLitterId(int id) {\n"
      "        this.litterId = id;\n"
      "    }\n"
      "    public int getLitterId() {\n"
      "        return litterId;\n"
      "    }\n"
      "\n"
      "    void setMother(Cat mother) {\n"
      "        this.mother = mother;\n"
      "    }\n"
      "    public Cat getMother() {\n"
      "        return mother;\n"
      "    }\n"
      "    void setKittens(Set kittens) {\n"
      "        this.kittens = kittens;\n"
      "    }\n"
      "    public Set getKittens() {\n"
      "        return kittens;\n"
      "    }\n"
      "    \n"
      "    // addKitten not needed by Hibernate\n"
      "    public void addKitten(Cat kitten) {\n"
      "            kitten.setMother(this);\n"
      "        kitten.setLitterId( kittens.size() ); \n"
      "        kittens.add(kitten);\n"
      "    }\n"
      "}]]>"

#: index.docbook:31
msgid "There are four main rules to follow here:"
msgstr "준수할 네 개의 주요 규칙들이 다음에 있다:"

#: index.docbook:37
msgid "Implement a no-argument constructor"
msgstr "아규먼트 없는 생성자를 구현하라"

#: index.docbook:39
msgid "<literal>Cat</literal> has a no-argument constructor. All persistent classes must have a default constructor (which may be non-public) so that Hibernate can instantiate them using <literal>Constructor.newInstance()</literal>. We strongly recommend having a default constructor with at least <emphasis>package</emphasis> visibility for runtime proxy generation in Hibernate."
msgstr "<literal>Cat</literal>은 아규먼트 없는 생성자를 갖는다. 모든 영속 클래스들은 Hibernate는 <literal>Constructor.newInstance()</literal>를 사용하여 그것들을 초기화 시킬 수 있도록 디폴트 생성자 (public이 아닐 수 있다)를 가져야 한다. 우리는 Hibernate 내에서 런타임 프락시 생성을 위한 최소한의 <emphasis>패키지</emphasis> 가시성(visibility)를 가진 디폴트 생성자를 가질 것을 강력하게 권장한다."

#: index.docbook:49
msgid "Provide an identifier property (optional)"
msgstr "identifier 프로퍼티를 제공하라(옵션)"

#: index.docbook:51
msgid "<literal>Cat</literal> has a property called <literal>id</literal>. This property maps to the primary key column of a database table. The property might have been called anything, and its type might have been any primitive type, any primitive \"wrapper\" type, <literal>java.lang.String</literal> or <literal>java.util.Date</literal>. (If your legacy database table has composite keys, you can even use a user-defined class with properties of these types - see the section on composite identifiers later.)"
msgstr "<literal>Cat</literal>은 <literal>id</literal>로 명명된 하나의 프로퍼티를 갖는다. 이 프로퍼티는 데이터베이스 테이블의 프라이머리 키 컬럼으로 매핑된다. 이 프로퍼티는 어떤 것으로 명명될 수도 있고, 그것의 타입은 임의의 원시 타입, 원시 \"wrapper\" 타입, <literal>java.lang.String</literal> 또는 <literal>java.util.Date</literal>일 수 있다. (만일 당신의 리거시 데이터베이스 테이블이 composite 키들을 갖고 있다면, 당신은 이들 타입들을 가진 사용자 정의 클래스를 사용할 수도 있다 - 나중에 composite 식별자들에 대한 절을 보라)"

#: index.docbook:60
msgid "The identifier property is strictly optional. You can leave them off and let Hibernate keep track of object identifiers internally. We do not recommend this, however."
msgstr "identifier 프로퍼티는 엄격하게 옵션이다. 당신은 그것을 생략할 수도 있고, Hibernate로 하여금 내부적으로 객체 식별자들을 추적하도록 할 수 있다. 하지만 우리는 이것을 권장하지 않는다."

#: index.docbook:65
msgid "In fact, some functionality is available only to classes which declare an identifier property:"
msgstr "사실, 어떤 기능은 identifier 프로퍼티를 선언하는 클래스들에 대해서만 이용 가능하다:"

#: index.docbook:72
msgid "Transitive reattachment for detached objects (cascade update or cascade merge) - see"
msgstr "detached 객체들에 대한 Transitive reattachment(cascade update 또는 cascade merge) -"

#: index.docbook:79
msgid "Session.saveOrUpdate()"
msgstr "Session.saveOrUpdate()"

#: index.docbook:84
msgid "Session.merge()"
msgstr "Session.merge()"

#: index.docbook:89
msgid "We recommend you declare consistently-named identifier properties on persistent classes. We further recommend that you use a nullable (ie. non-primitive) type."
msgstr "를 보라"

#: index.docbook:96
msgid "Prefer non-final classes (optional)"
msgstr "우리는 당신이 영속 클래스들에 대해 일관되게 명명된 identifier 프로퍼티들을 선언할 것을 권장한다. 게다가 우리는 당신이 nullable 타입(예를 들어 non-primitive)을 사용할 것을 권장한다."

#: index.docbook:97
msgid "A central feature of Hibernate, <emphasis>proxies</emphasis>, depends upon the persistent class being either non-final, or the implementation of an interface that declares all public methods."
msgstr "final이 아닌 클래스들을 선호하라(옵션)"

#: index.docbook:102
msgid "You can persist <literal>final</literal> classes that do not implement an interface with Hibernate, but you won't be able to use proxies for lazy association fetching - which will limit your options for performance tuning."
msgstr "Hibernate의 중심 특징인, 프락시(<emphasis>proxies</emphasis>)들은 final이 아닌 영속 클래스들 또는 모두 public 메소드들로 선언된 인터페이스의 구현인 영속 클래스들에 의존한다."

#: index.docbook:107
msgid "You should also avoid declaring <literal>public final</literal> methods on the non-final classes. If you want to use a class with a <literal>public final</literal> method, you must explicitly disable proxying by setting <literal>lazy=\"false\"</literal>."
msgstr "당신은 Hibernate로 인터페이스를 구현하지 않은 <literal>final</literal> 클래스들을 영속화 시킬 수 있지만 당신은 lazy 연관 페칭(lazy association fetching)에 대해 프락시들을 사용할 수 없을 것이다 -그것은 퍼포먼스 튜닝을 위한 당신의 옵션들을 제한시킬 것이다."

#: index.docbook:115
msgid "Declare accessors and mutators for persistent fields (optional)"
msgstr "당신은 또한 non-final 클래스들 상에 <literal>public final</literal> 메소드들을 선언하는 것을 피해야 한다. 만일 당신이 <literal>public final</literal> 메소드를 가진 클래스를 사용하고자 원할 경우, 당신은 <literal>lazy=\"false\"</literal>를 설정함으로써 명시적으로 프락싱을 사용 불가능하도록 해야 한다."

#: index.docbook:117
msgid "<literal>Cat</literal> declares accessor methods for all its persistent fields. Many other ORM tools directly persist instance variables. We believe it is better to provide an indirection between the relational schema and internal data structures of the class. By default, Hibernate persists JavaBeans style properties, and recognizes method names of the form <literal>getFoo</literal>, <literal>isFoo</literal> and <literal>setFoo</literal>. You may switch to direct field access for particular properties, if needed."
msgstr "영속 필드들을 위한 accessor들과 mutator들을 선언하라(옵션)"

#: index.docbook:127
msgid "Properties need <emphasis>not</emphasis> be declared public - Hibernate can persist a property with a default, <literal>protected</literal> or <literal>private</literal> get / set pair."
msgstr "<literal>Cat</literal>은 그것의 모든 영속 필드들에 대해 accessor 메소드들을 선언한다. 많은 다른 ORM 도구들은 인스턴스 변수들을 직접 영속화 시킨다. 우리는 관계형 스키마와 클래스의 내부적인 데이터 구조들 사이에 간접적인 수단을 제공하는 것이 더 좋다고 믿고 있다. 디폴트로 Hibernate는 자바빈즈 스타일 프로퍼티들을 영속화 시키고, <literal>getFoo</literal>, <literal>isFoo</literal>와 <literal>setFoo</literal> 형식의 메소드 이름들을 인지한다. 당신은 진정으로 특정 프로퍼티에 대한 직접적인 필드 접근으로 전환할 수도 있다."

#: index.docbook:138
msgid "Implementing inheritance"
msgstr "프로퍼티들은 public으로 선언될 필요가 <emphasis>없다</emphasis> - Hibernate는 디폴트로 <literal>protected</literal> get/set 쌍 또는 <literal>private</literal> get/set 쌍을 가진 프로퍼티를 영속화 시킬 수 있다."

#: index.docbook:140
msgid "A subclass must also observe the first and second rules. It inherits its identifier property from the superclass, <literal>Cat</literal>."
msgstr "상속 구현하기"

#: index.docbook:145
msgid ""
      "<![CDATA[package eg;\n"
      "\n"
      "public class DomesticCat extends Cat {\n"
      "        private String name;\n"
      "\n"
      "        public String getName() {\n"
      "                return name;\n"
      "        }\n"
      "        protected void setName(String name) {\n"
      "                this.name=name;\n"
      "        }\n"
      "}]]>"
msgstr "서브클래스는 또한 첫 번째 규칙들과 두 번째 규칙들을 주시해야 한다. 그것은 슈퍼클래스 <literal>Cat</literal>으로부터 그것의 identifier 프로퍼티를 상속받는다."

#: index.docbook:149
msgid "Implementing <literal>equals()</literal> and <literal>hashCode()</literal>"
msgstr ""
      "<![CDATA[package eg;\n"
      "\n"
      "public class DomesticCat extends Cat {\n"
      "        private String name;\n"
      "\n"
      "        public String getName() {\n"
      "                return name;\n"
      "        }\n"
      "        protected void setName(String name) {\n"
      "                this.name=name;\n"
      "        }\n"
      "}]]>"

#: index.docbook:151
msgid "You have to override the <literal>equals()</literal> and <literal>hashCode()</literal> methods if you"
msgstr "<literal>equals()</literal>와 <literal>hashCode()</literal> 구현하기"

#: index.docbook:157
msgid "intend to put instances of persistent classes in a <literal>Set</literal> (the recommended way to represent many-valued associations) <emphasis>and</emphasis>"
msgstr "만일 당신이 다음의 경우라면, 당신은 <literal>equals()</literal>와 <literal>hashCode()</literal> 메소드들을 오버라이드 시켜야 한다."

#: index.docbook:164
msgid "intend to use reattachment of detached instances"
msgstr "하나의 <literal>Set</literal> 속에 영속 클래스들의 인스턴스들을 집어넣고자 의도하고 (many-valued 연관들에 대해 권장되는 방법) <emphasis>그리고</emphasis>"

#: index.docbook:170
msgid "Hibernate guarantees equivalence of persistent identity (database row) and Java identity only inside a particular session scope. So as soon as we mix instances retrieved in different sessions, we must implement <literal>equals()</literal> and <literal>hashCode()</literal> if we wish to have meaningful semantics for <literal>Set</literal>s."
msgstr "detached 인스턴스들의 reattachment(재첨부)를 사용하고자 의도하는"

#: index.docbook:178
msgid "The most obvious way is to implement <literal>equals()</literal>/<literal>hashCode()</literal> by comparing the identifier value of both objects. If the value is the same, both must be the same database row, they are therefore equal (if both are added to a <literal>Set</literal>, we will only have one element in the <literal>Set</literal>). Unfortunately, we can't use that approach with generated identifiers! Hibernate will only assign identifier values to objects that are persistent, a newly created instance will not have any identifier value! Furthermore, if an instance is unsaved and currently in a <literal>Set</literal>, saving it will assign an identifier value to the object. If <literal>equals()</literal> and <literal>hashCode()</literal> are based on the identifier value, the hash code would change, breaking the contract of the <literal>Set</literal>. See the Hibernate website for a full discussion of this problem. Note that this is not a Hibernate issue, but normal Java semantics of object identity and equality."
msgstr "Hibernate는 특정 session 범위 내에서만 persistent identity(데이터베이스 행)과 Java identity의 같음을 보장한다. 따라서 우리가 다른 세션들에서 검색된 인스턴스들을 혼합시키자마자, 우리가 <literal>Set</literal>들에 대해 유의미하게 만들고자 원할 경우, 우리는 <literal>equals()</literal>와 <literal>hashCode()</literal>를 구현해야 한다."

#: index.docbook:192
msgid "We recommend implementing <literal>equals()</literal> and <literal>hashCode()</literal> using <emphasis>Business key equality</emphasis>. Business key equality means that the <literal>equals()</literal> method compares only the properties that form the business key, a key that would identify our instance in the real world (a <emphasis>natural</emphasis> candidate key):"
msgstr "가장 명백한 방법은 두 객체들의 identifier 값을 비교함으로써 <literal>equals()</literal>/<literal>hashCode()</literal>를 구현하는 것이다. 만일 그 값이 동일하다면, 둘다 동일한 데이터베이스 행이어야 하고, 그러므로 그것들은 같다(둘다 하나의 <literal>Set</literal>에 추가되는 경우에, 우리는 <literal>Set</literal> 속에서 하나의 요소만을 갖게 될 것이다). 불행하게도, 우리는 생성되는 식별자들을 갖는 그 접근법을 사용할 수 없다! Hibernate는 오직 식별자 값들을 영속화 되는 객체들에 할당할 것이고, 새로이 생성된 인스턴스는 임의의 identifier 값을 갖지 않을 것이다! 만일 인스턴스가 저장되지 않고 현재 하나의 <literal>Set</literal> 속에 있을 경우에, 그것을 저장하는것은 하나의 식별자 값을 그 객체에게 할당할 것이다. 만일 <literal>equals()</literal>와 <literal>hashCode()</literal>가 그 식별자 값에 기초할 경우, hash 코드는 <literal>Set</literal>의 계약을 파기하여 변경될 것이다. 이 문제에 대한 전체 논의에 대해서는 Hibernate 웹 사이트를 보라. 이것은 Hibernate 쟁점이 아닌, 객체 identity와 equality에 관한 통상의 자바 의미론임을 노트하라."

#: index.docbook:200
msgid ""
      "<![CDATA[public class Cat {\n"
      "\n"
      "    ...\n"
      "    public boolean equals(Object other) {\n"
      "        if (this == other) return true;\n"
      "        if ( !(other instanceof Cat) ) return false;\n"
      "\n"
      "        final Cat cat = (Cat) other;\n"
      "\n"
      "        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;\n"
      "        if ( !cat.getMother().equals( getMother() ) ) return false;\n"
      "\n"
      "        return true;\n"
      "    }\n"
      "\n"
      "    public int hashCode() {\n"
      "        int result;\n"
      "        result = getMother().hashCode();\n"
      "        result = 29 * result + getLitterId();\n"
      "        return result;\n"
      "    }\n"
      "\n"
      "}]]>"
msgstr "우리는 <emphasis>Business key equality</emphasis>를 사용하여 <literal>equals()</literal>와 <literal>hashCode()</literal>를 구현할 것 권장한다. Business key equality는 <literal>equals()</literal> 메소드가 비지니스 키, 즉 실세계에서 우리의 인스턴스를 식별하게 될 키(<emphasis>natural</emphasis> 후보 키)를 형성하는 프로퍼티들만을 비교한다는 점을 의미한다 :"

#: index.docbook:202
msgid "Note that a business key does not have to be as solid as a database primary key candidate (see <xref linkend=\"transactions-basics-identity\"/>). Immutable or unique properties are usually good candidates for a business key."
msgstr ""
      "<![CDATA[public class Cat {\n"
      "\n"
      "    ...\n"
      "    public boolean equals(Object other) {\n"
      "        if (this == other) return true;\n"
      "        if ( !(other instanceof Cat) ) return false;\n"
      "\n"
      "        final Cat cat = (Cat) other;\n"
      "\n"
      "        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;\n"
      "        if ( !cat.getMother().equals( getMother() ) ) return false;\n"
      "\n"
      "        return true;\n"
      "    }\n"
      "\n"
      "    public int hashCode() {\n"
      "        int result;\n"
      "        result = getMother().hashCode();\n"
      "        result = 29 * result + getLitterId();\n"
      "        return result;\n"
      "    }\n"
      "\n"
      "}]]>"

#: index.docbook:212
msgid "Dynamic models"
msgstr "하나의 비지니스 키는 데이터베이스 프라이머리 키 후보 만큼 견고하지 않아야 한다(<xref linkend=\"transactions-basics-identity\"/>를 보라). 대개 변경할 수 없는 프로퍼티 또는 유일한(unique) 프로퍼티는 대개 비지니스 키에 대한 좋은 후보들이다."

#: index.docbook:215
msgid "Note that the following features are currently considered experimental and may change in the near future."
msgstr "동적인 모형들"

#: index.docbook:219
msgid "Persistent entities don't necessarily have to be represented as POJO classes or as JavaBean objects at runtime. Hibernate also supports dynamic models (using <literal>Map</literal>s of <literal>Map</literal>s at runtime) and the representation of entities as DOM4J trees. With this approach, you don't write persistent classes, only mapping files."
msgstr "다음 특징들은 현재 실험적으로 고려되고 있으며 장래에는 변경될 수 있음을 노트하라."

#: index.docbook:227
msgid "By default, Hibernate works in normal POJO mode. You may set a default entity representation mode for a particular <literal>SessionFactory</literal> using the <literal>default_entity_mode</literal> configuration option (see <xref linkend=\"configuration-optional-properties\"/>."
msgstr "영속 엔티티들은 반드시 실행시에 POJO 클래스들로 또는 자바빈즈 객체들로 표현되어야할 필요는 없다. Hibernate는 또한 (실행 시에 <literal>Map</literal>들을 가진 <literal>Map</literal>들을 사용하여) 동적인 모형들을 지원하고 DOM4J 트리들로서 엔티티들에 대한 표현을 지원한다. 이 접근법으로, 당신은 영속 클래스들을 작성하지 않고, 오직 매핑 파일들 만을 작성한다."

#: index.docbook:234
msgid "The following examples demonstrates the representation using <literal>Map</literal>s. First, in the mapping file, an <literal>entity-name</literal> has to be declared instead of (or in addition to) a class name:"
msgstr "디폴트로, Hibernate는 통산의 POJO 모드로 동작한다. 당신은 <literal>default_entity_mode</literal> 구성 옵션을 사용하여 특별한 <literal>SessionFactory</literal>에 대해 디폴트 엔티티 표현 모드를 설정할 수 있다 (<xref linkend=\"configuration-optional-properties\"/>을 보라)."

#: index.docbook:240
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class entity-name=\"Customer\">\n"
      "\n"
      "        <id name=\"id\"\n"
      "            type=\"long\"\n"
      "            column=\"ID\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "\n"
      "        <property name=\"name\"\n"
      "            column=\"NAME\"\n"
      "            type=\"string\"/>\n"
      "\n"
      "        <property name=\"address\"\n"
      "            column=\"ADDRESS\"\n"
      "            type=\"string\"/>\n"
      "\n"
      "        <many-to-one name=\"organization\"\n"
      "            column=\"ORGANIZATION_ID\"\n"
      "            class=\"Organization\"/>\n"
      "\n"
      "        <bag name=\"orders\"\n"
      "            inverse=\"true\"\n"
      "            lazy=\"false\"\n"
      "            cascade=\"all\">\n"
      "            <key column=\"CUSTOMER_ID\"/>\n"
      "            <one-to-many class=\"Order\"/>\n"
      "        </bag>\n"
      "\n"
      "    </class>\n"
      "    \n"
      "</hibernate-mapping>]]>"
msgstr "다음 예제들은<literal>Map</literal>들을 사용하는 표현을 설명한다. 먼저 매핑 파일에서, <literal>entity-name</literal>은 클래스 이름 대신에(또는 클래스 이름에 덧붙여) 선언되어야 한다:"

#: index.docbook:242
msgid "Note that even though associations are declared using target class names, the target type of an associations may also be a dynamic entity instead of a POJO."
msgstr ""
      "<![CDATA[<hibernate-mapping>\n"
      "\n"
      "    <class entity-name=\"Customer\">\n"
      "\n"
      "        <id name=\"id\"\n"
      "            type=\"long\"\n"
      "            column=\"ID\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "\n"
      "        <property name=\"name\"\n"
      "            column=\"NAME\"\n"
      "            type=\"string\"/>\n"
      "\n"
      "        <property name=\"address\"\n"
      "            column=\"ADDRESS\"\n"
      "            type=\"string\"/>\n"
      "\n"
      "        <many-to-one name=\"organization\"\n"
      "            column=\"ORGANIZATION_ID\"\n"
      "            class=\"Organization\"/>\n"
      "\n"
      "        <bag name=\"orders\"\n"
      "            inverse=\"true\"\n"
      "            lazy=\"false\"\n"
      "            cascade=\"all\">\n"
      "            <key column=\"CUSTOMER_ID\"/>\n"
      "            <one-to-many class=\"Order\"/>\n"
      "        </bag>\n"
      "\n"
      "    </class>\n"
      "    \n"
      "</hibernate-mapping>]]>"

#: index.docbook:249
msgid "After setting the default entity mode to <literal>dynamic-map</literal> for the <literal>SessionFactory</literal>, we can at runtime work with <literal>Map</literal>s of <literal>Map</literal>s:"
msgstr "심지어 비록 연관들이 대상(target) 클래스 이름들을 사용하여 선언될지라도, 연관들의 대상(target) 타입은 또한 POJO가 아닌 동적인 엔티티일 수 있음을 노트하라."

#: index.docbook:255
msgid ""
      "<![CDATA[Session s = openSession();\n"
      "Transaction tx = s.beginTransaction();\n"
      "Session s = openSession();\n"
      "\n"
      "// Create a customer\n"
      "Map david = new HashMap();\n"
      "david.put(\"name\", \"David\");\n"
      "\n"
      "// Create an organization\n"
      "Map foobar = new HashMap();\n"
      "foobar.put(\"name\", \"Foobar Inc.\");\n"
      "\n"
      "// Link both\n"
      "david.put(\"organization\", foobar);\n"
      "\n"
      "// Save both\n"
      "s.save(\"Customer\", david);\n"
      "s.save(\"Organization\", foobar);\n"
      "\n"
      "tx.commit();\n"
      "s.close();]]>"
msgstr "<literal>SessionFactory</literal>에 대한 디폴트 엔티티 모드를 <literal>dynamic-map</literal>으로 설정한 후에, 우리는 <literal>Map</literal>들을 가진 <literal>Map</literal>들에 대해 실행 시에 작업할 수 있다:"

#: index.docbook:257
msgid "The advantages of a dynamic mapping are quick turnaround time for prototyping without the need for entity class implementation. However, you lose compile-time type checking and will very likely deal with many exceptions at runtime. Thanks to the Hibernate mapping, the database schema can easily be normalized and sound, allowing to add a proper domain model implementation on top later on."
msgstr ""
      "<![CDATA[Session s = openSession();\n"
      "Transaction tx = s.beginTransaction();\n"
      "Session s = openSession();\n"
      "\n"
      "// Create a customer\n"
      "Map david = new HashMap();\n"
      "david.put(\"name\", \"David\");\n"
      "\n"
      "// Create an organization\n"
      "Map foobar = new HashMap();\n"
      "foobar.put(\"name\", \"Foobar Inc.\");\n"
      "\n"
      "// Link both\n"
      "david.put(\"organization\", foobar);\n"
      "\n"
      "// Save both\n"
      "s.save(\"Customer\", david);\n"
      "s.save(\"Organization\", foobar);\n"
      "\n"
      "tx.commit();\n"
      "s.close();]]>"

#: index.docbook:265
msgid "Entity representation modes can also be set on a per <literal>Session</literal> basis:"
msgstr "dynamic 매핑의 장점들은 엔티티 클래스 구현에 대한 필요 없이도 프로토타이핑을 위한 빠른 전환 시간이다. 하지만 당신은 컴파일 시 타입 체킹을 잃고 실행 시에 많은 예외상황들을 다루게 될 것이다. Hibernate 매핑 덕분에, 나중에 고유한 도메인 모형 구현을 상단에 추가하는 것이 허용되어서, 데이터베이스 스키마가 쉽게 정규화 되고 소리가 울려 퍼질 수 있다."

#: index.docbook:270
msgid ""
      "<![CDATA[Session dynamicSession = pojoSession.getSession(EntityMode.MAP);\n"
      "\n"
      "// Create a customer\n"
      "Map david = new HashMap();\n"
      "david.put(\"name\", \"David\");\n"
      "dynamicSession.save(\"Customer\", david);\n"
      "...\n"
      "dynamicSession.flush();\n"
      "dynamicSession.close()\n"
      "...\n"
      "// Continue on pojoSession\n"
      "]]>"
msgstr "엔티티 표현 모드들은 또한 하나의 단위 <literal>Session</literal> 기준에 대해 설정될 수 있다:"

#: index.docbook:273
msgid "Please note that the call to <literal>getSession()</literal> using an <literal>EntityMode</literal> is on the <literal>Session</literal> API, not the <literal>SessionFactory</literal>. That way, the new <literal>Session</literal> shares the underlying JDBC connection, transaction, and other context information. This means you don't have tocall <literal>flush()</literal> and <literal>close()</literal> on the secondary <literal>Session</literal>, and also leave the transaction and connection handling to the primary unit of work."
msgstr ""
      "<![CDATA[Session dynamicSession = pojoSession.getSession(EntityMode.MAP);\n"
      "\n"
      "// Create a customer\n"
      "Map david = new HashMap();\n"
      "david.put(\"name\", \"David\");\n"
      "dynamicSession.save(\"Customer\", david);\n"
      "...\n"
      "dynamicSession.flush();\n"
      "dynamicSession.close()\n"
      "...\n"
      "// Continue on pojoSession\n"
      "]]>"

#: index.docbook:283
msgid "More information about the XML representation capabilities can be found in <xref linkend=\"xml\"/>."
msgstr "<literal>EntityMode</literal>를 사용하는 <literal>getSession()</literal>에 대한 호출은 <literal>SessionFactory</literal>가 아닌, <literal>Session</literal> API에 대한 것임을 노트하길 바란다. 그 방법으로, 새로운 <literal>Session</literal>은 기본 JDBC 커넥션, 트랜잭션, 그리고 다른 컨텍스트 정보를 공유한다. 이것은 당신이 두 번째 <literal>Session</literal> 상에서 <literal>flush()</literal>와 <literal>close()</literal>를 호출하지 말아야 하고, 또한 트랜잭션 및 커넥션 핸들링을 주된 작업 단위에게 맡긴다는 점을 의미한다."

#: index.docbook:291
msgid "Tuplizers"
msgstr "XML 표현 가용성들에 대한 추가 정보는 <xref linkend=\"xml\"/>에서 찾을 수 있다."

#: index.docbook:293
msgid "<literal>org.hibernate.tuple.Tuplizer</literal>, and its sub-interfaces, are responsible for managing a particular representation of a piece of data, given that representation's <literal>org.hibernate.EntityMode</literal>. If a given piece of data is thought of as a data structure, then a tuplizer is the thing which knows how to create such a data structure and how to extract values from and inject values into such a data structure. For example, for the POJO entity mode, the correpsonding tuplizer knows how create the POJO through its constructor and how to access the POJO properties using the defined property accessors. There are two high-level types of Tuplizers, represented by the <literal>org.hibernate.tuple.entity.EntityTuplizer</literal> and <literal>org.hibernate.tuple.component.ComponentTuplizer</literal> interfaces. <literal>EntityTuplizer</literal>s are responsible for managing the above mentioned contracts in regards to entities, while <literal>ComponentTuplizer</literal>s do the same for components."
msgstr "Tuplizer들"

#: index.docbook:308
msgid "Users may also plug in their own tuplizers. Perhaps you require that a <literal>java.util.Map</literal> implementation other than <literal>java.util.HashMap</literal> be used while in the dynamic-map entity-mode; or perhaps you need to define a different proxy generation strategy than the one used by default. Both would be achieved by defining a custom tuplizer implementation. Tuplizers definitions are attached to the entity or component mapping they are meant to manage. Going back to the example of our customer entity:"
msgstr "<literal>org.hibernate.tuple.Tuplizer</literal>, 그리고 그것의 서브-인터페이스들은 데이터의 조각에 대한 특별한 표현의 <literal>org.hibernate.EntityMode</literal>가 주어지면 그 표현을 관리하는 책임이 있다. 만일 주어진 데이터 조각이 하나의 데이터 구조로 간주될 경우, 그때 하나의 tuplizer는 그런 데이터 구조를 생성시키는 방법과 그런 데이터 구조로부터 값들을 추출시키는 방법 그리고 그런 데이터구조 속으로 값들을 삽입시키는 방법을 알고 있는 것이다. 예를 들어, POJO 엔티티 모드의 경우, 대응하는 tuplizer는 그것의 생성자를 통해 POJO를 생성시키는 방법, 그리고 정의된 프로퍼티 접근자들을 사용하여 POJO 프로퍼티들에 접근하는 방법을 안다. <literal>org.hibernate.tuple.entity.EntityTuplizer</literal> 인터페이스와 <literal>org.hibernate.tuple.component.ComponentTuplizer</literal> 인터페이스에 의해 표현되는 두 가지 고급 유형의 Tuplizer들이 존재한다. <literal>EntityTuplizer</literal>들은 엔티티들에 관해서는 위에 언급된 계약들을 매핑할 책임이 있는 반면에, <literal>ComponentTuplizer</literal>들은 컴포넌트들에 대해서도 동일한 것을 행한다."

#: index.docbook:317
msgid ""
      "<![CDATA[<hibernate-mapping>\n"
      "    <class entity-name=\"Customer\">\n"
      "        <!--\n"
      "            Override the dynamic-map entity-mode\n"
      "            tuplizer for the customer entity\n"
      "        -->\n"
      "        <tuplizer entity-mode=\"dynamic-map\"\n"
      "                class=\"CustomMapTuplizerImpl\"/>\n"
      "\n"
      "        <id name=\"id\" type=\"long\" column=\"ID\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "\n"
      "        <!-- other properties -->\n"
      "        ...\n"
      "    </class>\n"
      "</hibernate-mapping>\n"
      "\n"
      "\n"
      "public class CustomMapTuplizerImpl\n"
      "        extends org.hibernate.tuple.entity.DynamicMapEntityTuplizer {\n"
      "    // override the buildInstantiator() method to plug in our custom map...\n"
      "    protected final Instantiator buildInstantiator(\n"
      "            org.hibernate.mapping.PersistentClass mappingInfo) {\n"
      "        return new CustomMapInstantiator( mappingInfo );\n"
      "    }\n"
      "\n"
      "    private static final class CustomMapInstantiator\n"
      "            extends org.hibernate.tuple.DynamicMapInstantitor {\n"
      "        // override the generateMap() method to return our custom map...\n"
      "            protected final Map generateMap() {\n"
      "                    return new CustomMap();\n"
      "            }\n"
      "    }\n"
      "}]]>"
msgstr "사용자들은 또한 그들 자신의 tuplizer들을 플러그 시킬 수 있다. 아마 당신은 dynamic-map entity-mode 동안에 사용되는 <literal>java.util.HashMap</literal> 대신에 하나의 <literal>java.util.Map</literal> 구현을 필요로 한다; 또는 아마 당신은 디폴트로 사용되는 방도 보다는 하나의 다른 다른 프릭시 산출 방도를 필요로 한다. 둘다 하나의 맞춤형 tuplizer를 정의함으로써 성취될 것이다. Tuplizer들 정의들은 그것들이 관리할 수단인 엔티티 매핑 또는 컴포넌트 매핑에 첨부된다. 우리의 고객 엔티티에 대한 예제로 되돌아가면:"

#: index.docbook:322
msgid "TODO: Document user-extension framework in the property and proxy packages"
msgstr ""
      "<![CDATA[<hibernate-mapping>\n"
      "    <class entity-name=\"Customer\">\n"
      "        <!--\n"
      "            Override the dynamic-map entity-mode\n"
      "            tuplizer for the customer entity\n"
      "        -->\n"
      "        <tuplizer entity-mode=\"dynamic-map\"\n"
      "                class=\"CustomMapTuplizerImpl\"/>\n"
      "\n"
      "        <id name=\"id\" type=\"long\" column=\"ID\">\n"
      "            <generator class=\"sequence\"/>\n"
      "        </id>\n"
      "\n"
      "        <!-- other properties -->\n"
      "        ...\n"
      "    </class>\n"
      "</hibernate-mapping>\n"
      "\n"
      "\n"
      "public class CustomMapTuplizerImpl\n"
      "        extends org.hibernate.tuple.entity.DynamicMapEntityTuplizer {\n"
      "    // override the buildInstantiator() method to plug in our custom map...\n"
      "    protected final Instantiator buildInstantiator(\n"
      "            org.hibernate.mapping.PersistentClass mappingInfo) {\n"
      "        return new CustomMapInstantiator( mappingInfo );\n"
      "    }\n"
      "\n"
      "    private static final class CustomMapInstantiator\n"
      "            extends org.hibernate.tuple.DynamicMapInstantitor {\n"
      "        // override the generateMap() method to return our custom map...\n"
      "        protected final Map generateMap() {\n"
      "            return new CustomMap();\n"
      "        }\n"
      "    }\n"
      "}]]>"

#: index.docbook:293
msgid "appended paragraph 1"
msgstr "TODO: property 패키지와 proxy 패키지 내에 user-extension 프레임웍을 문서화 할 것."

msgid "ROLES_OF_TRANSLATORS"
msgstr "<!--TRANS:ROLES_OF_TRANSLATORS-->"

msgid "CREDIT_FOR_TRANSLATORS"
msgstr "<!--TRANS:CREDIT_FOR_TRANSLATORS-->"

