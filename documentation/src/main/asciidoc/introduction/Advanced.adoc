[[advanced]]
== Advanced Topics

In the last chapter of this Introduction, we turn to some topics that don't really belong in an introduction.
Here we consider some problems, and solutions, that you're probably not going to run into immediately if you're new to Hibernate.
But we do want you to know _about_ them, so that when the time comes, you'll know what tool to reach for.

[[filters]]
=== Filters

_Filters_ are one of the nicest and under-usedest features of Hibernate, and we're quite proud of them.
A filter is a named, globally-defined, parameterized restriction on the data that is visible in a given session.

Examples of well-defined filters might include:

- a filter that restricts the data visible to a given user according to row-level permissions,
- a filter which hides data which has been soft-deleted,
- in a versioned database, a filter that displays versions which were current at a given instant in the past, or
- a filter that restricts to data associated with a certain geographical region.

A filter must be declared somewhere.
A package descriptor is as good a place as any for a link:{doc-javadoc-url}org/hibernate/annotations/FilterDef.html[`@FilterDef`]:

[source,java]
----
@FilterDef(name = "ByRegion",
           parameters = @ParamDef(name = "region", type = String.class))
package org.hibernate.example;
----

This filter has one parameter.
Fancier filters might in principle have multiple parameters, though we admit this must be quite rare.

[IMPORTANT]
====
If you add annotations to a package descriptor, and you're using `Configuration` to configure Hibernate, make sure you call `Configuration.addPackage()` to let Hibernate know that the package descriptor is annotated.
====

_Typically_, but not necessarily, a `@FilterDef` specifies a default restriction:

[source,java]
----
@FilterDef(name = "ByRegion",
           parameters = @ParamDef(name = "region", type = String.class),
           defaultCondition = "region = :region")
package org.hibernate.example;
----

Note that filter restrictions are always written in the native SQL dialect of the database, _not_ in HQL.

The restriction must contain a reference to the parameter of the filter, specified using the usual syntax for named parameters.

Any entity or collection which is affected by a filter must be annotated link:{doc-javadoc-url}org/hibernate/annotations/Filter.html[`@Filter`]:

[source,java]
----
@Entity
@Filter(name = example_.BY_REGION)
class User {

    @Id String username;

    String region;

    ...
}
----

Here, as usual, `example_.BY_REGION` is generated by Hibernate Processor, and is just a constant with the value `"ByRegion"`.

If the `@Filter` annotation does not explicitly specify a restriction, the default restriction given by the `@FilterDef` will be applied to the entity.
But an entity is free to override the default condition.

[source,java]
----
@Entity
@Filter(name = example_.FILTER_BY_REGION, condition = "name = :region")
class Region {

    @Id String name;

    ...
}
----

Note that the restriction specified by the `condition` or `defaultCondition` is a native SQL expression.

.Annotations for defining filters
[%breakable,cols="25,~"]
|===
| Annotation | Purpose

| `@FilterDef` | Defines a filter and declares its name (exactly one per filter)
| `@Filter` | Specifies how a filter applies to a given entity or collection (many per filter)
|===

[TIP]
====
A filter `condition` may not specify joins to other tables, but it may contain a subquery.
[source,java]
----
@Filter(name="notDeleted"
        condition="(select r.deletionTimestamp from Record r where r.id = record_id) is not null")
----
Only unqualified column names like `record_id` in this example are interpreted as belonging to the table of the filtered entity.
====

By default, a new session comes with every filter disabled.
A filter may be explicitly enabled in a given session by calling link:{doc-javadoc-url}org/hibernate/Session.html#enableFilter(java.lang.String)[`enableFilter()`] and assigning arguments to the parameters of the filter using the returned instance of link:{doc-javadoc-url}org/hibernate/Filter.html[`Filter`].
You should do this right at the _start_ of the session.

[source,java]
----
sessionFactory.inTransaction(session -> {
    session.enableFilter(example_.FILTER_BY_REGION)
        .setParameter("region", "es")
        .validate();

    ...
});
----

Now, any queries executed within the session will have the filter restriction applied.
Collections annotated `@Filter` will also have their members correctly filtered.

[CAUTION]
====
On the other hand, filters are not applied to `@ManyToOne` associations, nor to `find()`.
This is completely by design and is not in any way a bug.
====

More than one filter may be enabled in a given session.

Alternatively, since Hibernate 6.5, a filter may be declared as `autoEnabled` in every session.
In this case, the argument to a filter parameter must be obtained from a `Supplier`.

[source,java]
----
@FilterDef(name = "ByRegion",
           autoEnabled = true,
           parameters = @ParamDef(name = "region", type = String.class,
                                  resolver = RegionSupplier.class),
           defaultCondition = "region = :region")
package org.hibernate.example;
----

It's not necessary to call `enableFilter()` for a filter declared `autoEnabled = true`.

[TIP]
====
When we only need to filter rows by a static condition with no parameters, we don't need a filter, since link:{doc-javadoc-url}org/hibernate/annotations/SQLRestriction.html[`@SQLRestriction`] provides a much simpler way to do that.
====

:envers: https://hibernate.org/orm/envers/
:envers-doc: {doc-user-guide-url}#envers

We've mentioned that a filter can be used to implement versioning, and to provide _historical_ views of the data.
Being such a general-purpose construct, filters provide a lot of flexibility here.
But if you're after a more focused/opinionated solution to this problem, you should definitely check out {envers}[Envers].

[[envers]]
.Using Envers for auditing historical data
****
Envers is an add-on to Hibernate ORM which keeps a historical record of each versioned entity in a separate _audit table_, and allows past revisions of the data to be viewed and queried.
A full introduction to Envers would require a whole chapter, so we'll just give you a quick taste here.

First, we must mark an entity as versioned, using the `@Audited` annotation:
[source,java]
----
@Audited @Entity
@Table(name="CurrentDocument")
@AuditTable("DocumentRevision")
class Document { ... }
----
[TIP]
====
The `@AuditTable` annotation is optional, and it's better to set either `org.hibernate.envers.audit_table_prefix` or `org.hibernate.envers.audit_table_suffix` and let the audit table name be inferred.
====
The `AuditReader` interface exposes operations for retrieving and querying historical revisions.
It's really easy to get hold of one of these:
[source,java]
----
AuditReader reader = AuditReaderFactory.get(entityManager);
----
Envers tracks revisions of the data via a global _revision number_.
We may easily find the revision number which was current at a given instant:
[source,java]
----
Number revision = reader.getRevisionNumberForDate(datetime);
----
We can use the revision number to ask for the version of our entity associated with the given revision number:
[source,java]
----
Document doc = reader.find(Document.class, id, revision);
----
Alternatively, we can directly ask for the version which was current at a given instant:
[source,java]
----
Document doc = reader.find(Document.class, id, datetime);
----
We can even execute queries to obtain lists of entities current at the given revision number:
[source,java]
----
List documents =
        reader.createQuery()
            .forEntitiesAtRevision(Document.class, revision)
            .getResultList();
----
For much more information, see the {envers-doc}[User Guide].
****

Historically, filters where often used to implement soft-delete.
But, since 6.4, Hibernate now comes with soft-delete built in.

[[soft-delete]]
=== Soft-delete

:soft-delete-doc: {doc-user-guide-url}#soft-delete

Even when we don't need complete historical versioning, we often prefer to "delete" a row by marking it as obsolete using a SQL `update`, rather than by executing an actual SQL `delete` and removing the row from the database completely.

The link:{doc-javadoc-url}org/hibernate/annotations/SoftDelete.html[`@SoftDelete`] annotation controls how this works:
[source,java]
----
@Entity
@SoftDelete(columnName = "deleted",
            converter = TrueFalseConverter.class)
class Draft {

    ...
}
----
The `columnName` specifies a column holding the deletion status, and the `converter` is responsible for converting a Java `Boolean` to the type of that column.
In this example, link:{doc-javadoc-url}org/hibernate/type/TrueFalseConverter.html[`TrueFalseConverter`] sets the column to the character `'F'` initially, and to `'T'` when the row is deleted.
Any JPA `AttributeConverter` for the Java `Boolean` type may be used here.
Built-in options include link:{doc-javadoc-url}org/hibernate/type/NumericBooleanConverter.html[`NumericBooleanConverter`] and link:{doc-javadoc-url}org/hibernate/type/YesNoConverter.html[`YesNoConverter`].

Much more information about soft delete is available in the {soft-delete-doc}[User Guide].

Another feature that you _could_ use filters for, but now don't need to, is multi-tenancy.

[[multitenancy]]
=== Multi-tenancy

:multitenacy-doc: {doc-user-guide-url}#multitenacy

A _multi-tenant_ database is one where the data is segregated by _tenant_.
We don't need to actually define what a "tenant" really represents here; all we care about at this level of abstraction is that each tenant may be distinguished by a unique identifier.
And that there's a well-defined _current tenant_ in each session.

We may specify the current tenant when we open a session:

[source,java]
----
var session =
        sessionFactory.withOptions()
            .tenantIdentifier(tenantId)
            .openSession();
----

Or, when using JPA-standard APIs:

[source,java]
----
var entityManager =
        entityManagerFactory.createEntityManager(Map.of(HibernateHints.HINT_TENANT_ID, tenantId));
----

However, since we often don't have this level of control over creation of the session, it's more common to supply an implementation of link:{doc-javadoc-url}org/hibernate/context/spi/CurrentTenantIdentifierResolver.html[`CurrentTenantIdentifierResolver`] to Hibernate.

To make use of multi-tenancy, we'll usually need to set at least one of these configuration properties:

.Multi-tenancy configuration
[%breakable,cols="36,~"]
|===
| Configuration property name           | Purpose

| link:{doc-javadoc-url}org/hibernate/cfg/MultiTenancySettings.html#MULTI_TENANT_IDENTIFIER_RESOLVER[`hibernate.tenant_identifier_resolver`]  | Specifies the `CurrentTenantIdentifierResolver`
| link:{doc-javadoc-url}org/hibernate/cfg/MultiTenancySettings.html#MULTI_TENANT_SCHEMA_MAPPER[`hibernate.multi_tenant.schema_mapper`]  | Specifies the `TenantSchemaMapper` for schema-based multi-tenancy
| link:{doc-javadoc-url}org/hibernate/cfg/MultiTenancySettings.html#MULTI_TENANT_CONNECTION_PROVIDER[`hibernate.multi_tenant_connection_provider`]  | Specifies the `MultiTenantConnectionProvider` for database-based multi-tenancy
|===

// Do not configure those properties if you would like the configured `BeanContainer` provide the implementation.

There are three common approaches to multi-tenancy:

1. each tenant has its own database,
2. each tenant has its own schema, or
3. tenants share tables in a single schema, and rows are tagged with the tenant id.

[discrete]
==== Database-based multi-tenancy

The first option is to give each tenant its own database.
That is, we'll use a separate source of JDBC connections for each tenant.

The interface link:{doc-javadoc-url}org/hibernate/engine/jdbc/connections/spi/MultiTenantConnectionProvider.html[`MultiTenantConnectionProvider`] is responsible for obtaining an appropriate `Connection` for a given tenant.
Typically, we'll provide a custom implementation of this interface:

- from time to time, Hibernate will ask for a connection, passing the id of the current tenant, and then we must create an appropriate connection or obtain one from a pool, and return it to Hibernate, and
- later, Hibernate will release the connection and ask us to destroy it or return it to the appropriate pool.

[TIP]
====
Check out link:{doc-javadoc-url}org/hibernate/engine/jdbc/connections/spi/DataSourceBasedMultiTenantConnectionProviderImpl.html[`DataSourceBasedMultiTenantConnectionProviderImpl`] for inspiration.
If your source of JDBC connections is a set of JNDI-bound ``DataSource``s, you might even be able to use this implementation directly.
====

[discrete]
==== Schema-based multi-tenancy

The second option is to keep all the data for different tenants in the same database, giving each tenant a different named database schema with its own set of tables.

In this case we must supply a link:{doc-javadoc-url}org/hibernate/context/spi/TenantSchemaMapper.html[`TenantSchemaMapper`] which is responsible for mapping from tenant ids to schema names.

[discrete]
==== Discriminator-based multi-tenancy

The third option is quite different.
In this case we store data from all tenants in the same tables, but each table has a dedicated column holding the tenant id mapped by each of our entities.

[source,java]
----
@Entity
class Account {
    @Id String id;
    @TenantId String tenantId;
    
    ...
}
----

The link:{doc-javadoc-url}org/hibernate/annotations/TenantId.html[`@TenantId`] annotation is used to indicate an attribute of an entity which holds the tenant id.
Within a given session, our data is automatically filtered so that only rows tagged with the tenant id of the current tenant are visible in that session.

[CAUTION]
====
Native SQL queries are _not_ automatically filtered by tenant id; you'll have to do that part yourself.
====

[[custom-sql]]
=== Using custom-written SQL

We've already discussed how to run <<native-queries,queries written in SQL>>, but occasionally that's not enough.
Sometimes—but much less often than you might expect—we would like to customize the SQL used by Hibernate to perform basic CRUD operations for an entity or collection.

For this we can use link:{doc-javadoc-url}org/hibernate/annotations/SQLInsert.html[`@SQLInsert`] and friends:

[source,java]
----
@Entity
@SQLInsert(sql = "insert into person (name, id, valid) values (?, ?, true)",
           verify = Expectation.RowCount.class)
@SQLUpdate(sql = "update person set name = ? where id = ?")
@SQLDelete(sql = "update person set valid = false where id = ?")
@SQLSelect(sql = "select id, name from person where id = ? and valid = true")
public static class Person { ... }
----

.Annotations for overriding generated SQL
[%breakable,cols="25,~"]
|===
| Annotation | Purpose

| link:{doc-javadoc-url}org/hibernate/annotations/SQLSelect.html[`@SQLSelect`] | Overrides a generated SQL `select` statement
| link:{doc-javadoc-url}org/hibernate/annotations/SQLInsert.html[`@SQLInsert`] | Overrides a generated SQL `insert` statement
| link:{doc-javadoc-url}org/hibernate/annotations/SQLUpdate.html[`@SQLUpdate`] | Overrides a generated SQL `update` statement
| link:{doc-javadoc-url}org/hibernate/annotations/SQDelete.html[`@SQDelete`] | Overrides a generated SQL `delete` statement for a single row
| link:{doc-javadoc-url}org/hibernate/annotations/SQDeleteAll.html[`@SQDeleteAll`] | Overrides a generated SQL `delete` statement for multiple rows
| link:{doc-javadoc-url}org/hibernate/annotations/SQLRestriction.html[`@SQLRestriction`] | Adds a restriction to generated SQL
| link:{doc-javadoc-url}org/hibernate/annotations/SQLOrder.html[`@SQLOrder`] | Adds an ordering to generated SQL
|===

[TIP]
====
If the custom SQL should be executed via a `CallableStatement`, just specify `callable=true`.
====

Any SQL statement specified by one of these annotations must have exactly the number of JDBC parameters that Hibernate expects, that is, one for each column mapped by the entity, in the exact order Hibernate expects. In particular, the primary key columns must come last.

However, the `@Column` annotation does lend some flexibility here:

- if a column should not be written as part of the custom `insert` statement, and has no corresponding JDBC parameter in the custom SQL, map it `@Column(insertable=false)`, or
- if a column should not be written as part of the custom `update` statement, and has no corresponding JDBC parameter in the custom SQL, map it `@Column(updatable=false)`.

The `verify` member of these annotations specifies a class implementing `Expectation`, allowing customized logic for checking the success of an operation executed via JDBC.
There are three built-in implementations:

- `Expectation.None`, which performs no checks,
- `Expectation.RowCount`, which is what Hibernate usually uses when executing its own generated SQL,
- and `Expectation.OutParameter`, which is useful for checking an output parameter of a stored procedure.

You can write your own implementation of `Expectation` if none of these options is suitable.

[TIP]
====
If you need custom SQL, but are targeting multiple dialects of SQL, you can use the annotations defined in link:{doc-javadoc-url}org/hibernate/annotations/DialectOverride.html[`DialectOverride`].
For example, this annotation lets us override the custom `insert` statement just for PostgreSQL:

[source,java]
----
@DialectOverride.SQLInsert(dialect = PostgreSQLDialect.class,
    override = @SQLInsert(sql="insert into person (name,id) values (?,gen_random_uuid())"))
----
It's even possible to override the custom SQL for specific _versions_ of a database.
====

Sometimes a custom `insert` or `update` statement assigns a value to a mapped column which is calculated when the statement is executed on the database.
For example, the value might be obtained by calling a SQL function:

[source,java]
----
@SQLInsert(sql = "insert into person (name, id) values (?, gen_random_uuid())")
----

But the entity instance which represents the row being inserted or updated won't be automatically populated with that value.
And so our persistence context loses synchronization with the database.
In situations like this, we may use the `@Generated` annotation to tell Hibernate to reread the state of the entity after each `insert` or `update`.

[[database-generated-columns]]
=== Handling database-generated columns

Sometimes, a column value is assigned or mutated by events that happen in the database, and aren't visible to Hibernate.
For example:

- a table might have a column value populated by a trigger,
- a mapped column might have a default value defined in DDL, or
- a custom SQL `insert` or `update` statement might assign a value to a mapped column, as we saw in the previous subsection.

One way to deal with this situation is to explicitly call `refresh()` at appropriate moments, forcing the session to reread the state of the entity.
But this is annoying.

The link:{doc-javadoc-url}org/hibernate/annotations/Generated.html[`@Generated`] annotation relieves us of the burden of explicitly calling `refresh()`.
It specifies that the value of the annotated entity attribute is generated by the database, and that the generated value should be automatically retrieved using a SQL `returning` clause, or separate `select` after it is generated.

A useful example is the following mapping:

[source,java]
----
@Entity
class Entity {
    @Generated @Id
    @ColumnDefault("gen_random_uuid()")
    UUID id;
}
----

The generated DDL is:

[source,sql]
----
create table Entity (
    id uuid default gen_random_uuid() not null,
    primary key (uuid)
)
----

So here the value of `id` is defined by the column default clause, by calling the PostgreSQL function `gen_random_uuid()`.

When a column value is generated during updates, use `@Generated(event=UPDATE)`.
When a value is generated by both inserts _and_ updates, use `@Generated(event={INSERT,UPDATE})`.

[TIP]
====
For columns which should be generated using a SQL `generated always as` clause, prefer the link:{doc-javadoc-url}org/hibernate/annotations/GeneratedColumn.html[`@GeneratedColumn`] annotation, so that Hibernate automatically generates the correct DDL.
====

Actually, the `@Generated` and `@GeneratedColumn` annotations are defined in terms of a more generic and user-extensible framework for handling attribute values generated in Java, or by the database.
So let's drop down a layer, and see how that works.

[[user-defined-generators]]
=== User-defined generators

JPA doesn't define a standard way to extend the set of id generation strategies, but Hibernate does:

- the link:{doc-javadoc-url}org/hibernate/generator/Generator.html[`Generator`] hierarchy of interfaces in the package `org.hibernate.generator` lets you define new generators, and
- the link:{doc-javadoc-url}org/hibernate/annotations/IdGeneratorType.html[`@IdGeneratorType`] meta-annotation from the package `org.hibernate.annotations` lets you write an annotation which associates a `Generator` type with identifier attributes.

Furthermore, the link:{doc-javadoc-url}org/hibernate/annotations/ValueGenerationType.html[`@ValueGenerationType`] meta-annotation lets you write an annotation which associates a `Generator` type with a non-`@Id` attribute.

[NOTE]
// .The older APIs are still available in Hibernate 6
====
These APIs were new in Hibernate 6, and supersede the classic `IdentifierGenerator` interface and `@GenericGenerator` annotation from older versions of Hibernate.
However, the older APIs are still available and custom ``IdentifierGenerator``s written for older versions of Hibernate continue to work in Hibernate 7.
====

Hibernate has a range of built-in generators which are defined in terms of this new framework.

.Built-in generators
[%breakable,cols="20,25,~"]
|===
| Annotation | Implementation | Purpose

| link:{doc-javadoc-url}org/hibernate/annotations/Generated.html[`@Generated`] | `GeneratedGeneration` | Generically handles database-generated values
| link:{doc-javadoc-url}org/hibernate/annotations/GeneratedColumn.html[`@GeneratedColumn`] | `GeneratedAlwaysGeneration` | Handles values generated using `generated always`
| link:{doc-javadoc-url}org/hibernate/annotations/CurrentTimestamp.html[`@CurrentTimestamp`] | `CurrentTimestampGeneration` | Generic support for database or in-memory generation of creation or update timestamps
| link:{doc-javadoc-url}org/hibernate/annotations/CreationTimestamp.html[`@CreationTimestamp`] | `CurrentTimestampGeneration` | A timestamp generated when an entity is first made persistent
| link:{doc-javadoc-url}org/hibernate/annotations/UpdateTimestamp.html[`@UpdateTimestamp`] | `CurrentTimestampGeneration` | A timestamp generated when an entity is made persistent, and regenerated every time the entity is modified
| link:{doc-javadoc-url}org/hibernate/annotations/UuidGenerator.html[`@UuidGenerator`] | `UuidGenerator` | A more flexible generator for RFC 4122 UUIDs
|===

Furthermore, support for JPA's standard id generation strategies is also defined in terms of this framework.

As an example, let's look at how link:{doc-javadoc-url}org/hibernate/annotations/UuidGenerator.html[`@UuidGenerator`] is defined:

[source,java]
----
@IdGeneratorType(org.hibernate.id.uuid.UuidGenerator.class)
@ValueGenerationType(generatedBy = org.hibernate.id.uuid.UuidGenerator.class)
@Retention(RUNTIME)
@Target({ FIELD, METHOD })
public @interface UuidGenerator { ... }
----

`@UuidGenerator` is meta-annotated both `@IdGeneratorType` and `@ValueGenerationType` because it may be used to generate both ids and values of regular attributes.
Either way, link:{doc-javadoc-url}org/hibernate/id/uuid/UuidGenerator.html[this `Generator` class] does the hard work:

[source,java]
----
public class UuidGenerator
        // this generator produced values before SQL is executed
        implements BeforeExecutionGenerator {
    
    // constructors accept an instance of the @UuidGenerator
    // annotation, allowing the generator to be "configured"

    // called to create an id generator
    public UuidGenerator(
            org.hibernate.annotations.UuidGenerator config,
            Member idMember,
            GeneratorCreationContext creationContext) {
        this(config, idMember);
    }

    // called to create a generator for a regular attribute
    public UuidGenerator(
            org.hibernate.annotations.UuidGenerator config,
            Member member,
            GeneratorCreationContext creationContext) {
        this(config, idMember);
    }
    
    ...

    @Override
    public EnumSet<EventType> getEventTypes() {
        // UUIDs are only assigned on insert, and never regenerated
        return INSERT_ONLY;
    }

    @Override
    public Object generate(SharedSessionContractImplementor session, Object owner, Object currentValue, EventType eventType) {
        // actually generate a UUID and transform it to the required type
        return valueTransformer.transform( generator.generateUuid( session ) );
    }
}
----

You can find out more about custom generators from the Javadoc for `@IdGeneratorType` and for `org.hibernate.generator`.


[[naming-strategies]]
=== Naming strategies

When working with a pre-existing relational schema, it's usual to find that the column and table naming conventions used in the schema don't match Java's naming conventions.

Of course, the `@Table` and `@Column` annotations let us explicitly specify a mapped table or column name.
But we would prefer to avoid scattering these annotations across our whole domain model.

Therefore, Hibernate lets us define a mapping between Java naming conventions, and the naming conventions of the relational schema.
Such a mapping is called a _naming strategy_.

First, we need to understand how Hibernate assigns and processes names.

- _Logical naming_ is the process of applying naming rules to determine the _logical names_ of objects which were not explicitly assigned names in the O/R mapping.
  That is, when there's no `@Table` or `@Column` annotation.
- _Physical naming_ is the process of applying additional rules to transform a logical name into an actual "physical" name that will be used in the database.
  For example, the rules might include things like using standardized abbreviations, or trimming the length of identifiers.

Thus, there's two flavors of naming strategy, with slightly different responsibilities.
Hibernate comes with default implementations of these interfaces:


|===
| Flavor | Default implementation

| An link:{doc-javadoc-url}org/hibernate/boot/model/naming/ImplicitNamingStrategy.html[`ImplicitNamingStrategy`] is responsible for assigning a logical name when none is specified by an annotation
| A default strategy which implements the rules defined by JPA
| A link:{doc-javadoc-url}org/hibernate/boot/model/naming/PhysicalNamingStrategy.html[`PhysicalNamingStrategy`] is responsible for transforming a logical name and producing the name used in the database
| A trivial implementation which does no processing
|===

[TIP]
====
We happen to not much like the naming rules defined by JPA, which specify that mixed case and camel case identifiers should be concatenated using underscores.
We bet you could easily come up with a much better `ImplicitNamingStrategy` than that!
(Hint: it should always produce legit mixed case identifiers.)
====

[TIP]
====
The popular link:{doc-javadoc-url}org/hibernate/boot/model/naming/PhysicalNamingStrategySnakeCaseImpl.html[`PhysicalNamingStrategySnakeCaseImpl`] produces snake case identifiers.
====

Custom naming strategies may be enabled using the configuration properties we already mentioned without much explanation back in <<minimizing>>.

.Naming strategy configuration
[%breakable,cols="35,~"]
|===
| Configuration property name           | Purpose

| link:{doc-javadoc-url}org/hibernate/cfg/MappingSettings.html#IMPLICIT_NAMING_STRATEGY[`hibernate.implicit_naming_strategy`]  | Specifies the `ImplicitNamingStrategy`
| link:{doc-javadoc-url}org/hibernate/cfg/MappingSettings.html#PHYSICAL_NAMING_STRATEGY[`hibernate.physical_naming_strategy`]  | Specifies the `PhysicalNamingStrategy`
|===

[[spatial]]
=== Spatial datatypes

:ogc: https://www.ogc.org
:geolatte: https://github.com/GeoLatte/geolatte-geom
:spatial-doc: {doc-user-guide-url}#spatial

Hibernate Spatial augments the <<basic-attributes,built-in basic types>> with a set of Java mappings for {ogc}[OGC] spatial types.

- {geolatte}[Geolatte-geom] defines a set of Java types implementing the OGC spatial types, and codecs for translating to and from database-native spatial datatypes.
- {spatial-doc}[Hibernate Spatial] itself supplies integration with Hibernate.

To use Hibernate Spatial, we must add it as a dependency, as described in <<optional-dependencies>>.

Then we may immediately use Geolatte-geom and JTS types in our entities.
No special annotations are needed:

[source,java]
----
import org.locationtech.jts.geom.Point;
import jakarta.persistence.*;

@Entity
class Event {
    Event() {}

    Event(String name, Point location) {
        this.name = name;
        this.location = location;
    }

    @Id @GeneratedValue
    Long id;

    String name;

    Point location;

}
----

The generated DDL uses `geometry` as the type of the column mapped by `location`:

[source,sql]
----
create table Event (
    id bigint not null,
    location geometry,
    name varchar(255),
    primary key (id)
)
----

Hibernate Spatial lets us work with spatial types just as we would with any of the built-in basic attribute types.

[source,java]
----
var geometryFactory = new GeometryFactory();
...

Point point = geometryFactory.createPoint(new Coordinate(10, 5));
session.persist(new Event("Hibernate ORM presentation", point));
----

But what makes this powerful is that we may write some very fancy queries involving functions of spatial types:

[source,java]
----
Polygon triangle =
        geometryFactory.createPolygon(
                new Coordinate[] {
                        new Coordinate(9, 4),
                        new Coordinate(11, 4),
                        new Coordinate(11, 20),
                        new Coordinate(9, 4)
                }
        );
Point event =
        session.createQuery("select location from Event where within(location, :zone) = true", Point.class)
                .setParameter("zone", triangle)
                .getSingleResult();
----

:matrix: {doc-user-guide-url}#spatial-configuration-dialect-features

Here, `within()` is one of the functions for testing spatial relations defined by the OpenGIS specification.
Other such functions include `touches()`, `intersects()`, `distance()`, `boundary()`, etc.
Not every spatial relation function is supported on every database.
A matrix of support for spatial relation functions may be found in the {matrix}[User Guide].

[TIP]
====
If you want to play with spatial functions on H2, run the following code first:

[source,java]
----
sessionFactory.inTransaction(session -> {
    session.doWork(connection -> {
        try (var statement = connection.createStatement()) {
            statement.execute("create alias if not exists h2gis_spatial for \"org.h2gis.functions.factory.H2GISFunctions.load\"");
            statement.execute("call h2gis_spatial()");
        }
    });
} );
----
====

[[ordered-sorted]]
=== Ordered and sorted collections and map keys

Java lists and maps don't map very naturally to foreign key relationships between tables, and so we tend to avoid using them to represent associations between our entity classes.
But if you feel like you _really_ need a collection with a fancier structure than `Set`, Hibernate does have options.

TIP: For more detail about the use of these annotations, please refer to https://in.relation.to/2024/11/12/-what-collection/[this post on the Hibernate blog].

The following options let us map the index of a `List` or key of a `Map` to a column, and are used with:

- `@ElementCollection`, or
- on the owning side of an association.

They should not be used on the unowned (that is, `mappedBy`) side of an association.

.Annotations for mapping lists and maps
[%breakable,cols="22,~,^13"]
|===
| Annotation | Purpose | JPA-standard

| `@OrderColumn` | Specifies the column used to maintain the order of a list | &#10004;
| link:{doc-javadoc-url}org/hibernate/annotations/ListIndexBase.html[`@ListIndexBase`] | The column value for the first element of the list (zero by default) | &#10006;
| `@MapKeyColumn` | Specifies the column used to persist the keys of a map
(used when the key is of basic type)| &#10004;
| `@MapKeyJoinColumn` | Specifies the column used to persist the keys of a map
(used when the key is an entity) | &#10004;
|===

The name of the `@OrderColumn` or `@MapKeyColumn` may be defaulted, for example:

[source,java]
----
@ManyToMany
@OrderColumn // order of list is persistent
List<Author> authors = new ArrayList<>();
----

But it's usually better to specify the column name explicitly:

[source,java]
----
@ElementCollection
@OrderColumn(name="tag_order")
@ListIndexBase(1) // order column and base value
List<String> tags;
----

Such mappings can get pretty complicated:

[source,java]
----
@ElementCollection
@CollectionTable(name = "author_bios",                 // table name
        joinColumns = @JoinColumn(name = "book_isbn")) // column holding foreign key of owner
@Column(name="bio")                                    // column holding map values
@MapKeyJoinColumn(name="author_ssn")                   // column holding map keys
Map<Author,String> biographies;
----

As you can imagine, we think you should use such mappings very sparingly, if at all.

For a `Map` representing an unowned `@OneToMany` association, the column holding the key of the map must also be mapped on the owning side, usually by an attribute of the target entity.
In this case we use a different annotation:

.Annotation for mapping an entity attribute to a map key
[%breakable,cols="22,~,^13"]
|===
| Annotation | Purpose | JPA-standard

| `@MapKey` | Specifies an attribute of the target entity which acts as the key of the map | &#10004;
|===

Note that `@MapKey` specifies a field or property name, not a column name.

[source,java]
----
@OneToMany(mappedBy = Book_.PUBLISHER)
@MapKey(name = Book_.TITLE) // the key of the map is the title of the book
Map<String,Book> booksByTitle = new HashMap<>();
----

In fact, `@MapKey` may also be used for owned collections.

Now, let's introduce a little distinction:

- an _ordered collection_ is one with an ordering maintained in the database, and
- a _sorted collection_ is one which is sorted in Java code.

These annotations allow us to specify how the elements of a collection should be ordered as they are read from the database:

.Annotations for ordered collections
[%breakable,cols="22,~,^13"]
|===
| Annotation | Purpose | JPA-standard

| `@OrderBy` | Specifies a fragment of JPQL used to order the collection | &#10004;
| `@SQLOrder` | Specifies a fragment of SQL used to order the collection | &#10006;
|===

On the other hand, the following annotations specify how a collection should be sorted in memory, and are used for collections of type `SortedSet` or `SortedMap`:

.Annotations for sorted collections
[%breakable,cols="22,~,^13"]
|===
| Annotation | Purpose | JPA-standard

| link:{doc-javadoc-url}org/hibernate/annotations/SortNatural.html[`@SortNatural`] | Specifies that the elements of a collection are `Comparable` | &#10006;
| link:{doc-javadoc-url}org/hibernate/annotations/SortComparator.html[`@SortComparator`] | Specifies a `Comparator` used to sort the collection | &#10006;
|===

Under the covers, Hibernate uses a `TreeSet` or `TreeMap` to maintain the collection in sorted order.

[[any]]
=== Any mappings

:any-doc: {doc-user-guide-url}#associations-any

An link:{doc-javadoc-url}org/hibernate/annotations/Any.html[`@Any`] mapping is a sort of polymorphic many-to-one association where the target entity types are not related by the usual entity inheritance.
The target type is distinguished using a discriminator value stored on the _referring_ side of the relationship.

This is quite different to <<entity-inheritance,discriminated inheritance>> where the discriminator is held in the tables mapped by the referenced entity hierarchy.

For example, consider an `Order` entity containing `Payment` information, where a `Payment` might be a `CashPayment` or a `CreditCardPayment`:

[source,java]
----
interface Payment { ... }

@Entity
class CashPayment { ... }

@Entity
class CreditCardPayment { ... }
----

In this example, `Payment` is not be declared as an entity type, and is not annotated `@Entity`. It might even be an interface, or at most just a mapped superclass, of `CashPayment` and `CreditCardPayment`. So in terms of the object/relational mappings, `CashPayment` and `CreditCardPayment` would not be considered to participate in the same entity inheritance hierarchy.

On the other hand, `CashPayment` and `CreditCardPayment` do have the same identifier type.
This is important.


An `@Any` mapping would store the discriminator value identifying the concrete type of `Payment` along with the state of the associated `Order`, instead of storing it in the table mapped by `Payment`.

[source,java]
----
@Entity
class Order {
    ...

    @Any
    @AnyKeyJavaClass(UUID.class)   //the foreign key type
    @JoinColumn(name="payment_id") // the foreign key column
    @Column(name="payment_type")   // the discriminator column
    // map from discriminator values to target entity types
    @AnyDiscriminatorValue(discriminator="CASH", entity=CashPayment.class)
    @AnyDiscriminatorValue(discriminator="CREDIT", entity=CreditCardPayment.class)
    Payment payment;

    ...
}
----

It's reasonable to think of the "foreign key" in an `@Any` mapping as a composite value made up of the foreign key and discriminator taken together. Note, however, that this composite foreign key is only conceptual and cannot be declared as a physical constraint on the relational database table.

There are a number of annotations which are useful to express this sort of complicated and unnatural mapping:

.Annotations for `@Any` mappings
|===
| Annotations | Purpose

| link:{doc-javadoc-url}org/hibernate/annotations/Any.html[`@Any`] | Declares that an attribute is a discriminated polymorphic association mapping
| link:{doc-javadoc-url}org/hibernate/annotations/AnyDiscriminator.html[`@AnyDiscriminator`] | Specify the Java type of the discriminator
| `@JdbcType` or `@JdbcTypeCode` | Specify the JDBC type of the discriminator
| link:{doc-javadoc-url}org/hibernate/annotations/AnyDiscriminatorValue.html[`@AnyDiscriminatorValue`] | Specifies how discriminator values map to entity types
| `@Column` or `@Formula` | Specify the column or formula in which the discriminator value is stored
| `@AnyKeyJavaType` or `@AnyKeyJavaClass` | Specify the Java type of the foreign key (that is, of the ids of the target entities)
| `@AnyKeyJdbcType` or `@AnyKeyJdbcTypeCode` | Specify the JDBC type of the foreign key
| `@JoinColumn` | Specifies the foreign key column
|===

Of course, `@Any` mappings are disfavored, except in extremely special cases, since it's much more difficult to enforce referential integrity at the database level.

There's also currently some limitations around querying `@Any` associations in HQL.
This is allowed:

[source,hql]
----
from Order ord
    join CashPayment cash
        on id(ord.payment) = cash.id
----

[CAUTION]
====
Polymorphic association joins for `@Any` mappings are not currently implemented.
====

Further information may be found in the {any-doc}[User Guide].

[[dynamic-insert-update]]
=== Selective column lists in inserts and updates

By default, Hibernate generates `insert` and `update` statements for each entity during boostrap, and reuses the same `insert` statement every time an instance of the entity is made persistent, and the same `update` statement every time an instance of the entity is modified.

This means that:

- if an attribute is `null` when the entity is made persistent, its mapped column is redundantly included in the SQL `insert`, and
- worse, if a certain attribute is unmodified when other attributes are changed, the column mapped by that attribute is redundantly included in the SQL `update`.

Most of the time, this just isn't an issue worth worrying about.
The cost of interacting with the database is _usually_ dominated by the cost of a round trip, not by the number of columns in the `insert` or `update`.
But in cases where it does become important, there are two ways to be more selective about which columns are included in the SQL.

The JPA-standard way is to indicate statically which columns are eligible for inclusion via the `@Column` annotation.
For example, if an entity is always created with an immutable `creationDate`, and with no `completionDate`, then we would write:

[source,java]
----
@Column(updatable=false) LocalDate creationDate;
@Column(insertable=false) LocalDate completionDate;
----

This approach works quite well in many cases, but often breaks down for entities with more than a handful of updatable columns.

An alternative solution is to ask Hibernate to generate SQL dynamically each time an `insert` or `update` is executed.
We do this by annotating the entity class.

.Annotations for dynamic SQL generation
[%breakable,cols="25,~"]
|===
| Annotation | Purpose

| link:{doc-javadoc-url}org/hibernate/annotations/DynamicInsert.html[`@DynamicInsert`] | Specifies that an `insert` statement should be generated each time an entity is made persistent
| link:{doc-javadoc-url}org/hibernate/annotations/DynamicUpdate.html[`@DynamicUpdate`] | Specifies that an `update` statement should be generated each time an entity is modified
|===

It's important to realize that, while `@DynamicInsert` has no impact on semantics, the more useful `@DynamicUpdate` annotation _does_ have a subtle side effect.

[CAUTION]
====
The wrinkle is that if an entity has no version property, `@DynamicUpdate` opens the possibility of two optimistic transactions concurrently reading and selectively updating a given instance of the entity.
In principle, this might lead to a row with inconsistent column values after both optimistic transactions commit successfully.
====

Of course, this consideration doesn't arise for entities with a `@Version` attribute.

[TIP]
====
But there's a solution!
Well-designed relational schemas should have _constraints_ to ensure data integrity.
That's true no matter what measures we take to preserve integrity in our program logic.
We may ask Hibernate to add a <<constraints,`check` constraint>> to our table using the `@Check` annotation.
Check constraints and foreign key constraints can help ensure that a row never contains inconsistent column values.
====

[[bytecode-enhancer]]
=== Using the bytecode enhancer

:enhancer: {doc-user-guide-url}#BytecodeEnhancement

Hibernate's {enhancer}[bytecode enhancer] enables the following features:

- _attribute-level lazy fetching_ for basic attributes annotated `@Basic(fetch=LAZY)` and for lazy non-polymorphic associations,
- _interception-based_—instead of the usual _snapshot-based_—detection of modifications.

To use the bytecode enhancer, we must add the Hibernate plugin to our gradle build:

[source,groovy,subs="attributes+"]
----
plugins {
    id "org.hibernate.orm" version "{fullVersion}"
}

hibernate {
  enhancement {}
}
----

[CAUTION]
====
Some online documentation (including previous versions of the present one) suggest to use `hibernate { enhancement }`, which will _not_ work as it is interpreted by Gradle as a (pointless) getter call instead of actual configuration.
That form will result in bytecode enhancement NOT happening (unfortunately silently).
To enable bytecode enhancement, make sure to always use the block form (with `{}`).
====

// [discrete]
// ==== Attribute-level lazy fetching

Consider this field:

[source,java]
----
@Entity
class Book {
    ...

    @Basic(optional = false, fetch = LAZY)
    @Column(length = LONG32)
    String fullText;
    
    ...
}
----

The `fullText` field maps to a `clob` or `text` column, depending on the SQL dialect.
Since it's expensive to retrieve the full book-length text, we've mapped the field `fetch=LAZY`, telling Hibernate not to read the field until it's actually used.

- _Without_ the bytecode enhancer, this instruction is ignored, and the field is always fetched immediately, as part of the initial `select` that retrieves the `Book` entity.
- _With_ bytecode enhancement, Hibernate is able to detect access to the field, and lazy fetching is possible.

[TIP]
====
By default, Hibernate fetches all lazy fields of a given entity at once, in a single `select`, when any one of them is accessed.
Using the link:{doc-javadoc-url}org/hibernate/annotations/LazyGroup.html[`@LazyGroup`] annotation, it's possible to assign fields to distinct "fetch groups", so that different lazy fields may be fetched independently.
====

Similarly, interception lets us implement lazy fetching for non-polymorphic associations without the need for a separate proxy object.
However, if an association is polymorphic, that is, if the target entity type has subclasses, then a proxy is still required.

// [discrete]
// ==== Interception-based change detection

Interception-based change detection is a nice performance optimization with a slight cost in terms of correctness.

- _Without_ the bytecode enhancer, Hibernate keeps a snapshot of the state of each entity after reading from or writing to the database.
When the session flushes, the snapshot state is compared to the current state of the entity to determine if the entity has been modified.
Maintaining these snapshots does have an impact on performance.
- _With_ bytecode enhancement, we may avoid this cost by intercepting writes to the field and recording these modifications as they happen.

This optimization isn't _completely_ transparent, however.

[CAUTION]
====
Interception-based change detection is less accurate than snapshot-based dirty checking.
For example, consider this attribute:

[source,java]
byte[] image;

Interception is able to detect writes to the `image` field, that is, replacement of the whole array.
It's not able to detect modifications made directly to the _elements_ of the array, and so such modifications may be lost.
====

[IMPORTANT]
Hibernate's extended bytecode enhancement feature has been deprecated, primarily because it relies on assumptions and behaviors that often require a broader runtime scope than what Hibernate alone can reliably provide, similar to container-based environments such as Quarkus or WildFly.
Applications which make use of this feature should instead use proper object-oriented encapsulation, exposing managed state via getters and setters.

[[fetch-profiles]]
=== Named fetch profiles

We've already seen two different ways to override the default <<association-fetching,fetching strategy>> for an association:

- <<entity-graph,JPA entity graphs>>, and
- the `join fetch` clause in <<hql-queries,HQL>>, or, equivalently, the method `From.fetch()` in the criteria query API.

A third way is to define a named fetch profile.
First, we must declare the profile, by annotating a class or package link:{doc-javadoc-url}org/hibernate/annotations/FetchProfile.html[`@FetchProfile`]:

[source,java]
----
@FetchProfile(name = "EagerBook")
@Entity
class Book { ... }
----

Note that even though we've placed this annotation on the `Book` entity, a fetch profile—unlike an entity graph—isn't "rooted" at any particular entity.

We may specify association fetching strategies using the `fetchOverrides` member of the `@FetchProfile` annotation, but frankly it looks so messy that we're embarrassed to show it to you here.

[NOTE]
====
Similarly, a JPA <<entity-graph,entity graph>> may be defined using `@NamedEntityGraph`.
But the format of this annotation is _even worse_ than `@FetchProfile(fetchOverrides=...)`, so we can't recommend it. 💀
====

A better way is to annotate an association with the fetch profiles it should be fetched in:

[source,java]
----
@FetchProfile(name = "EagerBook")
@Entity
class Book {
    ...

    @ManyToOne(fetch = LAZY)
    @FetchProfileOverride(profile = Book_.PROFILE_EAGER_BOOK, mode = JOIN)
    Publisher publisher;

    @ManyToMany
    @FetchProfileOverride(profile = Book_.PROFILE_EAGER_BOOK, mode = JOIN)
    Set<Author> authors;

    ...
}
----
[source,java]
----
@Entity
class Author {
    ...

    @OneToOne
    @FetchProfileOverride(profile = Book_.PROFILE_EAGER_BOOK, mode = JOIN)
    Person person;

    ...
}
----

Here, once again, `Book_.PROFILE_EAGER_BOOK` is generated by Hibernate Processor, and is just a constant with the value `"EagerBook"`.

For collections, we may even request subselect fetching:

[source,java]
----
@FetchProfile(name = "EagerBook")
@FetchProfile(name = "BookWithAuthorsBySubselect")
@Entity
class Book {
    ...

    @OneToOne
    @FetchProfileOverride(profile = Book_.PROFILE_EAGER_BOOK, mode = JOIN)
    Person person;

    @ManyToMany
    @FetchProfileOverride(profile = Book_.PROFILE_EAGER_BOOK, mode = JOIN)
    @FetchProfileOverride(profile = Book_.BOOK_WITH_AUTHORS_BY_SUBSELECT,
                          mode = SUBSELECT)
    Set<Author> authors;

    ...
}
----

We may define as many different fetch profiles as we like.

.Annotations for defining fetch profiles
[%breakable,cols="25,~"]
|===
| Annotation | Purpose

| `@FetchProfile` | Declares a named fetch profile, optionally including a list of ``@FetchOverride``s
| `@FetchProfile.FetchOverride` | Declares a fetch strategy override as part of the `@FetchProfile` declaration
| `@FetchProfileOverride` | Specifies the fetch strategy for the annotated association, in a given fetch profile
|===

A fetch profile must be explicitly enabled for a given session by passing the name of the profile to link:{doc-javadoc-url}org/hibernate/Session.html#enableFetchProfile(java.lang.String)[`enableFetchProfile()`]:

[source,java]
----
session.enableFetchProfile(Book_.PROFILE_EAGER_BOOK);
Book eagerBook = session.find(Book.class, bookId);
----

Alternatively, an instance of link:{doc-javadoc-url}org/hibernate/EnabledFetchProfile.html[`EnabledFetchProfile`] may be obtained in a type safe way from the static metamodel, and applied to the session:

[source,java]
----
Book_._EagerBook.enable(session);
Book eagerBook = session.find(Book.class, bookId);
----

Even better, the `EnabledFetchProfile` may be passed as a `FindOption`:

[source,java]
----
Book eagerBook = entityManager.find(Book.class, bookId, Book_._EagerBook);
----

So why or when might we prefer named fetch profiles to entity graphs?
Well, it's really hard to say.
It's nice that this feature _exists_, and if you love it, that's great.
But Hibernate offers alternatives that we think are more compelling most of the time.

The one and only advantage unique to fetch profiles is that they let us very selectively request <<batch-subselect-fetch,subselect fetching>>.
We can't do that with entity graphs, and we can't do it with HQL.

[%unbreakable]
[TIP]
====
There's a special built-in fetch profile named `org.hibernate.defaultProfile` which is defined as the profile with `@FetchProfileOverride(mode=JOIN)` applied to every eager `@ManyToOne` or `@OneToOne` association.
If you enable this profile:

[source,java]
----
session.enableFetchProfile("org.hibernate.defaultProfile");
----

Then ``outer join``s for such associations will _automatically_ be added to every HQL or criteria query.
This is nice if you can't be bothered typing out those ``join fetch``es explicitly.
And in principle it even helps partially mitigate the <<lazy-problem,problem>> of JPA having specified the wrong default for the `fetch` member of `@ManyToOne`.
====
