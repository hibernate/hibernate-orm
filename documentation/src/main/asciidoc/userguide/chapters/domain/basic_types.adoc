[[basic]]
=== Basic values
:root-project-dir: ../../../../../../..
:testing-project-dir: {root-project-dir}/hibernate-testing
:example-dir-model: {testing-project-dir}/src/main/java/org/hibernate/testing/orm/domain/userguide
:core-project-dir: {root-project-dir}/hibernate-core
:core-test-base: {core-project-dir}/src/test
:example-dir-basic-mapping: {core-test-base}/java/org/hibernate/orm/test/mapping
:example-dir-resources: {core-test-base}/resources/org/hibernate/orm/test/
:example-dir-generated: {core-test-base}/java/org/hibernate/orm/test/mapping/generated
:example-dir-converter: {core-test-base}/java/org/hibernate/orm/test/mapping/converted/converter
:extrasdir: extras

A basic type is a mapping between a Java type and a single database column.

Hibernate can map many standard Java types (`Integer`, `String`, etc.) as basic
types.  The mapping for many come from tables B-3 and B-4 in the JDBC specification<<jdbc>>.
Others (`URL` as `VARCHAR`, e.g.) simply make sense.

Additionally, Hibernate provides multiple, flexible ways to indicate how the Java type
should be mapped to the database.


[TIP]
====
The Jakarta Persistence specification strictly limits the Java types that can be marked as basic to the following:

|===
| Category | Package | Types

| Java primitive types | | `boolean`, `int`, `double`, etc.
| Primitive wrappers | `java.lang` | `Boolean`, `Integer`, `Double`, etc.
| Strings | `java.lang` | `String`
| Arbitrary-precision numeric types | `java.math` | `BigInteger` and `BigDecimal`
| Date/time types | `java.time` | `LocalDate`, `LocalTime`, `LocalDateTime`, `OffsetTime`, `OffsetDateTime`, `Instant`
| Deprecated date/time types | `java.util` | `Date` and `Calendar`
| Deprecated date/time types from | `java.sql` | `Date`, `Time`, `Timestamp`
| Byte and character arrays | | `byte[]` or `Byte[]`, `char[]` or `Character[]`
| Java enumerated types | | Any `enum`
| Serializable types | | Any type that implements ``java.io.Serializable``footnote:[Jakarta Persistence's support for Serializable types is to directly serialize their state to the database]
|===

If provider portability is a concern, you should stick to just these basic types.

Java Persistence 2.1 introduced the `jakarta.persistence.AttributeConverter` providing support for handling
types beyond those defined in the specification. See <<basic-jpa-convert>> for more on this topic.
====


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-basic-annotation]]
==== @Basic

Strictly speaking, a basic type is denoted by the `jakarta.persistence.Basic` annotation.

Generally, the `@Basic` annotation can be ignored as it is assumed by default.  Both of the following
examples are ultimately the same.

[[basic-annotation-explicit-example]]
.`@Basic` explicit
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ExplicitBasicTypeTest.java[tags=basic-annotation-explicit-example]
----
====

[[basic-annotation-implicit-example]]
.`@Basic` implied
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ImplicitBasicTypeTest.java[tags=basic-annotation-implicit-example]
----
====

The `@Basic` annotation defines 2 attributes.

`optional` - boolean (defaults to true):: Defines whether this attribute allows nulls.  Jakarta Persistence defines
    this as "a hint", which means the provider is free to ignore it.  Jakarta Persistence also says that it will be
    ignored if the type is primitive.  As long as the type is not primitive, Hibernate will honor this
    value.  Works in conjunction with `@Column#nullable` - see <<basic-column-annotation>>.
`fetch` - FetchType (defaults to EAGER):: Defines whether this attribute should be fetched eagerly or lazily.
    `EAGER` indicates that the value will be fetched as part of loading the owner.  `LAZY` values are
    fetched only when the value is accessed.  Jakarta Persistence requires providers to support `EAGER`, while support for
    `LAZY` is optional meaning that a provider is free to not support it.  Hibernate supports lazy loading
    of basic values as long as you are using its <<chapters/pc/BytecodeEnhancement.adoc#BytecodeEnhancement,bytecode enhancement>>
    support.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-column-annotation]]
==== @Column

Jakarta Persistence defines rules for implicitly determining the name of tables and columns.
For a detailed discussion of implicit naming see <<chapters/domain/naming.adoc#naming,Naming strategies>>.

For basic type attributes, the implicit naming rule is that the column name is the same as the attribute name.
If that implicit naming rule does not meet your requirements, you can explicitly tell Hibernate (and other providers) the column name to use.

[[basic-annotation-explicit-column-example]]
.Explicit column naming
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ExplicitColumnNamingTest.java[tags=basic-annotation-explicit-column-example]
----
====

Here we use `@Column` to explicitly map the `description` attribute to the `NOTES` column, as opposed to the
implicit column name `description`.  See <<naming>> for additional details.

The `@Column` annotation defines other mapping information as well. See its Javadocs for details.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-formula-annotation]]
==== @Formula

`@Formula` allows mapping any database computed value as a virtual read-only column.

[NOTE]
====
* The `@Formula` annotation takes a native SQL clause which may affect database portability.
* `@Formula` is a Hibernate-specific mapping construct and not covered by Jakarta Persistence.  Applications interested in portability should avoid its use.
====

[[mapping-column-formula-example]]
.`@Formula` mapping usage
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/FormulaTest.java[tags=mapping-column-formula-example]
----
====

When loading the `Account` entity, Hibernate is going to calculate the `interest` property using the configured `@Formula`:

[[mapping-column-formula-persistence-example]]
.Persisting an entity with a `@Formula` mapping
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/FormulaTest.java[tags=mapping-column-formula-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-column-formula-persistence-example.sql[]
----
====

[NOTE]
====
The SQL fragment defined by the `@Formula` annotation can be as complex as you want, and it can even include sub-selects.
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-mapping]]
==== Mapping basic values

To deal with values of basic type, Hibernate needs to understand a few things about the mapping:

* The capabilities of the Java type.  For example:
** How to compare values
** How to calculate a hash-code
** How to coerce values of this type to another type
* The JDBC type it should use
** How to bind values to JDBC statements
** How to extract from JDBC results
* Any conversion it should perform on the value to/from the database
* The mutability of the value - whether the internal state can change like `java.util.Date` or is immutable like `java.lang.String`

This section covers how Hibernate determines these pieces and how to influence that determination process.

[NOTE]
====
The following sections focus on approaches introduced in version 6 to influence how Hibernate will
map basic value to the database.

This includes removal of the following deprecated legacy annotations:

* `@TypeDef`
* `@TypeDefs`
* `@CollectionId#type`
* `@AnyMetaDef#metaType`
* `@AnyMetaDef#idType`

See the 6.0 migration guide for discussions about migrating uses of these annotations

The new annotations added as part of 6.0 support composing mappings in annotations
through "meta-annotations".
====


Looking at <<basic-annotation-implicit-example, this example>>, how does Hibernate know what mapping
to use for these attributes?  The annotations do not really provide much information.

This is an illustration of Hibernate's implicit basic-type resolution, which is a series of checks to determine
the appropriate mapping to use.  Describing the complete process for implicit resolution is beyond the scope
of this documentationfootnote:[For details see `org.hibernate.mapping.BasicValue#resolve()`].

This is primarily driven by the Java type defined for the basic type, which can generally
be determined through reflection.  Is the Java type an enum?  Is it temporal?  These answers
can indicate certain mappings be used.

The fallback is to map the value to the "recommended" JDBC type.

Worst case, if the Java type is `Serializable` Hibernate will try to handle it via binary serialization.

For cases where the Java type is not a standard type or if some specialized handling is desired, Hibernate
provides 2 main approaches to influence this mapping resolution:

* A compositional approach using a combination of one-or-more annotations to describe specific
    aspects of the mapping.  This approach is covered in <<basic-mapping-composition>>.
* The `UserType` contract, which is covered in <<basic-mapping-custom>>

These 2 approaches should be considered mutually exclusive.  A custom UserType will always
take precedence over compositional annotations.

The next few sections look at common, standard Java types and discusses various ways to map them.
See <<basic-bitset>> for examples of mapping `BitSet` as a basic type using all of these approaches.




[[basic-enums]]
==== Enums

Hibernate supports the mapping of Java enums as basic value types in a number of different ways.

[[basic-enums-Enumerated]]
===== `@Enumerated`

The original Jakarta Persistence-compliant way to map enums was via the `@Enumerated` or `@MapKeyEnumerated`
annotations, working on the principle that the enum values are stored according to one of 2 strategies indicated
by `jakarta.persistence.EnumType`:

`ORDINAL`:: stored according to the enum value's ordinal position within the enum class, as indicated by `java.lang.Enum#ordinal`
`STRING`:: stored according to the enum value's name, as indicated by `java.lang.Enum#name`

Assuming the following enumeration:

.`PhoneType` enumeration
====
[source, java, indent=0]
----
include::{example-dir-model}/PhoneType.java[tags=hql-examples-domain-model-example]
----
====

In the ORDINAL example, the `phone_type` column is defined as a (nullable) INTEGER type and would hold:

`NULL`:: For null values
`0`:: For the `LAND_LINE` enum
`1`:: For the `MOBILE` enum

[[basic-enums-Enumerated-ordinal-example]]
.`@Enumerated(ORDINAL)` example
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/PhoneTypeEnumeratedOrdinalTest.java[tags=basic-enums-Enumerated-ordinal-example]
----
====

When persisting this entity, Hibernate generates the following SQL statement:

[[basic-enums-Enumerated-ordinal-persistence-example]]
.Persisting an entity with an `@Enumerated(ORDINAL)` mapping
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/PhoneTypeEnumeratedOrdinalTest.java[tags=basic-enums-Enumerated-ordinal-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-enums-Enumerated-ordinal-persistence-example.sql[]
----
====

In the STRING example, the `phone_type` column is defined as a (nullable) VARCHAR type and would hold:

`NULL`:: For null values
`LAND_LINE`:: For the `LAND_LINE` enum
`MOBILE`:: For the `MOBILE` enum

[[basic-enums-Enumerated-string-example]]
.`@Enumerated(STRING)` example
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/PhoneTypeEnumeratedStringTest.java[tags=basic-enums-Enumerated-string-example]
----
====

Persisting the same entity as in the `@Enumerated(ORDINAL)` example, Hibernate generates the following SQL statement:

[[basic-enums-Enumerated-string-persistence-example]]
.Persisting an entity with an `@Enumerated(STRING)` mapping
====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-enums-Enumerated-string-persistence-example.sql[]
----
====

[[basic-enums-attribute-converter]]
===== Using AttributeConverter

Let's consider the following `Gender` enum which stores its values using the `'M'` and `'F'` codes.

[[basic-enums-converter-example]]
.Enum with a custom constructor
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/Gender.java[tags=basic-enums-converter-example]
----
====

You can map enums in a Jakarta Persistence compliant way using a Jakarta Persistence AttributeConverter.

[[basic-enums-attribute-converter-example]]
.Enum mapping with `AttributeConverter` example
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/EnumerationConverterTest.java[tags=basic-enums-attribute-converter-example]
----
====

Here, the gender column is defined as a CHAR type and would hold:

`NULL`:: For null values
`'M'`:: For the `MALE` enum
`'F'`:: For the `FEMALE` enum

For additional details on using AttributeConverters, see <<basic-jpa-convert>> section.

[NOTE]
====
Jakarta Persistence explicitly disallows the use of an `AttributeConverter` with an attribute marked as `@Enumerated`.

So, when using the `AttributeConverter` approach, be sure not to mark the attribute as `@Enumerated`.
====



[[basic-enums-custom-type]]
===== Custom type

You can also map enums using a Hibernate custom type mapping.
Let's again revisit the Gender enum example, this time using a custom Type to store the more standardized `'M'` and `'F'` codes.

[[basic-enums-custom-type-example]]
.Enum mapping with custom Type example
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/EnumerationCustomTypeTest.java[tags=basic-enums-custom-type-example, indent=0]

include::{example-dir-basic-mapping}/basic/GenderType.java[tags=basic-enums-custom-type-example, indent=0]

include::{example-dir-basic-mapping}/basic/GenderJavaType.java[tags=basic-enums-custom-type-example, indent=0]
----
====

Again, the gender column is defined as a CHAR type and would hold:

`NULL`:: For null values
`'M'`:: For the `MALE` enum
`'F'`:: For the `FEMALE` enum

For additional details on using custom types, see <<basic-mapping-custom>> section.




[[basic-boolean]]
==== Boolean

By default, `Boolean` attributes map to `BOOLEAN` columns, at least when the database has a
dedicated `BOOLEAN` type. On databases which don't, Hibernate uses whatever else is available:
`BIT`, `TINYINT`, or `SMALLINT`.

[[basic-boolean-example-implicit]]
.Implicit boolean mapping
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/BooleanMappingTests.java[tags=basic-boolean-example-implicit]
----
====

However, it is quite common to find boolean values encoded as a character or as an integer.
Such cases are exactly the intention of `AttributeConverter`.  For convenience, Hibernate
provides 3 built-in converters for the common boolean mapping cases:

- `YesNoConverter` encodes a boolean value as `'Y'` or `'N'`,
- `TrueFalseConverter` encodes a boolean value as `'T'` or `'F'`, and
- `NumericBooleanConverter` encodes the value as an integer, `1` for true, and `0` for false.

[[basic-boolean-example-converted]]
.Using `AttributeConverter`
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-yes-no]

include::{example-dir-basic-mapping}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-t-f]

include::{example-dir-basic-mapping}/basic/BooleanMappingTests.java[tags=basic-boolean-example-explicit-numeric]
----
====

If the boolean value is defined in the database as something other than `BOOLEAN`, character or integer,
the value can also be mapped using a custom `AttributeConverter` - see <<basic-jpa-convert>>.

A `UserType` may also be used - see <<basic-mapping-custom>>


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-byte]]
==== Byte

By default, Hibernate maps values of `Byte` / `byte` to the `TINYINT` JDBC type.

[[basic-byte-example]]
.Mapping Byte
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ByteMappingTests.java[tags=basic-byte-example-implicit]
----
====


See <<basic-bytearray>> for mapping arrays of bytes.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-short]]
==== Short

By default, Hibernate maps values of `Short` / `short` to the `SMALLINT` JDBC type.

[[basic-short-example]]
.Mapping Short
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ShortMappingTests.java[tags=basic-short-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-integer]]
==== Integer

By default, Hibernate maps values of `Integer` / `int` to the `INTEGER` JDBC type.

[[basic-integer-example]]
.Mapping Integer
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/IntegerMappingTests.java[tags=basic-integer-example-implicit]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-long]]
==== Long

By default, Hibernate maps values of `Long` / `long` to the `BIGINT` JDBC type.

[[basic-long-example]]
.Mapping Long
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/LongMappingTests.java[tags=basic-long-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-biginteger]]
==== BigInteger

By default, Hibernate maps values of `BigInteger` to the `NUMERIC` JDBC type.

[[basic-bitinteger-example]]
.Mapping BigInteger
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/BigIntegerMappingTests.java[tags=basic-biginteger-example-implicit]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-double]]
==== Double

By default, Hibernate maps values of `Double` to the `DOUBLE`, `FLOAT`, `REAL` or
`NUMERIC` JDBC type depending on the capabilities of the database

[[basic-double-example]]
.Mapping Double
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/DoubleMappingTests.java[tags=basic-double-example-implicit]
----
====

A specific type can be influenced using any of the JDBC type influencers covered in
<<basic-mapping-composition-jdbc>> section.

If `@JdbcTypeCode` is used, the Dialect is still consulted to make sure the database
supports the requested type.  If not, an appropriate type is selected



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-float]]
==== Float

By default, Hibernate maps values of `Float` to the `FLOAT`, `REAL` or
`NUMERIC` JDBC type depending on the capabilities of the database.

[[basic-float-example]]
.Mapping Float
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/FloatMappingTests.java[tags=basic-float-example-implicit]
----
====

A specific type can be influenced using any of the JDBC type influencers covered in
<<basic-mapping>> section.

If `@JdbcTypeCode` is used, the Dialect is still consulted to make sure the database
supports the requested type.  If not, an appropriate type is selected



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-bigdecimal]]
==== BigDecimal

By default, Hibernate maps values of `BigDecimal` to the `NUMERIC` JDBC type.

[[basic-bigdecimal-example]]
.Mapping BigDecimal
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/BigDecimalMappingTests.java[tags=basic-bigdecimal-example-implicit]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-character]]
==== Character

By default, Hibernate maps `Character` to the `CHAR` JDBC type.

[[basic-character-example]]
.Mapping Character
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/CharacterMappingTests.java[tags=basic-character-example-implicit]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-String]]
==== String

By default, Hibernate maps `String` to the `VARCHAR` JDBC type.

[[basic-string-example]]
.Mapping String
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/StringMappingTests.java[tags=basic-string-example]
----
====

Optionally, you may specify the maximum length of the string using `@Column(length=...)`,
or using the `@Size` annotation from Hibernate Validator.
For very large strings, you can use one of the constant values defined by the class
`org.hibernate.Length`, for example:

[source, java, indent=0]
----
@Column(length=Length.LONG)
private String text;
----

Alternatively, you may explicitly specify the JDBC type `LONGVARCHAR`, which is treated
as a `VARCHAR` mapping with default `length=Length.LONG` when no `length` is explicitly
specified:

[source, java, indent=0]
----
@JdbcTypeCode(Types.LONGVARCHAR)
private String text;
----

If you use Hibernate for schema generation, Hibernate will generate DDL with a column type
that is large enough to accommodate the maximum length you've specified.

[TIP]
====
If the maximum length you specify is too long to fit in the largest `VARCHAR` column supported
by your database, Hibernate's schema exporter will automatically upgrade the column type to
`TEXT`, `CLOB`, or whatever is the equivalent type for your database.
Please _don't_ (ab)use JPA's `@Lob` annotation just because you want a `TEXT` column.
The purpose of the `@Lob` annotation is not to control DDL generation!
====

See <<basic-lob>> for details on mapping to a database CLOB.

For databases which support nationalized character sets, you can also store strings as
nationalized data.

[[basic-nstring-example]]
.Mapping String as nationalized
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/StringNationalizedMappingTests.java[tags=basic-nstring-example]
----
====

See <<basic-nationalized>> for details on mapping strings using nationalized character sets.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-chararray]]
==== Character arrays

By default, Hibernate maps `char[]` to the `VARCHAR` JDBC type.
Since `Character[]` can contain null elements, it is mapped as <<basic-mapping-array,basic array type>> instead.
Prior to Hibernate 6.2, also `Character[]` mapped to `VARCHAR`, yet disallowed `null` elements.
To continue mapping `Character[]` to the `VARCHAR` JDBC type, or for LOBs mapping to the `CLOB` JDBC type,
it is necessary to annotate the persistent attribute with `@JavaType( CharacterArrayJavaType.class )`.

[[basic-string-example-implicit]]
.Mapping Character
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/CharacterArrayMappingTests.java[tags=basic-chararray-example]
----
====

See <<basic-lob>> for details on mapping as database LOB.

For databases which support nationalized character sets, you can also store character arrays as
nationalized data.

[[basic-nchararray-example]]
.Mapping character arrays as nationalized
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/CharacterArrayNationalizedMappingTests.java[tags=basic-nchararray-example]
----
====

See <<basic-nationalized>> for details on mapping strings using nationalized character sets.



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-clob]]
==== Clob / NClob

[NOTE]
====
Be sure to check out <<basic-lob>> which covers basics of LOB handling and <<basic-nationalized>> which covers basics
of nationalized data handling.
====

By default, Hibernate will map the `java.sql.Clob` Java type to `CLOB` and `java.sql.NClob` to `NCLOB`.

Considering we have the following database table:

[[basic-clob-sql-example]]
.CLOB - SQL
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-clob-sql-example.sql[]
----
====

Let's first map this using the `@Lob` Jakarta Persistence annotation and the `java.sql.Clob` type:

[[basic-clob-example]]
.`CLOB` mapped to `java.sql.Clob`
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ClobTest.java[tags=basic-clob-example]
----
====

To persist such an entity, you have to create a `Clob` using the `ClobProxy` Hibernate utility:

[[basic-clob-persist-example]]
.Persisting a `java.sql.Clob` entity
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ClobTest.java[tags=basic-clob-persist-example]
----
====

To retrieve the `Clob` content, you need to transform the underlying `java.io.Reader`:

[[basic-clob-find-example]]
.Returning a `java.sql.Clob` entity
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ClobTest.java[tags=basic-clob-find-example]
----
====

We could also map the CLOB in a materialized form. This way, we can either use a `String` or a `char[]`.

[[basic-clob-string-example]]
.`CLOB` mapped to `String`
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ClobStringTest.java[tags=basic-clob-string-example]
----
====

We might even want the materialized data as a char array.

[[basic-clob-char-array-example]]
.CLOB - materialized `char[]` mapping
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ClobCharArrayTest.java[tags=basic-clob-char-array-example]
----
====

Just like with `CLOB`, Hibernate can also deal with `NCLOB` SQL data types:

[[basic-nclob-sql-example]]
.`NCLOB` - SQL
====
[source, java, indent=0]
----
include::{extrasdir}/basic/basic-nclob-sql-example.sql[]
----
====

Hibernate can map the `NCLOB` to a `java.sql.NClob`

[[basic-nclob-example]]
.`NCLOB` mapped to `java.sql.NClob`
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/NClobTest.java[tags=basic-nclob-example]
----
====

To persist such an entity, you have to create an `NClob` using the `NClobProxy` Hibernate utility:

[[basic-nclob-persist-example]]
.Persisting a `java.sql.NClob` entity
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/NClobTest.java[tags=basic-nclob-persist-example]
----
====

To retrieve the `NClob` content, you need to transform the underlying `java.io.Reader`:

[[basic-nclob-find-example]]
.Returning a `java.sql.NClob` entity
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/NClobTest.java[tags=basic-nclob-find-example]
----
====

We could also map the `NCLOB` in a materialized form. This way, we can either use a `String` or a `char[]`.

[[basic-nclob-string-example]]
.`NCLOB` mapped to `String`
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/NClobStringTest.java[tags=basic-nclob-string-example]
----
====

We might even want the materialized data as a char array.

[[basic-nclob-char-array-example]]
.NCLOB - materialized `char[]` mapping
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/NClobCharArrayTest.java[tags=basic-nclob-char-array-example]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-bytearray]]
==== Byte array

By default, Hibernate maps `byte[]` to the `VARBINARY` JDBC type.
Since `Byte[]` can contain null elements, it is mapped as <<basic-mapping-array,basic array type>> instead.
Prior to Hibernate 6.2, also `Byte[]` mapped to `VARBINARY`, yet disallowed `null` elements.
To continue mapping `Byte[]` to the `VARBINARY` JDBC type, or for LOBs mapping to the `BLOB` JDBC type,
it is necessary to annotate the persistent attribute with `@JavaType( ByteArrayJavaType.class )`.

[[basic-bytearray-example]]
.Mapping arrays of bytes
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ByteArrayMappingTests.java[tags=basic-bytearray-example]
----
====

Just like with strings, you may specify the maximum length using `@Column(length=...)`
or the `@Size` annotation from Hibernate Validator.
For very large arrays, you can use the constants defined by `org.hibernate.Length`.
Alternatively `@JdbcTypeCode(Types.LONGVARBINARY)` is treated as a `VARBINARY` mapping
with default `length=Length.LONG` when no length is explicitly specified.

If you use Hibernate for schema generation, Hibernate will generate DDL with a column type
that is large enough to accommodate the maximum length you've specified.

[TIP]
====
If the maximum length you specify is too long to fit in the largest `VARBINARY` column
supported by your database, Hibernate's schema exporter will automatically upgrade the
column type to `IMAGE`, `BLOB`, or whatever is the equivalent type for your database.
Please _don't_ (ab)use JPA's `@Lob` annotation for DDL customization.
====


See <<basic-lob>> for details on mapping to a database BLOB.




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-blob]]
==== Blob


[NOTE]
====
Be sure to check out <<basic-lob>> which covers basics of LOB handling.
====

By default, Hibernate will map the `java.sql.Blob` Java type to `BLOB`.

Considering we have the following database table:

[[basic-blob-sql-example]]
.BLOB - SQL
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-blob-sql-example.sql[]
----
====

Let's first map this using the JDBC `java.sql.Blob` type.

[[basic-blob-example]]
.`BLOB` mapped to `java.sql.Blob`
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/BlobTest.java[tags=basic-blob-example]
----
====

To persist such an entity, you have to create a `Blob` using the `BlobProxy` Hibernate utility:

[[basic-blob-persist-example]]
.Persisting a `java.sql.Blob` entity
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/BlobTest.java[tags=basic-blob-persist-example]
----
====

To retrieve the `Blob` content, you need to transform the underlying `java.io.InputStream`:

[[basic-blob-find-example]]
.Returning a `java.sql.Blob` entity
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/BlobTest.java[tags=basic-blob-find-example]
----
====

We could also map the BLOB in a materialized form (e.g. `byte[]`).

[[basic-blob-byte-array-example]]
.`BLOB` mapped to `byte[]`
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/BlobByteArrayTest.java[tags=basic-blob-byte-array-example]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Duration

By default, Hibernate maps `Duration` to the `NUMERIC` SQL type.

TIP: It's possible to map `Duration` to the `INTERVAL_SECOND` SQL type using `@JdbcTypeCode(INTERVAL_SECOND)` or by setting `hibernate.type.preferred_duration_jdbc_type=INTERVAL_SECOND`

[[basic-duration-example]]
.Mapping Duration
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/DurationMappingTests.java[tags=basic-duration-example]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Instant

`Instant` is mapped to the `TIMESTAMP_UTC` SQL type.


[[basic-instant-example]]
.Mapping Instant
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/InstantMappingTests.java[tags=basic-instant-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalDate

`LocalDate` is mapped to the `DATE` JDBC type.

[[basic-localDate-example]]
.Mapping LocalDate
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/LocalDateMappingTests.java[tags=basic-localDate-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalDateTime

`LocalDateTime` is mapped to the `TIMESTAMP` JDBC type.

[[basic-localDateTime-example]]
.Mapping LocalDateTime
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/LocalDateTimeMappingTests.java[tags=basic-localDateTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== LocalTime

`LocalTime` is mapped to the `TIME` JDBC type.

[[basic-localTime-example]]
.Mapping LocalTime
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/LocalTimeMappingTests.java[tags=basic-localTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== OffsetDateTime

`OffsetDateTime` is mapped to the `TIMESTAMP` or `TIMESTAMP_WITH_TIMEZONE` JDBC type
depending on the database.


[[basic-OffsetDateTime-example]]
.Mapping OffsetDateTime
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/OffsetDateTimeMappingTests.java[tags=basic-OffsetDateTime-example]
----
====


See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling






// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== OffsetTime

`OffsetTime` is mapped to the `TIME` or `TIME_WITH_TIMEZONE` JDBC type
depending on the database.


[[basic-OffsetTime-example]]
.Mapping OffsetTime
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/OffsetTimeMappingTests.java[tags=basic-offsetTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== TimeZone

`TimeZone` is mapped to `VARCHAR` JDBC type.

[[basic-TimeZone-example]]
.Mapping OffsetTime
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/TimeZoneMappingTests.java[tags=basic-timeZone-example]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== ZonedDateTime


`ZonedDateTime` is mapped to the `TIMESTAMP` or `TIMESTAMP_WITH_TIMEZONE` JDBC type
depending on the database.


[[basic-ZonedDateTime-example]]
.Mapping ZonedDateTime
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ZonedDateTimeMappingTests.java[tags=basic-ZonedDateTime-example]
----
====

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== ZoneOffset

`ZoneOffset` is mapped to `VARCHAR` JDBC type.

[[basic-ZoneOffset-example]]
.Mapping ZoneOffset
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ZoneOffsetMappingTests.java[tags=basic-ZoneOffset-example]
----
====





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Calendar

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling








// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Date

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Time

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling







// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Timestamp

See <<basic-temporal>> for basics of temporal mapping
See <<basic-datetime-time-zone>> for basics of time-zone handling





// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

==== Class

Hibernate maps `Class` references to `VARCHAR` JDBC type

[[basic-Class-example]]
.Mapping Class
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ClassMappingTests.java[tags=basic-Class-example]
----
====



==== Currency

Hibernate maps `Currency` references to `VARCHAR` JDBC type

[[basic-Currency-example]]
.Mapping Currency
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/CurrencyMappingTests.java[tags=basic-Currency-example]
----
====



==== Locale

Hibernate maps `Locale` references to `VARCHAR` JDBC type

[[basic-Locale-example]]
.Mapping Locale
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/LocaleMappingTests.java[tags=basic-Locale-example]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-uuid]]
==== UUID

Hibernate allows mapping UUID values in a number of ways.  By default, Hibernate will
store UUID values in the native form by using the SQL type `UUID` or in binary form with the `BINARY` JDBC type
if the database does not have a native UUID type.


[NOTE]
====
The default uses the binary representation because it uses a more efficient column storage.

However, many applications prefer the readability of the character-based column storage.

To switch the default mapping, set the `*hibernate.type.preferred_uuid_jdbc_type*` configuration to `CHAR`.
====

===== UUID as binary

As mentioned, the default mapping for UUID attributes.
Maps the UUID to a `byte[]` using `java.util.UUID#getMostSignificantBits` and `java.util.UUID#getLeastSignificantBits` and stores that as `BINARY` data.

Chosen as the default simply because it is generally more efficient from a storage perspective.

===== UUID as (var)char

Maps the UUID to a String using `java.util.UUID#toString` and `java.util.UUID#fromString` and stores that as `CHAR` or `VARCHAR` data.

===== UUID as identifier

Hibernate supports using UUID values as identifiers, and they can even be generated on the user's behalf.
For details, see the discussion of generators in <<chapters/domain/identifiers.adoc#identifiers,_Identifiers_>>.


==== InetAddress

By default, Hibernate will map `InetAddress` to the `INET` SQL type and fallback to `BINARY` if necessary.

[[basic-inet-address-example]]
.Mapping InetAddress
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/InetAddressMappingTests.java[tags=basic-inet-address-example]
----
====

[[basic-mapping-json]]
==== JSON mapping

Hibernate will only use the `JSON` type if explicitly configured through `@JdbcTypeCode( SqlTypes.JSON )`.
The JSON library used for serialization/deserialization is detected automatically,
but can be overridden by setting `hibernate.type.json_format_mapper`
as can be read in the <<appendices/SettingsReference.adoc#settings-hibernate.type.json_format_mapper,Configurations>> section.

[[basic-json-example]]
.Mapping JSON
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/JsonMappingTests.java[tags=basic-json-example]
----
====

[[basic-mapping-xml]]
==== XML mapping

Hibernate will only use the `XML` type if explicitly configured through `@JdbcTypeCode( SqlTypes.SQLXML )`.
The XML library used for serialization/deserialization is detected automatically,
but can be overridden by setting `hibernate.type.xml_format_mapper`
as can be read in the <<appendices/SettingsReference.adoc#settings-hibernate.type.xml_format_mapper,Configurations>> section.

[[basic-xml-example]]
.Mapping XML
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/XmlMappingTests.java[tags=basic-xml-example]
----
====

[[basic-mapping-array]]
==== Basic array mapping

Basic arrays, other than `byte[]`/Byte[] and `char[]`/`Character[]`, map to the type code `SqlTypes.ARRAY` by default,
which maps to the SQL standard `array` type if possible,
as determined via the new methods `getArrayTypeName` and `supportsStandardArrays` of `org.hibernate.dialect.Dialect`.
If SQL standard array types are not available, data will be modeled as `SqlTypes.JSON`, `SqlTypes.XML` or `SqlTypes.VARBINARY`,
depending on the database support as determined via the new method `org.hibernate.dialect.Dialect.getPreferredSqlTypeCodeForArray`.

[[basic-array-example]]
.Mapping basic arrays
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/BasicArrayMappingTests.java[tags=basic-array-example]
----
====

[[basic-mapping-collection]]
==== Basic collection mapping

Basic collections (only subtypes of `Collection`), which are not annotated with `@ElementCollection`,
map to the type code `SqlTypes.ARRAY` by default, which maps to the SQL standard `array` type if possible,
as determined via the new methods `getArrayTypeName` and `supportsStandardArrays` of `org.hibernate.dialect.Dialect`.
If SQL standard array types are not available, data will be modeled as `SqlTypes.JSON`, `SqlTypes.XML` or `SqlTypes.VARBINARY`,
depending on the database support as determined via the new method `org.hibernate.dialect.Dialect.getPreferredSqlTypeCodeForArray`.

[[basic-collection-example]]
.Mapping basic collections
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/BasicCollectionMappingTests.java[tags=basic-collection-example]
----
====


[[basic-mapping-composition]]
==== Compositional basic mapping

The compositional approach allows defining how the mapping should work in terms of influencing
individual parts that make up a basic-value mapping. This section will look at these individual
parts and the specifics of influencing each.



[[basic-mapping-composition-java]]
===== JavaType

Hibernate needs to understand certain aspects of the Java type to handle values properly and efficiently.
Hibernate understands these capabilities through its `org.hibernate.type.descriptor.java.JavaType` contract.
Hibernate provides built-in support for many JDK types (`Integer`, `String`, e.g.), but also supports the ability
for the application to change the handling for any of the standard `JavaType` registrations as well as
add in handling for non-standard types. Hibernate provides multiple ways for the application to influence
the `JavaType` descriptor to use.

The resolution can be influenced locally using the `@JavaType` annotation on a particular mapping.  The
indicated descriptor will be used just for that mapping.  There are also forms of `@JavaType` for influencing
the keys of a Map (`@MapKeyJavaType`), the index of a List or array (`@ListIndexJavaType`), the identifier
of an ID-BAG mapping (`@CollectionIdJavaType`) as well as the discriminator (`@AnyDiscriminator`) and
key (`@AnyKeyJavaClass`, `@AnyKeyJavaType`) of an ANY mapping.

The resolution can also be influenced globally by registering the appropriate `JavaType` descriptor with the
`JavaTypeRegistry`.  This approach is able to both "override" the handling for certain Java types or
to register new types.  See <<basic-mapping-registries>> for discussion of `JavaTypeRegistry`.

See <<basic-mapping-composition-resolution>> for a discussion of the process used to resolve the
mapping composition.


[[basic-mapping-composition-jdbc]]
===== JdbcType

Hibernate also needs to understand aspects of the JDBC type it should use (how it should bind values,
how it should extract values, etc.) which is the role of its `org.hibernate.type.descriptor.jdbc.JdbcType`
contract. Hibernate provides multiple ways for the application to influence the `JdbcType` descriptor to use.

Locally, the resolution can be influenced using either the `@JdbcType` or `@JdbcTypeCode` annotations.  There
are also annotations for influencing the `JdbcType` in relation to Map keys (`@MapKeyJdbcType`, `@MapKeyJdbcTypeCode`),
the index of a List or array (`@ListIndexJdbcType`, `@ListIndexJdbcTypeCode`), the identifier of an ID-BAG mapping
(`@CollectionIdJdbcType`, `@CollectionIdJdbcTypeCode`) as well as the key of an ANY mapping (`@AnyKeyJdbcType`,
`@AnyKeyJdbcTypeCode`).  The `@JdbcType` specifies a specific `JdbcType` implementation to use while `@JdbcTypeCode`
specifies a "code" that is then resolved against the `JdbcTypeRegistry`.

[TIP]
====
The "type code" relative to a `JdbcType` generally maps to the corresponding value in `java.sql.Types`.
registers entries in the `JdbcTypeRegistry` for all the standard `java.sql.Types` codes (aside from OTHER, which
is special).  See <<basic-mapping-registries>> for more discussion.
====

Customizing the `JdbcTypeRegistry` can be accomplished through `@JdbcTypeRegistration` and
`TypeContributor`.  See <<basic-mapping-registries>> for discussion of `JavaTypeRegistry`.
See <<basic-type-contributor>> for discussion of `TypeContributor`.

See the `@JdbcTypeCode` Javadoc for details.

See <<basic-mapping-composition-resolution>> for a discussion of the process used to resolve the
mapping composition.


[[basic-mapping-composition-mutability]]
===== MutabilityPlan

`MutabilityPlan` is the means by which Hibernate understands how to deal with the domain value in terms
of its internal mutability as well as related concerns such as making copies.  While it seems like a minor
concern, it can have a major impact on performance.  See <<basic-jpa-convert-mutability>> for one case where
this can manifest.  See also <<basic-bitset>> for another discussion.

The `MutabilityPlan` for a mapping can be influenced by any of the following annotations:

* `@Mutability`
* `@Immutable`
* `@MapKeyMutability`
* `@CollectionIdMutability`

Hibernate checks the following places for `@Mutability` and `@Immutable`, in order of precedence:

. Local to the mapping
. On the associated `AttributeConverter` implementation class (if one)
. On the value's Java type

In most cases, the fallback defined by `JavaType#getMutabilityPlan` is the proper strategy.

Hibernate uses `MutabilityPlan` to:

1. Check whether a value is considered dirty
2. Make deep copies
3. Marshal values to and from the second-level cache

Generally speaking, immutable values perform better in all of these cases

1. To check for dirtiness, Hibernate just needs to check object identity (`==`) as opposed
    to equality (`Object#equals`).
2. The same value instance can be used as the deep copy of itself.
3. The same value can be used from the second-level cache as well as the value we put into the
    second-level cache.

If a particular Java type is considered mutable (a `Date` e.g.), `@Immutable` or a immutable-specific
`MutabilityPlan` implementation can be specified to have Hibernate treat the value as immutable.  This
also acts as a contract from the application that the internal state of these objects is not changed
by the application. Specifying that a mutable type is immutable and then changing the internal state
will lead to problems; so only do this if the application unequivocally does not change the internal
state.

See <<basic-mapping-composition-resolution>> for a discussion of the process used to resolve the
mapping composition.


[[basic-mapping-composition-conversion]]
===== BasicValueConverter

`BasicValueConverter` is roughly analogous to `AttributeConverter` in that it describes a conversion to
happen when reading or writing values of a basic-valued model part.  In fact, internally Hibernate wraps
an applied `AttributeConverter` in a `BasicValueConverter`.  It also applies implicit `BasicValueConverter`
converters in certain cases such as enum handling, etc.

Hibernate does not provide an explicit facility to influence these conversions beyond `AttributeConverter`.
See <<basic-jpa-convert>>.

See <<basic-mapping-composition-resolution>> for a discussion of the process used to resolve the
mapping composition.


[[basic-mapping-composition-resolution]]
===== Resolving the composition

Using this composition approach, Hibernate will need to resolve certain parts of this mapping.  Often
this involves "filling in the blanks" as it will be configured for just parts of the mapping.  This section
outlines how this resolution happens.

[NOTE]
====
This is a complicated process and is only covered at a high level for the most common cases here.

For the full specifics, consult the source code for `org.hibernate.mapping.BasicValue#buildResolution`
====

First, we look for a custom type.  If found, this takes predence.  See <<basic-mapping-custom>> for details

If an `AttributeConverter` is applied, we use it as the basis for the resolution

. If `@JavaType` is also used, that specific `JavaType` is used for the converter's "domain type".  Otherwise,
    the Java type defined by the converter as its "domain type" is resolved against the `JavaTypeRegistry`
. If `@JdbcType` or `@JdbcTypeCode` is used, the indicated `JdbcType` is used and the converted "relational Java
    type" is determined by `JdbcType#getJdbcRecommendedJavaTypeMapping`.  Otherwise, the Java type defined by the
    converter as its relational type is used and the `JdbcType` is determined by `JdbcType#getRecommendedJdbcType`
. The `MutabilityPlan` can be specified using `@Mutability` or `@Immutable` on the `AttributeConverter` implementation,
    the basic value mapping or the Java type used as the domain-type.  Otherwise, `JdbcType#getJdbcRecommendedJavaTypeMapping`
    for the conversion's domain-type is used to determine the mutability-plan.

Next we try to resolve the `JavaType` to use for the mapping.  We check for an explicit `@JavaType` and use the specified
`JavaType` if found.  Next any "implicit" indication is checked; for example, the index for a List has the implicit Java type
of `Integer`.  Next, we use reflection if possible. If we are unable to determine the `JavaType` to use through the preceeding
steps, we try to resolve an explicitly specified `JdbcType` to use and, if found, use its
`JdbcType#getJdbcRecommendedJavaTypeMapping` as the mapping's `JavaType`.  If we are not able to determine the
`JavaType` by this point, an error is thrown.

The `JavaType` resolved earlier is then inspected for a number of special cases.

. For enum values, we check for an explicit `@Enumerated` and create an enumeration mapping.  Note that this resolution
    still uses any explicit `JdbcType` indicators
. For temporal values, we check for `@Temporal` and create an enumeration mapping.  Note that this resolution
    still uses any explicit `JdbcType` indicators; this includes `@JdbcType` and `@JdbcTypeCode`, as well as
    `@TimeZoneStorage` and `@TimeZoneColumn` if appropriate.

The fallback at this point is to use the `JavaType` and `JdbcType` determined in earlier steps to create a
JDBC-mapping (which encapsulates the `JavaType` and `JdbcType`) and combines it with the resolved `MutabilityPlan`


When using the compositional approach, there are other ways to influence the resolution as covered
in <<basic-enums>>, <<basic-temporal>>, <<basic-lob>> and <<basic-nationalized>>



See <<basic-type-contributor>> for an alternative to `@JavaTypeRegistration` and `@JdbcTypeRegistration`.


[[basic-mapping-custom]]
==== Custom type mapping

Another approach is to supply the implementation of the `org.hibernate.usertype.UserType` contract using `@Type`.

There are also corresponding, specialized forms of `@Type` for specific model parts:

* When mapping a Map, `@Type` describes the Map value while `@MapKeyType` describe the Map key
* When mapping an id-bag, `@Type` describes the elements while `@CollectionIdType` describes the collection-id
* For other collection mappings, `@Type` describes the elements
* For discriminated association mappings (`@Any` and `@ManyToAny`), `@Type` describes the discriminator value

`@Type` allows for more complex mapping concerns; but, <<basic-jpa-convert,AttributeConverter>> and
<<basic-mapping-composition>> should generally be preferred as simpler solutions

[[basic-nationalized]]
==== Handling nationalized character data

How nationalized character data is handled and stored depends on the underlying database.

Most databases support storing nationalized character data through the standardized SQL
NCHAR, NVARCHAR, LONGNVARCHAR and NCLOB variants.

Others support storing nationalized data as part of CHAR, VARCHAR, LONGVARCHAR
and CLOB.  Generally these databases do not support NCHAR, NVARCHAR, LONGNVARCHAR
and NCLOB, even as aliased types.

Ultimately Hibernate understands this through `Dialect#getNationalizationSupport()`

To ensure nationalized character data gets stored and accessed correctly, `@Nationalized`
can be used locally or `hibernate.use_nationalized_character_data` can be set globally.

[NOTE]
====
`@Nationalized` and `hibernate.use_nationalized_character_data` can be used regardless
of the specific database support for nationalized data and allows the application to
work portably across databases with varying support.
====

[IMPORTANT]
====
For databases with no `NCLOB` data type, attributes of type `java.sql.NClob` are simply
unsupported. Use `java.sql.Clob` (which `NClob` extends) or a materialized mapping like
`String` or `char[]` instead.

See also <<basic-lob>> regarding similar limitation for databases which do not support
explicit `CLOB` data-type.
====

Considering we have the following database table:

[[basic-nationalized-sql-example]]
.`NVARCHAR` - SQL
====
[source, java, indent=0]
----
include::{extrasdir}/basic/basic-nationalized-sql-example.sql[]
----
====

To map a specific attribute to a nationalized variant data type, Hibernate defines the `@Nationalized` annotation.

[[basic-nationalized-example]]
.`NVARCHAR` mapping
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/NationalizedTest.java[tags=basic-nationalized-example]
----
====




[[basic-lob]]
==== Handling LOB data

The `@Lob` annotation specifies that character or binary data should be written to the database
using the special JDBC APIs for handling database LOB (Large OBject) types.

[NOTE]
====
How JDBC deals with `LOB` data varies from driver to driver. Hibernate tries to take care of all
these differences, and protect you as much as possible from inconsistent driver behavior.
Sadly, Hibernate is only partially successful at achieving this goal.

Some database drivers (i.e. PostgreSQL) are especially problematic and in such cases you might
have to do some extra work to get LOBs functioning. But that's beyond the scope of this guide.
====

[IMPORTANT]
====
For databases with no `CLOB` type, attributes of type `java.sql.Clob` are simply unsupported.
Use a materialized type like `String` or `char[]` instead.
====

There's two ways a LOB may be represented in the Java domain model:

- using a special JDBC-defined _LOB locator type_, or
- using a regular "materialized" type like `String`, `char[]`, or `byte[]`.

===== LOB Locator

The JDBC LOB locator types are:

* `java.sql.Blob`
* `java.sql.Clob`
* `java.sql.NClob`

These types represent references to off-table LOB data.
In principle, they allow JDBC drivers to support more efficient access to the LOB data.
Some drivers stream parts of the LOB data as needed, potentially consuming less memory.

However, `java.sql.Blob` and `java.sql.Clob` can be unnatural to deal with and suffer
certain limitations.
For example, it's not portable to access a LOB locator after the end of the transaction
in which it was obtained.

===== Materialized LOB

Alternatively, Hibernate lets you access LOB data via the familiar Java types `String`,
`char[]`, and `byte[]`. But of course this requires materializing the entire contents
of the LOB in memory when the object is first retrieved. Whether this performance cost
is acceptable depends on many factors, including the vagaries of the JDBC driver.

[TIP]
====
You don't need to use a `@Lob` mapping for every database column of type `BLOB` or `CLOB`.
The `@Lob` annotation is a special-purpose tool that should only be used when a default
basic mapping to `String` would result in unacceptable performance characteristics.
====




[[basic-temporal]]
==== Handling temporal data

Hibernate supports mapping temporal values in numerous ways, though ultimately these strategies
boil down to the 3 main Date/Time types defined by the SQL specification:

DATE:: Represents a calendar date by storing years, months and days.
TIME:: Represents the time of a day by storing hours, minutes and seconds.
TIMESTAMP:: Represents both a DATE and a TIME plus nanoseconds.
TIMESTAMP WITH TIME ZONE:: Represents both a DATE and a TIME plus nanoseconds and zone id or offset.

The mapping of `java.time` temporal types to the specific SQL Date/Time types is implied as follows:

DATE:: `java.time.LocalDate`
TIME:: `java.time.LocalTime`, `java.time.OffsetTime`
TIMESTAMP:: `java.time.Instant`, `java.time.LocalDateTime`, `java.time.OffsetDateTime` and `java.time.ZonedDateTime`
TIMESTAMP WITH TIME ZONE:: `java.time.OffsetDateTime`, `java.time.ZonedDateTime`

Although Hibernate recommends the use of the `java.time` package for representing temporal values,
it does support using `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp`, `java.util.Date` and
`java.util.Calendar`.

The mappings for `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp` are implicit:

DATE:: `java.sql.Date`
TIME:: `java.sql.Time`
TIMESTAMP:: `java.sql.Timestamp`


[IMPORTANT]
====
Applying `@Temporal` to `java.sql.Date`, `java.sql.Time`, `java.sql.Timestamp` or any of the `java.time` types
is considered an exception
====

When using `java.util.Date` or `java.util.Calendar`, Hibernate assumes `TIMESTAMP`.  To alter that,
use `@Temporal`.

[[basic-temporal-java-util-example]]
.Mapping java.util.Date
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/DatePrecisionTests.java[tags=basic-temporal-example]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-datetime-time-zone]]
===== Using a specific time zone

By default, Hibernate is going to use the https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTimestamp-int-java.sql.Timestamp-[`PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp)`] or
https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTime-int-java.sql.Time-[`PreparedStatement.setTime(int parameterIndex, java.sql.Time x)`] when saving a `java.sql.Timestamp` or a `java.sql.Time` property.

When the time zone is not specified, the JDBC driver is going to use the underlying JVM default time zone, which might not be suitable if the application is used from all across the globe.
For this reason, it is very common to use a single reference time zone (e.g. UTC) whenever saving/loading data from the database.

One alternative would be to configure all JVMs to use the reference time zone:

Declaratively::
+
[source,java]
----
java -Duser.timezone=UTC ...
----

Programmatically::
+
[source,java]
----
TimeZone.setDefault( TimeZone.getTimeZone( "UTC" ) );
----

However, as explained in https://in.relation.to/2016/09/12/jdbc-time-zone-configuration-property/[this article], this is not always practical, especially for front-end nodes.
For this reason, Hibernate offers the `hibernate.jdbc.time_zone` configuration property which can be configured:

Declaratively, at the `SessionFactory` level::
+
[source,java]
----
settings.put(
    AvailableSettings.JDBC_TIME_ZONE,
    TimeZone.getTimeZone( "UTC" )
);
----

Programmatically, on a per `Session` basis::
+
[source,java]
----
Session session = sessionFactory()
    .withOptions()
    .jdbcTimeZone( TimeZone.getTimeZone( "UTC" ) )
    .openSession();
----

With this configuration property in place, Hibernate is going to call the https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTimestamp-int-java.sql.Timestamp-java.util.Calendar-[`PreparedStatement.setTimestamp(int parameterIndex, java.sql.Timestamp, Calendar cal)`] or
https://docs.oracle.com/javase/8/docs/api/java/sql/PreparedStatement.html#setTime-int-java.sql.Time-java.util.Calendar-[`PreparedStatement.setTime(int parameterIndex, java.sql.Time x, Calendar cal)`], where the `java.util.Calendar` references the time zone provided via the `hibernate.jdbc.time_zone` property.

[[basic-timestamp-with-time-zone]]
===== Handling time zoned temporal data

By default, Hibernate will convert and normalize `OffsetDateTime` and `ZonedDateTime` to `java.sql.Timestamp` in UTC.
This behavior can be altered by configuring the `hibernate.timezone.default_storage` property

[source,java]
----
settings.put(
    AvailableSettings.TIMEZONE_DEFAULT_STORAGE,
    TimeZoneStorageType.AUTO
);
----

Other possible storage types are `AUTO`, `COLUMN`, `NATIVE` and `NORMALIZE` (the default).
With `COLUMN`, Hibernate will save the time zone information into a dedicated column,
whereas `NATIVE` will require the support of database for a `TIMESTAMP WITH TIME ZONE` data type
that retains the time zone information.
`NORMALIZE` doesn't store time zone information and will simply convert the timestamp to UTC.
Hibernate understands what a database/dialect supports through `Dialect#getTimeZoneSupport`
and will abort with a boot error if the `NATIVE` is used in conjunction with a database that doesn't support this.
For `AUTO`, Hibernate tries to use `NATIVE` if possible and falls back to `COLUMN` otherwise.

==== `@TimeZoneStorage`

Hibernate supports defining the storage to use for time zone information for individual properties
via the `@TimeZoneStorage` and `@TimeZoneColumn` annotations.
The storage type can be specified via the `@TimeZoneStorage` by specifying a `org.hibernate.annotations.TimeZoneStorageType`.
The default storage type is `AUTO` which will ensure that the time zone information is retained.
The `@TimeZoneColumn` annotation can be used in conjunction with `AUTO` or `COLUMN` and allows to define
the column details for the time zone information storage.

[NOTE]
====
Storing the zone offset might be problematic for future timestamps as zone rules can change.
Due to this, storing the offset is only safe for past timestamps, and we advise sticking to the `NORMALIZE` strategy by default.
====

.`@TimeZoneColumn` usage
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/TimeZoneStorageMappingTests.java[tags=time-zone-column-examples-mapping-example]
----
====



// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-jpa-convert]]
==== AttributeConverters

With a custom `AttributeConverter`, the application developer can map a given JDBC type to an entity basic type.

In the following example, the `java.time.Period` is going to be mapped to a `VARCHAR` database column.

[[basic-jpa-convert-period-string-converter-example]]
.`java.time.Period` custom `AttributeConverter`
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/converter/PeriodStringConverter.java[tags=basic-jpa-convert-period-string-converter-example]
----
====

To make use of this custom converter, the `@Convert` annotation must decorate the entity attribute.

[[basic-jpa-convert-period-string-converter-mapping-example]]
.Entity using the custom `java.time.Period` `AttributeConverter` mapping
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-mapping-example]
----
====

When persisting such entity, Hibernate will do the type conversion based on the `AttributeConverter` logic:

[[basic-jpa-convert-period-string-converter-sql-example]]
.Persisting entity using the custom `AttributeConverter`
====
[source, sql, indent=0]
----
include::{extrasdir}/basic/basic-jpa-convert-period-string-converter-sql-example.sql[]
----
====

An `AttributeConverter` can be applied globally for (`@Converter( autoApply=true )`) or locally.


[[basic-jpa-convert-type]]
===== `AttributeConverter` Java and JDBC types

In cases when the Java type specified for the "database side" of the conversion (the second `AttributeConverter` bind parameter) is not known,
Hibernate will fallback to a `java.io.Serializable` type.

If the Java type is not known to Hibernate, you will encounter the following message:

> HHH000481: Encountered Java type for which we could not locate a JavaType and which does not appear to implement equals and/or hashCode.
> This can lead to significant performance problems when performing equality/dirty checking involving this Java type.
> Consider registering a custom JavaType or at least implementing equals/hashCode.

A Java type is "known" if it has an entry in the `JavaTypeRegistry`.  While Hibernate does load many JDK types into
the `JavaTypeRegistry`, an application can also expand the `JavaTypeRegistry` by adding new `JavaType`
entries as discussed in <<basic-mapping-composition>> and <<basic-type-contributor>>.
















[[basic-hbm-attribute-converter]]
===== Mapping an AttributeConverter using HBM mappings

When using HBM mappings, you can still make use of the Jakarta Persistence `AttributeConverter` because Hibernate supports
such mapping via the `type` attribute as demonstrated by the following example.

Let's consider we have an application-specific `Money` type:

[[basic-hbm-attribute-converter-mapping-money-example]]
.Application-specific `Money` type
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/converter/hbm/Money.java[tags=basic-hbm-attribute-converter-mapping-money-example]
----
====

Now, we want to use the `Money` type when mapping the `Account` entity:

[[basic-hbm-attribute-converter-mapping-account-example]]
.`Account` entity using the `Money` type
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/converter/hbm/Account.java[tags=basic-hbm-attribute-converter-mapping-account-example]
----
====

Since Hibernate has no knowledge how to persist the `Money` type, we could use a Jakarta Persistence `AttributeConverter`
to transform the `Money` type as a `Long`. For this purpose, we are going to use the following
`MoneyConverter` utility:

[[basic-hbm-attribute-converter-mapping-moneyconverter-example]]
.`MoneyConverter` implementing the Jakarta Persistence `AttributeConverter` interface
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/converter/hbm/MoneyConverter.java[tags=basic-hbm-attribute-converter-mapping-moneyconverter-example]
----
====

To map the `MoneyConverter` using HBM configuration files you need to use the `converted::` prefix in the `type`
attribute of the `property` element.

[[basic-hbm-attribute-converter-mapping-xml-config-example]]
.HBM mapping for `AttributeConverter`
====
[source, java, indent=0]
----
include::{example-dir-resources}/mapping/converter/hbm/MoneyConverterHbmTest.hbm.xml[]
----
====




[[basic-jpa-convert-mutability]]
===== `AttributeConverter` Mutability Plan

A basic type that's converted by a Jakarta Persistence `AttributeConverter` is immutable if the underlying Java type is immutable
and is mutable if the associated attribute type is mutable as well.

Therefore, mutability is given by the https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/type/descriptor/java/JavaType.html#getMutabilityPlan--[`JavaType#getMutabilityPlan`]
of the associated entity attribute type.

This can be adjusted by using `@Immutable` or `@Mutability` on any of:

1. the basic value
2. the `AttributeConverter` class
3. the basic value type

See <<basic-mapping>> for additional details.


====== Immutable types

If the entity attribute is a `String`, a primitive wrapper (e.g. `Integer`, `Long`), an Enum type, or any other immutable `Object` type,
then you can only change the entity attribute value by reassigning it to a new value.

Considering we have the same `Period` entity attribute as illustrated in the <<basic-jpa-convert>> section:

[source, java, indent=0]
----
include::{example-dir-basic-mapping}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-mapping-example]
----

The only way to change the `span` attribute is to reassign it to a different value:

[source, java, indent=0]
----
include::{example-dir-basic-mapping}/converter/PeriodStringTest.java[tags=basic-jpa-convert-period-string-converter-immutability-plan-example]
----

====== Mutable types

On the other hand, consider the following example where the `Money` type is a mutable.

[source, java, indent=0]
----
include::{example-dir-basic-mapping}/converter/MoneyConverterTest.java[tags=basic-jpa-convert-money-converter-mapping-example]
----

A mutable `Object` allows you to modify its internal structure, and Hibernate's dirty checking mechanism is going to propagate the change to the database:

[source, java, indent=0]
----
include::{example-dir-basic-mapping}/converter/MoneyConverterTest.java[tags=basic-jpa-convert-money-converter-mutability-plan-example]
----

[TIP]
====
Although the `AttributeConverter` types can be mutable so that dirty checking, deep copying, and second-level caching work properly,
treating these as immutable (when they really are) is more efficient.

For this reason, prefer immutable types over mutable ones whenever possible.
====



[[basic-attribute-converter-query-parameter]]
====== Using the AttributeConverter entity property as a query parameter

Assuming you have the following entity:

[[basic-attribute-converter-query-parameter-entity-example]]
.`Photo` entity with `AttributeConverter`
====
[source, java, indent=0]
----
include::{example-dir-converter}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-entity-example]
----
====

And the `Caption` class looks as follows:

[[basic-attribute-converter-query-parameter-object-example]]
.`Caption` Java object
====
[source, java, indent=0]
----
include::{example-dir-converter}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-object-example]
----
====

And we have an `AttributeConverter` to handle the `Caption` Java object:

[[basic-attribute-converter-query-parameter-converter-example]]
.`Caption` Java object AttributeConverter
====
[source, java, indent=0]
----
include::{example-dir-converter}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-example]
----
====

Traditionally, you could only use the DB data `Caption` representation, which in our case is a `String`, when referencing the `caption` entity property.

[[basic-attribute-converter-query-parameter-converter-dbdata-example]]
.Filtering by the `Caption` property using the DB data representation
====
[source, java, indent=0]
----
include::{example-dir-converter}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-dbdata-example]
----
====

In order to use the Java object `Caption` representation, you have to get the associated Hibernate `Type`.

[[basic-attribute-converter-query-parameter-converter-object-example]]
.Filtering by the `Caption` property using the Java Object representation
====
[source, java, indent=0]
----
include::{example-dir-converter}/ConverterTest.java[tags=basic-attribute-converter-query-parameter-converter-object-example]
----
====

By passing the associated Hibernate `Type`, you can use the `Caption` object when binding the query parameter value.


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-mapping-registries]]
==== Registries

We've covered `JavaTypeRegistry` and `JdbcTypeRegistry` a few times now, mainly in regards to mapping resolution
as discussed in <<basic-mapping-composition-resolution>>.  But they each also serve additional important roles.

The `JavaTypeRegistry` is a registry of `JavaType` references keyed by Java type.  In addition to mapping resolution,
this registry is used to handle `Class` references exposed in various APIs such as `Query` parameter types.
`JavaType` references can be registered through `@JavaTypeRegistration`.

The `JdbcTypeRegistry` is a registry of `JdbcType` references keyed by an integer code.  As discussed in
<<basic-mapping-composition-jdbc>>, these type-codes typically match with the corresponding code from
`java.sql.Types`, but that is not a requirement - integers other than those defined by `java.sql.Types` can
be used.  This might be useful for mapping JDBC User Data Types (UDTs) or other specialized database-specific
types (PostgreSQL's UUID type, e.g.).  In addition to its use in mapping resolution, this registry is also used
as the primary source for resolving "discovered" values in a JDBC `ResultSet`.  `JdbcType` references can be
registered through `@JdbcTypeRegistration`.

See <<basic-type-contributor>> for an alternative to `@JavaTypeRegistration` and `@JdbcTypeRegistration` for
registration.


[[basic-type-contributor]]
==== TypeContributor

`org.hibernate.boot.model.TypeContributor` is a contract for overriding or extending parts of the Hibernate type
system.

There are many ways to integrate a `TypeContributor`.  The most common is to define the `TypeContributor` as
a Java service (see `java.util.ServiceLoader`).

`TypeContributor` is passed a `TypeContributions` reference, which allows registration of custom `JavaType`,
`JdbcType` and `BasicType` references.


[[IMPORTANT]]
====
While `TypeContributor` still exposes the ability to register `BasicType` references, this is considered
deprecated.  As of 6.0, these `BasicType` registrations are only used while interpreting `hbm.xml` mappings,
which are themselves considered deprecated.  Use <<basic-mapping-custom>> or <<basic-mapping-composition>> instead.
====


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[[basic-bitset]]
==== Case Study : BitSet

We've covered many ways to specify basic value mappings so far.  This section will look at mapping the
`java.util.BitSet` type by applying the different techniques covered so far.

[[basic-bitset-example-implicit]]
.Implicit BitSet mapping
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/bitset/BitSetImplicitTests.java[tags=basic-bitset-example-implicit]
----
====

As mentioned previously, the worst-case fallback for Hibernate mapping a basic type
which implements `Serializable` is to simply serialize it to the database.  BitSet
does implement `Serializable`, so by default Hibernate would handle this mapping by serialization.

That is not an ideal mapping.  In the following sections we will look at approaches to change
various aspects of how the BitSet gets mapped to the database.


[[basic-bitset-converter]]
===== Using `AttributeConverter`

We've seen uses of `AttributeConverter` previously.

This works well in most cases and is portable across Jakarta Persistence providers.

[[basic-bitset-example-converter]]
.BitSet AttributeConverter
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/bitset/BitSetConverterTests.java[tags=basic-bitset-example-convert]

include::{example-dir-basic-mapping}/basic/bitset/BitSetConverterTests.java[tags=basic-bitset-example-converter]
----
====

[NOTE]
====
The `@Convert` annotation was used for illustration.  Generally such a converter would be auto-applied instead

See <<basic-jpa-convert>> for details.
====

This greatly improves the reading and writing performance of dealing with these
BitSet values because the `AttributeConverter` does that more efficiently using
a simple externalizable form of the BitSet rather than serializing and deserializing
the values.

See also <<basic-jpa-convert-mutability>>.


[[basic-bitset-java-type]]
===== Using a custom `JavaTypeDescriptor`

As covered in <<basic-mapping-explicit>>, we will define a `JavaType`
for `BitSet` that maps values to `VARCHAR` for storage by default.

[[basic-bitset-example-java-type]]
.BitSet JavaTypeDescriptor
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/bitset/BitSetJavaType.java[tags=basic-bitset-example-java-type]
----
====


We can either apply that type locally using `@JavaType`

[[basic-bitset-example-java-type-local]]
.@JavaType
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/bitset/BitSetJavaTypeTests.java[tags=basic-bitset-example-java-type-local,indent=0]
----
====

Or we can apply it globally using `@JavaTypeRegistration`.  This allows the registered `JavaType`
to be used as the default whenever we encounter the `BitSet` type

[[basic-bitset-example-java-type-global]]
.@JavaTypeRegistration
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/bitset/BitSetJavaTypeRegistrationTests.java[tags=basic-bitset-example-java-type-global,indent=0]
----
====


[[basic-bitset-jdbc-type]]
===== Selecting different `JdbcTypeDescriptor`

Our custom `BitSetJavaType` maps `BitSet` values to `VARCHAR` by default.  That was a better option
than direct serialization.  But as `BitSet` is ultimately binary data we would probably really want to
map this to `VARBINARY` type instead.  One way to do that would be to change `BitSetJavaType#getRecommendedJdbcType`
to instead return `VARBINARY` descriptor.  Another option would be to use a local `@JdbcType` or `@JdbcTypeCode`.

The following examples for specifying the `JdbcType` assume our `BitSetJavaType`
is globally registered.

We will again store the values as `VARBINARY` in the database.  The difference now however is that
the coercion methods `#wrap` and `#unwrap` will be used to prepare the value rather than relying on
serialization.


[[basic-bitset-example-jdbc-type-code]]
.@JdbcTypeCode
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/bitset/BitSetJdbcTypeCodeTests.java[tags=basic-bitset-example-jdbc-type-code,indent=0]
----
====

In this example, `@JdbcTypeCode` has been used to indicate that the `JdbcType` registered for JDBC's
`VARBINARY` type should be used.


[[basic-bitset-example-jdbc-type-local]]
.@JdbcType
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/bitset/BitSetJdbcTypeTests.java[tags=basic-bitset-example-jdbc-type-local,indent=0]
----
====

In this example, `@JdbcType` has been used to specify our custom `BitSetJdbcType` descriptor locally for
this attribute.

We could instead replace how Hibernate deals with all `VARBINARY` handling with our custom impl using
`@JdbcTypeRegistration`

[[basic-bitset-example-jdbc-type-global]]
.@JdbcType
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/bitset/BitSetJdbcTypeRegistrationTests.java[tags=basic-bitset-example-jdbc-type-global,indent=0]
----
====




// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


[[mapping-quoted-identifiers]]
==== SQL quoted identifiers

You can force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document.
While traditionally, Hibernate used backticks for escaping SQL reserved keywords, Jakarta Persistence uses double quotes instead.

Once the reserved keywords are escaped, Hibernate will use the correct quotation style for the SQL `Dialect`.
This is usually double quotes, but SQL Server uses brackets and MySQL uses backticks.

[[basic-quoting-example]]
.Hibernate quoting
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/QuotingTest.java[tags=basic-quoting-example]
----
====

[[basic-jpa-quoting-example]]
.Jakarta Persistence quoting
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/JpaQuotingTest.java[tags=basic-jpa-quoting-example]
----
====

Because `name` and `number` are reserved words, the `Product` entity mapping uses backticks to quote these column names.

When saving the following `Product entity`, Hibernate generates the following SQL insert statement:

[[basic-quoting-persistence-example]]
.Persisting a quoted column name
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/QuotingTest.java[tags=basic-quoting-persistence-example, indent=0]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-quoting-persistence-example.sql[indent=0]
----
====

[[mapping-global-quoted-identifiers]]
===== Global quoting

Hibernate can also quote all identifiers (e.g. table, columns) using the following configuration property:

====
[source,xml]
----
<property
    name="hibernate.globally_quoted_identifiers"
    value="true"
/>
----
====

This way, we don't need to manually quote any identifier:

[[basic-auto-quoting-example]]
.Jakarta Persistence quoting
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/AutoQuotingTest.java[tags=basic-auto-quoting-example]
----
====

When persisting a `Product` entity, Hibernate is going to quote all identifiers as in the following example:

====
[source, SQL, indent=0]
----
include::{extrasdir}/basic/basic-auto-quoting-persistence-example.sql[indent=0]
----
====

As you can see, both the table name and all the column have been quoted.

For more about quoting-related configuration properties, check out the <<appendices/SettingsReference.adoc#settings-mapping,Mapping configurations>> section as well.




















[[mapping-generated]]
==== Generated properties

NOTE:: This section talks about generating values for non-identifier attributes.  For discussion of generated identifier values, see <<identifiers-generators>>.

Generated attributes have their values generated as part of performing a SQL INSERT or UPDATE.  Applications can generate these
values in any number of ways (SQL DEFAULT value, trigger, etc).  Typically, the application needs to refresh objects that
contain any properties for which the database was generating values, which is a major drawback.

Applications can also delegate generation to Hibernate, in which case Hibernate will manage the value generation
and (potentialfootnote:[Only in-DB generation requires the refresh]) state refresh itself.

[IMPORTANT]
====
Only `@Basic` and `@Version` attributes can be marked as generated.

Generated attributes must additionally be _non-insertable_ and _non-updateable_.
====

Hibernate supports both in-VM and in-DB generation.  A generation that uses the current JVM timestamp as the
generated value is an example of an in-VM strategy.  A generation that uses the database's `current_timestamp`
function is an example of an in-DB strategy.

Hibernate supports the following timing (when) for generation:

`NEVER` (the default):: the given attribute value is not generated
`INSERT`:: the attribute value is generated on insert but is not regenerated on subsequent updates
`ALWAYS`:: the attribute value is generated both on insert and update.

Hibernate supports multiple ways to mark an attribute as generated:

* Using the dedicated generators provided by Hibernate
    * `@CurrentTimestamp` - <<mapping-generated-CurrentTimestamp>>
    * `@CreationTimestamp` - <<mapping-generated-CreationTimestamp>>
    * `@UpdateTimestamp` - <<mapping-generated-UpdateTimestamp>>
    * `@Generated` - <<mapping-generated-Generated>>
* Using a custom generation strategy - <<mapping-generated-custom>>


[[mapping-generated-CurrentTimestamp]]
===== `@CurrentTimestamp`

The `@CurrentTimestamp` annotation is an in-DB strategy that can be configured for either INSERT or ALWAYS timing.
It uses the database's `current_timestamp` function as the generated value

[[mapping-generated-provided-CurrentTimestamp-ex1]]
.`@UpdateTimestamp` mapping example
====
[source, java, indent=0]
----
include::{example-dir-generated}/CurrentTimestampAnnotationTests.java[tags=mapping-generated-CurrentTimestamp-ex1]
----
====



[[mapping-generated-CreationTimestamp]]
===== `@CreationTimestamp`

The `@CreationTimestamp` annotation is an in-VM `INSERT` strategy.  Hibernate will use
the current timestamp of the JVM as the insert value for the attribute.

Supports most temporal types (`java.time.Instant`, `java.util.Date`, `java.util.Calendar`, etc)

[[mapping-generated-CreationTimestamp-example]]
.`@CreationTimestamp` mapping example
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/generated/CreationTimestampTest.java[tags=mapping-generated-provided-creation-ex1]
----
====

While inserting the `Event`, Hibernate will populate the underlying `timestamp` column with the current JVM timestamp value


[[mapping-generated-UpdateTimestamp]]
===== `@UpdateTimestamp` annotation

The `@UpdateTimestamp` annotation is an in-VM `INSERT` strategy.  Hibernate will use
the current timestamp of the JVM as the insert and update value for the attribute.

Supports most temporal types (`java.time.Instant`, `java.util.Date`, `java.util.Calendar`, etc)


[[mapping-generated-provided-update-ex1]]
.`@UpdateTimestamp` mapping example
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/generated/UpdateTimestampTest.java[tags=mapping-generated-provided-update-ex1]
----
====



[[mapping-generated-Generated]]
===== `@Generated` annotation

The `@Generated` annotation is an in-DB strategy that can be configured for either INSERT or ALWAYS timing

This is the legacy mapping for in-DB generated values.


[[mapping-generated-provided-Generated]]
.`@Generated` mapping example
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/generated/GeneratedTest.java[tags=mapping-generated-provided-generated]
----
====



[[mapping-generated-custom]]
===== Custom generation strategy

Hibernate also supports value generation via a pluggable API using `@ValueGenerationType` and `AnnotationBasedGenerator`
allowing users to define any generation strategy they wish.

Let's look at an example of generating UUID values.  First the attribute mapping

[[mapping-generated-custom-ex1]]
.Custom generation mapping example
====
[source, java, indent=0]
----
include::{example-dir-generated}/temporals/GeneratedUuidTests.java[tags=mapping-generated-custom-ex1]
----
====

This example makes use of an annotation named `@GeneratedUuidValue` - but where is that annotation defined?  This is a custom
annotations provided by the application.

[[mapping-generated-custom-ex2]]
.Custom generation mapping example
====
[source, java, indent=0]
----
include::{example-dir-generated}/temporals/GeneratedUuidTests.java[tags=mapping-generated-custom-ex2]
----
====

The `@ValueGenerationType( generatedBy = UuidValueGeneration.class )` here is the important piece; it tells
Hibernate how to generate values for the attribute - here it will use the specified `UuidValueGeneration` class

[[mapping-generated-custom-ex3]]
.Custom generation mapping example
====
[source, java, indent=0]
----
include::{example-dir-generated}/temporals/GeneratedUuidTests.java[tags=mapping-generated-custom-ex3]
----
====

See https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/annotations/ValueGenerationType.html[`@ValueGenerationType`]
and https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/generator/AnnotationValueGeneration.html[`AnnotationBasedGenerator`]
for details of each contract




[[mapping-column-read-and-write]]
==== Column transformers: read and write expressions

Hibernate allows you to customize the SQL it uses to read and write the values of columns mapped to `@Basic` types.
For example, if your database provides a set of data encryption functions, you can invoke them for individual columns like in the following example.

[[mapping-column-read-and-write-example]]
.`@ColumnTransformer` example
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/../fetching/FetchingTest.java[tags=mapping-column-read-and-write-example]
----
====

If a property uses more than one column, you must use the `forColumn` attribute to specify which column the `@ColumnTransformer` read and write expressions are targeting.

[[mapping-column-read-and-write-composite-type-example]]
.`@ColumnTransformer` `forColumn` attribute usage
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ColumnTransformerTest.java[tags=mapping-column-read-and-write-composite-type-example]
----
====

Hibernate applies the custom expressions automatically whenever the property is referenced in a query.
This functionality is similar to a derived-property <<basic-formula-annotation>> with two differences:

* The property is backed by one or more columns that are exported as part of automatic schema generation.
* The property is read-write, not read-only.

The `write` expression, if specified, must contain exactly one '?' placeholder for the value.

[[mapping-column-read-and-write-composite-type-persistence-example]]
.Persisting an entity with a `@ColumnTransformer` and a composite type
====
[source, java, indent=0]
----
include::{example-dir-basic-mapping}/basic/ColumnTransformerTest.java[tags=mapping-column-read-and-write-composite-type-persistence-example]
----

[source, SQL, indent=0]
----
include::{extrasdir}/basic/mapping-column-read-and-write-composite-type-persistence-example.sql[]
----
====






