[[naturalid]]
=== Natural Ids
:core-project-dir: {root-project-dir}/hibernate-core
:core-test-base-dir: {core-project-dir}/src/test/java/org/hibernate/orm/test
:example-dir-naturalid: {core-test-base-dir}/mapping/identifier
:jcache-project-dir: {root-project-dir}/hibernate-jcache
:example-dir-caching: {jcache-project-dir}/src/test/java/org/hibernate/orm/test/caching
:extrasdir: extras

Natural ids are unique identifiers in the domain model that have a meaning in the real world too.
Even if a natural id does not make a good primary key (surrogate keys being usually preferred), it's still useful to tell Hibernate about it.
As we will see <<find-by-natural-id,later>>, Hibernate provides an efficient means for loading an entity by its natural id much like it offers for loading by identifier (PK).

[[naturalid-mapping]]
==== Natural Id Mapping

Natural ids are defined in terms of one or more persistent attributes.

[[naturalid-simple-basic-attribute-mapping-example]]
.Natural id using single basic attribute
====
[source,java]
----
include::{example-dir-naturalid}/SimpleNaturalIdTest.java[tags=naturalid-simple-basic-attribute-mapping-example,indent=0]
----
====

[[naturalid-single-embedded-attribute-mapping-example]]
.Natural id using single embedded attribute
====
[source,java]
----
include::{example-dir-naturalid}/CompositeNaturalIdTest.java[tags=naturalid-single-embedded-attribute-mapping-example,indent=0]
----
====

[[naturalid-multiple-attribute-mapping-example]]
.Natural id using multiple persistent attributes
====
[source,java]
----
include::{example-dir-naturalid}/MultipleNaturalIdTest.java[tags=naturalid-multiple-attribute-mapping-example,indent=0]
----
====

Natural ids defined using multiple persistent attributes may also define a link:{doc-javadoc-url}org/hibernate/annotations/NaturalIdClass.html[`@NaturalIdClass`] which can be used for <<find-by-natural-id,find operations>>.

[[naturalidclass-example]]
.Natural id with @NaturalIdClass
====
[source,java]
----
include::{core-test-base-dir}/mapping/naturalid/idclass/SimpleNaturalIdClassTests.java[tags=naturalidclass-mapping-example,indent=0]
----
====


[[natural-id-mutability]]
==== Natural id mutability

A natural id may be mutable or immutable. By default, the `@NaturalId` annotation marks the attribute as immutable.
An immutable natural id is expected to never change its value.
In fact, Hibernate will check at flush-time to ensure that the value has not been altered.

If the value(s) of the natural id attribute(s) may change, `@NaturalId(mutable = true)` should be used instead.

[[naturalid-mutable-mapping-example]]
.Mutable natural id mapping
====
[source,java]
----
include::{example-dir-naturalid}/MutableNaturalIdTest.java[tags=naturalid-mutable-mapping-example,indent=0]
----
====

















[[natural-id-caching]]
==== Natural id resolution caching

Within the Session, Hibernate maintains a cross reference of the resolutions from natural id values to entity identifier (PK) values.
We can also have this value resolution cached in the second level cache if second level caching is enabled.

[[naturalid-caching]]
.Natural id caching
====
[source,java]
----
include::{example-dir-caching}/CacheableNaturalIdTest.java[tags=naturalid-cacheable-mapping-example,indent=0]
----
====

[IMPORTANT]
====
Think carefully before caching resolutions for natural ids which are partially or fully <<natural-id-mutability,mutable>> in the second level cache as this will often have a negative impact on performance.
====



[[find-by-natural-id]]
[[naturalid-api]]
==== Loading by natural id

Hibernate provides a means to load one or more entities by natural id using the `KeyType.NATURAL` `FindOption` passed to `find()` or `findMultiple()`.

[NOTE]
====
Hibernate historically offered the dedicated `byNaturalId()`, `bySimpleNaturalId()` and `byMultipleNaturalId()` APIs for loading one or more entities by natural id using its legacy "load access" approach.  However, with JPA 3.2 and the introduction of `FindOption`, etc., these "load access" approaches are considered deprecated and are not discussed here.
====


[[find-by-natural-id-example]]
.Loading by natural id
====
[source,java]
----
include::{example-dir-naturalid}/SimpleNaturalIdTest.java[tags=naturalid-loading-example,indent=0]
----
====

When loading by natural id, the type of value accepted depends on the definition of the natural id.

* For single-attribute natural ids, whether defined by a basic or embedded type, the attribute type should be used.
* For multi-attribute natural ids, Hibernate will accept a number of forms:

** If a link:{doc-javadoc-url}org/hibernate/annotations/NaturalIdClass.html[`@NaturalIdClass`] is defined, an instance of the natural id class may be used.
** A `List` of the individual attribute values, ordered alphabetically by name, may be used.
** A `Map` of the individual attribute values, keyed by the attribute name, may be used.

There are a few differences to be aware of when loading by natural id compared to loading by primary key.  Most importantly, if the natural id is mutable and its values have changed, it is possible for the resolution caching to become out of date until a flush occurs resulting in incorrect results.
To work around this condition, Hibernate will attempt to discover any such pending changes and adjust them prior to performing the load.

[IMPORTANT]
====
This _discovery and adjustment_ (synchronization) has a performance impact.
If you are certain that none of the mutable natural ids already associated with the current `Session` have changed, you can disable this using the `NaturalIdSynchronization.DISABLED` option which will force Hibernate to skip the checking of mutable natural ids.
To be clear: this is only pertinent for mutable natural ids.
====

[[naturalid-mutable-synchronized-example]]
.Mutable natural id synchronization use-case
====
[source,java]
----
include::{example-dir-naturalid}/MutableNaturalIdTest.java[tags=naturalid-mutable-synchronized-example,indent=0]
----
====

