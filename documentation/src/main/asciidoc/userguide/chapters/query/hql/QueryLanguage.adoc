[[query-language]]
== Hibernate Query Language
:modeldir: ../../../../../../main/java/org/hibernate/userguide/model
:sourcedir: ../../../../../../test/java/org/hibernate/userguide/hql
:extrasdir: extras

This chapter describes Hibernate Query Language (HQL) and Jakarta Persistence Query Language (JPQL).

[NOTE]
====
JPQL was inspired by early versions of HQL, and is a subset of modern HQL.
Here we focus on describing the complete, more powerful HQL language as it exists today.

If strict Jakarta Persistence compliance is desired, use the setting `hibernate.jpa.compliance.query=true`.
With this configuration, any attempt to use HQL features beyond the JPQL subset will result in an exception.
We don't recommend the use of this setting.
====

HQL (and JPQL) are loosely based on SQL and are easy to learn for anyone familiar with SQL.

[[hql-case-sensitivity]]
=== Case Sensitivity

Case sensitivity depends on the language element:

- keywords, identification variable names, and function names are case-insensitive, but
- Java class names, and the names of attributes of Java classes, are case-sensitive.

So `SeLeCT` is the same as `sELEct` is the same as `select`, but `org.hibernate.eg.FOO` and `org.hibernate.eg.Foo` are different, as are `foo.barSet` and `foo.BARSET`.

[NOTE]
====
It is standard practice to use lowercase keywords in HQL and JPQL.

The use of uppercase keywords indicates an endearing but unhealthy attachment to the culture of the 1970's.
====

[[hql-statement-types]]
=== Statement types

HQL features four different kinds of statement:

* `select` queries,
* `update` statements,
* `delete` statements, and
* `insert ... values` and `insert ... select` statements.

[IMPORTANT]
====
The effect of an `update` and `delete` statement is not reflected in the persistence context, nor in the state of entity objects held in memory at the time the statement is executed.

It is the responsibility of the application maintain synchronization of state held in memory with the database after execution of an `update` or `delete` statement.
====

[[hql-select]]
==== Select statements

The full https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_Form[BNF] for a `select` query is quite complicated.

[[hql-select-bnf-example]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/statement_select_bnf.txt[]
----
====

Most of the complexity here arises from the interplay of set operators (`union`, `intersect`, and `except`) with ordering.

We'll describe the various clauses of a query later in this chapter, but to summarize, a query might have:

* a `select` list, specifying a <<hql-select-clause,projection>> (the things to return from the query),
* a `from` clause and joins, <<hql-from-clause,specifying>> the entities involved in the query,
* a `where` clause, specifying a <<hql-where-clause,restriction>>,
* a `group by` clause, for <<hql-group-by,aggregation>>,
* a `having` clause, specifying a <<hql-having,restriction>> to apply _after_ aggregation,
* <<hql-set-operators,set operators>> applied to the results of multiple subqueries,
* an `order by` clause, for <<hql-order-by,sorting>> the results, and even
* a `limit`/`offset` clause, for <<hql-limit-offset,limiting or paginating>> the results.

Every one of these clauses is optional!

For example, the simplest query in HQL has no `select` clause at all:

[[hql-select-simplest-example]]
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-simplest-example]
----
====

[NOTE]
====
JPQL requires a `select` clause, whereas HQL does not.
Naturally, the previous query may be written with a `select` clause:

[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-simplest-jpql-example]
----

For complicated queries, it's probably best to explicitly specify a `select` list.
====

An alternative "simplest" query has _only_ a `select` list:

[[hql-select-simplest-example-alt]]
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-simplest-example-alt]
----
====

This results in a SQL `from dual` query (or equivalent).

[TIP]
====
Looking carefully at the BNF given above, you might notice that the `select` list may occur either at the beginning of a query, or near the end, right before `order by`.

Of course, standard SQL, and JPQL, require that the `select` list comes at the beginning.
But it's more natural to put it last:

[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-last-example]
----

This form of the query is more readable, because the alias is declared _before_ it's used, just as God and nature intended.
====

[[hql-update]]
==== Update statements

The BNF for an `update` statement is much easier to understand:

[[hql-update-bnf-example]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/statement_update_bnf.txt[]
----
====

For example:

[[hql-update-example]]
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-update-example]
----
====

[IMPORTANT]
====
No `update` or `delete` statement may have an implicit (or explicit) join.
====

An `update` statement must be executed using `Query#executeUpdate()`.
A single HQL `update` statement might result in multiple SQL update statements executed against the database.

[NOTE]
====
The integer value returned by `executeUpdate()` indicates the number of entity instances affected by the operation.
In a `JOINED` inheritance hierarchy, multiple rows are required to store a single entity instance.
In this case, the update count returned by Hibernate might not be exactly the same as the number of rows affected in the database.
====

An `update` statement, by default, does not affect the `@Version` column of the affected entities.

Adding the keyword `versioned`&mdash;writing `update versioned`&mdash;specifies that Hibernate should update the version or update timestamp.

[NOTE]
====
`update versioned` does not work with custom version types defined by implementing `UserVersionType`, and is not available in JPQL.
====

[[hql-update-examples]]
//.Example update queries
====
[source, SQL, indent=0]
----
include::{sourcedir}/../batch/BatchTest.java[tags=batch-bulk-jpql-update-example]

include::{sourcedir}/../batch/BatchTest.java[tags=batch-bulk-hql-update-example]

include::{sourcedir}/../batch/BatchTest.java[tags=batch-bulk-hql-update-version-example]
----
====

[[hql-delete]]
==== Delete statements

The BNF for a `delete` statement is also quite simple:

[[hql-delete-bnf-example]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/statement_delete_bnf.txt[]
----
====

A `delete` statement is executed by calling `Query#executeUpdate()`.

[[hql-insert]]
==== Insert statements

There are two kinds of `insert` statement:

- `insert ... values`, where the attribute values to insert are given directly, and
- `insert ... select`, where the inserted attribute values are sourced from a subquery.

The first form inserts a single row in the database.
The second form may insert many new rows, or none at all.

[TIP]
====
The first sort of `insert` statement is not very useful.
It's better to just use `persist()`.
====

The BNF for an `insert` statement is:

[[hql-insert-bnf-example]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/statement_insert_bnf.txt[]
----
====

For example:

[[hql-insert-example]]
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-insert-example]
----

[source, SQL, indent=0]
----
include::{sourcedir}/../batch/BatchTest.java[tags=batch-bulk-hql-insert-example]
----
====

An `insert` statement must be executed by calling `Query#executeUpdate()`.

[IMPORTANT]
====
`insert` statements are inherently _not_ polymorphic!
The `targetFields` list is of fixed length, whereas each subclass of an entity class might declare additional fields.
If the entity is involved in a mapped inheritance hierarchy, only attributes declared directly by the named entity and its superclasses may occur in the list of target fields.
Attributes declared by subclasses may not occur.
====

The `queryExpression` may be any valid `select` query, with the caveat that the types of the values in the `select` list must match the types of the target fields.

[NOTE]
====
This is checked during query compilation rather than allowing the type check to delegate to the database.
This may cause problems when two Java types map to the same database type.
For example, an attribute of type `LocalDateTime` and an attribute or type `Timestamp` both map to the SQL type `timestamp`, but are not considered assignable by the query compiler.
====

There are two ways to assign a value to the `@Id` attribute:

- explicitly specify the id attribute in the list of target fields, and its value in the values assigned to the target fields, or
- omit it, in which case a generated value is used.

Of course, the second option is only available for entities with database-level id generation (sequences or identity/autoincrement columns).
It's not available for entities whose id generator is implemented in Java, nor for entities whose id is assigned by the application.

The same two options are available for a `@Version` attribute.
When no version is explicitly specified, the version for a new entity instance is used.

[NOTE]
====
`insert ... select` statements are not available in JPQL.
====

[[hql-literals]]
=== Literals

We now switch gears, and begin describing the language from the bottom up.
The very bottom of a programming language is its syntax for literal values.

The most important literal value in this language is `null`. It's assignable to any other type.

[[hql-boolean-literals]]
==== Boolean literals

The boolean literal values are the (case-insensitive) keywords `true` and `false`.

[[hql-string-literals]]
==== String literals

String literals are enclosed in single quotes.

To escape a single quote within a string literal, use a doubled single quote: `''`.

[[hql-string-literals-example]]
//.String literals examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-string-literals-example]
----
====

==== Numeric literals

Numeric literals come in several different forms.

[[hql-numeric-literals-example]]
//.Numeric literal examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-numeric-literals-example]
----
====

The type of a numeric literal may be specified using a Java-style postfix:
|===
| Postfix | Type | Java type

| `L` or `l` | long integer | `long`
| `D` or `d` | double precision | `double`
| `F` or `f` | single precision | `float`
| `BI` or `bi` | large integer | `BigInteger`
| `BD` or `bd` | exact decimal | `BigDecimal`
|===

It's not usually necessary to specify the precision explicitly.

[NOTE]
====
In a literal with an exponent, the `E` is case-insensitive.
Similarly, the Java-style postfix is case-insensitive.
====

Hexadecimal literals may be written using the same syntax as Java: `0X1A2B` or `0x1a2b`.

[[hql-datetime-literals]]
==== Date and time literals

According to the JPQL specification, date and time literals may be specified using the JDBC escape syntax.
Since this syntax is rather unpleasant to look at, HQL provides not one, but two alternatives.

|===
| Date/time type | Recommended Java type | JDBC escape syntax | Braced literal syntax | Explicitly typed literal syntax

| Date | `LocalDate` | `{d 'yyyy-mm-dd'}` | `{yyyy-mm-dd}` | `date yyyy-mm-dd`
| Time | `LocalTime` | `{t 'hh:mm'}` | `{hh:mm}` | `time hh:mm`
| Time with seconds | `LocalTime` | `{t 'hh:mm:ss'}` | `{hh:mm:ss}` | `time hh:mm:ss`
| Datetime | `LocalDateTime` | `{ts 'yyyy-mm-ddThh:mm:ss'}` | `{yyyy-mm-dd hh:mm:ss}` | `datetime yyyy-mm-dd hh:mm:ss`
| Datetime with milliseconds | `LocalDateTime` | `{ts 'yyyy-mm-ddThh:mm:ss.millis'}` | `{yyyy-mm-dd hh:mm:ss.millis}` | `datetime yyyy-mm-dd hh:mm:ss.millis`
| Datetime with an offset | `OffsetDateTime` | `{ts 'yyyy-mm-ddThh:mm:ss+hh:mm'}` | `{yyyy-mm-dd hh:mm:ss +hh:mm}` | `datetime yyyy-mm-dd hh:mm:ss +hh:mm`
| Datetime with a time zone | `OffsetDateTime` | `{ts 'yyyy-mm-ddThh:mm:ss GMT'}` | `{yyyy-mm-dd hh:mm:ss GMT}` | `datetime yyyy-mm-dd hh:mm:ss GMT`
|===

Literals referring to the current date and time are also provided.
Again there is some flexibility.

|===
| Date/time type | Java type | Underscore syntax | Spaced syntax

| Date | `java.time.LocalDate` | `local_date` | `local date`
| Time | `java.time.LocalTime` | `local_time` | `local time`
| Datetime | `java.time.LocalDateTime` | `local_datetime` | `local datetime`
| Offset datetime | `java.time.OffsetDateTime`| `offset_datetime` | `offset datetime`
| Instant | `java.time.Instant` | `instant` | `instant`
| Date | `java.sql.Date` | `current_date` | `current date`
| Time | `java.sql.Time` | `current_time` | `current time`
| Datetime | `java.sql.Timestamp` | `current_timestamp` | `current timestamp`
|===

[IMPORTANT]
====
Of these, only `current_date`, `current_time`, and `current_timestamp` are defined by the JPQL specification.

However, the use of date and time types from the `java.sql` package is strongly discouraged, so we encourage the use of the HQL extensions.
====

[[hql-duration-literals]]
==== Duration literals

There are two sorts of duration in HQL:

* year/quarter/month/week/day durations, and
* week/day/hour/minute/second/nanosecond durations.

Literal duration expressions are of form `n unit`, for example `1 day` or `10 year` or `100 nanosecond`.

[NOTE]
====
A HQL duration is considered to map to a Java `java.time.Duration`, but semantically they're perhaps more similar to an ANSI SQL `INTERVAL` type.
====

[[hql-binary-literals]]
==== Binary string literals

HQL also provides a choice of formats for binary strings:

* the braced syntax `{0xDE, 0xAD, 0xBE, 0xEF}`, a list of Java-style hexadecimal byte literals, or
* the quoted syntax `X'DEADBEEF'` or `x'deadbeef'`, similar to SQL.

[[hql-enum-literals]]
==== Enum literals

Literal values of a Java enumerated type may be written without needing to specify the enum class name:

[[hql-enum-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-enum-example]
----
====

Here, the enum class is inferred from the type of the expression on the left of the relational operator.

[[hql-java-constants]]
==== Java constants

HQL allows any Java `static` constant to be used in HQL, but it must be referenced by its fully-qualified name:

[[hql-java-constant-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-java-constant-example]
----
====

[[hql-entity-name-literals]]
==== Literal entity names

Entity names may also occur as a literal value. They do not need to be qualified. See <<hql-treat-type>>.

[[hql-expressions]]
=== Expressions

Essentially, expressions are references that resolve to basic or tuple values.

[[hql-concatenation]]
==== String concatenation

HQL defines two ways to concatenate strings:

* the SQL-style concatenation operator, `||`, and
* the JPQL-standard `concat()` function.

See <<jpql-standardized-functions,below>> for details of the `concat()` function.

[[hql-concatenation-example]]
//.Concatenation operation example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-concatenation-example]
----
====

Many more operations on strings are defined below, in <<hql-exp-functions>>.

[[hql-numeric-arithmetic]]
==== Numeric arithmetic

The basic SQL arithmetic operators, `+`,`-`,`*`, and `/` are joined by the remainder operator `%`.

[[hql-numeric-arithmetic-example]]
//.Numeric arithmetic examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-numeric-arithmetic-example]
----
====

The following rules apply to the result of arithmetic operations:

* If either of the operands is `Double`/`double`, the result is a `Double`
* else, if either of the operands is `Float`/`float`, the result is a `Float`
* else, if either operand is `BigDecimal`, the result is `BigDecimal`
* else, if either operand is `BigInteger`, the result is `BigInteger` (except for division, in which case the result type is not further defined)
* else, if either operand is `Long`/`long`, the result is `Long` (except for division, in which case the result type is not further defined)
* else, (the assumption being that both operands are of integral type) the result is `Integer` (except for division, in which case the result type is not further defined)

Many more numeric operations are defined below, in <<hql-exp-functions>>.

[[hql-Datetime-arithmetic]]
==== Datetime arithmetic

Arithmetic involving dates, datetimes, and durations is quite subtle.
Here we list the basic operations.

|===
| Operator | Expression type | Example | Resulting type

| `-` | Difference between two dates | `your.birthday - local date` | year/quarter/month/week/day duration
| `-` | Difference between two datetimes | `local datetime - record.lastUpdated` | week/day/hour/minute/second/nanosecond duration
| `+` | Sum of a date and a year/quarter/month/week/day duration | `local date + 1 week` | date
| `+` | Sum of a datetime and a week/day/hour/minute/second/nanosecond duration | `record.lastUpdated + 1 second` | datetime
| `*` | Product of an integer and a duration | `billing.cycles * 30 day` | duration
| `by unit` | Convert a duration to an integer | `(1 year) by day` | integer
|===

The `by unit` operator converts a duration to an integer, for example: `(local date - your.birthday) by day` evaluates to the number of days you still have to wait.

The function `extract(unit from ...)` extracts a field from a date, time, or datetime type, for example, `extract(year from your.birthday)` produces the year in which you were born, and throws away important information about your birthday.

[IMPORTANT]
====
Please carefully note the difference between these two operations: `by` and `extract()` both evaluate to an integer, but they have very different uses.
====

Additional datetime operations, including the useful `format()` function, are defined below, in <<hql-exp-functions>>.

[[hql-path-expressions]]
==== Identification variables and path expressions

Identification variables, and path expressions beginning with an identification variable are legal expression in almost every context.

See <<hql-identification-variables>> and <<hql-implicit-join>>.

[[hql-case-expressions]]
==== Case expressions

Just like in standard SQL, there are two forms of case expression:

* the _simple_ case expression, and
* the so-called _searched_ case expression.

[TIP]
====
Case expressions are verbose.
It's often simpler to use the `coalesce()`, `nullif()`, or `ifnull()` functions.
====

[[hql-simple-case-expressions]]
===== Simple case expressions

The syntax of the simple form is defined by:

[[hql-simple-case-expressions-bnf]]
[source, antlrv4, indent=0]
----
include::{extrasdir}/simple_case_bnf.txt[]
----

For example:

[[hql-simple-case-expressions-example]]
//.Simple case expression example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-simple-case-expressions-example]
----
====

[[hql-searched-case-expressions]]
===== Searched case expressions

The searched form has the following syntax:

[[hql-searched-case-expressions-bnf]]
[source, antlrv4, indent=0]
----
include::{extrasdir}/searched_case_bnf.txt[]
----

For example:

[[hql-searched-case-expressions-example]]
//.Searched case expression example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-searched-case-expressions-example]
----
====

[[hql-case-arithmetic-expressions]]
===== Case expressions with arithmetic operations

Any arithmetic operation in the `case` expression must be enclosed in parentheses, as illustrated by the following example:

[[hql-case-arithmetic-expressions-example]]
//.Case expression with arithmetic operation example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-case-arithmetic-expressions-example]
----
====

[IMPORTANT]
====
If the arithmetic expression was not enclosed in parentheses, the parser would be unable to parse the expression.
====


[[hql-exp-functions]]
=== Functions

Both HQL and JPQL define some standard functions that are portable between databases.

In some cases, the syntax of these functions looks a bit funny at first, for example, `cast(number as String)`, or `extract(year from date)`, or even `trim(leading '.' from string)`.
This syntax is inspired by standard ANSI SQL, and we promise you'll get used to it.


[IMPORTANT]
====
HQL abstracts away from the actual database-native SQL functions, letting you write queries which are portable between databases.

For some functions, and always depending on the database, a HQL function invocation translates to a quite complicated SQL expression!
====

In addition, there are several ways to use a database function that's not known to Hibernate.

[[hql-treat-type]]
==== Types and typecasts

The special function `type()`, applied to an identification variable, evaluates to the entity name of the referenced entity.
This is mainly useful when dealing with entity inheritance hierarchies.

[[hql-entity-type-exp-example]]
//.Entity type expression examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-entity-type-exp-example]
----
====

The special function `treat()` may be used to narrow the type of an identification variable.
This is useful when dealing with entity inheritance hierarchies.

[[hql-treat-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-treat-example]
----
====

The type of the expression `treat(p as CreditCardPayment)` is the narrowed type, `CreditCardPayment`, instead of the declared type `Payment` of `p`.
This allows the attribute `cardNumber` declared by the subtype `CreditCardPayment` to be referenced.

The `treat()` function may even occur in a <<hql-join-treat,join>>.

[[jpql-standardized-functions]]
==== JPQL standard functions

Here we present the list of functions defined by JPQL.

[TIP]
====
A program that wishes to remain portable between Jakarta Persistence providers should in principle limit itself to the use of these functions.

On the other hand, this is an extremely short list. Any nontrivial program will probably need to look beyond it.
====

===== `nullif()`

An abbreviated `case` expression that evaluates to null if its operands are equal.

[[hql-nullif-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-nullif-example]
----
====

===== `coalesce()`

An abbreviated `case` expression that returns the first non-null operand.

[[hql-coalesce-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-coalesce-example]
----
====

TIP: HQL allows `ifnull()` as a synonym for `coalesce()` in the case of exactly two arguments.

===== `concat()`
Produces a string by concatenating its arguments.

Accepts a variable number of arguments.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-concat-function-example]
----
====

===== `substring()`
A substring of the given string.

The second argument specifies the starting position, where position 1 is the first character of the string.
The third (optional) argument specified the maximum length of the resulting string.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-substring-function-example]
----
====

===== `upper()`
The given string, with lowercase characters converted to uppercase.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-upper-function-example]
----
====

===== `lower()`
The given string, with uppercase characters converted to lowercase.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-lower-function-example]
----
====

===== `trim()`
Follows the semantics of the SQL `trim()` function.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-trim-function-example]
----
====

===== `length()`
The length of a string.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-length-function-example]
----
====

===== `locate()`
Locates a string within another string.

The third argument (optional) is used to specify a position at which to start the search.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-locate-function-example]
----
====

===== `abs()`
The magnitude of a numeric value.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-abs-function-example]
----
====

===== `mod()`
Calculates the remainder of dividing the first argument by the second.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-mod-function-example]
----
====

===== `sqrt()`
The square root of a numeric value.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-sqrt-function-example]
----
====
//
//CURRENT_DATE::
//Returns the database current date.
//
//====
//[source, JAVA, indent=0]
//----
//include::{sourcedir}/HQLTest.java[tags=hql-current-date-function-example]
//----
//====
//
//CURRENT_TIME::
//Returns the database current time.
//
//====
//[source, JAVA, indent=0]
//----
//include::{sourcedir}/HQLTest.java[tags=hql-current-time-function-example]
//----
//====
//
//CURRENT_TIMESTAMP::
//Returns the database current timestamp.
//
//====
//[source, JAVA, indent=0]
//----
//include::{sourcedir}/HQLTest.java[tags=hql-current-timestamp-function-example]
//----
//====

We have not included <<hql-aggregate-functions,aggregate functions>> in this list, because their purpose is more specialized.

[[hql-functions]]
==== Important HQL functions

Beyond the JPQL standardized functions, HQL makes some additional functions available, and ensures that they are as portable as possible across all supported databases.

[[hql-function-cast]]
===== `cast()`
A typecast for basic-typed values.

The target type is an unqualified Java class name:
`String`, `Long`, `Integer`, `Double`, `Float`, `Character`, `Byte`, `BigInteger`, `BigDecimal`, `LocalDate`, `LocalTime`, `LocalDateTime`, etc.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-cast-function-example]
----
====

The function `str(x)` is a synonym for `cast(x as String)`.

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-str-function-example]
----
====

[[hql-function-extract]]
===== `extract()`
Extracts a field of a datetime.

Field types include: `day`, `month`, `year`, `second`, `minute`, `hour`, `day of week`, `day of month`, `week of year`, `date`, `time` and more.
For a full list of field types, see the Javadoc for https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/query/TemporalUnit.html[`TemporalUnit`].

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-extract-function-example]
----
====

The following synonyms for `extract()` are also provided:

|===
| `year(x)` | `extract(year from x)`
| `month(x)` | `extract(month from x)`
| `day(x)` | `extract(day from x)`
| `hour(x)` | `hour(year from x)`
| `minute(x)` | `minute(year from x)`
| `second(x)` | `second(year from x)`
|===

====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-year-function-example]
----
====

===== `collate()`

Selects a collation to be used for its string-valued argument.
Collations are useful for <<hql-relational-comparisons,binary comparisons>> with `<` or `>`, and in the <<hql-order-by,order by clause>>.

For example, `collate(p.name as ucs_basic)` specifies the SQL standard collation `ucs_basic`.

IMPORTANT: Collations aren't very portable between databases.

[[hql-function-format]]
===== `format()`

Formats a date, time, or datetime according to a pattern.

The syntax is `format(datetime as pattern)`, and the pattern must be written in a subset of the pattern language defined by Java's `java.time.format.DateTimeFormatter`.

For a full list of `format()` pattern elements, see the Javadoc for https://docs.jboss.org/hibernate/orm/{majorMinorVersion}/javadocs/org/hibernate/dialect/Dialect.html#appendDatetimeFormat[`Dialect#appendDatetimeFormat`].

[[hql-more-functions]]
==== More HQL functions

Here we summarize the remaining standard functions defined by HQL.

First, functions for working with strings:

|===
| HQL Function | Purpose | Syntax | Notes on syntax

| `position()` | Similar to `locate()` | `position(pattern in string)` | Standard ANSI SQL
| `substring()` | An alternative syntax for JPQL's `substring()`
| `substring(string from start)`, `substring(string from start for length)` | Standard ANSI SQL
| `overlay()` | For replacing a substring
| `overlay(string placing replacement from start)`, `overlay(string placing replacement from start for length)` | Standard ANSI SQL
| `pad()` | Pads a string with whitespace, or with a specified character
| `pad(string with length)`, `pad(string with length leading)`, `pad(string with length trailing)`, or `pad(string with length leading character)`
| Designed to look like `trim()`
| `left()` | The leftmost characters of a string | `left(string, length)` | Common in SQL dialects
| `right()` | The rightmost characters of a string | `right(string, length)`  | Common in SQL dialects
| `replace()` | Replace every occurrence of a pattern in a string | `replace(string, pattern, replacement)` | Common in SQL dialects
|===

Next, functions for working with numeric values:

|===
| HQL Function | Purpose | Signature | Notes on naming

| `sign()` | The sign of a number | `sign(x)` | Universal in SQL dialects
| `exp()` | Exponential function | `exp(x)` | Universal in SQL dialects
| `power()` | Exponentiation | `power(x,y)` | Universal in SQL dialects
| `ln()` | Natural logarithm | `ln(x)` | Very common in SQL dialects
| `log10()` | Base-10 logarithm | `log10(x)` | Very common in SQL dialects
| `sin()`, `cos()`, `tan()`, `asin()`, `acos()`, `atan()`, `atan2()` | Basic trigonometric functions | `sin(theta)`, `cos(theta)`, `atan2(opposite, adjacent)` | Very common in SQL dialects
| `round()` | Numeric rounding | As usual: `round(number, places)` | Very common in SQL dialects
| `floor()` | Floor function | `floor(x)` | Universal in SQL dialects
| `ceiling()` | Ceiling function | `ceiling(x)` | Very common in SQL dialects
| `least()` | Return the smallest of the given arguments | `least(x, y, z)` | Very common in SQL dialects
| `greatest()` | Return the largest of the given arguments | `greatest(x, y, z)` | Very common in SQL dialects
|===

Finally, specialized functions for working with collection-valued attributes and to-many associations:

|===
| HQL Function | Applies to | Purpose

| `size()` | Any collection | The size of the collection.
| `maxelement()` | Collections of basic type | The maximum element as determined by applying the `max()` SQL aggregation.
| `minelement()` | Collections of basic type | The minimum element as determined by applying the `min()` SQL aggregation.
| `maxindex()` | Indexed collections (lists and maps) | The maximum index (key/position) as determined by applying the `max()` SQL aggregation.
| `minindex()` | Indexed collections (lists and maps) | The minimum index (key/position) as determined by applying the `min()` SQL aggregation.
|===

We've intentionally left two functions off this list, so we can come back to them <<hql-elements-indices,later>>.

[[hql-collection-expressions-example]]
//.Collection-related expressions examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-expressions-example]
----
====

[TIP]
====
These operations can almost always be written in another way, without the use of these convenience functions.
====

See also <<hql-collection-qualification>>.

[[hql-user-defined-functions]]
==== Native and user-defined functions

There are several ways to call native or user-defined SQL functions.

- A native or user-defined function may be called using JPQL's `function` syntax, for example, ``function('sinh', phi)``.
- A user-written `FunctionContributor` may register user-defined functions.
- A custom `Dialect` may register additional native functions be overriding `initializeFunctionRegistry()`.

Registering a function isn't hard, but is beyond the scope of this chapter.

[[hql-conditional-expressions]]
=== Predicates

A predicate is an operator which, when applied to some argument, evaluates to `true` or `false`.
In the world of SQL-style ternary logic, we must expand this definition to encompass the possibility that the predicate evaluates to `null`.
Typically, a predicate evaluates to `null` when one of its arguments is `null`.

Predicates occur in the `where` clause, the `having` clause and in searched case expressions.

[[hql-relational-comparisons]]
==== Relational operators

The binary comparison operators are borrowed from SQL: `=`, `>`, `>=`, `<`, `\<=`, `<>`.

TIP: If you prefer, HQL treats `!=` as a synonym for `<>`.

The operands should be of the same type.

[[hql-relational-comparisons-example]]
//.Relational comparison examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-relational-comparisons-example]
----
====

[[hql-between-predicate]]
==== `between`

The ternary `between` operator, and its negation, `not between`, determine if a value falls within a range.

Of course, all three operands must be of compatible type.

[[hql-between-predicate-example]]
//.Between examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-between-predicate-example]
----
====

[[hql-null-predicate]]
==== Operators for dealing with null

The following operators make it easier to deal with null values.

|===
| Operator | Negation | Type | Semantics

| `is null` | `is not null` | Unary postfix | `true` if the value to the left is null
| `is distinct from` | `is not distinct from` | Binary | `true` if the value on the left is equal to the value on the right, or if both are null
|===

[[hql-null-predicate-example]]
//.Nullness checking examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-null-predicate-example]
----
====

[[hql-like-predicate]]
==== String pattern matching

The `like` operator performs pattern matching on strings.
Its friend `ilike` performs case-insensitive matching.

Their syntax is defined by:

[[hql-like-predicate-bnf]]
[source, antlrv4, indent=0]
----
include::{extrasdir}/predicate_like_bnf.txt[]
----

The expression on the right is a pattern, where:

* `_` matches any single character,
* `%` matches any number of characters, and
* if an escape character is specified, it may be used to escape either of these wildcards.

[[hql-like-predicate-example]]
//.Like predicate examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-like-predicate-example]
----
====

The optional `escape` character allows a pattern to include a literal `_` or `%` character.

For example, to match all stored procedures prefixed with `Dr_`, the like criteria could be `'Dr|_%' escape '|'`:

[[hql-like-predicate-escape-example]]
//.Like with escape symbol
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-like-predicate-escape-example]
----
====

As you can guess, `not like` and `not ilike` are the enemies of `like` and `ilike`, and evaluate to the exact opposite boolean values.

[[hql-elements-indices]]
==== Elements and indices

There's two special HQL functions that we didn't mention <<hql-more-functions,earlier>>, since they're only useful in conjunction with the predicate operators we're about to meet.

These functions are only allowed in the `where` clause, and result in a subquery in the generated SQL.
Indeed, you can think of them as just a shortcut way to write a subquery.

//They are usually used in conjunction with either:
//
//* one of the qualifiers `every`, `all`, `any` or `some`, as defined below in <<hql-relational-comparisons-subqueries>>,
//* `in`, defined in <<hql-in-predicate>>, or
//* `exists`, defined in <<hql-exists-predicate>>.

|===
| HQL Function | Applies to | Purpose

| `elements()` |  Any collection | Refers to the elements of a collection as a whole.

| `indices()` | Indexed collections (lists and maps) | Similar to `elements()` but refers to the collections indices (keys/positions) as a whole.
|===

In the next three sections, we'll see how these two functions are useful.

[[hql-in-predicate]]
==== `in`

The `in` predicates evaluates to true if the value to its left is in ... well, whatever it finds to its right.

Its syntax is unexpectedly complicated:

[[hql-in-predicate-bnf]]
[source, antlrv4, indent=0]
----
include::{extrasdir}/predicate_in_bnf.txt[]
----

This less-than-lovely fragment of the HQL ANTLR grammar tells is that the thing to the right might be:

* a list of values enclosed in parentheses,
* a query parameter,
* a subquery, or
* one of the functions `elements()` or `indices()`  defined <<hql-elements-indices,above>>.

The type of the expression on the left, and the types of all the values on the right must be compatible.

[NOTE]
====
JPQL limits the legal types to string, numeric, date/time, and enum types, and in JPQL the left expression must be either:

* a "state field", which means a simple attribute, excluding associations and embedded attributes, or
* an entity type expression (see <<hql-treat-type>>).

HQL is far more permissive. HQL itself does not restrict the type any way, though the database itself might.
Even embedded attributes are allowed, although that feature depends on the level of support for tuple or "row value constructors" in the underlying database.
====

[[hql-in-predicate-example]]
//.In predicate examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-in-predicate-example]
----
====

[[hql-collection-expressions-in-example]]
//.In indices example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-expressions-in-example]
----
====

[[hql-relational-comparisons-subqueries]]
==== Relational operators and subqueries

The binary comparisons we met above in <<hql-relational-comparisons>> may involve a qualifier:

* a qualified subquery, or
* a qualifier applied to one of the functions `elements()` or `indices()`  defined <<hql-elements-indices,above>>.

The qualifiers are unary prefix operators: `all`, `every`, `any`, and `some`.

|===
| Subquery operator | Synonym | Semantics

| `every` | `all` | Evaluates to true of the comparison is true for every value in the result set of the subquery.
| `any` | `some` | Evaluates to true of the comparison is true for at least one value in the result set of the subquery.
|===

[[hql-all-subquery-comparison-qualifier-example]]
//.Subquery comparison example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-all-subquery-comparison-qualifier-example]
----
====

[[hql-collection-expressions-all-some-example]]
//.All elements and some elements
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-expressions-all-example]
----

[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-expressions-some-example]
----
====

[[hql-exists-predicate]]
==== Exists operator

The unary prefix `exists` operator evaluates to true if the thing to its right is nonempty.

The thing to its right might be:

* a subquery, or
* one of the functions `elements()` or `indices()`  defined <<hql-elements-indices,above>>.

As you can surely guess, `not exists` evaluates to true if the thing to the right _is_ empty.

[[hql-collection-expressions-exists-example]]
//.Exists elements example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-expressions-exists-example]
----
====

[[hql-collection-operators]]
==== Collection operators

The following operators apply to collection-valued attributes and to-many associations.

|===
| Operator | Negation | Type | Semantics

| `is empty` | `is not empty` | Unary postfix | `true` if the collection or association on the left has no elements
| `member of` | `not member of` | Binary | `true` if the value on the left is a member of the collection or association on the right
|===

[[hql-empty-collection-predicate-example]]
//.Empty collection expression examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-empty-collection-predicate-example]
----
====

[[hql-member-of-collection-predicate-example]]
//.Member-of collection expression examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-member-of-collection-predicate-example]
----
====

[[hql-logical-operators]]
==== Logical operators

The logical operators are binary infix `and` and `or`, and unary prefix `not`.

Just like SQL, logical expressions are based on ternary logic.
A logical operator evaluates to null if it has a null operand.

[[hql-from-clause]]
=== Declaring root entities: `from`

The `from` clause is responsible for declaring the entities available in the rest of the query, and assigning them aliases, or, in the language of the JPQL specification, _identification variables_.

[[hql-identification-variables]]
==== Identification variables

An identification variable is just a name we can use to refer to an entity and its attributes from expressions in the query.
It may be any legal Java identifier.
According to the JPQL specification, identification variables must be treated as case-insensitive language elements.

[TIP]
====
The identification variable is actually optional, but for queries involving more than one entity it's almost always a good idea to declare one.
====

Identification variables may be declared with the `as` keyword, but this is optional.

[[hql-root-reference]]
==== Root entity references

A root entity reference, or what the JPQL specification calls a _range variable declaration_, is a direct reference to a mapped `@Entity` type by its entity name.

[TIP]
====
Remember, the _entity name_ is the value of the `name` member of the `@Entity` annotation, or the unqualified Java class name by default.
====

[[hql-root-reference-jpql-example]]
//.Entity name for root entity reference
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-simplest-jpql-example]
----
====

In this example, `Person` is the entity name, and `p` is the identification variable.

Alternatively, a fully-qualified Java class name may be specified.
Then Hibernate will query every entity which inherits the named type.

[[hql-root-reference-jpql-fqn-example]]
//.Class name for root entity reference
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-simplest-jpql-fqn-example]
----
====

Of course, there may be multiple root entities.

[[hql-multiple-root-reference-jpql-example]]
//.Simple query using multiple root entity references
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-multiple-root-reference-jpql-example]
----

[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-multiple-same-root-reference-jpql-example]
----
====

The previous queries may even be written using the syntax `cross join` in place of the comma:

[[hql-cross-join-jpql-example]]
//.Simple query using cross join
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-cross-join-jpql-example]
----
====

[[hql-polymorphism]]
==== Polymorphism

HQL and JPQL queries are inherently polymorphic.
Consider:

[[hql-polymorphism-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-polymorphism-example, indent=0]
----
====

This query names the `Payment` entity explicitly.
But the `CreditCardPayment` and `WireTransferPayment` entities inherit `Payment`, and so `p` ranges over all three types.
Instances of all these entities are returned by the query.

[NOTE]
====
The query `from java.lang.Object` is completely legal. (But not very useful!)

It returns every object of every mapped entity type.
====

This behavior may be slightly adjusted using the `@Polymorphism` annotation.

See <<chapters/domain/inheritance.adoc#entity-inheritance-polymorphism>> for more.

[[hql-join]]
=== Declaring joined entities

Joins allow us to navigate from one entity to another, via its associations, or via explicit join conditions.
There are:

- _explicit joins_, declared within the `from` clause using the keyword ``join``,
- and _implicit joins_, which don't need to be declared in the `from` clause.

[[hql-explicit-join]]
==== Explicit joins

An explicit association join is declared using the `join` keyword.
An explicit join may be either:

* an inner join, written as `join` or `inner join`, or
* a left outer join, written as `left join` or `left outer join`.

Every explicit join specifies an entity attribute to be joined.
The specified attribute:

* is usually a `@OneToMany`, `@ManyToMany`, `@OneToOne`, or `@ManyToOne` association, but
* it could be an `@ElementCollection`, and
* it might even be an attribute of embeddable type.

In the case of an association or collection, the generated SQL will have a join of the same type.
(For a many-to-many association it will have _two_ joins.)
In the case of an embedded attribute, the join is purely logical and does not result in a join in the generated SQL.

An explicit join may assign an identification variable to the joined entity.

[[hql-explicit-inner-join-example]]
//.Explicit inner join examples
====
[source, SQL, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-explicit-inner-join-example]
----
====

[[hql-explicit-outer-join-example]]
//.Explicit left (outer) join examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-explicit-outer-join-example]
----
====

For further information about collection-valued association references, see <<hql-collection-valued-associations>>.

[[hql-explicit-join-conditions]]
==== Explicit joins with join conditions

The `with` or `on` clause allows explicit qualification of the join conditions.

[NOTE]
====
The specified join conditions are _added_ to the join conditions specified by the foreign key association.
That's why, historically, HQL uses the keword `with` here:
"with" emphasizes that the new condition doesn't _replace_ the original join conditions.

The `with` keyword is specific to Hibernate. JPQL uses `on`.
====

Join conditions occurring in the `with` or `on` clause are added to the `on` clause in the generated SQL.

[[hql-explicit-join-with-example]]
//.HQL `with` clause join example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-explicit-join-with-example]
----
====

The following query is arguably less clear, but semantically equivalent:

[[hql-explicit-join-jpql-on-example]]
//.JPQL `on` clause join example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-explicit-join-jpql-on-example]
----
====

[[hql-explicit-fetch-join]]
==== `fetch join` for association fetching

A `fetch join`  overrides the laziness of a given association, specifying that the association should be fetched with a SQL join.
The join may be an inner or outer join.

* A `join fetch`, or, more explicitly, `inner join fetch`, only returns base entities with an associated entity.
* A `left join fetch`, or&mdash;for lovers of verbosity&mdash;``left outer join fetch``, returns all the base entities, including those which have no associated joined entity.

[IMPORTANT]
====
This is one of the most important features of Hibernate.
To achieve acceptable performance with HQL, you'll need to use `fetch join` quite often.
Without it, you'll quickly run into the dreaded "n+1 selects" problem.
====

For example, if `Person` has a one-to-many association named `phones`, the use of `join fetch` in the following query specifies that the collection elements should be fetched in the same SQL query:

[[hql-explicit-fetch-join-example]]
//.Fetch join example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-explicit-fetch-join-example]
----
====

In this example, we used a left outer join because we also wanted to obtain customers with no orders.

A query may have more than one `fetch join`, but be aware that:

* it's perfectly safe to fetch several to-one associations in series or parallel in a single query, and
* a single series of _nested_ fetch joins is also fine, but
* fetching multiple collections or to-many associations in _parallel_ results in a Cartesian product at the database level, and might exhibit very poor performance.

HQL doesn't disallow it, but it's usually a bad idea to apply a restriction to a ``fetch join``ed entity, since the elements of the fetched collection would be incomplete.
Indeed, it's best to avoid even assigning an identification variable to a fetched joined entity except for the purpose of specifying a nested fetch join.

[IMPORTANT]
====
Fetch joins should not be used in limited or paged queries.
This includes:

- queries executed using `setFirstResult()` or `setMaxResults()`, as in <<jpql-pagination>>, or
- queries with a limit or offset declared in HQL, described below in <<hql-limit-offset>>.

Nor should they be used with the `scroll()` and `stream()` methods described in <<hql-api-incremental>>.
====

Fetch joins are disallowed in subqueries, where they would make no sense.

[[hql-join-treat]]
==== Joins with typecasts

An explicit join may narrow the type of the joined entity using `treat()`.

[[hql-join-treat-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-join-treat-example]
----
====

Here, the identification variable `ccp` declared to the right of `treat()` has the narrowed type `CreditCardPayment`, instead of the declared type `Payment`.
This allows the attribute `cardNumber` declared by the subtype `CreditCardPayment` to be referenced in the rest of the query.

See <<hql-treat-type>> for more information about `treat()`.

[[hql-implicit-join]]
==== Implicit joins (path expressions)

It's not necessary to explicitly `join` every entity that occurs in a query.
Instead, entity associations may be _navigated_, just like in Java:

* if an attribute is of embedded type, or is a to-one association, it may be further navigated, but
* if an attribute is of basic type, is collection-valued, or is a to-many association, it is considered terminal, and may not be further navigated.

It's clear that:

* A path expression like `p.name` with only two elements just refers to state held directly by an entity with an alias `p` defined in `from` or `join`.
* But a longer path expression, for example, `ph.person.name`, might refer to state held by an associated entity.
  (Alternatively, it might refer to state held by an embedded class.)

In the second case, Hibernate with automatically add a join to the generated SQL if necessary.

[[hql-implicit-join-example]]
//.Simple implicit join example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-implicit-join-example]
----
====

As in this example, implicit joins usually appear outside the `from` clause of the HQL query.
However, they always affect the `from` clause of the SQL query.

Note that:

* Implicit joins are always treated as inner joins.
* Multiple occurrences of the same implicit join always refer to the same SQL join.

[[hql-implicit-join-alias-example]]
//.Reused implicit join
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-implicit-join-alias-example]
----
====

[[hql-collection-valued-associations]]
==== Collection member references

References to collection-valued associations actually refer to the _elements_ of that collection.

[[hql-collection-valued-associations-example]]
//.Collection references example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-valued-associations]
----
====

In the example, the identification variable `ph` actually refers to the object model type `Phone`, which is the type of the elements of the `Person#phones` association.

But there _is_ a way to refer to the keys or indexes of a collection.

[[hql-collection-qualification]]
==== Collection elements, map keys, and list indexes

The following functions may be applied to a collection valued path expression to obtain a reference to a list index or map key.

|===
| Function | Applies to | Interpretation | Notes

| `value()` | Any collection | The collection element or map entry value
| Always optional, and useful only to explicitly indicate intent.
| `index()` | Any `List` with an index column | The index of the element in the list
| For backward compatibility, it's also an alternative to ``key()``, when applied to a map.
| `key()` | Any `Map` | The key of the entry in the list | If the key is of entity type, it may be further navigated.
| `entry()` | Any `Map` | The map entry, that is, the `Map.Entry` of key and value.
| Only legal as a terminal path, and only allowed in the `select` clause.
|===

NOTE: Of these, only `index()` is defined by the JPQL specification.

[[hql-collection-qualification-example]]
//.Qualified collection references example
====
[source, JAVA, indent=0]
----
include::{modeldir}/Phone.java[tags=hql-collection-qualification-example, indent=0]

include::{sourcedir}/HQLTest.java[tags=hql-collection-qualification-example, indent=0]
----
====

An element of an indexed collections (an array, list, or map) may even be identified using the index operator:

[[hql-collection-index-operator-example]]
//.Index operator examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-collection-index-operator-example]
----
====

See <<hql-more-functions>> for additional collection-related functions.

[[hql-select-clause]]
=== Projection: `select`

The `select` list identifies which objects and values to return as the query results.

NOTE: This operation is called _projection_.

Any of the expression types discussed in <<hql-expressions>> may occur in the projection list, unless otherwise noted.

There might be multiple items in a projection list, in which case each query result is a tuple, and this poses a problem:
Java doesn't have a good way to represent tuples.

If there's just one projected item in the `select` list, then, no sweat, that's the type of each query result.
There's no need to bother with trying to represent a "tuple of length 1".

But if there are multiple expressions in the select list then:

- by default, each query result is packaged as an array of type `Object[]`, or
- if explicitly requested by passing the class `Tuple` to `createQuery()`, the query result is packaged as an instance of `javax.persistence.Tuple`.

[[hql-select-clause-projection-example]]
//.Query results as lists
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=jpql-projection-example]
----
====

The names of the `Tuple` elements are determined by the aliases given to the projected items in the select list.
If no aliases are specified, the elements may be accessed by their position in the list (positions are numbered from 0).

Unfortunately, neither `Object[]` nor `Tuple` lets us access an individual item in a result tuple of an HQL query without explicitly specifying the type of the item.
(Using a typecast in the case of `Object[]`, or by passing the class object to `get()` in the case of `Tuple`.)
But there's another option, as we're about to see.

Simplifying slightly, the BNF for a projected item is:

[[hql-select-item-bnf]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/select_item_bnf.txt[]
----
====

where `instantiatiationArgs` is essentially a nested projection list.

So there's a special expression type that's only legal in the select clause: the `instantiation` rule in the BNF above.
Let's see what it does.

[[hql-select-new]]
==== `select new`

The `select new` construct packages the query results into a user-written Java class instead of an array.

[[hql-select-clause-dynamic-instantiation-example]]
//.Query results via `select new`
====
[source, JAVA, indent=0]
----
include::{sourcedir}/CallStatistics.java[tags=hql-select-clause-dynamic-instantiation-example]

include::{sourcedir}/HQLTest.java[tags=hql-select-clause-dynamic-instantiation-example, indent=0]
----
====

The class must be specified by its fully qualified name, and it must have a matching constructor.

[IMPORTANT]
====
This class does not need to be mapped or annotated in any way.

Even if the class _is_ an entity class, the resulting instances are _not_ managed entities and are _not_ associated with the session.
====

Alternatively, using the syntax `select new map`, the query may specify that each result should be packaged as a map:

[[hql-select-clause-dynamic-map-instantiation-example]]
//.Query results as maps
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-clause-dynamic-map-instantiation-example]
----
====

The keys of the map are determined by the aliases given to the projected items in the select list.
If no aliases are specified, the key of an item is its position in the list (positions are numbered from 0).

Or, using the syntax `select new list`, the query may specify that each result should be packaged as a list:

[[hql-select-clause-dynamic-list-instantiation-example]]
//.Query results as lists
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-select-clause-dynamic-list-instantiation-example]
----
====

[NOTE]
====
This is an older syntax, that predates JPQL.
In hindsight, it's hard to see what advantage `List<Object>` offers compared to `Object[]`.
On the other hand, `Map` is a perfectly fine alternative `Tuple`, but isn't portable to other persistence providers.
====

[[hql-distinct]]
==== `distinct`

The `distinct` keyword helps remove duplicate results from the query result list.
It's only effect is to add `distinct` to the generated SQL.

[[hql-distinct-projection-query-example]]
//.Using `distinct` to remove duplicate rows
====
[source, JAVA, indent=0]
----
include::{sourcedir}/SelectDistinctTest.java[tags=hql-distinct-projection-query-example]
----
====

[NOTE]
====
As of Hibernate 6, duplicate results arising from the use of `join fetch` are automatically removed by Hibernate in memory, _after_ reading the database results and materializing entity instances as Java objects.
It's no longer necessary to remove duplicate results explicitly, and, in particular, `distinct` should not be used for this purpose.
====

[[hql-aggregate-functions]]
==== Aggregate functions

It's common to have aggregate functions like `count()`, `sum()`, and `max()` in a select list.
Aggregate functions are special functions that reduce the size of the result set.

The standard aggregate functions defined in both ANSI SQL and JPQL are:

|===
| Aggregate function | Argument type | Result type

| `count()`, including `count(distinct)`, `count(all)`, and `count(*)` | Any | `Long`
| `avg()` | Any numeric type | `Double`
| `min()` | Any numeric type, or string | Same as the argument type
| `max()` | Any numeric type, or string | Same as the argument type
| `sum()` | Any numeric type | See table below
|===

In the case of `sum()`, the rules for assigning a result type are:
|===
| Argument type | Result type

| Any integral numeric type except `BigInteger` | `Long`
| Any floating point numeric type | `Double`
| `BigInteger` | `BigInteger`
| `BigDecimal` |  `BigDecimal`
|===

[[hql-aggregate-functions-example]]
//.Aggregate function examples
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-aggregate-functions-example]
----
====

HQL defines the two additional aggregate functions which accept a logical predicate as an argument, for example, `every(p.amount < 1000.0)`.

|===
| Aggregate function | Argument type | Result type

| `any()` | Logical predicate | `Boolean`
| `every()` | Logical predicate | `Boolean`
|===

NOTE: Aggregate functions usually appear in the `select` clause, but control over aggregation is the responsibility of the `group by` clause, as described <<hql-group-by,below>>.

[[hql-aggregate-functions-filter]]
==== `filter`

All aggregate functions support the inclusion of a _filter clause_, a sort of mini-`where`-clause applying a restriction to just one item of the select list:

[[hql-aggregate-functions-filter-example]]
//.Using filter with aggregate functions
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-aggregate-functions-simple-filter-example]
----

[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-aggregate-functions-filter-example]
----
====

[[hql-where-clause]]
=== Restriction: `where`

The `where` clause restricts the results returned by a `select` query or limits the scope of an `update` or `delete` query.

NOTE: This operation is usually called _selection_, but since that term is often confused with the `select` keyword, and since both projection and selection involve "selecting" things, here we'll use the less-ambiguous term _restriction_.

A restriction is nothing more than a single logical expression, a topic we exhausted above in <<hql-conditional-expressions>>.

[[hql-aggregation]]
=== Aggregation: `group by` and `having`

An aggregate query is one with <<hql-aggregate-functions,aggregate functions>> in its projection list.

The `group by` clause divides the result set into groups, so that a query with aggregate functions in the select list returns not a single result for the whole query, but one result for each group.

NOTE: In short, _grouping_ controls the effect of _aggregation_.

A query with aggregation may also have a `having` clause, a restriction applied to the groups.

[[hql-group-by]]
==== `group by`

The `group by` clause looks quite similar to the `select` clause&mdash;it has a list of grouped items, but:

- if there's just one item, then the query will have a single result for each unique value of that item, or
- if there are multiple items, the query will have a result for each unique _combination_ or their values.

Consider the following queries:

[[hql-group-by-example]]
//.Group by example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-group-by-example]
----
====

The first query retrieves the complete total over all orders.
The second retrieves the total for each customer, after grouping the orders by customer.

[[hql-group-by-rollup-cube]]
==== `rollup` and `cube`

The special functions `rollup()` and `cube()` may be used in the `group by` clause, when supported by the database.
The semantics are identical to SQL.

These functions are especially useful for reporting:

* A `group by` clause with `rollup()` is used to produce subtotals and grand totals.
* A `group by` clause with `cube()` allows totals for every combination of columns.

[[hql-having]]
==== `having`

In a grouped query, the `where` clause applies to the non-aggregated values (it determines which rows will make it into the aggregation).
The `having` clause also restricts results, but it operates on the aggregated values.

In an <<hql-group-by-example,example above>>, we retrieved `Call` duration totals for all persons.
If that ended up being too much data to deal with, we might want to restrict the results to focus only on customers with a summed total of more than 1000:

[[hql-group-by-having-example]]
//.Having example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-group-by-having-example]
----
====

The `having` clause follows the same rules as the `where` clause and is also made up of predicates.
`having` is applied after the groupings and aggregations have been done, while the `where` clause is applied before.

[[hql-set-operators]]
=== Operations on result sets: `union`, `intersect`, and `except`

These operators apply not to expressions, but to entire result sets:

- `union` and `union all`,
- `intersect` and `intersect all`, and
- `except` and `except all`.

Just like in SQL, `all` suppresses the elimination of duplicate results.

[[hql-union-example]]
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-union-example]
----
====

[[hql-order-by]]
=== Sorting: `order by`

By default, the results of the query are returned in an arbitrary order.

[NOTE]
====
Imposing an order on a set is called _sorting_.

A relation (a database table) is a set, and therefore certain particularly dogmatic purists have argued that sorting has no place in the algebra of relations.
We think this is more than a bit silly: practical data analysis almost always involves sorting, which is a perfectly well-defined operation.
====

The `order by` clause specifies a list of projected items used to sort the results.
Each sorted item may be:

* an attribute of an entity or embeddable class,
* a more complex <<hql-expressions,expression>>,
* the alias of a projected item declared in the select list, or
* a literal integer indicating the ordinal position of a projected item in the select list.

Of course, in principle, only certain types may be sorted: numeric types, string, and date and time types.
But HQL is very permissive here and will allow an expression of almost any type to occur in a sort list.
Even the identification variable of an entity with a sortable identifier type may occur as a sorted item.

[NOTE]
====
The JPQL specification requires that every sorted item in the `order by` clause also occur in the `select` clause.
HQL does not enforce this restriction, but applications desiring database portability should be aware that some databases _do_.

Therefore, you might wish to avoid the use of complex expressions in the sort list.
====

The BNF for a sorted item is:

[[hql-order-by-item-bnf]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/order_by_item_bnf.txt[]
----
====

Each sorted item listed in the `order by` clause may explicitly specify a direction, either:

* `asc` for ascending order, or
* `desc` for descending order.

If no direction is explicitly specified, the results are returned in ascending order.

Of course, there's an ambiguity with respect to null values.
Therefore, the sorting of null values may also be explicitly specified:

* `nulls first` puts null values at the beginning of the result set, and
* `nulls last` puts them last.

[[hql-order-by-example]]
//.Order by example
====
[source, JAVA, indent=0]
----
include::{sourcedir}/HQLTest.java[tags=hql-order-by-example]
----
====

[[hql-limit-offset]]
=== Limits and offsets

It's often useful to place a hard upper limit on the number of results that may be returned by a query.

[NOTE]
====
_Limiting_ certainly _isn't_ a well-defined relational operation, and must be used with care.

A limit can easily break the semantics of certain other features of HQL, including <<hql-explicit-fetch-join,fetch joins>>.
====

The `limit` and `offset` clauses are an alternative to the use of `setMaxResults()` and `setFirstResult()` respectively.

[TIP]
====
If the `limit` or `offset` is parameterized, it's much easier to use `setMaxResults()` or `setFirstResult()`.
====

The SQL syntax `fetch first ... rows only` and `fetch next ... rows only` is also allowed.

The BNF is a bit complicated:

[[hql-limit-offset-bnf]]
====
[source, antlrv4, indent=0]
----
include::{extrasdir}/limit_offset_bnf.txt[]
----
====

In the next chapter we'll see a completely different way to write queries in Hibernate.
