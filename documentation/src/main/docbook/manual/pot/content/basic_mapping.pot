# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2011-01-21 21:18+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: application/x-xml2pot; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: basic_mapping.xml:31
#, no-c-format
msgid "Basic O/R Mapping"
msgstr ""

#. Tag: title
#: basic_mapping.xml:34
#, no-c-format
msgid "Mapping declaration"
msgstr ""

#. Tag: para
#: basic_mapping.xml:36
#, no-c-format
msgid "Object/relational mappings can be defined in three approaches:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:41
#, no-c-format
msgid "using Java 5 annotations (via the Java Persistence 2 annotations)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:46
#, no-c-format
msgid "using JPA 2 XML deployment descriptors (described in chapter XXX)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:51
#, no-c-format
msgid "using the Hibernate legacy XML files approach known as hbm.xml"
msgstr ""

#. Tag: para
#: basic_mapping.xml:56
#, no-c-format
msgid "Annotations are split in two categories, the logical mapping annotations (describing the object model, the association between two entities etc.) and the physical mapping annotations (describing the physical schema, tables, columns, indexes, etc). We will mix annotations from both categories in the following code examples."
msgstr ""

#. Tag: para
#: basic_mapping.xml:62
#, no-c-format
msgid "JPA annotations are in the <literal>javax.persistence.*</literal> package. Hibernate specific extensions are in <literal>org.hibernate.annotations.*</literal>. You favorite IDE can auto-complete annotations and their attributes for you (even without a specific \"JPA\" plugin, since JPA annotations are plain Java 5 annotations)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:69
#, no-c-format
msgid "Here is an example of mapping"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:71
#, no-c-format
msgid ""
      "package eg;\n"
      "\n"
      "@Entity \n"
      "@Table(name=\"cats\") @Inheritance(strategy=SINGLE_TABLE)\n"
      "@DiscriminatorValue(\"C\") @DiscriminatorColumn(name=\"subclass\", discriminatorType=CHAR)\n"
      "public class Cat {\n"
      "   \n"
      "   @Id @GeneratedValue\n"
      "   public Integer getId() { return id; }\n"
      "   public void setId(Integer id) { this.id = id; }\n"
      "   private Integer id;\n"
      "\n"
      "   public BigDecimal getWeight() { return weight; }\n"
      "   public void setWeight(BigDecimal weight) { this.weight = weight; }\n"
      "   private BigDecimal weight;\n"
      "\n"
      "   @Temporal(DATE) @NotNull @Column(updatable=false)\n"
      "   public Date getBirthdate() { return birthdate; }\n"
      "   public void setBirthdate(Date birthdate) { this.birthdate = birthdate; }\n"
      "   private Date birthdate;\n"
      "\n"
      "   @org.hibernate.annotations.Type(type=\"eg.types.ColorUserType\")\n"
      "   @NotNull @Column(updatable=false)\n"
      "   public ColorType getColor() { return color; }\n"
      "   public void setColor(ColorType color) { this.color = color; }\n"
      "   private ColorType color;\n"
      "\n"
      "   @NotNull @Column(updatable=false)\n"
      "   public String getSex() { return sex; }\n"
      "   public void setSex(String sex) { this.sex = sex; }\n"
      "   private String sex;\n"
      "\n"
      "   @NotNull @Column(updatable=false)\n"
      "   public Integer getLitterId() { return litterId; }\n"
      "   public void setLitterId(Integer litterId) { this.litterId = litterId; }\n"
      "   private Integer litterId;\n"
      "\n"
      "   @ManyToOne @JoinColumn(name=\"mother_id\", updatable=false)\n"
      "   public Cat getMother() { return mother; }\n"
      "   public void setMother(Cat mother) { this.mother = mother; }\n"
      "   private Cat mother;\n"
      "\n"
      "   @OneToMany(mappedBy=\"mother\") @OrderBy(\"litterId\")\n"
      "   public Set&lt;Cat&gt; getKittens() { return kittens; }\n"
      "   public void setKittens(Set&lt;Cat&gt; kittens) { this.kittens = kittens; }\n"
      "   private Set&lt;Cat&gt; kittens = new HashSet&lt;Cat&gt;();\n"
      "}\n"
      "\n"
      "@Entity @DiscriminatorValue(\"D\")\n"
      "public class DomesticCat extends Cat {\n"
      "\n"
      "   public String getName() { return name; }\n"
      "   public void setName(String name) { this.name = name }\n"
      "   private String name;\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Dog { ... }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:73
#, no-c-format
msgid "The legacy hbm.xml approach uses an XML schema designed to be readable and hand-editable. The mapping language is Java-centric, meaning that mappings are constructed around persistent class declarations and not table declarations."
msgstr ""

#. Tag: para
#: basic_mapping.xml:78
#, no-c-format
msgid "Please note that even though many Hibernate users choose to write the XML by hand, a number of tools exist to generate the mapping document. These include XDoclet, Middlegen and AndroMDA."
msgstr ""

#. Tag: para
#: basic_mapping.xml:82
#, no-c-format
msgid "Here is an example mapping:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:84
#, no-c-format
msgid ""
      "&lt;?xml version=\"1.0\"?&gt;\n"
      "&lt;!DOCTYPE hibernate-mapping PUBLIC\n"
      "      \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
      "          \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n"
      "\n"
      "&lt;hibernate-mapping package=\"eg\"&gt;\n"
      "\n"
      "        &lt;class name=\"Cat\"\n"
      "            table=\"cats\"\n"
      "            discriminator-value=\"C\"&gt;\n"
      "\n"
      "                &lt;id name=\"id\"&gt;\n"
      "                        &lt;generator class=\"native\"/&gt;\n"
      "                &lt;/id&gt;\n"
      "\n"
      "                &lt;discriminator column=\"subclass\"\n"
      "                     type=\"character\"/&gt;\n"
      "\n"
      "                &lt;property name=\"weight\"/&gt;\n"
      "\n"
      "                &lt;property name=\"birthdate\"\n"
      "                    type=\"date\"\n"
      "                    not-null=\"true\"\n"
      "                    update=\"false\"/&gt;\n"
      "\n"
      "                &lt;property name=\"color\"\n"
      "                    type=\"eg.types.ColorUserType\"\n"
      "                    not-null=\"true\"\n"
      "                    update=\"false\"/&gt;\n"
      "\n"
      "                &lt;property name=\"sex\"\n"
      "                    not-null=\"true\"\n"
      "                    update=\"false\"/&gt;\n"
      "\n"
      "                &lt;property name=\"litterId\"\n"
      "                    column=\"litterId\"\n"
      "                    update=\"false\"/&gt;\n"
      "\n"
      "                &lt;many-to-one name=\"mother\"\n"
      "                    column=\"mother_id\"\n"
      "                    update=\"false\"/&gt;\n"
      "\n"
      "                &lt;set name=\"kittens\"\n"
      "                    inverse=\"true\"\n"
      "                    order-by=\"litter_id\"&gt;\n"
      "                        &lt;key column=\"mother_id\"/&gt;\n"
      "                        &lt;one-to-many class=\"Cat\"/&gt;\n"
      "                &lt;/set&gt;\n"
      "\n"
      "                &lt;subclass name=\"DomesticCat\"\n"
      "                    discriminator-value=\"D\"&gt;\n"
      "\n"
      "                        &lt;property name=\"name\"\n"
      "                            type=\"string\"/&gt;\n"
      "\n"
      "                &lt;/subclass&gt;\n"
      "\n"
      "        &lt;/class&gt;\n"
      "\n"
      "        &lt;class name=\"Dog\"&gt;\n"
      "                &lt;!-- mapping for Dog could go here --&gt;\n"
      "        &lt;/class&gt;\n"
      "\n"
      "&lt;/hibernate-mapping&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:86
#, no-c-format
msgid "We will now discuss the concepts of the mapping documents (both annotations and XML). We will only describe, however, the document elements and attributes that are used by Hibernate at runtime. The mapping document also contains some extra optional attributes and elements that affect the database schemas exported by the schema export tool (for example, the <literal> not-null</literal> attribute)."
msgstr ""

#. Tag: title
#: basic_mapping.xml:94
#, no-c-format
msgid "Entity"
msgstr ""

#. Tag: para
#: basic_mapping.xml:96
#, no-c-format
msgid "An entity is a regular Java object (aka POJO) which will be persisted by Hibernate."
msgstr ""

#. Tag: para
#: basic_mapping.xml:99
#, no-c-format
msgid "To mark an object as an entity in annotations, use the <classname>@Entity</classname> annotation."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:102
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Flight implements Serializable {\n"
      "    Long id;\n"
      "\n"
      "    @Id\n"
      "    public Long getId() { return id; }\n"
      "\n"
      "    public void setId(Long id) { this.id = id; }\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:104
#, no-c-format
msgid "That's pretty much it, the rest is optional. There are however any options to tweak your entity mapping, let's explore them."
msgstr ""

#. Tag: para
#: basic_mapping.xml:107
#, no-c-format
msgid "<classname>@Table</classname> lets you define the table the entity will be persisted into. If undefined, the table name is the unqualified class name of the entity. You can also optionally define the catalog, the schema as well as unique constraints on the table."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:112
#, no-c-format
msgid ""
      "@Entity\n"
      "@Table(name=\"TBL_FLIGHT\", \n"
      "       schema=\"AIR_COMMAND\", \n"
      "       uniqueConstraints=\n"
      "           @UniqueConstraint(\n"
      "               name=\"flight_number\", \n"
      "               columnNames={\"comp_prefix\", \"flight_number\"} ) )\n"
      "public class Flight implements Serializable {\n"
      "    @Column(name=\"comp_prefix\")\n"
      "    public String getCompagnyPrefix() { return companyPrefix; }\n"
      "\n"
      "    @Column(name=\"flight_number\")\n"
      "    public String getNumber() { return number; }\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:114
#, no-c-format
msgid "The constraint name is optional (generated if left undefined). The column names composing the constraint correspond to the column names as defined before the Hibernate <classname>NamingStrategy</classname> is applied."
msgstr ""

#. Tag: para
#: basic_mapping.xml:119
#, no-c-format
msgid "<literal>@Entity.name</literal> lets you define the shortcut name of the entity you can used in JP-QL and HQL queries. It defaults to the unqualified class name of the class."
msgstr ""

#. Tag: para
#: basic_mapping.xml:123
#, no-c-format
msgid "Hibernate goes beyond the JPA specification and provide additional configurations. Some of them are hosted on <classname>@org.hibernate.annotations.Entity</classname>:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:129
#, no-c-format
msgid "<literal>dynamicInsert</literal> / <literal>dynamicUpdate</literal> (defaults to false): specifies that <literal>INSERT</literal> / <literal>UPDATE</literal> SQL should be generated at runtime and contain only the columns whose values are not null. The <literal>dynamic-update</literal> and <literal>dynamic-insert</literal> settings are not inherited by subclasses. Although these settings can increase performance in some cases, they can actually decrease performance in others."
msgstr ""

#. Tag: para
#: basic_mapping.xml:140
#, no-c-format
msgid "<literal>selectBeforeUpdate</literal> (defaults to false): specifies that Hibernate should <emphasis>never</emphasis> perform an SQL <literal>UPDATE</literal> unless it is certain that an object is actually modified. Only when a transient object has been associated with a new session using <literal>update()</literal>, will Hibernate perform an extra SQL <literal>SELECT</literal> to determine if an <literal>UPDATE</literal> is actually required. Use of <literal>select-before-update</literal> will usually decrease performance. It is useful to prevent a database update trigger being called unnecessarily if you reattach a graph of detached instances to a <literal>Session</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:154
#, no-c-format
msgid "<literal>polymorphisms</literal> (defaults to <literal>IMPLICIT</literal>): determines whether implicit or explicit query polymorphisms is used. <emphasis>Implicit</emphasis> polymorphisms means that instances of the class will be returned by a query that names any superclass or implemented interface or class, and that instances of any subclass of the class will be returned by a query that names the class itself. <emphasis>Explicit</emphasis> polymorphisms means that class instances will be returned only by queries that explicitly name that class. Queries that name the class will return only instances of subclasses mapped. For most purposes, the default <literal>polymorphisms=IMPLICIT</literal> is appropriate. Explicit polymorphisms is useful when two different classes are mapped to the same table This allows a \"lightweight\" class that contains a subset of the table columns."
msgstr ""

#. Tag: para
#: basic_mapping.xml:171
#, no-c-format
msgid "<literal>persister</literal>: specifies a custom <literal>ClassPersister</literal>. The <literal>persister</literal> attribute lets you customize the persistence strategy used for the class. You can, for example, specify your own subclass of <literal>org.hibernate.persister.EntityPersister</literal>, or you can even provide a completely new implementation of the interface <literal>org.hibernate.persister.ClassPersister</literal> that implements, for example, persistence via stored procedure calls, serialization to flat files or LDAP. See <literal>org.hibernate.test.CustomPersister</literal> for a simple example of \"persistence\" to a <literal>Hashtable</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:185
#, no-c-format
msgid "<literal>optimisticLock</literal> (defaults to <literal>VERSION</literal>): determines the optimistic locking strategy. If you enable <literal>dynamicUpdate</literal>, you will have a choice of optimistic locking strategies:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:192
#, no-c-format
msgid "<literal>version</literal>: check the version/timestamp columns"
msgstr ""

#. Tag: para
#: basic_mapping.xml:197
#, no-c-format
msgid "<literal>all</literal>: check all columns"
msgstr ""

#. Tag: para
#: basic_mapping.xml:201
#, no-c-format
msgid "<literal>dirty</literal>: check the changed columns, allowing some concurrent updates"
msgstr ""

#. Tag: para
#: basic_mapping.xml:206
#, no-c-format
msgid "<literal>none</literal>: do not use optimistic locking"
msgstr ""

#. Tag: para
#: basic_mapping.xml:211
#, no-c-format
msgid "It is <emphasis>strongly</emphasis> recommended that you use version/timestamp columns for optimistic locking with Hibernate. This strategy optimizes performance and correctly handles modifications made to detached instances (i.e. when <literal>Session.merge()</literal> is used)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:220
#, no-c-format
msgid "Be sure to import <classname>@javax.persistence.Entity</classname> to mark a class as an entity. It's a common mistake to import <classname>@org.hibernate.annotations.Entity</classname> by accident."
msgstr ""

#. Tag: para
#: basic_mapping.xml:227
#, no-c-format
msgid "Some entities are not mutable. They cannot be updated or deleted by the application. This allows Hibernate to make some minor performance optimizations.. Use the <classname>@Immutable</classname> annotation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:232
#, no-c-format
msgid "You can also alter how Hibernate deals with lazy initialization for this class. On <classname>@Proxy</classname>, use <literal>lazy</literal>=false to disable lazy fetching (not recommended). You can also specify an interface to use for lazy initializing proxies (defaults to the class itself): use <literal>proxyClass</literal> on <classname>@Proxy</classname>. Hibernate will initially return proxies (Javassist or CGLIB) that implement the named interface. The persistent object will load when a method of the proxy is invoked. See \"Initializing collections and proxies\" below."
msgstr ""

#. Tag: para
#: basic_mapping.xml:243
#, no-c-format
msgid "<classname>@BatchSize</classname> specifies a \"batch size\" for fetching instances of this class by identifier. Not yet loaded instances are loaded batch-size at a time (default 1)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:247
#, no-c-format
msgid "You can specific an arbitrary SQL WHERE condition to be used when retrieving objects of this class. Use <classname>@Where</classname> for that."
msgstr ""

#. Tag: para
#: basic_mapping.xml:251
#, no-c-format
msgid "In the same vein, <classname>@Check</classname> lets you define an SQL expression used to generate a multi-row <emphasis>check</emphasis> constraint for automatic schema generation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:255
#, no-c-format
msgid "There is no difference between a view and a base table for a Hibernate mapping. This is transparent at the database level, although some DBMS do not support views properly, especially with updates. Sometimes you want to use a view, but you cannot create one in the database (i.e. with a legacy schema). In this case, you can map an immutable and read-only entity to a given SQL subselect expression using <classname>@org.hibernate.annotations.Subselect</classname>:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:263
#, no-c-format
msgid ""
      "@Entity\n"
      "@Subselect(\"select item.name, max(bid.amount), count(*) \"\n"
      "        + \"from item \"\n"
      "        + \"join bid on bid.item_id = item.id \"\n"
      "        + \"group by item.name\")\n"
      "@Synchronize( {\"item\", \"bid\"} ) //tables impacted\n"
      "public class Summary {\n"
      "    @Id\n"
      "    public String getId() { return id; }\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:265
#, no-c-format
msgid "Declare the tables to synchronize this entity with, ensuring that auto-flush happens correctly and that queries against the derived entity do not return stale data. The <literal>&lt;subselect&gt;</literal> is available both as an attribute and a nested mapping element."
msgstr ""

#. Tag: para
#: basic_mapping.xml:270
#, no-c-format
msgid "We will now explore the same options using the hbm.xml structure. You can declare a persistent class using the <literal>class</literal> element. For example:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:319
#, no-c-format
msgid ""
      "&lt;class\n"
      "        name=\"ClassName\"\n"
      "        table=\"tableName\"\n"
      "        discriminator-value=\"discriminator_value\"\n"
      "        mutable=\"true|false\"\n"
      "        schema=\"owner\"\n"
      "        catalog=\"catalog\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        select-before-update=\"true|false\"\n"
      "        polymorphism=\"implicit|explicit\"\n"
      "        where=\"arbitrary sql where condition\"\n"
      "        persister=\"PersisterClass\"\n"
      "        batch-size=\"N\"\n"
      "        optimistic-lock=\"none|version|dirty|all\"\n"
      "        lazy=\"true|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "        check=\"arbitrary sql check condition\"\n"
      "        rowid=\"rowid\"\n"
      "        subselect=\"SQL expression\"\n"
      "        abstract=\"true|false\"\n"
      "        node=\"element-name\"\n"
      "/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:323
#, no-c-format
msgid "<literal>name</literal> (optional): the fully qualified Java class name of the persistent class or interface. If this attribute is missing, it is assumed that the mapping is for a non-POJO entity."
msgstr ""

#. Tag: para
#: basic_mapping.xml:330
#, no-c-format
msgid "<literal>table</literal> (optional - defaults to the unqualified class name): the name of its database table."
msgstr ""

#. Tag: para
#: basic_mapping.xml:335
#, no-c-format
msgid "<literal>discriminator-value</literal> (optional - defaults to the class name): a value that distinguishes individual subclasses that is used for polymorphic behavior. Acceptable values include <literal>null</literal> and <literal>not null</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:343
#, no-c-format
msgid "<literal>mutable</literal> (optional - defaults to <literal>true</literal>): specifies that instances of the class are (not) mutable."
msgstr ""

#. Tag: para
#: basic_mapping.xml:349 basic_mapping.xml:2948
#, no-c-format
msgid "<literal>schema</literal> (optional): overrides the schema name specified by the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr ""

#. Tag: para
#: basic_mapping.xml:355 basic_mapping.xml:2954
#, no-c-format
msgid "<literal>catalog</literal> (optional): overrides the catalog name specified by the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr ""

#. Tag: para
#: basic_mapping.xml:361
#, no-c-format
msgid "<literal>proxy</literal> (optional): specifies an interface to use for lazy initializing proxies. You can specify the name of the class itself."
msgstr ""

#. Tag: para
#: basic_mapping.xml:367
#, no-c-format
msgid "<literal>dynamic-update</literal> (optional - defaults to <literal>false</literal>): specifies that <literal>UPDATE</literal> SQL should be generated at runtime and can contain only those columns whose values have changed."
msgstr ""

#. Tag: para
#: basic_mapping.xml:374
#, no-c-format
msgid "<literal>dynamic-insert</literal> (optional - defaults to <literal>false</literal>): specifies that <literal>INSERT</literal> SQL should be generated at runtime and contain only the columns whose values are not null."
msgstr ""

#. Tag: para
#: basic_mapping.xml:381
#, no-c-format
msgid "<literal>select-before-update</literal> (optional - defaults to <literal>false</literal>): specifies that Hibernate should <emphasis>never</emphasis> perform an SQL <literal>UPDATE</literal> unless it is certain that an object is actually modified. Only when a transient object has been associated with a new session using <literal>update()</literal>, will Hibernate perform an extra SQL <literal>SELECT</literal> to determine if an <literal>UPDATE</literal> is actually required."
msgstr ""

#. Tag: para
#: basic_mapping.xml:393
#, no-c-format
msgid "<literal>polymorphisms</literal> (optional - defaults to <literal>implicit</literal>): determines whether implicit or explicit query polymorphisms is used."
msgstr ""

#. Tag: para
#: basic_mapping.xml:399
#, no-c-format
msgid "<literal>where</literal> (optional): specifies an arbitrary SQL <literal>WHERE</literal> condition to be used when retrieving objects of this class."
msgstr ""

#. Tag: para
#: basic_mapping.xml:405
#, no-c-format
msgid "<literal>persister</literal> (optional): specifies a custom <literal>ClassPersister</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:410
#, no-c-format
msgid "<literal>batch-size</literal> (optional - defaults to <literal>1</literal>): specifies a \"batch size\" for fetching instances of this class by identifier."
msgstr ""

#. Tag: para
#: basic_mapping.xml:416
#, no-c-format
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>version</literal>): determines the optimistic locking strategy."
msgstr ""

#. Tag: para
#: basic_mapping.xml:422
#, no-c-format
msgid "<literal>lazy</literal> (optional): lazy fetching can be disabled by setting <literal>lazy=\"false\"</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:427
#, no-c-format
msgid "<literal>entity-name</literal> (optional - defaults to the class name): Hibernate3 allows a class to be mapped multiple times, potentially to different tables. It also allows entity mappings that are represented by Maps or XML at the Java level. In these cases, you should provide an explicit arbitrary name for the entity. See <xref linkend=\"persistent-classes-dynamicmodels\"/> and <xref linkend=\"xml\"/> for more information."
msgstr ""

#. Tag: para
#: basic_mapping.xml:437
#, no-c-format
msgid "<literal>check</literal> (optional): an SQL expression used to generate a multi-row <emphasis>check</emphasis> constraint for automatic schema generation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:443
#, no-c-format
msgid "<literal>rowid</literal> (optional): Hibernate can use ROWIDs on databases. On Oracle, for example, Hibernate can use the <literal>rowid</literal> extra column for fast updates once this option has been set to <literal>rowid</literal>. A ROWID is an implementation detail and represents the physical location of a stored tuple."
msgstr ""

#. Tag: para
#: basic_mapping.xml:452
#, no-c-format
msgid "<literal>subselect</literal> (optional): maps an immutable and read-only entity to a database subselect. This is useful if you want to have a view instead of a base table. See below for more information."
msgstr ""

#. Tag: para
#: basic_mapping.xml:459
#, no-c-format
msgid "<literal>abstract</literal> (optional): is used to mark abstract superclasses in <literal>&lt;union-subclass&gt;</literal> hierarchies."
msgstr ""

#. Tag: para
#: basic_mapping.xml:466
#, no-c-format
msgid "It is acceptable for the named persistent class to be an interface. You can declare implementing classes of that interface using the <literal>&lt;subclass&gt;</literal> element. You can persist any <emphasis>static</emphasis> inner class. Specify the class name using the standard form i.e. <literal>e.g.Foo$Bar</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:472
#, no-c-format
msgid "Here is how to do a virtual view (subselect) in XML:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:474
#, no-c-format
msgid ""
      "&lt;class name=\"Summary\"&gt;\n"
      "    &lt;subselect&gt;\n"
      "        select item.name, max(bid.amount), count(*)\n"
      "        from item\n"
      "        join bid on bid.item_id = item.id\n"
      "        group by item.name\n"
      "    &lt;/subselect&gt;\n"
      "    &lt;synchronize table=\"item\"/&gt;\n"
      "    &lt;synchronize table=\"bid\"/&gt;\n"
      "    &lt;id name=\"name\"/&gt;\n"
      "    ...\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:476
#, no-c-format
msgid "The <literal>&lt;subselect&gt;</literal> is available both as an attribute and a nested mapping element."
msgstr ""

#. Tag: title
#: basic_mapping.xml:481
#, no-c-format
msgid "Identifiers"
msgstr ""

#. Tag: para
#: basic_mapping.xml:483
#, no-c-format
msgid "Mapped classes <emphasis>must</emphasis> declare the primary key column of the database table. Most classes will also have a JavaBeans-style property holding the unique identifier of an instance."
msgstr ""

#. Tag: para
#: basic_mapping.xml:488
#, no-c-format
msgid "Mark the identifier property with <classname>@Id</classname>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:491
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Person {\n"
      "   @Id Integer getId() { ... }\n"
      "   ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:493
#, no-c-format
msgid "In hbm.xml, use the <literal>&lt;id&gt;</literal> element which defines the mapping from that property to the primary key column."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:509
#, no-c-format
msgid ""
      "&lt;id\n"
      "        name=\"propertyName\"\n"
      "        type=\"typename\"\n"
      "        column=\"column_name\"\n"
      "        unsaved-value=\"null|any|none|undefined|id_value\"\n"
      "        access=\"field|property|ClassName\"&gt;\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "\n"
      "        &lt;generator class=\"generatorClass\"/&gt;\n"
      "&lt;/id&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:513
#, no-c-format
msgid "<literal>name</literal> (optional): the name of the identifier property."
msgstr ""

#. Tag: para
#: basic_mapping.xml:518 basic_mapping.xml:2152
#, no-c-format
msgid "<literal>type</literal> (optional): a name that indicates the Hibernate type."
msgstr ""

#. Tag: para
#: basic_mapping.xml:523
#, no-c-format
msgid "<literal>column</literal> (optional - defaults to the property name): the name of the primary key column."
msgstr ""

#. Tag: para
#: basic_mapping.xml:528
#, no-c-format
msgid "<literal>unsaved-value</literal> (optional - defaults to a \"sensible\" value): an identifier property value that indicates an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session."
msgstr ""

#. Tag: para
#: basic_mapping.xml:536
#, no-c-format
msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): the strategy Hibernate should use for accessing the property value."
msgstr ""

#. Tag: para
#: basic_mapping.xml:543
#, no-c-format
msgid "If the <literal>name</literal> attribute is missing, it is assumed that the class has no identifier property."
msgstr ""

#. Tag: para
#: basic_mapping.xml:546
#, no-c-format
msgid "The <literal>unsaved-value</literal> attribute is almost never needed in Hibernate3 and indeed has no corresponding element in annotations."
msgstr ""

#. Tag: para
#: basic_mapping.xml:550
#, no-c-format
msgid "You can also declare the identifier as a composite identifier. This allows access to legacy data with composite keys. Its use is strongly discouraged for anything else."
msgstr ""

#. Tag: title
#: basic_mapping.xml:555
#, no-c-format
msgid "Composite identifier"
msgstr ""

#. Tag: para
#: basic_mapping.xml:557
#, no-c-format
msgid "You can define a composite primary key through several syntaxes:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:562
#, no-c-format
msgid "use a component type to represent the identifier and map it as a property in the entity: you then annotated the property as <classname>@EmbeddedId</classname>. The component type has to be <classname>Serializable</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:569
#, no-c-format
msgid "map multiple properties as <classname>@Id</classname> properties: the identifier type is then the entity class itself and needs to be <classname>Serializable</classname>. This approach is unfortunately not standard and only supported by Hibernate."
msgstr ""

#. Tag: para
#: basic_mapping.xml:577
#, no-c-format
msgid "map multiple properties as <classname>@Id</classname> properties and declare an external class to be the identifier type. This class, which needs to be <classname>Serializable</classname>, is declared on the entity via the <classname>@IdClass</classname> annotation. The identifier type must contain the same properties as the identifier properties of the entity: each property name must be the same, its type must be the same as well if the entity property is of a basic type, its type must be the type of the primary key of the associated entity if the entity property is an association (either a <classname>@OneToOne</classname> or a <classname>@ManyToOne</classname>)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:592
#, no-c-format
msgid "As you can see the last case is far from obvious. It has been inherited from the dark ages of EJB 2 for backward compatibilities and we recommend you not to use it (for simplicity sake)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:596
#, no-c-format
msgid "Let's explore all three cases using examples."
msgstr ""

#. Tag: title
#: basic_mapping.xml:599
#, no-c-format
msgid "id as a property using a component type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:601
#, no-c-format
msgid "Here is a simple example of <classname>@EmbeddedId</classname>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:604
#, no-c-format
msgid ""
      "@Entity\n"
      "class User {\n"
      "   @EmbeddedId\n"
      "   @AttributeOverride(name=\"firstName\", column=@Column(name=\"fld_firstname\")\n"
      "   UserId id;\n"
      "\n"
      "   Integer age;\n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "class UserId implements Serializable {\n"
      "   String firstName;\n"
      "   String lastName;\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:606
#, no-c-format
msgid "You can notice that the <classname>UserId</classname> class is serializable. To override the column mapping, use <classname>@AttributeOverride</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:610
#, no-c-format
msgid "An embedded id can itself contains the primary key of an associated entity."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:613
#, no-c-format
msgid ""
      "@Entity\n"
      "class Customer {\n"
      "   @EmbeddedId CustomerId id;\n"
      "   boolean preferredCustomer;\n"
      "\n"
      "   @MapsId(\"userId\")\n"
      "   @JoinColumns({\n"
      "      @JoinColumn(name=\"userfirstname_fk\", referencedColumnName=\"firstName\"),\n"
      "      @JoinColumn(name=\"userlastname_fk\", referencedColumnName=\"lastName\")\n"
      "   })\n"
      "   @OneToOne User user;\n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "class CustomerId implements Serializable {\n"
      "   UserId userId;\n"
      "   String customerNumber;\n"
      "\n"
      "   //implements equals and hashCode\n"
      "}\n"
      "\n"
      "@Entity \n"
      "class User {\n"
      "   @EmbeddedId UserId id;\n"
      "   Integer age;\n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "class UserId implements Serializable {\n"
      "   String firstName;\n"
      "   String lastName;\n"
      "\n"
      "   //implements equals and hashCode\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:615
#, no-c-format
msgid "In the embedded id object, the association is represented as the identifier of the associated entity. But you can link its value to a regular association in the entity via the <classname>@MapsId</classname> annotation. The <classname>@MapsId</classname> value correspond to the property name of the embedded id object containing the associated entity's identifier. In the database, it means that the <literal>Customer.user</literal> and the <literal>CustomerId.userId</literal> properties share the same underlying column (<literal>user_fk</literal> in this case)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:627
#, no-c-format
msgid "The component type used as identifier must implement <methodname>equals()</methodname> and <methodname>hashCode()</methodname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:632
#, no-c-format
msgid "In practice, your code only sets the <literal>Customer.user</literal> property and the user id value is copied by Hibernate into the <literal>CustomerId.userId</literal> property."
msgstr ""

#. Tag: para
#: basic_mapping.xml:638
#, no-c-format
msgid "The id value can be copied as late as flush time, don't rely on it until after flush time."
msgstr ""

#. Tag: para
#: basic_mapping.xml:642
#, no-c-format
msgid "While not supported in JPA, Hibernate lets you place your association directly in the embedded id component (instead of having to use the <classname>@MapsId</classname> annotation)."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:646
#, no-c-format
msgid ""
      "@Entity\n"
      "class Customer {\n"
      "   @EmbeddedId CustomerId id;\n"
      "   boolean preferredCustomer;\n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "class CustomerId implements Serializable {\n"
      "   @OneToOne\n"
      "   @JoinColumns({\n"
      "      @JoinColumn(name=\"userfirstname_fk\", referencedColumnName=\"firstName\"),\n"
      "      @JoinColumn(name=\"userlastname_fk\", referencedColumnName=\"lastName\")\n"
      "   }) \n"
      "   User user;\n"
      "   String customerNumber;\n"
      "\n"
      "   //implements equals and hashCode\n"
      "}\n"
      "\n"
      "@Entity \n"
      "class User {\n"
      "   @EmbeddedId UserId id;\n"
      "   Integer age;\n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "class UserId implements Serializable {\n"
      "   String firstName;\n"
      "   String lastName;\n"
      "\n"
      "\n"
      "   //implements equals and hashCode\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:648
#, no-c-format
msgid "Let's now rewrite these examples using the hbm.xml syntax."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:651
#, no-c-format
msgid ""
      "&lt;composite-id\n"
      "        name=\"propertyName\"\n"
      "        class=\"ClassName\"\n"
      "        mapped=\"true|false\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        node=\"element-name|.\"&gt;\n"
      "\n"
      "        &lt;key-property name=\"propertyName\" type=\"typename\" column=\"column_name\"/&gt;\n"
      "        &lt;key-many-to-one name=\"propertyName\" class=\"ClassName\" column=\"column_name\"/&gt;\n"
      "        ......\n"
      "&lt;/composite-id&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:653
#, no-c-format
msgid "First a simple example:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:655
#, no-c-format
msgid ""
      "&lt;class name=\"User\"&gt;\n"
      "   &lt;composite-id name=\"id\" class=\"UserId\"&gt;\n"
      "      &lt;key-property name=\"firstName\" column=\"fld_firstname\"/&gt;\n"
      "      &lt;key-property name=\"lastName\"/&gt;\n"
      "   &lt;/composite-id&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:657
#, no-c-format
msgid "Then an example showing how an association can be mapped."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:660
#, no-c-format
msgid ""
      "&lt;class name=\"Customer\"&gt;\n"
      "   &lt;composite-id name=\"id\" class=\"CustomerId\"&gt;\n"
      "      &lt;key-property name=\"firstName\" column=\"userfirstname_fk\"/&gt;\n"
      "      &lt;key-property name=\"lastName\" column=\"userfirstname_fk\"/&gt;\n"
      "      &lt;key-property name=\"customerNumber\"/&gt;\n"
      "   &lt;/composite-id&gt;\n"
      "\n"
      "   &lt;property name=\"preferredCustomer\"/&gt;\n"
      "\n"
      "   &lt;many-to-one name=\"user\"&gt;\n"
      "      &lt;column name=\"userfirstname_fk\" updatable=\"false\" insertable=\"false\"/&gt;\n"
      "      &lt;column name=\"userlastname_fk\" updatable=\"false\" insertable=\"false\"/&gt;\n"
      "   &lt;/many-to-one&gt;\n"
      "&lt;/class&gt;\n"
      "\n"
      "&lt;class name=\"User\"&gt;\n"
      "   &lt;composite-id name=\"id\" class=\"UserId\"&gt;\n"
      "      &lt;key-property name=\"firstName\"/&gt;\n"
      "      &lt;key-property name=\"lastName\"/&gt;\n"
      "   &lt;/composite-id&gt;\n"
      "\n"
      "   &lt;property name=\"age\"/&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:662
#, no-c-format
msgid "Notice a few things in the previous example:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:666
#, no-c-format
msgid "the order of the properties (and column) matters. It must be the same between the association and the primary key of the associated entity"
msgstr ""

#. Tag: para
#: basic_mapping.xml:672
#, no-c-format
msgid "the many to one uses the same columns as the primary key and thus must be marked as read only (<literal>insertable</literal> and <literal>updatable</literal> to false)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:679
#, no-c-format
msgid "unlike with <classname>@MapsId</classname>, the id value of the associated entity is not transparently copied, check the <literal>foreign</literal> id generator for more information."
msgstr ""

#. Tag: para
#: basic_mapping.xml:686
#, no-c-format
msgid "The last example shows how to map association directly in the embedded id component."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:689
#, no-c-format
msgid ""
      "&lt;class name=\"Customer\"&gt;\n"
      "   &lt;composite-id name=\"id\" class=\"CustomerId\"&gt;\n"
      "      &lt;key-many-to-one name=\"user\"&gt;\n"
      "         &lt;column name=\"userfirstname_fk\"/&gt;\n"
      "         &lt;column name=\"userlastname_fk\"/&gt;\n"
      "      &lt;/key-many-to-one&gt;\n"
      "      &lt;key-property name=\"customerNumber\"/&gt;\n"
      "   &lt;/composite-id&gt;\n"
      "\n"
      "   &lt;property name=\"preferredCustomer\"/&gt;\n"
      "&lt;/class&gt;\n"
      "\n"
      "&lt;class name=\"User\"&gt;\n"
      "   &lt;composite-id name=\"id\" class=\"UserId\"&gt;\n"
      "      &lt;key-property name=\"firstName\"/&gt;\n"
      "      &lt;key-property name=\"lastName\"/&gt;\n"
      "   &lt;/composite-id&gt;\n"
      "\n"
      "   &lt;property name=\"age\"/&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:691
#, no-c-format
msgid "This is the recommended approach to map composite identifier. The following options should not be considered unless some constraint are present."
msgstr ""

#. Tag: title
#: basic_mapping.xml:697
#, no-c-format
msgid "Multiple id properties without identifier type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:699
#, no-c-format
msgid "Another, arguably more natural, approach is to place <classname>@Id</classname> on multiple properties of your entity. This approach is only supported by Hibernate (not JPA compliant) but does not require an extra embeddable component."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:704
#, no-c-format
msgid ""
      "@Entity\n"
      "class Customer implements Serializable {\n"
      "   @Id @OneToOne\n"
      "   @JoinColumns({\n"
      "      @JoinColumn(name=\"userfirstname_fk\", referencedColumnName=\"firstName\"),\n"
      "      @JoinColumn(name=\"userlastname_fk\", referencedColumnName=\"lastName\")\n"
      "   })\n"
      "   User user;\n"
      "  \n"
      "   @Id String customerNumber;\n"
      "\n"
      "   boolean preferredCustomer;\n"
      "\n"
      "   //implements equals and hashCode\n"
      "}\n"
      "\n"
      "@Entity \n"
      "class User {\n"
      "   @EmbeddedId UserId id;\n"
      "   Integer age;\n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "class UserId implements Serializable {\n"
      "   String firstName;\n"
      "   String lastName;\n"
      "\n"
      "   //implements equals and hashCode\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:706
#, no-c-format
msgid "In this case <classname>Customer</classname> is its own identifier representation: it must implement <classname>Serializable</classname> and must implement <methodname>equals()</methodname> and <methodname>hashCode()</methodname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:712
#, no-c-format
msgid "In hbm.xml, the same mapping is:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:714
#, no-c-format
msgid ""
      "&lt;class name=\"Customer\"&gt;\n"
      "   &lt;composite-id&gt;\n"
      "      &lt;key-many-to-one name=\"user\"&gt;\n"
      "         &lt;column name=\"userfirstname_fk\"/&gt;\n"
      "         &lt;column name=\"userlastname_fk\"/&gt;\n"
      "      &lt;/key-many-to-one&gt;\n"
      "      &lt;key-property name=\"customerNumber\"/&gt;\n"
      "   &lt;/composite-id&gt;\n"
      "\n"
      "   &lt;property name=\"preferredCustomer\"/&gt;\n"
      "&lt;/class&gt;\n"
      "\n"
      "&lt;class name=\"User\"&gt;\n"
      "   &lt;composite-id name=\"id\" class=\"UserId\"&gt;\n"
      "      &lt;key-property name=\"firstName\"/&gt;\n"
      "      &lt;key-property name=\"lastName\"/&gt;\n"
      "   &lt;/composite-id&gt;\n"
      "\n"
      "   &lt;property name=\"age\"/&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: title
#: basic_mapping.xml:718
#, no-c-format
msgid "Multiple id properties with with a dedicated identifier type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:721
#, no-c-format
msgid "<classname>@IdClass</classname> on an entity points to the class (component) representing the identifier of the class. The properties marked <classname>@Id</classname> on the entity must have their corresponding property on the <classname>@IdClass</classname>. The return type of search twin property must be either identical for basic properties or must correspond to the identifier class of the associated entity for an association."
msgstr ""

#. Tag: para
#: basic_mapping.xml:730
#, no-c-format
msgid "This approach is inherited from the EJB 2 days and we recommend against its use. But, after all it's your application and Hibernate supports it."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:735
#, no-c-format
msgid ""
      "@Entity\n"
      "@IdClass(CustomerId.class)\n"
      "class Customer implements Serializable {\n"
      "   @Id @OneToOne\n"
      "   @JoinColumns({\n"
      "      @JoinColumn(name=\"userfirstname_fk\", referencedColumnName=\"firstName\"),\n"
      "      @JoinColumn(name=\"userlastname_fk\", referencedColumnName=\"lastName\")\n"
      "   }) \n"
      "   User user;\n"
      "  \n"
      "   @Id String customerNumber;\n"
      "\n"
      "   boolean preferredCustomer;\n"
      "}\n"
      "\n"
      "class CustomerId implements Serializable {\n"
      "   UserId user;\n"
      "   String customerNumber;\n"
      "\n"
      "   //implements equals and hashCode\n"
      "}\n"
      "\n"
      "@Entity \n"
      "class User {\n"
      "   @EmbeddedId UserId id;\n"
      "   Integer age;\n"
      "\n"
      "   //implements equals and hashCode\n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "class UserId implements Serializable {\n"
      "   String firstName;\n"
      "   String lastName;\n"
      "\n"
      "   //implements equals and hashCode\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:737
#, no-c-format
msgid "<classname>Customer</classname> and <classname>CustomerId</classname> do have the same properties <literal>customerNumber</literal> as well as <literal>user</literal>. <classname>CustomerId</classname> must be <classname>Serializable</classname> and implement <classname>equals()</classname> and <classname>hashCode()</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:745
#, no-c-format
msgid "While not JPA standard, Hibernate let's you declare the vanilla associated property in the <classname>@IdClass</classname>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:749
#, no-c-format
msgid ""
      "@Entity\n"
      "@IdClass(CustomerId.class)\n"
      "class Customer implements Serializable {\n"
      "   @Id @OneToOne\n"
      "   @JoinColumns({\n"
      "      @JoinColumn(name=\"userfirstname_fk\", referencedColumnName=\"firstName\"),\n"
      "      @JoinColumn(name=\"userlastname_fk\", referencedColumnName=\"lastName\")\n"
      "   }) \n"
      "   User user;\n"
      "  \n"
      "   @Id String customerNumber;\n"
      "\n"
      "   boolean preferredCustomer;\n"
      "}\n"
      "\n"
      "class CustomerId implements Serializable {\n"
      "   @OneToOne User user;\n"
      "   String customerNumber;\n"
      "\n"
      "   //implements equals and hashCode\n"
      "}\n"
      "\n"
      "@Entity \n"
      "class User {\n"
      "   @EmbeddedId UserId id;\n"
      "   Integer age;\n"
      "\n"
      "   //implements equals and hashCode\n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "class UserId implements Serializable {\n"
      "  String firstName;\n"
      "  String lastName;\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:751
#, no-c-format
msgid "This feature is of limited interest though as you are likely to have chosen the <classname>@IdClass</classname> approach to stay JPA compliant or you have a quite twisted mind."
msgstr ""

#. Tag: para
#: basic_mapping.xml:755
#, no-c-format
msgid "Here are the equivalent on hbm.xml files:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:757
#, no-c-format
msgid ""
      "&lt;class name=\"Customer\"&gt;\n"
      "   &lt;composite-id class=\"CustomerId\" mapped=\"true\"&gt;\n"
      "      &lt;key-many-to-one name=\"user\"&gt;\n"
      "         &lt;column name=\"userfirstname_fk\"/&gt;\n"
      "         &lt;column name=\"userlastname_fk\"/&gt;\n"
      "      &lt;/key-many-to-one&gt;\n"
      "      &lt;key-property name=\"customerNumber\"/&gt;\n"
      "   &lt;/composite-id&gt;\n"
      "\n"
      "   &lt;property name=\"preferredCustomer\"/&gt;\n"
      "&lt;/class&gt;\n"
      "\n"
      "&lt;class name=\"User\"&gt;\n"
      "   &lt;composite-id name=\"id\" class=\"UserId\"&gt;\n"
      "      &lt;key-property name=\"firstName\"/&gt;\n"
      "      &lt;key-property name=\"lastName\"/&gt;\n"
      "   &lt;/composite-id&gt;\n"
      "\n"
      "   &lt;property name=\"age\"/&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: title
#: basic_mapping.xml:762
#, no-c-format
msgid "Identifier generator"
msgstr ""

#. Tag: para
#: basic_mapping.xml:764
#, no-c-format
msgid "Hibernate can generate and populate identifier values for you automatically. This is the recommended approach over \"business\" or \"natural\" id (especially composite ids)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:768
#, no-c-format
msgid "Hibernate offers various generation strategies, let's explore the most common ones first that happens to be standardized by JPA:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:774
#, no-c-format
msgid "IDENTITY: supports identity columns in DB2, MySQL, MS SQL Server, Sybase and HypersonicSQL. The returned identifier is of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:781
#, no-c-format
msgid "SEQUENCE (called <literal>seqhilo</literal> in Hibernate): uses a hi/lo algorithm to efficiently generate identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>, given a named database sequence."
msgstr ""

#. Tag: para
#: basic_mapping.xml:788
#, no-c-format
msgid "TABLE (called <classname>MultipleHiLoPerTableGenerator</classname> in Hibernate) : uses a hi/lo algorithm to efficiently generate identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>, given a table and column as a source of hi values. The hi/lo algorithm generates identifiers that are unique only for a particular database."
msgstr ""

#. Tag: para
#: basic_mapping.xml:798
#, no-c-format
msgid "AUTO: selects <literal>IDENTITY</literal>, <literal>SEQUENCE</literal> or <literal>TABLE</literal> depending upon the capabilities of the underlying database."
msgstr ""

#. Tag: para
#: basic_mapping.xml:805
#, no-c-format
msgid "We recommend all new projects to use the new enhanced identifier generators. They are deactivated by default for entities using annotations but can be activated using <code>hibernate.id.new_generator_mappings=true</code>. These new generators are more efficient and closer to the JPA 2 specification semantic."
msgstr ""

#. Tag: para
#: basic_mapping.xml:812
#, no-c-format
msgid "However they are not backward compatible with existing Hibernate based application (if a sequence or a table is used for id generation). See XXXXXXX <xref linkend=\"ann-setup-properties\"/> for more information on how to activate them."
msgstr ""

#. Tag: para
#: basic_mapping.xml:818
#, no-c-format
msgid "To mark an id property as generated, use the <classname>@GeneratedValue</classname> annotation. You can specify the strategy used (default to <literal>AUTO</literal>) by setting <literal>strategy</literal>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:823
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Customer {\n"
      "   @Id @GeneratedValue\n"
      "   Integer getId() { ... };\n"
      "}\n"
      "\n"
      "@Entity \n"
      "public class Invoice {\n"
      "   @Id @GeneratedValue(strategy=GenerationType.IDENTITY)\n"
      "   Integer getId() { ... };\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:825
#, no-c-format
msgid "<literal>SEQUENCE</literal> and <literal>TABLE</literal> require additional configurations that you can set using <classname>@SequenceGenerator</classname> and <classname>@TableGenerator</classname>:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:832
#, no-c-format
msgid "<literal>name</literal>: name of the generator"
msgstr ""

#. Tag: para
#: basic_mapping.xml:836
#, no-c-format
msgid "<literal>table</literal> / <literal>sequenceName</literal>: name of the table or the sequence (defaulting respectively to <literal>hibernate_sequences</literal> and <literal>hibernate_sequence</literal>)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:843
#, no-c-format
msgid "<literal>catalog</literal> / <literal>schema</literal>:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:848
#, no-c-format
msgid "<literal>initialValue</literal>: the value from which the id is to start generating"
msgstr ""

#. Tag: para
#: basic_mapping.xml:853
#, no-c-format
msgid "<literal>allocationSize</literal>: the amount to increment by when allocating id numbers from the generator"
msgstr ""

#. Tag: para
#: basic_mapping.xml:858
#, no-c-format
msgid "In addition, the <classname>TABLE</classname> strategy also let you customize:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:863
#, no-c-format
msgid "<literal>pkColumnName</literal>: the column name containing the entity identifier"
msgstr ""

#. Tag: para
#: basic_mapping.xml:868
#, no-c-format
msgid "<literal>valueColumnName</literal>: the column name containing the identifier value"
msgstr ""

#. Tag: para
#: basic_mapping.xml:873
#, no-c-format
msgid "<literal>pkColumnValue</literal>: the entity identifier"
msgstr ""

#. Tag: para
#: basic_mapping.xml:878
#, no-c-format
msgid "<literal>uniqueConstraints</literal>: any potential column constraint on the table containing the ids"
msgstr ""

#. Tag: para
#: basic_mapping.xml:883
#, no-c-format
msgid "To link a table or sequence generator definition with an actual generated property, use the same name in both the definition <literal>name</literal> and the generator value <literal>generator</literal> as shown below."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:888
#, no-c-format
msgid ""
      "@Id \n"
      "@GeneratedValue(\n"
      "    strategy=GenerationType.SEQUENCE, \n"
      "    generator=\"SEQ_GEN\")\n"
      "@javax.persistence.SequenceGenerator(\n"
      "    name=\"SEQ_GEN\",\n"
      "    sequenceName=\"my_sequence\",\n"
      "    allocationSize=20\n"
      ")\n"
      "public Integer getId() { ... }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:890
#, no-c-format
msgid "The scope of a generator definition can be the application or the class. Class-defined generators are not visible outside the class and can override application level generators. Application level generators are defined in JPA's XML deployment descriptors (see XXXXXX <xref linkend=\"xml-overriding\"/>):"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:896
#, no-c-format
msgid ""
      "&lt;table-generator name=\"EMP_GEN\"\n"
      "            table=\"GENERATOR_TABLE\"\n"
      "            pk-column-name=\"key\"\n"
      "            value-column-name=\"hi\"\n"
      "            pk-column-value=\"EMP\"\n"
      "            allocation-size=\"20\"/&gt;\n"
      "\n"
      "//and the annotation equivalent\n"
      "\n"
      "@javax.persistence.TableGenerator(\n"
      "    name=\"EMP_GEN\",\n"
      "    table=\"GENERATOR_TABLE\",\n"
      "    pkColumnName = \"key\",\n"
      "    valueColumnName = \"hi\"\n"
      "    pkColumnValue=\"EMP\",\n"
      "    allocationSize=20\n"
      ")\n"
      "\n"
      "&lt;sequence-generator name=\"SEQ_GEN\" \n"
      "    sequence-name=\"my_sequence\"\n"
      "    allocation-size=\"20\"/&gt;\n"
      "\n"
      "//and the annotation equivalent\n"
      "\n"
      "@javax.persistence.SequenceGenerator(\n"
      "    name=\"SEQ_GEN\",\n"
      "    sequenceName=\"my_sequence\",\n"
      "    allocationSize=20\n"
      ")"
msgstr ""

#. Tag: para
#: basic_mapping.xml:898
#, no-c-format
msgid "If a JPA XML descriptor (like <filename>META-INF/orm.xml</filename>) is used to define the generators, <literal>EMP_GEN</literal> and <literal>SEQ_GEN</literal> are application level generators."
msgstr ""

#. Tag: para
#: basic_mapping.xml:904
#, no-c-format
msgid "Package level definition is not supported by the JPA specification. However, you can use the <literal>@GenericGenerator</literal> at the package level (see <xref linkend=\"entity-hibspec-identifier\"/>)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:910
#, no-c-format
msgid "These are the four standard JPA generators. Hibernate goes beyond that and provide additional generators or additional options as we will see below. You can also write your own custom identifier generator by implementing <classname>org.hibernate.id.IdentifierGenerator</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:916
#, no-c-format
msgid "To define a custom generator, use the <classname>@GenericGenerator</classname> annotation (and its plural counter part <classname>@GenericGenerators</classname>) that describes the class of the identifier generator or its short cut name (as described below) and a list of key/value parameters. When using <classname>@GenericGenerator</classname> and assigning it via <classname>@GeneratedValue.generator</classname>, the <classname>@GeneratedValue.strategy</classname> is ignored: leave it blank."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:926
#, no-c-format
msgid ""
      "@Id @GeneratedValue(generator=\"system-uuid\")\n"
      "@GenericGenerator(name=\"system-uuid\", strategy = \"uuid\")\n"
      "public String getId() {\n"
      "\n"
      "@Id @GeneratedValue(generator=\"trigger-generated\")\n"
      "@GenericGenerator(\n"
      "    name=\"trigger-generated\", \n"
      "    strategy = \"select\",\n"
      "    parameters = @Parameter(name=\"key\", value = \"socialSecurityNumber\")\n"
      ")\n"
      "public String getId() {"
msgstr ""

#. Tag: para
#: basic_mapping.xml:928
#, no-c-format
msgid "The hbm.xml approach uses the optional <literal>&lt;generator&gt;</literal> child element inside <literal>&lt;id&gt;</literal>. If any parameters are required to configure or initialize the generator instance, they are passed using the <literal>&lt;param&gt;</literal> element."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:934
#, no-c-format
msgid ""
      "&lt;id name=\"id\" type=\"long\" column=\"cat_id\"&gt;\n"
      "        &lt;generator class=\"org.hibernate.id.TableHiLoGenerator\"&gt;\n"
      "                &lt;param name=\"table\"&gt;uid_table&lt;/param&gt;\n"
      "                &lt;param name=\"column\"&gt;next_hi_value_column&lt;/param&gt;\n"
      "        &lt;/generator&gt;\n"
      "&lt;/id&gt;"
msgstr ""

#. Tag: title
#: basic_mapping.xml:937
#, no-c-format
msgid "Various additional generators"
msgstr ""

#. Tag: para
#: basic_mapping.xml:939
#, no-c-format
msgid "All generators implement the interface <literal>org.hibernate.id.IdentifierGenerator</literal>. This is a very simple interface. Some applications can choose to provide their own specialized implementations, however, Hibernate provides a range of built-in implementations. The shortcut names for the built-in generators are as follows:"
msgstr ""

#. Tag: literal
#: basic_mapping.xml:946
#, no-c-format
msgid "increment"
msgstr ""

#. Tag: para
#: basic_mapping.xml:949
#, no-c-format
msgid "generates identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal> that are unique only when no other process is inserting data into the same table. <emphasis>Do not use in a cluster.</emphasis>"
msgstr ""

#. Tag: literal
#: basic_mapping.xml:958
#, no-c-format
msgid "identity"
msgstr ""

#. Tag: para
#: basic_mapping.xml:961
#, no-c-format
msgid "supports identity columns in DB2, MySQL, MS SQL Server, Sybase and HypersonicSQL. The returned identifier is of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:969
#, no-c-format
msgid "sequence"
msgstr ""

#. Tag: para
#: basic_mapping.xml:972
#, no-c-format
msgid "uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator in Interbase. The returned identifier is of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>"
msgstr ""

#. Tag: literal
#: basic_mapping.xml:980
#, no-c-format
msgid "hilo"
msgstr ""

#. Tag: para
#: basic_mapping.xml:984
#, no-c-format
msgid "uses a hi/lo algorithm to efficiently generate identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>, given a table and column (by default <literal>hibernate_unique_key</literal> and <literal>next_hi</literal> respectively) as a source of hi values. The hi/lo algorithm generates identifiers that are unique only for a particular database."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:996
#, no-c-format
msgid "seqhilo"
msgstr ""

#. Tag: para
#: basic_mapping.xml:999
#, no-c-format
msgid "uses a hi/lo algorithm to efficiently generate identifiers of type <literal>long</literal>, <literal>short</literal> or <literal>int</literal>, given a named database sequence."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1007
#, no-c-format
msgid "uuid"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1010
#, no-c-format
msgid "Generates a 128-bit UUID based on a custom algorithm. The value generated is represented as a string of 32 hexidecimal digits. Users can also configure it to use a separator (config parameter \"separator\") which separates the hexidecimal digits into 8{sep}8{sep}4{sep}8{sep}4. Note specifically that this is different than the IETF RFC 4122 representation of 8-4-4-4-12. If you need RFC 4122 compliant UUIDs, consider using \"uuid2\" generator discussed below."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1023
#, no-c-format
msgid "uuid2"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1026
#, no-c-format
msgid "Generates a IETF RFC 4122 compliant (variant 2) 128-bit UUID. The exact \"version\" (the RFC term) generated depends on the pluggable \"generation strategy\" used (see below). Capable of generating values as <classname>java.util.UUID</classname>, <classname>java.lang.String</classname> or as a byte array of length 16 (<literal>byte[16]</literal>). The \"generation strategy\" is defined by the interface <interfacename>org.hibernate.id.UUIDGenerationStrategy</interfacename>. The generator defines 2 configuration parameters for defining which generation strategy to use:"
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1038
#, no-c-format
msgid "uuid_gen_strategy_class"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1041
#, no-c-format
msgid "Names the UUIDGenerationStrategy class to use"
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1047
#, no-c-format
msgid "uuid_gen_strategy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1050
#, no-c-format
msgid "Names the UUIDGenerationStrategy instance to use"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1056
#, no-c-format
msgid "Out of the box, comes with the following strategies:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1059
#, no-c-format
msgid "<classname>org.hibernate.id.uuid.StandardRandomStrategy</classname> (the default) - generates \"version 3\" (aka, \"random\") UUID values via the <methodname>randomUUID</methodname> method of <classname>java.util.UUID</classname>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1067
#, no-c-format
msgid "<classname>org.hibernate.id.uuid.CustomVersionOneStrategy</classname> - generates \"version 1\" UUID values, using IP address since mac address not available. If you need mac address to be used, consider leveraging one of the existing third party UUID generators which sniff out mac address and integrating it via the <interfacename>org.hibernate.id.UUIDGenerationStrategy</interfacename> contract. Two such libraries known at time of this writing include <ulink url=\"http://johannburkard.de/software/uuid/\">http://johannburkard.de/software/uuid/</ulink> and <ulink url=\"http://commons.apache.org/sandbox/id/uuid.html\">http://commons.apache.org/sandbox/id/uuid.html</ulink>"
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1085
#, no-c-format
msgid "guid"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1088
#, no-c-format
msgid "uses a database-generated GUID string on MS SQL Server and MySQL."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1094
#, no-c-format
msgid "native"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1097
#, no-c-format
msgid "selects <literal>identity</literal>, <literal>sequence</literal> or <literal>hilo</literal> depending upon the capabilities of the underlying database."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1105
#, no-c-format
msgid "assigned"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1108
#, no-c-format
msgid "lets the application assign an identifier to the object before <literal>save()</literal> is called. This is the default strategy if no <literal>&lt;generator&gt;</literal> element is specified."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1117
#, no-c-format
msgid "select"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1120
#, no-c-format
msgid "retrieves a primary key, assigned by a database trigger, by selecting the row by some unique key and retrieving the primary key value."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1127
#, no-c-format
msgid "foreign"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1130
#, no-c-format
msgid "uses the identifier of another associated object. It is usually used in conjunction with a <literal>&lt;one-to-one&gt;</literal> primary key association."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1138
#, no-c-format
msgid "sequence-identity"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1141
#, no-c-format
msgid "a specialized sequence generation strategy that utilizes a database sequence for the actual value generation, but combines this with JDBC3 getGeneratedKeys to return the generated identifier value as part of the insert statement execution. This strategy is only supported on Oracle 10g drivers targeted for JDK 1.4. Comments on these insert statements are disabled due to a bug in the Oracle drivers."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1155
#, no-c-format
msgid "Hi/lo algorithm"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1157
#, no-c-format
msgid "The <literal>hilo</literal> and <literal>seqhilo</literal> generators provide two alternate implementations of the hi/lo algorithm. The first implementation requires a \"special\" database table to hold the next available \"hi\" value. Where supported, the second uses an Oracle-style sequence."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1163
#, no-c-format
msgid ""
      "&lt;id name=\"id\" type=\"long\" column=\"cat_id\"&gt;\n"
      "        &lt;generator class=\"hilo\"&gt;\n"
      "                &lt;param name=\"table\"&gt;hi_value&lt;/param&gt;\n"
      "                &lt;param name=\"column\"&gt;next_value&lt;/param&gt;\n"
      "                &lt;param name=\"max_lo\"&gt;100&lt;/param&gt;\n"
      "        &lt;/generator&gt;\n"
      "&lt;/id&gt;"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1165
#, no-c-format
msgid ""
      "&lt;id name=\"id\" type=\"long\" column=\"cat_id\"&gt;\n"
      "        &lt;generator class=\"seqhilo\"&gt;\n"
      "                &lt;param name=\"sequence\"&gt;hi_value&lt;/param&gt;\n"
      "                &lt;param name=\"max_lo\"&gt;100&lt;/param&gt;\n"
      "        &lt;/generator&gt;\n"
      "&lt;/id&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1167
#, no-c-format
msgid "Unfortunately, you cannot use <literal>hilo</literal> when supplying your own <literal>Connection</literal> to Hibernate. When Hibernate uses an application server datasource to obtain connections enlisted with JTA, you must configure the <literal>hibernate.transaction.manager_lookup_class</literal>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1175
#, no-c-format
msgid "UUID algorithm"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1177
#, no-c-format
msgid "The UUID contains: IP address, startup time of the JVM that is accurate to a quarter second, system time and a counter value that is unique within the JVM. It is not possible to obtain a MAC address or memory address from Java code, so this is the best option without using JNI."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1185
#, no-c-format
msgid "Identity columns and sequences"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1187
#, no-c-format
msgid "For databases that support identity columns (DB2, MySQL, Sybase, MS SQL), you can use <literal>identity</literal> key generation. For databases that support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you can use <literal>sequence</literal> style key generation. Both of these strategies require two SQL queries to insert a new object. For example:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1195
#, no-c-format
msgid ""
      "&lt;id name=\"id\" type=\"long\" column=\"person_id\"&gt;\n"
      "        &lt;generator class=\"sequence\"&gt;\n"
      "                &lt;param name=\"sequence\"&gt;person_id_sequence&lt;/param&gt;\n"
      "        &lt;/generator&gt;\n"
      "&lt;/id&gt;"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1197
#, no-c-format
msgid ""
      "&lt;id name=\"id\" type=\"long\" column=\"person_id\" unsaved-value=\"0\"&gt;\n"
      "        &lt;generator class=\"identity\"/&gt;\n"
      "&lt;/id&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1199
#, no-c-format
msgid "For cross-platform development, the <literal>native</literal> strategy will, depending on the capabilities of the underlying database, choose from the <literal>identity</literal>, <literal>sequence</literal> and <literal>hilo</literal> strategies."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1207
#, no-c-format
msgid "Assigned identifiers"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1209
#, no-c-format
msgid "If you want the application to assign identifiers, as opposed to having Hibernate generate them, you can use the <literal>assigned</literal> generator. This special generator uses the identifier value already assigned to the object's identifier property. The generator is used when the primary key is a natural key instead of a surrogate key. This is the default behavior if you do not specify <classname>@GeneratedValue</classname> nor <literal>&lt;generator&gt;</literal> elements."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1218
#, no-c-format
msgid "The <literal>assigned</literal> generator makes Hibernate use <literal>unsaved-value=\"undefined\"</literal>. This forces Hibernate to go to the database to determine if an instance is transient or detached, unless there is a version or timestamp property, or you define <literal>Interceptor.isUnsaved()</literal>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1226
#, no-c-format
msgid "Primary keys assigned by triggers"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1228
#, no-c-format
msgid "Hibernate does not generate DDL with triggers. It is for legacy schemas only."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1231
#, no-c-format
msgid ""
      "&lt;id name=\"id\" type=\"long\" column=\"person_id\"&gt;\n"
      "        &lt;generator class=\"select\"&gt;\n"
      "                &lt;param name=\"key\"&gt;socialSecurityNumber&lt;/param&gt;\n"
      "        &lt;/generator&gt;\n"
      "&lt;/id&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1233
#, no-c-format
msgid "In the above example, there is a unique valued property named <literal>socialSecurityNumber</literal>. It is defined by the class, as a natural key and a surrogate key named <literal>person_id</literal>, whose value is generated by a trigger."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1241
#, no-c-format
msgid "Identity copy (foreign generator)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1243
#, no-c-format
msgid "Finally, you can ask Hibernate to copy the identifier from another associated entity. In the Hibernate jargon, it is known as a foreign generator but the JPA mapping reads better and is encouraged."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1248
#, no-c-format
msgid ""
      "@Entity\n"
      "class MedicalHistory implements Serializable {\n"
      "  @Id @OneToOne\n"
      "  @JoinColumn(name = \"person_id\")\n"
      "  Person patient;\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Person implements Serializable {\n"
      "  @Id @GeneratedValue Integer id;\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1250
#, no-c-format
msgid "Or alternatively"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1252
#, no-c-format
msgid ""
      "@Entity\n"
      "class MedicalHistory implements Serializable {\n"
      "  @Id Integer id;\n"
      "\n"
      "  @MapsId @OneToOne\n"
      "  @JoinColumn(name = \"patient_id\")\n"
      "  Person patient;\n"
      "}\n"
      "\n"
      "@Entity\n"
      "class Person {\n"
      "  @Id @GeneratedValue Integer id;\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1254
#, no-c-format
msgid "In hbm.xml use the following approach:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1256
#, no-c-format
msgid ""
      "&lt;class name=\"MedicalHistory\"&gt;\n"
      "   &lt;id name=\"id\"&gt;\n"
      "      &lt;generator class=\"foreign\"&gt;\n"
      "         &lt;param name=\"property\"&gt;patient&lt;/param&gt;\n"
      "      &lt;/generator&gt;\n"
      "   &lt;/id&gt;\n"
      "   &lt;one-to-one name=\"patient\" class=\"Person\" constrained=\"true\"/&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: title
#: basic_mapping.xml:1261
#, no-c-format
msgid "Enhanced identifier generators"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1263
#, no-c-format
msgid "Starting with release 3.2.3, there are 2 new generators which represent a re-thinking of 2 different aspects of identifier generation. The first aspect is database portability; the second is optimization Optimization means that you do not have to query the database for every request for a new identifier value. These two new generators are intended to take the place of some of the named generators described above, starting in 3.3.x. However, they are included in the current releases and can be referenced by FQN."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1272
#, no-c-format
msgid "The first of these new generators is <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal> which is intended, firstly, as a replacement for the <literal>sequence</literal> generator and, secondly, as a better portability generator than <literal>native</literal>. This is because <literal>native</literal> generally chooses between <literal>identity</literal> and <literal>sequence</literal> which have largely different semantics that can cause subtle issues in applications eyeing portability. <literal>org.hibernate.id.enhanced.SequenceStyleGenerator</literal>, however, achieves portability in a different manner. It chooses between a table or a sequence in the database to store its incrementing values, depending on the capabilities of the dialect being used. The difference between this and <literal>native</literal> is that table-based and sequence-based storage have the same exact semantic. In fact, sequences are exactly what Hibernate tries to emulate with its table-based generators. This generator has a number of configuration parameters:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1291
#, no-c-format
msgid "<literal>sequence_name</literal> (optional, defaults to <literal>hibernate_sequence</literal>): the name of the sequence or table to be used."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1297
#, no-c-format
msgid "<literal>initial_value</literal> (optional, defaults to <literal>1</literal>): the initial value to be retrieved from the sequence/table. In sequence creation terms, this is analogous to the clause typically named \"STARTS WITH\"."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1304
#, no-c-format
msgid "<literal>increment_size</literal> (optional - defaults to <literal>1</literal>): the value by which subsequent calls to the sequence/table should differ. In sequence creation terms, this is analogous to the clause typically named \"INCREMENT BY\"."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1312
#, no-c-format
msgid "<literal>force_table_use</literal> (optional - defaults to <literal>false</literal>): should we force the use of a table as the backing structure even though the dialect might support sequence?"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1319
#, no-c-format
msgid "<literal>value_column</literal> (optional - defaults to <literal>next_val</literal>): only relevant for table structures, it is the name of the column on the table which is used to hold the value."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1326
#, no-c-format
msgid "<literal>optimizer</literal> (optional - defaults to <literal>none</literal>): See"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1332
#, no-c-format
msgid "The second of these new generators is <literal>org.hibernate.id.enhanced.TableGenerator</literal>, which is intended, firstly, as a replacement for the <literal>table</literal> generator, even though it actually functions much more like <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal>, and secondly, as a re-implementation of <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> that utilizes the notion of pluggable optimizers. Essentially this generator defines a table capable of holding a number of different increment values simultaneously by using multiple distinctly keyed rows. This generator has a number of configuration parameters:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1345
#, no-c-format
msgid "<literal>table_name</literal> (optional - defaults to <literal>hibernate_sequences</literal>): the name of the table to be used."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1351
#, no-c-format
msgid "<literal>value_column_name</literal> (optional - defaults to <literal>next_val</literal>): the name of the column on the table that is used to hold the value."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1357
#, no-c-format
msgid "<literal>segment_column_name</literal> (optional - defaults to <literal>sequence_name</literal>): the name of the column on the table that is used to hold the \"segment key\". This is the value which identifies which increment value to use."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1365
#, no-c-format
msgid "<literal>segment_value</literal> (optional - defaults to <literal>default</literal>): The \"segment key\" value for the segment from which we want to pull increment values for this generator."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1372
#, no-c-format
msgid "<literal>segment_value_length</literal> (optional - defaults to <literal>255</literal>): Used for schema generation; the column size to create this segment key column."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1378
#, no-c-format
msgid "<literal>initial_value</literal> (optional - defaults to <literal>1</literal>): The initial value to be retrieved from the table."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1384
#, no-c-format
msgid "<literal>increment_size</literal> (optional - defaults to <literal>1</literal>): The value by which subsequent calls to the table should differ."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1390
#, no-c-format
msgid "<literal>optimizer</literal> (optional - defaults to <literal>??</literal>): See <xref linkend=\"mapping-declaration-id-enhanced-optimizers\"/>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1397
#, no-c-format
msgid "Identifier generator optimization"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1399
#, no-c-format
msgid "For identifier generators that store values in the database, it is inefficient for them to hit the database on each and every call to generate a new identifier value. Instead, you can group a bunch of them in memory and only hit the database when you have exhausted your in-memory value group. This is the role of the pluggable optimizers. Currently only the two enhanced generators (<xref linkend=\"mapping-declaration-id-enhanced\"/> support this operation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1410
#, no-c-format
msgid "<literal>none</literal> (generally this is the default if no optimizer was specified): this will not perform any optimizations and hit the database for each and every request."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1417
#, no-c-format
msgid "<literal>hilo</literal>: applies a hi/lo algorithm around the database retrieved values. The values from the database for this optimizer are expected to be sequential. The values retrieved from the database structure for this optimizer indicates the \"group number\". The <literal>increment_size</literal> is multiplied by that value in memory to define a group \"hi value\"."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1427
#, no-c-format
msgid "<literal>pooled</literal>: as with the case of <literal>hilo</literal>, this optimizer attempts to minimize the number of hits to the database. Here, however, we simply store the starting value for the \"next group\" into the database structure rather than a sequential value in combination with an in-memory grouping algorithm. Here, <literal>increment_size</literal> refers to the values coming from the database."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1441
#, no-c-format
msgid "Partial identifier generation"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1443
#, no-c-format
msgid "Hibernate supports the automatic generation of some of the identifier properties. Simply use the <classname>@GeneratedValue</classname> annotation on one or several id properties."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1449
#, no-c-format
msgid "The Hibernate team has always felt such a construct as fundamentally wrong. Try hard to fix your data model before using this feature."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1454
#, no-c-format
msgid ""
      "@Entity\n"
      "public class CustomerInventory implements Serializable {\n"
      "  @Id\n"
      "  @TableGenerator(name = \"inventory\",\n"
      "    table = \"U_SEQUENCES\",\n"
      "    pkColumnName = \"S_ID\",\n"
      "    valueColumnName = \"S_NEXTNUM\",\n"
      "    pkColumnValue = \"inventory\",\n"
      "    allocationSize = 1000)\n"
      "  @GeneratedValue(strategy = GenerationType.TABLE, generator = \"inventory\")\n"
      "  Integer id;\n"
      "\n"
      "\n"
      "  @Id @ManyToOne(cascade = CascadeType.MERGE)\n"
      "  Customer customer;\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class Customer implements Serializable {\n"
      "   @Id\n"
      "   private int id;\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1456
#, no-c-format
msgid "You can also generate properties inside an <classname>@EmbeddedId</classname> class."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1462
#, no-c-format
msgid "Optimistic locking properties (optional)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1464
#, no-c-format
msgid "When using long transactions or conversations that span several database transactions, it is useful to store versioning data to ensure that if the same entity is updated by two conversations, the last to commit changes will be informed and not override the other conversation's work. It guarantees some isolation while still allowing for good scalability and works particularly well in read-often write-sometimes situations."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1472
#, no-c-format
msgid "You can use two approaches: a dedicated version number or a timestamp."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1475
#, no-c-format
msgid "A version or timestamp property should never be null for a detached instance. Hibernate will detect any instance with a null version or timestamp as transient, irrespective of what other <literal>unsaved-value</literal> strategies are specified. <emphasis>Declaring a nullable version or timestamp property is an easy way to avoid problems with transitive reattachment in Hibernate. It is especially useful for people using assigned identifiers or composite keys</emphasis>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1485
#, no-c-format
msgid "Version number"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1487
#, no-c-format
msgid "You can add optimistic locking capability to an entity using the <literal>@Version</literal> annotation:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1490
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Flight implements Serializable {\n"
      "...\n"
      "    @Version\n"
      "    @Column(name=\"OPTLOCK\")\n"
      "    public Integer getVersion() { ... }\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1492
#, no-c-format
msgid "The version property will be mapped to the <literal>OPTLOCK</literal> column, and the entity manager will use it to detect conflicting updates (preventing lost updates you might otherwise see with the last-commit-wins strategy)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1497
#, no-c-format
msgid "The version column may be a numeric. Hibernate supports any kind of type provided that you define and implement the appropriate <classname>UserVersionType</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1501
#, no-c-format
msgid "The application must not alter the version number set up by Hibernate in any way. To artificially increase the version number, check in Hibernate Entity Manager's reference documentation <literal>LockModeType.OPTIMISTIC_FORCE_INCREMENT</literal> or <literal>LockModeType.PESSIMISTIC_FORCE_INCREMENT</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1507
#, no-c-format
msgid "If the version number is generated by the database (via a trigger for example), make sure to use <code>@org.hibernate.annotations.Generated(GenerationTime.ALWAYS).</code>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1511
#, no-c-format
msgid "To declare a version property in hbm.xml, use:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1530
#, no-c-format
msgid ""
      "&lt;version\n"
      "        column=\"version_column\"\n"
      "        name=\"propertyName\"\n"
      "        type=\"typename\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        unsaved-value=\"null|negative|undefined\"\n"
      "        generated=\"never|always\"\n"
      "        insert=\"true|false\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1534
#, no-c-format
msgid "<literal>column</literal> (optional - defaults to the property name): the name of the column holding the version number."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1540
#, no-c-format
msgid "<literal>name</literal>: the name of a property of the persistent class."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1545
#, no-c-format
msgid "<literal>type</literal> (optional - defaults to <literal>integer</literal>): the type of the version number."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1551
#, no-c-format
msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): the strategy Hibernate uses to access the property value."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1557
#, no-c-format
msgid "<literal>unsaved-value</literal> (optional - defaults to <literal>undefined</literal>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <literal>Undefined</literal> specifies that the identifier property value should be used."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1567
#, no-c-format
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): specifies that this version property value is generated by the database. See the discussion of <link linkend=\"mapping-generated\">generated properties</link> for more information."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1575
#, no-c-format
msgid "<literal>insert</literal> (optional - defaults to <literal>true</literal>): specifies whether the version column should be included in SQL insert statements. It can be set to <literal>false</literal> if the database column is defined with a default value of <literal>0</literal>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1586
#, no-c-format
msgid "Timestamp"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1588
#, no-c-format
msgid "Alternatively, you can use a timestamp. Timestamps are a less safe implementation of optimistic locking. However, sometimes an application might use the timestamps in other ways as well."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1592
#, no-c-format
msgid "Simply mark a property of type <classname>Date</classname> or <classname>Calendar</classname> as <classname>@Version</classname>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1596
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Flight implements Serializable {\n"
      "...\n"
      "    @Version\n"
      "    public Date getLastUpdate() { ... }\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1598
#, no-c-format
msgid "When using timestamp versioning you can tell Hibernate where to retrieve the timestamp value from - database or JVM - by optionally adding the <classname>@org.hibernate.annotations.Source</classname> annotation to the property. Possible values for the value attribute of the annotation are <classname>org.hibernate.annotations.SourceType.VM</classname> and <classname>org.hibernate.annotations.SourceType.DB</classname>. The default is <classname>SourceType.DB</classname> which is also used in case there is no <classname>@Source</classname> annotation at all."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1609
#, no-c-format
msgid "Like in the case of version numbers, the timestamp can also be generated by the database instead of Hibernate. To do that, use <code>@org.hibernate.annotations.Generated(GenerationTime.ALWAYS).</code>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1613
#, no-c-format
msgid "In hbm.xml, use the <literal>&lt;timestamp&gt;</literal> element:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1631
#, no-c-format
msgid ""
      "&lt;timestamp\n"
      "        column=\"timestamp_column\"\n"
      "        name=\"propertyName\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        unsaved-value=\"null|undefined\"\n"
      "        source=\"vm|db\"\n"
      "        generated=\"never|always\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1635
#, no-c-format
msgid "<literal>column</literal> (optional - defaults to the property name): the name of a column holding the timestamp."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1641
#, no-c-format
msgid "<literal>name</literal>: the name of a JavaBeans style property of Java type <literal>Date</literal> or <literal>Timestamp</literal> of the persistent class."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1647 basic_mapping.xml:2174 basic_mapping.xml:2391 basic_mapping.xml:3262 basic_mapping.xml:3456 basic_mapping.xml:3629
#, no-c-format
msgid "<literal>access</literal> (optional - defaults to <literal>property</literal>): the strategy Hibernate uses for accessing the property value."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1653
#, no-c-format
msgid "<literal>unsaved-value</literal> (optional - defaults to <literal>null</literal>): a version property value that indicates that an instance is newly instantiated (unsaved), distinguishing it from detached instances that were saved or loaded in a previous session. <literal>Undefined</literal> specifies that the identifier property value should be used."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1663
#, no-c-format
msgid "<literal>source</literal> (optional - defaults to <literal>vm</literal>): Where should Hibernate retrieve the timestamp value from? From the database, or from the current JVM? Database-based timestamps incur an overhead because Hibernate must hit the database in order to determine the \"next value\". It is safer to use in clustered environments. Not all <literal>Dialects</literal> are known to support the retrieval of the database's current timestamp. Others may also be unsafe for usage in locking due to lack of precision (Oracle 8, for example)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1676
#, no-c-format
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): specifies that this timestamp property value is actually generated by the database. See the discussion of <link linkend=\"mapping-generated\">generated properties</link> for more information."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1686
#, no-c-format
msgid "Note"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1688
#, no-c-format
msgid "<literal>&lt;Timestamp&gt;</literal> is equivalent to <literal>&lt;version type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source=\"db\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp\"&gt;</literal>"
msgstr ""

#. Tag: title
#: basic_mapping.xml:1697
#, no-c-format
msgid "Property"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1699
#, no-c-format
msgid "You need to decide which property needs to be made persistent in a given entity. This differs slightly between the annotation driven metadata and the hbm.xml files."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1704
#, no-c-format
msgid "Property mapping with annotations"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1706
#, no-c-format
msgid "In the annotations world, every non static non transient property (field or method depending on the access type) of an entity is considered persistent, unless you annotate it as <literal>@Transient</literal>. Not having an annotation for your property is equivalent to the appropriate <literal>@Basic</literal> annotation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1713
#, no-c-format
msgid "The <literal>@Basic</literal> annotation allows you to declare the fetching strategy for a property. If set to <literal>LAZY</literal>, specifies that this property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation, if your classes are not instrumented, property level lazy loading is silently ignored. The default is <literal>EAGER</literal>. You can also mark a property as not optional thanks to the <classname>@Basic.optional</classname> attribute. This will ensure that the underlying column are not nullable (if possible). Note that a better approach is to use the <classname>@NotNull</classname> annotation of the Bean Validation specification."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1726
#, no-c-format
msgid "Let's look at a few examples:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1728
#, no-c-format
msgid ""
      "public transient int counter; //transient property\n"
      "\n"
      "private String firstname; //persistent property\n"
      "\n"
      "@Transient\n"
      "String getLengthInMeter() { ... } //transient property\n"
      "\n"
      "String getName() {... } // persistent property\n"
      "\n"
      "@Basic\n"
      "int getLength() { ... } // persistent property\n"
      "\n"
      "@Basic(fetch = FetchType.LAZY)\n"
      "String getDetailedComment() { ... } // persistent property\n"
      "\n"
      "@Temporal(TemporalType.TIME)\n"
      "java.util.Date getDepartureTime() { ... } // persistent property           \n"
      "\n"
      "@Enumerated(EnumType.STRING)\n"
      "Starred getNote() { ... } //enum persisted as String in database"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1730
#, no-c-format
msgid "<literal>counter</literal>, a transient field, and <literal>lengthInMeter</literal>, a method annotated as <literal>@Transient</literal>, and will be ignored by the Hibernate. <literal>name</literal>, <literal>length</literal>, and <literal>firstname</literal> properties are mapped persistent and eagerly fetched (the default for simple properties). The <literal>detailedComment</literal> property value will be lazily fetched from the database once a lazy property of the entity is accessed for the first time. Usually you don't need to lazy simple properties (not to be confused with lazy association fetching). The recommended alternative is to use the projection capability of JP-QL (Java Persistence Query Language) or Criteria queries."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1743
#, no-c-format
msgid "JPA support property mapping of all basic types supported by Hibernate (all basic Java types , their respective wrappers and serializable classes). Hibernate Annotations supports out of the box enum type mapping either into a ordinal column (saving the enum ordinal) or a string based column (saving the enum string representation): the persistence representation, defaulted to ordinal, can be overridden through the <literal>@Enumerated</literal> annotation as shown in the <literal>note</literal> property example."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1753
#, no-c-format
msgid "In plain Java APIs, the temporal precision of time is not defined. When dealing with temporal data you might want to describe the expected precision in database. Temporal data can have <literal>DATE</literal>, <literal>TIME</literal>, or <literal>TIMESTAMP</literal> precision (ie the actual date, only the time, or both). Use the <literal>@Temporal</literal> annotation to fine tune that."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1761
#, no-c-format
msgid "<literal>@Lob</literal> indicates that the property should be persisted in a Blob or a Clob depending on the property type: <classname>java.sql.Clob</classname>, <classname>Character[]</classname>, <classname>char[]</classname> and java.lang.<classname>String</classname> will be persisted in a Clob. <classname>java.sql.Blob</classname>, <classname>Byte[]</classname>, <classname>byte[] </classname>and <classname>Serializable</classname> type will be persisted in a Blob."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1770
#, no-c-format
msgid ""
      "@Lob\n"
      "public String getFullText() {\n"
      "    return fullText;\n"
      "}\n"
      "\n"
      "@Lob\n"
      "public byte[] getFullCode() {\n"
      "    return fullCode;\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1772
#, no-c-format
msgid "If the property type implements <classname>java.io.Serializable</classname> and is not a basic type, and if the property is not annotated with <literal>@Lob</literal>, then the Hibernate <literal>serializable</literal> type is used."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1779
#, no-c-format
msgid "Type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1781
#, no-c-format
msgid "You can also manually specify a type using the <literal>@org.hibernate.annotations.Type</literal> and some parameters if needed. <classname>@Type.type</classname> could be:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1788 basic_mapping.xml:2220
#, no-c-format
msgid "The name of a Hibernate basic type: <literal>integer, string, character, date, timestamp, float, binary, serializable, object, blob</literal> etc."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1794 basic_mapping.xml:2226
#, no-c-format
msgid "The name of a Java class with a default basic type: <literal>int, float, char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</literal> etc."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1800 basic_mapping.xml:2232
#, no-c-format
msgid "The name of a serializable Java class."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1804 basic_mapping.xml:2236
#, no-c-format
msgid "The class name of a custom type: <literal>com.illflow.type.MyCustomType</literal> etc."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1809
#, no-c-format
msgid "If you do not specify a type, Hibernate will use reflection upon the named property and guess the correct Hibernate type. Hibernate will attempt to interpret the name of the return class of the property getter using, in order, rules 2, 3, and 4."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1814
#, no-c-format
msgid "<literal>@org.hibernate.annotations.TypeDef</literal> and <literal>@org.hibernate.annotations.TypeDefs</literal> allows you to declare type definitions. These annotations can be placed at the class or package level. Note that these definitions are global for the session factory (even when defined at the class level). If the type is used on a single entity, you can place the definition on the entity itself. Otherwise, it is recommended to place the definition at the package level. In the example below, when Hibernate encounters a property of class <literal>PhoneNumer</literal>, it delegates the persistence strategy to the custom mapping type <literal>PhoneNumberType</literal>. However, properties belonging to other classes, too, can delegate their persistence strategy to <literal>PhoneNumberType</literal>, by explicitly using the <literal>@Type</literal> annotation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1830
#, no-c-format
msgid "Package level annotations are placed in a file named <filename>package-info.java</filename> in the appropriate package. Place your annotations before the package declaration."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1835
#, no-c-format
msgid ""
      "@TypeDef(\n"
      "   name = \"phoneNumber\",\n"
      "   defaultForType = PhoneNumber.class,\n"
      "   typeClass = PhoneNumberType.class\n"
      ")\n"
      "\n"
      "@Entity\n"
      "public class ContactDetails {\n"
      "   [...]\n"
      "   private PhoneNumber localPhoneNumber;\n"
      "   @Type(type=\"phoneNumber\")\n"
      "   private OverseasPhoneNumber overseasPhoneNumber;\n"
      "   [...]\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1837
#, no-c-format
msgid "The following example shows the usage of the <literal>parameters</literal> attribute to customize the TypeDef."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1841
#, no-c-format
msgid ""
      "//in org/hibernate/test/annotations/entity/package-info.java\n"
      "@TypeDefs(\n"
      "    {\n"
      "    @TypeDef(\n"
      "        name=\"caster\",\n"
      "        typeClass = CasterStringType.class,\n"
      "        parameters = {\n"
      "            @Parameter(name=\"cast\", value=\"lower\")\n"
      "        }\n"
      "    )\n"
      "    }\n"
      ")\n"
      "package org.hibernate.test.annotations.entity;\n"
      "\n"
      "//in org/hibernate/test/annotations/entity/Forest.java\n"
      "public class Forest {\n"
      "    @Type(type=\"caster\")\n"
      "    public String getSmallText() {\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1843
#, no-c-format
msgid "When using composite user type, you will have to express column definitions. The <literal>@Columns</literal> has been introduced for that purpose."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1847
#, no-c-format
msgid ""
      "@Type(type=\"org.hibernate.test.annotations.entity.MonetaryAmountUserType\")\n"
      "@Columns(columns = {\n"
      "    @Column(name=\"r_amount\"),\n"
      "    @Column(name=\"r_currency\")\n"
      "})\n"
      "public MonetaryAmount getAmount() {\n"
      "    return amount;\n"
      "}\n"
      "\n"
      "\n"
      "public class MonetaryAmount implements Serializable {\n"
      "    private BigDecimal amount;\n"
      "    private Currency currency;\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: title
#: basic_mapping.xml:1851
#, no-c-format
msgid "Access type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1853
#, no-c-format
msgid "By default the access type of a class hierarchy is defined by the position of the <classname>@Id</classname> or <classname>@EmbeddedId</classname> annotations. If these annotations are on a field, then only fields are considered for persistence and the state is accessed via the field. If there annotations are on a getter, then only the getters are considered for persistence and the state is accessed via the getter/setter. That works well in practice and is the recommended approach."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1861
#, no-c-format
msgid "The placement of annotations within a class hierarchy has to be consistent (either field or on property) to be able to determine the default access type. It is recommended to stick to one single annotation placement strategy throughout your whole application."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1868
#, no-c-format
msgid "However in some situations, you need to:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1872
#, no-c-format
msgid "force the access type of the entity hierarchy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1876
#, no-c-format
msgid "override the access type of a specific entity in the class hierarchy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1881
#, no-c-format
msgid "override the access type of an embeddable type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1885
#, no-c-format
msgid "The best use case is an embeddable class used by several entities that might not use the same access type. In this case it is better to force the access type at the embeddable class level."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1890
#, no-c-format
msgid "To force the access type on a given class, use the <classname>@Access</classname> annotation as showed below:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1893
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Order {\n"
      "   @Id private Long id;\n"
      "   public Long getId() { return id; }\n"
      "   public void setId(Long id) { this.id = id; }\n"
      "\n"
      "   @Embedded private Address address;\n"
      "   public Address getAddress() { return address; }\n"
      "   public void setAddress() { this.address = address; }\n"
      "}\n"
      "\n"
      "@Entity\n"
      "public class User {\n"
      "   private Long id;\n"
      "   @Id public Long getId() { return id; }\n"
      "   public void setId(Long id) { this.id = id; }\n"
      "\n"
      "   private Address address;\n"
      "   @Embedded public Address getAddress() { return address; }\n"
      "   public void setAddress() { this.address = address; }\n"
      "}\n"
      "\n"
      "@Embeddable\n"
      "@Access(AcessType.PROPERTY)\n"
      "public class Address {\n"
      "   private String street1;\n"
      "   public String getStreet1() { return street1; }\n"
      "   public void setStreet1() { this.street1 = street1; }\n"
      "\n"
      "   private hashCode; //not persistent\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1895
#, no-c-format
msgid "You can also override the access type of a single property while keeping the other properties standard."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1898
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Order {\n"
      "   @Id private Long id;\n"
      "   public Long getId() { return id; }\n"
      "   public void setId(Long id) { this.id = id; }\n"
      "   @Transient private String userId;\n"
      "   @Transient private String orderId;\n"
      "\n"
      "   @Access(AccessType.PROPERTY)\n"
      "   public String getOrderNumber() { return userId + \":\" + orderId; }\n"
      "   public void setOrderNumber() { this.userId = ...; this.orderId = ...; }\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1900
#, no-c-format
msgid "In this example, the default access type is <classname>FIELD</classname> except for the <literal>orderNumber</literal> property. Note that the corresponding field, if any must be marked as <classname>@Transient</classname> or <code>transient</code>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1907
#, no-c-format
msgid "@org.hibernate.annotations.AccessType"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1909
#, no-c-format
msgid "The annotation <classname>@org.hibernate.annotations.AccessType</classname> should be considered deprecated for FIELD and PROPERTY access. It is still useful however if you need to use a custom access type."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1918
#, no-c-format
msgid "Optimistic lock"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1920
#, no-c-format
msgid "It is sometimes useful to avoid increasing the version number even if a given property is dirty (particularly collections). You can do that by annotating the property (or collection) with <literal>@OptimisticLock(excluded=true)</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1925
#, no-c-format
msgid "More formally, specifies that updates to this property do not require acquisition of the optimistic lock."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1930
#, no-c-format
msgid "Declaring column attributes"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1932
#, no-c-format
msgid "The column(s) used for a property mapping can be defined using the <literal>@Column</literal> annotation. Use it to override default values (see the JPA specification for more information on the defaults). You can use this annotation at the property level for properties that are:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1940
#, no-c-format
msgid "not annotated at all"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1944
#, no-c-format
msgid "annotated with <literal>@Basic</literal>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1948
#, no-c-format
msgid "annotated with <literal>@Version</literal>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1952
#, no-c-format
msgid "annotated with <literal>@Lob</literal>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1956
#, no-c-format
msgid "annotated with <literal>@Temporal</literal>"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1960
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Flight implements Serializable {\n"
      "...\n"
      "@Column(updatable = false, name = \"flight_name\", nullable = false, length=50)\n"
      "public String getName() { ... }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1962
#, no-c-format
msgid "The <literal>name</literal> property is mapped to the <literal>flight_name</literal> column, which is not nullable, has a length of 50 and is not updatable (making the property immutable)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1967
#, no-c-format
msgid "This annotation can be applied to regular properties as well as <literal>@Id</literal> or <literal>@Version</literal> properties."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1994
#, no-c-format
msgid ""
      "@Column(\n"
      "    name=\"columnName\";\n"
      "    boolean unique() default false;\n"
      "    boolean nullable() default true;\n"
      "    boolean insertable() default true;\n"
      "    boolean updatable() default true;\n"
      "    String columnDefinition() default \"\";\n"
      "    String table() default \"\";\n"
      "    int length() default 255;\n"
      "    int precision() default 0; // decimal precision\n"
      "    int scale() default 0; // decimal scale"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1998
#, no-c-format
msgid "<literal>name</literal> (optional): the column name (default to the property name)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2003
#, no-c-format
msgid "<literal>unique</literal> (optional): set a unique constraint on this column or not (default false)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2008
#, no-c-format
msgid "<literal>nullable</literal> (optional): set the column as nullable (default true)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2013
#, no-c-format
msgid "<literal>insertable</literal> (optional): whether or not the column will be part of the insert statement (default true)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2019
#, no-c-format
msgid "<literal>updatable</literal> (optional): whether or not the column will be part of the update statement (default true)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2025
#, no-c-format
msgid "<literal>columnDefinition</literal> (optional): override the sql DDL fragment for this particular column (non portable)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2031
#, no-c-format
msgid "<literal>table</literal> (optional): define the targeted table (default primary table)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2036
#, no-c-format
msgid "<literal><literal>length</literal></literal> (optional): column length (default 255)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2041
#, no-c-format
msgid "<literal><literal>precision</literal></literal> (optional): column decimal precision (default 0)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2046
#, no-c-format
msgid "<literal><literal>scale</literal></literal> (optional): column decimal scale if useful (default 0)"
msgstr ""

#. Tag: title
#: basic_mapping.xml:2054
#, no-c-format
msgid "Formula"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2056
#, no-c-format
msgid "Sometimes, you want the Database to do some computation for you rather than in the JVM, you might also create some kind of virtual column. You can use a SQL fragment (aka formula) instead of mapping a property into a column. This kind of property is read only (its value is calculated by your formula fragment)."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2062
#, no-c-format
msgid ""
      "@Formula(\"obj_length * obj_height * obj_width\")\n"
      "public long getObjectVolume()"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2064
#, no-c-format
msgid "The SQL fragment can be as complex as you want and even include subselects."
msgstr ""

#. Tag: title
#: basic_mapping.xml:2069
#, no-c-format
msgid "Non-annotated property defaults"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2071
#, no-c-format
msgid "If a property is not annotated, the following rules apply:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2074
#, no-c-format
msgid "If the property is of a single type, it is mapped as @Basic"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2079
#, no-c-format
msgid "Otherwise, if the type of the property is annotated as @Embeddable, it is mapped as @Embedded"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2084
#, no-c-format
msgid "Otherwise, if the type of the property is <classname>Serializable</classname>, it is mapped as <classname>@Basic</classname> in a column holding the object in its serialized version"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2091
#, no-c-format
msgid "Otherwise, if the type of the property is <classname>java.sql.Clob</classname> or <classname>java.sql.Blob</classname>, it is mapped as <classname>@Lob</classname> with the appropriate <classname>LobType</classname>"
msgstr ""

#. Tag: title
#: basic_mapping.xml:2102
#, no-c-format
msgid "Property mapping with hbm.xml"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2104
#, no-c-format
msgid "The <literal>&lt;property&gt;</literal> element declares a persistent JavaBean style property of the class."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2136
#, no-c-format
msgid ""
      "&lt;property\n"
      "        name=\"propertyName\"\n"
      "        column=\"column_name\"\n"
      "        type=\"typename\"\n"
      "        update=\"true|false\"\n"
      "        insert=\"true|false\"\n"
      "        formula=\"arbitrary SQL expression\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        lazy=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        not-null=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        generated=\"never|insert|always\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "        index=\"index_name\"\n"
      "        unique_key=\"unique_key_id\"\n"
      "        length=\"L\"\n"
      "        precision=\"P\"\n"
      "        scale=\"S\"\n"
      "/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2140
#, no-c-format
msgid "<literal>name</literal>: the name of the property, with an initial lowercase letter."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2145
#, no-c-format
msgid "<literal>column</literal> (optional - defaults to the property name): the name of the mapped database table column. This can also be specified by nested <literal>&lt;column&gt;</literal> element(s)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2157
#, no-c-format
msgid "<literal>update, insert</literal> (optional - defaults to <literal>true</literal>): specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal> allows a pure \"derived\" property whose value is initialized from some other property that maps to the same column(s), or by a trigger or other application."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2167
#, no-c-format
msgid "<literal>formula</literal> (optional): an SQL expression that defines the value for a <emphasis>computed</emphasis> property. Computed properties do not have a column mapping of their own."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2180
#, no-c-format
msgid "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): specifies that this property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2187
#, no-c-format
msgid "<literal>unique</literal> (optional): enables the DDL generation of a unique constraint for the columns. Also, allow this to be the target of a <literal>property-ref</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2194
#, no-c-format
msgid "<literal>not-null</literal> (optional): enables the DDL generation of a nullability constraint for the columns."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2199 basic_mapping.xml:3282
#, no-c-format
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies that updates to this property do or do not require acquisition of the optimistic lock. In other words, it determines if a version increment should occur when this property is dirty."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2207
#, no-c-format
msgid "<literal>generated</literal> (optional - defaults to <literal>never</literal>): specifies that this property value is actually generated by the database. See the discussion of <link linkend=\"mapping-generated\">generated properties</link> for more information."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2216
#, no-c-format
msgid "<emphasis>typename</emphasis> could be:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2241
#, no-c-format
msgid "If you do not specify a type, Hibernate will use reflection upon the named property and guess the correct Hibernate type. Hibernate will attempt to interpret the name of the return class of the property getter using, in order, rules 2, 3, and 4. In certain cases you will need the <literal>type</literal> attribute. For example, to distinguish between <literal>Hibernate.DATE</literal> and <literal>Hibernate.TIMESTAMP</literal>, or to specify a custom type."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2250
#, no-c-format
msgid "The <literal>access</literal> attribute allows you to control how Hibernate accesses the property at runtime. By default, Hibernate will call the property get/set pair. If you specify <literal>access=\"field\"</literal>, Hibernate will bypass the get/set pair and access the field directly using reflection. You can specify your own strategy for property access by naming a class that implements the interface <literal>org.hibernate.property.access.spi.PropertyAccessStrategy</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2259
#, no-c-format
msgid "A powerful feature is derived properties. These properties are by definition read-only. The property value is computed at load time. You declare the computation as an SQL expression. This then translates to a <literal>SELECT</literal> clause subquery in the SQL query that loads an instance:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2265
#, no-c-format
msgid ""
      "&lt;property name=\"totalPrice\"\n"
      "    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product p\n"
      "                WHERE li.productId = p.productId\n"
      "                AND li.customerId = customerId\n"
      "                AND li.orderNumber = orderNumber )\"/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2267
#, no-c-format
msgid "You can reference the entity table by not declaring an alias on a particular column. This would be <literal>customerId</literal> in the given example. You can also use the nested <literal>&lt;formula&gt;</literal> mapping element if you do not want to use the attribute."
msgstr ""

#. Tag: title
#: basic_mapping.xml:2276
#, no-c-format
msgid "Embedded objects (aka components)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2278
#, no-c-format
msgid "Embeddable objects (or components) are objects whose properties are mapped to the same table as the owning entity's table. Components can, in turn, declare their own properties, components or collections"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2283
#, no-c-format
msgid "It is possible to declare an embedded component inside an entity and even override its column mapping. Component classes have to be annotated at the class level with the <literal>@Embeddable</literal> annotation. It is possible to override the column mapping of an embedded object for a particular entity using the <literal>@Embedded</literal> and <literal>@AttributeOverride</literal> annotation in the associated property:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2291
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Person implements Serializable {\n"
      "\n"
      "    // Persistent component using defaults\n"
      "    Address homeAddress;\n"
      "\n"
      "    @Embedded\n"
      "    @AttributeOverrides( {\n"
      "            @AttributeOverride(name=\"iso2\", column = @Column(name=\"bornIso2\") ),\n"
      "            @AttributeOverride(name=\"name\", column = @Column(name=\"bornCountryName\") )\n"
      "    } )\n"
      "    Country bornIn;\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2293
#, no-c-format
msgid ""
      "@Embeddable\n"
      "public class Address implements Serializable {\n"
      "    String city;\n"
      "    Country nationality; //no overriding here\n"
      "}"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2295
#, no-c-format
msgid ""
      "@Embeddable\n"
      "public class Country implements Serializable {\n"
      "    private String iso2;\n"
      "    @Column(name=\"countryName\") private String name;\n"
      "\n"
      "    public String getIso2() { return iso2; }\n"
      "    public void setIso2(String iso2) { this.iso2 = iso2; }\n"
      "\n"
      "    \n"
      "    public String getName() { return name; }\n"
      "    public void setName(String name) { this.name = name; }\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2297
#, no-c-format
msgid "An embeddable object inherits the access type of its owning entity (note that you can override that using the <literal>@Access</literal> annotation)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2301
#, no-c-format
msgid "The <literal>Person</literal> entity has two component properties, <literal>homeAddress</literal> and <literal>bornIn</literal>. <literal>homeAddress</literal> property has not been annotated, but Hibernate will guess that it is a persistent component by looking for the <literal>@Embeddable</literal> annotation in the Address class. We also override the mapping of a column name (to <literal>bornCountryName</literal>) with the <literal>@Embedded</literal> and <literal>@AttributeOverride </literal>annotations for each mapped attribute of <literal>Country</literal>. As you can see, <literal>Country </literal>is also a nested component of <literal>Address</literal>, again using auto-detection by Hibernate and JPA defaults. Overriding columns of embedded objects of embedded objects is through dotted expressions."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2316
#, no-c-format
msgid ""
      "@Embedded\n"
      "    @AttributeOverrides( {\n"
      "            @AttributeOverride(name=\"city\", column = @Column(name=\"fld_city\") ),\n"
      "            @AttributeOverride(name=\"nationality.iso2\", column = @Column(name=\"nat_Iso2\") ),\n"
      "            @AttributeOverride(name=\"nationality.name\", column = @Column(name=\"nat_CountryName\") )\n"
      "            //nationality columns in homeAddress are overridden\n"
      "    } )\n"
      "    Address homeAddress;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2318
#, no-c-format
msgid "Hibernate Annotations supports something that is not explicitly supported by the JPA specification. You can annotate a embedded object with the <literal>@MappedSuperclass</literal> annotation to make the superclass properties persistent (see <literal>@MappedSuperclass</literal> for more informations)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2324
#, no-c-format
msgid "You can also use association annotations in an embeddable object (ie <literal>@OneToOne</literal>, <classname>@ManyToOne</classname>, <classname>@OneToMany</classname> or <literal>@ManyToMany</literal>). To override the association columns you can use <literal>@AssociationOverride</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2330
#, no-c-format
msgid "If you want to have the same embeddable object type twice in the same entity, the column name defaulting will not work as several embedded objects would share the same set of columns. In plain JPA, you need to override at least one set of columns. Hibernate, however, allows you to enhance the default naming mechanism through the <classname>NamingStrategy</classname> interface. You can write a strategy that prevent name clashing in such a situation. <classname>DefaultComponentSafeNamingStrategy</classname> is an example of this."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2340
#, no-c-format
msgid "If a property of the embedded object points back to the owning entity, annotate it with the <classname>@Parent</classname> annotation. Hibernate will make sure this property is properly loaded with the entity reference."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2345
#, no-c-format
msgid "In XML, use the <literal>&lt;component&gt;</literal> element."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2367
#, no-c-format
msgid ""
      "&lt;component\n"
      "        name=\"propertyName\"\n"
      "        class=\"className\"\n"
      "        insert=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        lazy=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        node=\"element-name|.\"\n"
      "&gt;\n"
      "\n"
      "        &lt;property ...../&gt;\n"
      "        &lt;many-to-one .... /&gt;\n"
      "        ........\n"
      "&lt;/component&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2371 basic_mapping.xml:3217 basic_mapping.xml:3417
#, no-c-format
msgid "<literal>name</literal>: the name of the property."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2375
#, no-c-format
msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): the name of the component (child) class."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2381 basic_mapping.xml:3677
#, no-c-format
msgid "<literal>insert</literal>: do the mapped columns appear in SQL <literal>INSERTs</literal>?"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2386 basic_mapping.xml:3682
#, no-c-format
msgid "<literal>update</literal>: do the mapped columns appear in SQL <literal>UPDATEs</literal>?"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2397
#, no-c-format
msgid "<literal>lazy</literal> (optional - defaults to <literal>false</literal>): specifies that this component should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2404
#, no-c-format
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies that updates to this component either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when this property is dirty."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2412 basic_mapping.xml:3695
#, no-c-format
msgid "<literal>unique</literal> (optional - defaults to <literal>false</literal>): specifies that a unique constraint exists upon all mapped columns of the component."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2419
#, no-c-format
msgid "The child <literal>&lt;property&gt;</literal> tags map properties of the child class to table columns."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2422
#, no-c-format
msgid "The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;parent&gt;</literal> subelement that maps a property of the component class as a reference back to the containing entity."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2426
#, no-c-format
msgid "The <literal>&lt;dynamic-component&gt;</literal> element allows a <literal>Map</literal> to be mapped as a component, where the property names refer to keys of the map. See <xref linkend=\"components-dynamic\"/> for more information. This feature is not supported in annotations."
msgstr ""

#. Tag: title
#: basic_mapping.xml:2434
#, no-c-format
msgid "Inheritance strategy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2436
#, no-c-format
msgid "Java is a language supporting polymorphism: a class can inherit from another. Several strategies are possible to persist a class hierarchy:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2442
#, no-c-format
msgid "Single table per class hierarchy strategy: a single table hosts all the instances of a class hierarchy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2447
#, no-c-format
msgid "Joined subclass strategy: one table per class and subclass is present and each table persist the properties specific to a given subclass. The state of the entity is then stored in its corresponding class table and all its superclasses"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2454
#, no-c-format
msgid "Table per class strategy: one table per concrete class and subclass is present and each table persist the properties of the class and its superclasses. The state of the entity is then stored entirely in the dedicated table for its class."
msgstr ""

#. Tag: title
#: basic_mapping.xml:2462
#, no-c-format
msgid "Single table per class hierarchy strategy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2464
#, no-c-format
msgid "With this approach the properties of all the subclasses in a given mapped class hierarchy are stored in a single table."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2467
#, no-c-format
msgid "Each subclass declares its own persistent properties and subclasses. Version and id properties are assumed to be inherited from the root class. Each subclass in a hierarchy must define a unique discriminator value. If this is not specified, the fully qualified Java class name is used."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2473 basic_mapping.xml:2581
#, no-c-format
msgid ""
      "@Entity\n"
      "@Inheritance(strategy=InheritanceType.SINGLE_TABLE)\n"
      "@DiscriminatorColumn(\n"
      "    name=\"planetype\",\n"
      "    discriminatorType=DiscriminatorType.STRING\n"
      ")\n"
      "@DiscriminatorValue(\"Plane\")\n"
      "public class Plane { ... }\n"
      "\n"
      "@Entity\n"
      "@DiscriminatorValue(\"A320\")\n"
      "public class A320 extends Plane { ... }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2475
#, no-c-format
msgid "In hbm.xml, for the table-per-class-hierarchy mapping strategy, the <literal>&lt;subclass&gt;</literal> declaration is used. For example:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2490
#, no-c-format
msgid ""
      "&lt;subclass\n"
      "        name=\"ClassName\"\n"
      "        discriminator-value=\"discriminator_value\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        lazy=\"true|false\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\"\n"
      "        extends=\"SuperclassName\"&gt;\n"
      "\n"
      "        &lt;property .... /&gt;\n"
      "        .....\n"
      "&lt;/subclass&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2494 basic_mapping.xml:2692 basic_mapping.xml:2756
#, no-c-format
msgid "<literal>name</literal>: the fully qualified class name of the subclass."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2499
#, no-c-format
msgid "<literal>discriminator-value</literal> (optional - defaults to the class name): a value that distinguishes individual subclasses."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2505
#, no-c-format
msgid "<literal>proxy</literal> (optional): specifies a class or interface used for lazy initializing proxies."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2510
#, no-c-format
msgid "<literal>lazy</literal> (optional - defaults to <literal>true</literal>): setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2518 basic_mapping.xml:2721 basic_mapping.xml:2782
#, no-c-format
msgid "For information about inheritance mappings see <xref linkend=\"inheritance\"/>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:2522
#, no-c-format
msgid "Discriminator"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2524
#, no-c-format
msgid "Discriminators are required for polymorphic persistence using the table-per-class-hierarchy mapping strategy. It declares a discriminator column of the table. The discriminator column contains marker values that tell the persistence layer what subclass to instantiate for a particular row. Hibernate Core supports the follwoing restricted set of types as discriminator column: <literal>string</literal>, <literal>character</literal>, <literal>integer</literal>, <literal>byte</literal>, <literal>short</literal>, <literal>boolean</literal>, <literal>yes_no</literal>, <literal>true_false</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2535
#, no-c-format
msgid "Use the <classname>@DiscriminatorColumn</classname> to define the discriminator column as well as the discriminator type. <note> <para><classname>The enum DiscriminatorType</classname> used in <classname>javax.persitence.DiscriminatorColumn</classname> only contains the values <constant>STRING</constant>, <constant>CHAR</constant> and <constant>INTEGER</constant> which means that not all Hibernate supported types are available via the <classname>@DiscriminatorColumn</classname> annotation.</para> </note>You can also use <classname>@DiscriminatorFormula</classname> to express in SQL a virtual discriminator column. This is particularly useful when the discriminator value can be extracted from one or more columns of the table. Both <classname>@DiscriminatorColumn</classname> and <classname>@DiscriminatorFormula</classname> are to be set on the root entity (once per persisted hierarchy)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2552
#, no-c-format
msgid "<classname>@org.hibernate.annotations.DiscriminatorOptions</classname> allows to optionally specify Hibernate specific discriminator options which are not standardized in JPA. The available options are <literal>force</literal> and <literal>insert</literal>. The <literal>force</literal> attribute is useful if the table contains rows with \"extra\" discriminator values that are not mapped to a persistent class. This could for example occur when working with a legacy database. If <literal>force</literal> is set to <constant>true</constant> Hibernate will specify the allowed discriminator values in the <literal>SELECT</literal> query, even when retrieving all instances of the root class. The second option - <literal>insert</literal> - tells Hibernate whether or not to include the discriminator column in SQL <literal>INSERTs</literal>. Usually the column should be part of the <literal>INSERT</literal> statement, but if your discriminator column is also part of a mapped composite identifier you have to set this option to <constant>false</constant>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2569
#, no-c-format
msgid "There is also a <classname>@org.hibernate.annotations.ForceDiscriminator</classname> annotation which is deprecated since version 3.6. Use <classname>@DiscriminatorOptions</classname> instead."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2575
#, no-c-format
msgid "Finally, use <classname>@DiscriminatorValue</classname> on each class of the hierarchy to specify the value stored in the discriminator column for a given entity. If you do not set <classname>@DiscriminatorValue</classname> on a class, the fully qualified class name is used."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2583
#, no-c-format
msgid "In hbm.xml, the <literal>&lt;discriminator&gt;</literal> element is used to define the discriminator column or formula:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2600
#, no-c-format
msgid ""
      "&lt;discriminator\n"
      "        column=\"discriminator_column\"\n"
      "        type=\"discriminator_type\"\n"
      "        force=\"true|false\"\n"
      "        insert=\"true|false\"\n"
      "        formula=\"arbitrary sql expression\"\n"
      "/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2604
#, no-c-format
msgid "<literal>column</literal> (optional - defaults to <literal>class</literal>): the name of the discriminator column."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2610
#, no-c-format
msgid "<literal>type</literal> (optional - defaults to <literal>string</literal>): a name that indicates the Hibernate type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2616
#, no-c-format
msgid "<literal>force</literal> (optional - defaults to <literal>false</literal>): \"forces\" Hibernate to specify the allowed discriminator values, even when retrieving all instances of the root class."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2623
#, no-c-format
msgid "<literal>insert</literal> (optional - defaults to <literal>true</literal>): set this to <literal>false</literal> if your discriminator column is also part of a mapped composite identifier. It tells Hibernate not to include the column in SQL <literal>INSERTs</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2631
#, no-c-format
msgid "<literal>formula</literal> (optional): an arbitrary SQL expression that is executed when a type has to be evaluated. It allows content-based discrimination."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2638
#, no-c-format
msgid "Actual values of the discriminator column are specified by the <literal>discriminator-value</literal> attribute of the <literal>&lt;class&gt;</literal> and <literal>&lt;subclass&gt;</literal> elements."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2643
#, no-c-format
msgid "The <literal>formula</literal> attribute allows you to declare an arbitrary SQL expression that will be used to evaluate the type of a row. For example:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2647
#, no-c-format
msgid ""
      "&lt;discriminator\n"
      "    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
      "    type=\"integer\"/&gt;"
msgstr ""

#. Tag: title
#: basic_mapping.xml:2652
#, no-c-format
msgid "Joined subclass strategy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2654
#, no-c-format
msgid "Each subclass can also be mapped to its own table. This is called the table-per-subclass mapping strategy. An inherited state is retrieved by joining with the table of the superclass. A discriminator column is not required for this mapping strategy. Each subclass must, however, declare a table column holding the object identifier. The primary key of this table is also a foreign key to the superclass table and described by the <classname>@PrimaryKeyJoinColumn</classname>s or the <literal>&lt;key&gt;</literal> element."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2664
#, no-c-format
msgid ""
      "@Entity @Table(name=\"CATS\")\n"
      "@Inheritance(strategy=InheritanceType.JOINED)\n"
      "public class Cat implements Serializable { \n"
      "    @Id @GeneratedValue(generator=\"cat-uuid\") \n"
      "    @GenericGenerator(name=\"cat-uuid\", strategy=\"uuid\")\n"
      "    String getId() { return id; }\n"
      "\n"
      "    ...\n"
      "}\n"
      "\n"
      "@Entity @Table(name=\"DOMESTIC_CATS\")\n"
      "@PrimaryKeyJoinColumn(name=\"CAT\")\n"
      "public class DomesticCat extends Cat { \n"
      "    public String getName() { return name; }\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2667
#, no-c-format
msgid "The table name still defaults to the non qualified class name. Also if <classname>@PrimaryKeyJoinColumn</classname> is not set, the primary key / foreign key columns are assumed to have the same names as the primary key columns of the primary table of the superclass."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2674
#, no-c-format
msgid "In hbm.xml, use the <literal>&lt;joined-subclass&gt;</literal> element. For example:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2688
#, no-c-format
msgid ""
      "&lt;joined-subclass\n"
      "        name=\"ClassName\"\n"
      "        table=\"tablename\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        lazy=\"true|false\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        schema=\"schema\"\n"
      "        catalog=\"catalog\"\n"
      "        extends=\"SuperclassName\"\n"
      "        persister=\"ClassName\"\n"
      "        subselect=\"SQL expression\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\"&gt;\n"
      "\n"
      "        &lt;key .... &gt;\n"
      "\n"
      "        &lt;property .... /&gt;\n"
      "        .....\n"
      "&lt;/joined-subclass&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2697 basic_mapping.xml:2761
#, no-c-format
msgid "<literal>table</literal>: the name of the subclass table."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2702 basic_mapping.xml:2766
#, no-c-format
msgid "<literal>proxy</literal> (optional): specifies a class or interface to use for lazy initializing proxies."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2707 basic_mapping.xml:2771
#, no-c-format
msgid "<literal>lazy</literal> (optional, defaults to <literal>true</literal>): setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2715
#, no-c-format
msgid "Use the <literal>&lt;key&gt;</literal> element to declare the primary key / foreign key column. The mapping at the start of the chapter would then be re-written as:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2719
#, no-c-format
msgid ""
      "&lt;?xml version=\"1.0\"?&gt;\n"
      "&lt;!DOCTYPE hibernate-mapping PUBLIC\n"
      "        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
      "        \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n"
      "\n"
      "&lt;hibernate-mapping package=\"eg\"&gt;\n"
      "\n"
      "        &lt;class name=\"Cat\" table=\"CATS\"&gt;\n"
      "                &lt;id name=\"id\" column=\"uid\" type=\"long\"&gt;\n"
      "                        &lt;generator class=\"hilo\"/&gt;\n"
      "                &lt;/id&gt;\n"
      "                &lt;property name=\"birthdate\" type=\"date\"/&gt;\n"
      "                &lt;property name=\"color\" not-null=\"true\"/&gt;\n"
      "                &lt;property name=\"sex\" not-null=\"true\"/&gt;\n"
      "                &lt;property name=\"weight\"/&gt;\n"
      "                &lt;many-to-one name=\"mate\"/&gt;\n"
      "                &lt;set name=\"kittens\"&gt;\n"
      "                        &lt;key column=\"MOTHER\"/&gt;\n"
      "                        &lt;one-to-many class=\"Cat\"/&gt;\n"
      "                &lt;/set&gt;\n"
      "                &lt;joined-subclass name=\"DomesticCat\" table=\"DOMESTIC_CATS\"&gt;\n"
      "                    &lt;key column=\"CAT\"/&gt;\n"
      "                    &lt;property name=\"name\" type=\"string\"/&gt;\n"
      "                &lt;/joined-subclass&gt;\n"
      "        &lt;/class&gt;\n"
      "\n"
      "        &lt;class name=\"eg.Dog\"&gt;\n"
      "                &lt;!-- mapping for Dog could go here --&gt;\n"
      "        &lt;/class&gt;\n"
      "\n"
      "&lt;/hibernate-mapping&gt;"
msgstr ""

#. Tag: title
#: basic_mapping.xml:2726
#, no-c-format
msgid "Table per class strategy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2728
#, no-c-format
msgid "A third option is to map only the concrete classes of an inheritance hierarchy to tables. This is called the table-per-concrete-class strategy. Each table defines all persistent states of the class, including the inherited state. In Hibernate, it is not necessary to explicitly map such inheritance hierarchies. You can map each class as a separate entity root. However, if you wish use polymorphic associations (e.g. an association to the superclass of your hierarchy), you need to use the union subclass mapping."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2737
#, no-c-format
msgid ""
      "@Entity\n"
      "@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n"
      "public class Flight implements Serializable { ... }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2739
#, no-c-format
msgid "Or in hbm.xml:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2752
#, no-c-format
msgid ""
      "&lt;union-subclass\n"
      "        name=\"ClassName\"\n"
      "        table=\"tablename\"\n"
      "        proxy=\"ProxyInterface\"\n"
      "        lazy=\"true|false\"\n"
      "        dynamic-update=\"true|false\"\n"
      "        dynamic-insert=\"true|false\"\n"
      "        schema=\"schema\"\n"
      "        catalog=\"catalog\"\n"
      "        extends=\"SuperclassName\"\n"
      "        abstract=\"true|false\"\n"
      "        persister=\"ClassName\"\n"
      "        subselect=\"SQL expression\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name\"&gt;\n"
      "\n"
      "        &lt;property .... /&gt;\n"
      "        .....\n"
      "&lt;/union-subclass&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2779
#, no-c-format
msgid "No discriminator column or key column is required for this mapping strategy."
msgstr ""

#. Tag: title
#: basic_mapping.xml:2787
#, no-c-format
msgid "Inherit properties from superclasses"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2789
#, no-c-format
msgid "This is sometimes useful to share common properties through a technical or a business superclass without including it as a regular mapped entity (ie no specific table for this entity). For that purpose you can map them as <literal>@MappedSuperclass</literal>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2794
#, no-c-format
msgid ""
      "@MappedSuperclass\n"
      "public class BaseEntity {\n"
      "    @Basic\n"
      "    @Temporal(TemporalType.TIMESTAMP)\n"
      "    public Date getLastUpdate() { ... }\n"
      "    public String getLastUpdater() { ... }\n"
      "    ...\n"
      "}\n"
      "\n"
      "@Entity class Order extends BaseEntity {\n"
      "    @Id public Integer getId() { ... }\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2796
#, no-c-format
msgid "In database, this hierarchy will be represented as an <literal>Order</literal> table having the <literal>id</literal>, <literal>lastUpdate</literal> and <literal>lastUpdater</literal> columns. The embedded superclass property mappings are copied into their entity subclasses. Remember that the embeddable superclass is not the root of the hierarchy though."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2804
#, no-c-format
msgid "Properties from superclasses not mapped as <literal>@MappedSuperclass</literal> are ignored."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2809
#, no-c-format
msgid "The default access type (field or methods) is used, unless you use the <literal>@Access</literal> annotation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2814
#, no-c-format
msgid "The same notion can be applied to <literal>@Embeddable</literal> objects to persist properties from their superclasses. You also need to use <literal>@MappedSuperclass</literal> to do that (this should not be considered as a standard EJB3 feature though)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2822
#, no-c-format
msgid "It is allowed to mark a class as <literal>@MappedSuperclass</literal> in the middle of the mapped inheritance hierarchy."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2828
#, no-c-format
msgid "Any class in the hierarchy non annotated with <literal>@MappedSuperclass</literal> nor <literal>@Entity</literal> will be ignored."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2833
#, no-c-format
msgid "You can override columns defined in entity superclasses at the root entity level using the <literal>@AttributeOverride</literal> annotation."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2837
#, no-c-format
msgid ""
      "@MappedSuperclass\n"
      "public class FlyingObject implements Serializable {\n"
      "\n"
      "    public int getAltitude() {\n"
      "        return altitude;\n"
      "    }\n"
      "\n"
      "    @Transient\n"
      "    public int getMetricAltitude() {\n"
      "        return metricAltitude;\n"
      "    }\n"
      "\n"
      "    @ManyToOne\n"
      "    public PropulsionType getPropulsion() {\n"
      "        return metricAltitude;\n"
      "    }\n"
      "    ...\n"
      "}\n"
      "\n"
      "@Entity\n"
      "@AttributeOverride( name=\"altitude\", column = @Column(name=\"fld_altitude\") )\n"
      "@AssociationOverride( \n"
      "   name=\"propulsion\", \n"
      "   joinColumns = @JoinColumn(name=\"fld_propulsion_fk\") \n"
      ")\n"
      "public class Plane extends FlyingObject {\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2839
#, no-c-format
msgid "The <literal>altitude</literal> property will be persisted in an <literal>fld_altitude</literal> column of table <literal>Plane</literal> and the propulsion association will be materialized in a <literal>fld_propulsion_fk</literal> foreign key column."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2845
#, no-c-format
msgid "You can define <literal>@AttributeOverride</literal>(s) and <literal>@AssociationOverride</literal>(s) on <literal>@Entity</literal> classes, <literal>@MappedSuperclass</literal> classes and properties pointing to an <literal>@Embeddable</literal> object."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2851
#, no-c-format
msgid "In hbm.xml, simply map the properties of the superclass in the <literal>&lt;class&gt;</literal> element of the entity that needs to inherit them."
msgstr ""

#. Tag: title
#: basic_mapping.xml:2857
#, no-c-format
msgid "Mapping one entity to several tables"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2859
#, no-c-format
msgid "While not recommended for a fresh schema, some legacy databases force your to map a single entity on several tables."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2862
#, no-c-format
msgid "Using the <literal>@SecondaryTable</literal> or <literal>@SecondaryTables</literal> class level annotations. To express that a column is in a particular table, use the <literal>table</literal> parameter of <literal>@Column</literal> or <literal>@JoinColumn</literal>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2868
#, no-c-format
msgid ""
      "@Entity\n"
      "@Table(name=\"MainCat\")\n"
      "@SecondaryTables({\n"
      "    @SecondaryTable(name=\"Cat1\", pkJoinColumns={\n"
      "        @PrimaryKeyJoinColumn(name=\"cat_id\", referencedColumnName=\"id\")\n"
      "    ),\n"
      "    @SecondaryTable(name=\"Cat2\", uniqueConstraints={@UniqueConstraint(columnNames={\"storyPart2\"})})\n"
      "})\n"
      "public class Cat implements Serializable {\n"
      "\n"
      "    private Integer id;\n"
      "    private String name;\n"
      "    private String storyPart1;\n"
      "    private String storyPart2;\n"
      "\n"
      "    @Id @GeneratedValue\n"
      "    public Integer getId() {\n"
      "        return id;\n"
      "    }\n"
      "\n"
      "    public String getName() {\n"
      "        return name;\n"
      "    }\n"
      "    \n"
      "    @Column(table=\"Cat1\")\n"
      "    public String getStoryPart1() {\n"
      "        return storyPart1;\n"
      "    }\n"
      "\n"
      "    @Column(table=\"Cat2\")\n"
      "    public String getStoryPart2() {\n"
      "        return storyPart2;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2870
#, no-c-format
msgid "In this example, <literal>name</literal> will be in <literal>MainCat</literal>. <literal>storyPart1</literal> will be in <literal>Cat1</literal> and <literal>storyPart2</literal> will be in <literal>Cat2</literal>. <literal>Cat1</literal> will be joined to <literal>MainCat</literal> using the <literal>cat_id</literal> as a foreign key, and <literal>Cat2</literal> using <literal>id</literal> (ie the same column name, the <literal>MainCat</literal> id column has). Plus a unique constraint on <literal>storyPart2</literal> has been set."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2880
#, no-c-format
msgid "There is also additional tuning accessible via the <classname>@org.hibernate.annotations.Table</classname> annotation:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2886
#, no-c-format
msgid "<literal>fetch</literal>: If set to JOIN, the default, Hibernate will use an inner join to retrieve a secondary table defined by a class or its superclasses and an outer join for a secondary table defined by a subclass. If set to <classname>SELECT</classname> then Hibernate will use a sequential select for a secondary table defined on a subclass, which will be issued only if a row turns out to represent an instance of the subclass. Inner joins will still be used to retrieve a secondary defined by the class and its superclasses."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2898
#, no-c-format
msgid "<literal>inverse</literal>: If true, Hibernate will not try to insert or update the properties defined by this join. Default to false."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2904
#, no-c-format
msgid "<literal>optional</literal>: If enabled (the default), Hibernate will insert a row only if the properties defined by this join are non-null and will always use an outer join to retrieve the properties."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2911
#, no-c-format
msgid "<literal>foreignKey</literal>: defines the Foreign Key name of a secondary table pointing back to the primary table."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2916
#, no-c-format
msgid "Make sure to use the secondary table name in the <methodname>appliesto</methodname> property"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2919
#, no-c-format
msgid ""
      "@Entity\n"
      "@Table(name=\"MainCat\")\n"
      "@SecondaryTable(name=\"Cat1\")\n"
      "@org.hibernate.annotations.Table(\n"
      "   appliesTo=\"Cat1\",\n"
      "   fetch=FetchMode.SELECT,\n"
      "   optional=true)\n"
      "public class Cat implements Serializable {\n"
      "\n"
      "    private Integer id;\n"
      "    private String name;\n"
      "    private String storyPart1;\n"
      "    private String storyPart2;\n"
      "\n"
      "    @Id @GeneratedValue\n"
      "    public Integer getId() {\n"
      "        return id;\n"
      "    }\n"
      "\n"
      "    public String getName() {\n"
      "        return name;\n"
      "    }\n"
      "    \n"
      "    @Column(table=\"Cat1\")\n"
      "    public String getStoryPart1() {\n"
      "        return storyPart1;\n"
      "    }\n"
      "\n"
      "    @Column(table=\"Cat2\")\n"
      "    public String getStoryPart2() {\n"
      "        return storyPart2;\n"
      "    }\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2921
#, no-c-format
msgid "In hbm.xml, use the <literal>&lt;join&gt;</literal> element."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2939
#, no-c-format
msgid ""
      "&lt;join\n"
      "        table=\"tablename\"\n"
      "        schema=\"owner\"\n"
      "        catalog=\"catalog\"\n"
      "        fetch=\"join|select\"\n"
      "        inverse=\"true|false\"\n"
      "        optional=\"true|false\"&gt;\n"
      "\n"
      "        &lt;key ... /&gt;\n"
      "\n"
      "        &lt;property ... /&gt;\n"
      "        ...\n"
      "&lt;/join&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2943
#, no-c-format
msgid "<literal>table</literal>: the name of the joined table."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2960
#, no-c-format
msgid "<literal>fetch</literal> (optional - defaults to <literal>join</literal>): if set to <literal>join</literal>, the default, Hibernate will use an inner join to retrieve a <literal>&lt;join&gt;</literal> defined by a class or its superclasses. It will use an outer join for a <literal>&lt;join&gt;</literal> defined by a subclass. If set to <literal>select</literal> then Hibernate will use a sequential select for a <literal>&lt;join&gt;</literal> defined on a subclass. This will be issued only if a row represents an instance of the subclass. Inner joins will still be used to retrieve a <literal>&lt;join&gt;</literal> defined by the class and its superclasses."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2975
#, no-c-format
msgid "<literal>inverse</literal> (optional - defaults to <literal>false</literal>): if enabled, Hibernate will not insert or update the properties defined by this join."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2981
#, no-c-format
msgid "<literal>optional</literal> (optional - defaults to <literal>false</literal>): if enabled, Hibernate will insert a row only if the properties defined by this join are non-null. It will always use an outer join to retrieve the properties."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2989
#, no-c-format
msgid "For example, address information for a person can be mapped to a separate table while preserving value type semantics for all properties:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2993
#, no-c-format
msgid ""
      "&lt;class name=\"Person\"\n"
      "    table=\"PERSON\"&gt;\n"
      "\n"
      "    &lt;id name=\"id\" column=\"PERSON_ID\"&gt;...&lt;/id&gt;\n"
      "\n"
      "    &lt;join table=\"ADDRESS\"&gt;\n"
      "        &lt;key column=\"ADDRESS_ID\"/&gt;\n"
      "        &lt;property name=\"address\"/&gt;\n"
      "        &lt;property name=\"zip\"/&gt;\n"
      "        &lt;property name=\"country\"/&gt;\n"
      "    &lt;/join&gt;\n"
      "    ..."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2995
#, no-c-format
msgid "This feature is often only useful for legacy data models. We recommend fewer tables than classes and a fine-grained domain model. However, it is useful for switching between inheritance mapping strategies in a single hierarchy, as explained later."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3003
#, no-c-format
msgid "Mapping one to one and one to many associations"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3005
#, no-c-format
msgid "To link one entity to an other, you need to map the association property as a to one association. In the relational model, you can either use a foreign key or an association table, or (a bit less common) share the same primary key value between the two entities."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3010
#, no-c-format
msgid "To mark an association, use either <classname>@ManyToOne</classname> or <classname>@OnetoOne</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3014
#, no-c-format
msgid "<literal>@ManyToOne</literal> and <classname>@OneToOne</classname> have a parameter named <literal>targetEntity</literal> which describes the target entity name. You usually don't need this parameter since the default value (the type of the property that stores the association) is good in almost all cases. However this is useful when you want to use interfaces as the return type instead of the regular entity."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3021
#, no-c-format
msgid "Setting a value of the <literal>cascade</literal> attribute to any meaningful value other than nothing will propagate certain operations to the associated object. The meaningful values are divided into three categories."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3028
#, no-c-format
msgid "basic operations, which include: <literal>persist, merge, delete, save-update, evict, replicate, lock and refresh</literal>;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3034
#, no-c-format
msgid "special values: <literal>delete-orphan</literal> or <literal>all</literal> ;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3039
#, no-c-format
msgid "comma-separated combinations of operation names: <literal>cascade=\"persist,merge,evict\"</literal> or <literal>cascade=\"all,delete-orphan\"</literal>. See <xref linkend=\"objectstate-transitive\"/> for a full explanation. Note that single valued many-to-one associations do not support orphan delete."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3048
#, no-c-format
msgid "By default, single point associations are eagerly fetched in JPA 2. You can mark it as lazily fetched by using <classname>@ManyToOne(fetch=FetchType.LAZY) </classname>in which case Hibernate will proxy the association and load it when the state of the associated entity is reached. You can force Hibernate not to use a proxy by using <classname>@LazyToOne(NO_PROXY)</classname>. In this case, the property is fetched lazily when the instance variable is first accessed. This requires build-time bytecode instrumentation. lazy=\"false\" specifies that the association will always be eagerly fetched."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3058
#, no-c-format
msgid "With the default JPA options, single-ended associations are loaded with a subsequent select if set to <literal>LAZY</literal>, or a SQL JOIN is used for <literal>EAGER</literal> associations. You can however adjust the fetching strategy, ie how data is fetched by using <literal>@Fetch</literal>. <literal>FetchMode</literal> can be <literal>SELECT</literal> (a select is triggered when the association needs to be loaded) or <literal>JOIN</literal> (use a SQL JOIN to load the association while loading the owner entity). <literal>JOIN</literal> overrides any lazy attribute (an association loaded through a <literal>JOIN</literal> strategy cannot be lazy)."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3070
#, no-c-format
msgid "Using a foreign key or an association table"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3072
#, no-c-format
msgid "An ordinary association to another persistent class is declared using a"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3077
#, no-c-format
msgid "<classname>@ManyToOne</classname> if several entities can point to the the target entity"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3082
#, no-c-format
msgid "<classname>@OneToOne</classname> if only a single entity can point to the the target entity"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3087
#, no-c-format
msgid "and a foreign key in one table is referencing the primary key column(s) of the target table."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3090
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Flight implements Serializable {\n"
      "    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )\n"
      "    @JoinColumn(name=\"COMP_ID\")\n"
      "    public Company getCompany() {\n"
      "        return company;\n"
      "    }\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3092
#, no-c-format
msgid "The <literal>@JoinColumn</literal> attribute is optional, the default value(s) is the concatenation of the name of the relationship in the owner side, <keycap>_</keycap> (underscore), and the name of the primary key column in the owned side. In this example <literal>company_id</literal> because the property name is <literal>company</literal> and the column id of Company is <literal>id</literal>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3100
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Flight implements Serializable {\n"
      "    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE}, targetEntity=CompanyImpl.class )\n"
      "    @JoinColumn(name=\"COMP_ID\")\n"
      "    public Company getCompany() {\n"
      "        return company;\n"
      "    }\n"
      "    ...\n"
      "}\n"
      "\n"
      "public interface Company {\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3102
#, no-c-format
msgid "You can also map a to one association through an association table. This association table described by the <literal>@JoinTable</literal> annotation will contains a foreign key referencing back the entity table (through <literal>@JoinTable.joinColumns</literal>) and a a foreign key referencing the target entity table (through <literal>@JoinTable.inverseJoinColumns</literal>)."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3110
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Flight implements Serializable {\n"
      "    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )\n"
      "    @JoinTable(name=\"Flight_Company\",\n"
      "        joinColumns = @JoinColumn(name=\"FLIGHT_ID\"),\n"
      "        inverseJoinColumns = @JoinColumn(name=\"COMP_ID\")\n"
      "    )\n"
      "    public Company getCompany() {\n"
      "        return company;\n"
      "    }\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3113
#, no-c-format
msgid "You can use a SQL fragment to simulate a physical join column using the <classname>@JoinColumnOrFormula</classname> / <classname>@JoinColumnOrformulas</classname> annotations (just like you can use a SQL fragment to simulate a property column via the <classname>@Formula</classname> annotation)."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3119
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Ticket implements Serializable {\n"
      "    @ManyToOne\n"
      "    @JoinColumnOrFormula(formula=\"(firstname + ' ' + lastname)\")\n"
      "    public Person getOwner() {\n"
      "        return person;\n"
      "    }\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3122
#, no-c-format
msgid "You can mark an association as mandatory by using the <literal>optional=false</literal> attribute. We recommend to use Bean Validation's <classname>@NotNull</classname> annotation as a better alternative however. As a consequence, the foreign key column(s) will be marked as not nullable (if possible)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3128
#, no-c-format
msgid "When Hibernate cannot resolve the association because the expected associated element is not in database (wrong id on the association column), an exception is raised. This might be inconvenient for legacy and badly maintained schemas. You can ask Hibernate to ignore such elements instead of raising an exception using the <literal>@NotFound</literal> annotation."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3136
#, no-c-format
msgid "@NotFound annotation"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3138
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Child {\n"
      "    ...\n"
      "    @ManyToOne\n"
      "    @NotFound(action=NotFoundAction.IGNORE)\n"
      "    public Parent getParent() { ... }\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3141
#, no-c-format
msgid "Sometimes you want to delegate to your database the deletion of cascade when a given entity is deleted. In this case Hibernate generates a cascade delete constraint at the database level."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3146
#, no-c-format
msgid "@OnDelete annotation"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3148
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Child {\n"
      "    ...\n"
      "    @ManyToOne\n"
      "    @OnDelete(action=OnDeleteAction.CASCADE)\n"
      "    public Parent getParent() { ... }\n"
      "    ...\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3151
#, no-c-format
msgid "Foreign key constraints, while generated by Hibernate, have a fairly unreadable name. You can override the constraint name using <literal>@ForeignKey</literal>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3156
#, no-c-format
msgid "@ForeignKey annotation"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3158
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Child {\n"
      "    ...\n"
      "    @ManyToOne\n"
      "    @ForeignKey(name=\"FK_PARENT\")\n"
      "    public Parent getParent() { ... }\n"
      "    ...\n"
      "}\n"
      "\n"
      "alter table Child add constraint FK_PARENT foreign key (parent_id) references Parent"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3161
#, no-c-format
msgid "Sometimes, you want to link one entity to an other not by the target entity primary key but by a different unique key. You can achieve that by referencing the unique key column(s) in <methodname>@JoinColumn.referenceColumnName</methodname>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3166 basic_mapping.xml:3718
#, no-c-format
msgid ""
      "@Entity\n"
      "class Person {\n"
      "   @Id Integer personNumber;\n"
      "   String firstName;\n"
      "   @Column(name=\"I\")\n"
      "   String initial;\n"
      "   String lastName;\n"
      "}\n"
      "\n"
      "@Entity\n"
      "class Home {\n"
      "   @ManyToOne\n"
      "   @JoinColumns({\n"
      "      @JoinColumn(name=\"first_name\", referencedColumnName=\"firstName\"),\n"
      "      @JoinColumn(name=\"init\", referencedColumnName=\"I\"),\n"
      "      @JoinColumn(name=\"last_name\", referencedColumnName=\"lastName\"),\n"
      "   })\n"
      "   Person owner\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3168
#, no-c-format
msgid "This is not encouraged however and should be reserved to legacy mappings."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3171
#, no-c-format
msgid "In hbm.xml, mapping an association is similar. The main difference is that a <classname>@OneToOne</classname> is mapped as <literal>&lt;many-to-one unique=\"true\"/&gt;</literal>, let's dive into the subject."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3213
#, no-c-format
msgid ""
      "&lt;many-to-one\n"
      "        name=\"propertyName\"\n"
      "        column=\"column_name\"\n"
      "        class=\"ClassName\"\n"
      "        cascade=\"cascade_style\"\n"
      "        fetch=\"join|select\"\n"
      "        update=\"true|false\"\n"
      "        insert=\"true|false\"\n"
      "        property-ref=\"propertyNameFromAssociatedClass\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        unique=\"true|false\"\n"
      "        not-null=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        lazy=\"proxy|no-proxy|false\"\n"
      "        not-found=\"ignore|exception\"\n"
      "        entity-name=\"EntityName\"\n"
      "        formula=\"arbitrary SQL expression\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "        embed-xml=\"true|false\"\n"
      "        index=\"index_name\"\n"
      "        unique_key=\"unique_key_id\"\n"
      "        foreign-key=\"foreign_key_name\"\n"
      "/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3221 basic_mapping.xml:3904
#, no-c-format
msgid "<literal>column</literal> (optional): the name of the foreign key column. This can also be specified by nested <literal>&lt;column&gt;</literal> element(s)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3227 basic_mapping.xml:3421
#, no-c-format
msgid "<literal>class</literal> (optional - defaults to the property type determined by reflection): the name of the associated class."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3233 basic_mapping.xml:3427
#, no-c-format
msgid "<literal>cascade</literal> (optional): specifies which operations should be cascaded from the parent object to the associated object."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3239 basic_mapping.xml:3443
#, no-c-format
msgid "<literal>fetch</literal> (optional - defaults to <literal>select</literal>): chooses between outer-join fetching or sequential select fetching."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3245
#, no-c-format
msgid "<literal>update, insert</literal> (optional - defaults to <literal>true</literal>): specifies that the mapped columns should be included in SQL <literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. Setting both to <literal>false</literal> allows a pure \"derived\" association whose value is initialized from another property that maps to the same column(s), or by a trigger or other application."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3255
#, no-c-format
msgid "<literal>property-ref</literal> (optional): the name of a property of the associated class that is joined to this foreign key. If not specified, the primary key of the associated class is used."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3268
#, no-c-format
msgid "<literal>unique</literal> (optional): enables the DDL generation of a unique constraint for the foreign-key column. By allowing this to be the target of a <literal>property-ref</literal>, you can make the association multiplicity one-to-one."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3276
#, no-c-format
msgid "<literal>not-null</literal> (optional): enables the DDL generation of a nullability constraint for the foreign key columns."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3290
#, no-c-format
msgid "<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): by default, single point associations are proxied. <literal>lazy=\"no-proxy\"</literal> specifies that the property should be fetched lazily when the instance variable is first accessed. This requires build-time bytecode instrumentation. <literal>lazy=\"false\"</literal> specifies that the association will always be eagerly fetched."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3300
#, no-c-format
msgid "<literal>not-found</literal> (optional - defaults to <literal>exception</literal>): specifies how foreign keys that reference missing rows will be handled. <literal>ignore</literal> will treat a missing row as a null association."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3308 basic_mapping.xml:3484
#, no-c-format
msgid "<literal>entity-name</literal> (optional): the entity name of the associated class."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3313
#, no-c-format
msgid "<literal>formula</literal> (optional): an SQL expression that defines the value for a <emphasis>computed</emphasis> foreign key."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3320
#, no-c-format
msgid "Setting a value of the <literal>cascade</literal> attribute to any meaningful value other than <literal>none</literal> will propagate certain operations to the associated object. The meaningful values are divided into three categories. First, basic operations, which include: <literal>persist, merge, delete, save-update, evict, replicate, lock and refresh</literal>; second, special values: <literal>delete-orphan</literal>; and third,<literal>all</literal> comma-separated combinations of operation names: <literal>cascade=\"persist,merge,evict\"</literal> or <literal>cascade=\"all,delete-orphan\"</literal>. See <xref linkend=\"objectstate-transitive\"/> for a full explanation. Note that single valued, many-to-one and one-to-one, associations do not support orphan delete."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3334
#, no-c-format
msgid "Here is an example of a typical <literal>many-to-one</literal> declaration:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3337
#, no-c-format
msgid "&lt;many-to-one name=\"product\" class=\"Product\" column=\"PRODUCT_ID\"/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3339
#, no-c-format
msgid "The <literal>property-ref</literal> attribute should only be used for mapping legacy data where a foreign key refers to a unique key of the associated table other than the primary key. This is a complicated and confusing relational model. For example, if the <literal>Product</literal> class had a unique serial number that is not the primary key. The <literal>unique</literal> attribute controls Hibernate's DDL generation with the SchemaExport tool."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3347
#, no-c-format
msgid "&lt;property name=\"serialNumber\" unique=\"true\" type=\"string\" column=\"SERIAL_NUMBER\"/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3349
#, no-c-format
msgid "Then the mapping for <literal>OrderItem</literal> might use:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3352
#, no-c-format
msgid "&lt;many-to-one name=\"product\" property-ref=\"serialNumber\" column=\"PRODUCT_SERIAL_NUMBER\"/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3354
#, no-c-format
msgid "This is not encouraged, however."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3356
#, no-c-format
msgid "If the referenced unique key comprises multiple properties of the associated entity, you should map the referenced properties inside a named <literal>&lt;properties&gt;</literal> element."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3360
#, no-c-format
msgid "If the referenced unique key is the property of a component, you can specify a property path:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3363
#, no-c-format
msgid "&lt;many-to-one name=\"owner\" property-ref=\"identity.ssn\" column=\"OWNER_SSN\"/&gt;"
msgstr ""

#. Tag: title
#: basic_mapping.xml:3367
#, no-c-format
msgid "Sharing the primary key with the associated entity"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3369
#, no-c-format
msgid "The second approach is to ensure an entity and its associated entity share the same primary key. In this case the primary key column is also a foreign key and there is no extra column. These associations are always one to one."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3375
#, no-c-format
msgid "One to One association"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3377
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Body {\n"
      "    @Id\n"
      "    public Long getId() { return id; }\n"
      "\n"
      "    @OneToOne(cascade = CascadeType.ALL)\n"
      "    @MapsId\n"
      "    public Heart getHeart() {\n"
      "        return heart;\n"
      "    }\n"
      "    ...\n"
      "}   \n"
      "\n"
      "@Entity\n"
      "public class Heart {\n"
      "    @Id\n"
      "    public Long getId() { ...}\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3381
#, no-c-format
msgid "Many people got confused by these primary key based one to one associations. They can only be lazily loaded if Hibernate knows that the other side of the association is always present. To indicate to Hibernate that it is the case, use <classname>@OneToOne(optional=false)</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3388
#, no-c-format
msgid "In hbm.xml, use the following mapping."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3413
#, no-c-format
msgid ""
      "&lt;one-to-one\n"
      "        name=\"propertyName\"\n"
      "        class=\"ClassName\"\n"
      "        cascade=\"cascade_style\"\n"
      "        constrained=\"true|false\"\n"
      "        fetch=\"join|select\"\n"
      "        property-ref=\"propertyNameFromAssociatedClass\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        formula=\"any SQL expression\"\n"
      "        lazy=\"proxy|no-proxy|false\"\n"
      "        entity-name=\"EntityName\"\n"
      "        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
      "        embed-xml=\"true|false\"\n"
      "        foreign-key=\"foreign_key_name\"\n"
      "/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3433
#, no-c-format
msgid "<literal>constrained</literal> (optional): specifies that a foreign key constraint on the primary key of the mapped table and references the table of the associated class. This option affects the order in which <literal>save()</literal> and <literal>delete()</literal> are cascaded, and determines whether the association can be proxied. It is also used by the schema export tool."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3449
#, no-c-format
msgid "<literal>property-ref</literal> (optional): the name of a property of the associated class that is joined to the primary key of this class. If not specified, the primary key of the associated class is used."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3462
#, no-c-format
msgid "<literal>formula</literal> (optional): almost all one-to-one associations map to the primary key of the owning entity. If this is not the case, you can specify another column, columns or expression to join on using an SQL formula. See <literal>org.hibernate.test.onetooneformula</literal> for an example."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3471
#, no-c-format
msgid "<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): by default, single point associations are proxied. <literal>lazy=\"no-proxy\"</literal> specifies that the property should be fetched lazily when the instance variable is first accessed. It requires build-time bytecode instrumentation. <literal>lazy=\"false\"</literal> specifies that the association will always be eagerly fetched. <emphasis>Note that if <literal>constrained=\"false\"</literal>, proxying is impossible and Hibernate will eagerly fetch the association</emphasis>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3490
#, no-c-format
msgid "Primary key associations do not need an extra table column. If two rows are related by the association, then the two table rows share the same primary key value. To relate two objects by a primary key association, ensure that they are assigned the same identifier value."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3496
#, no-c-format
msgid "For a primary key association, add the following mappings to <literal>Employee</literal> and <literal>Person</literal> respectively:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3500
#, no-c-format
msgid "&lt;one-to-one name=\"person\" class=\"Person\"/&gt;"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3502
#, no-c-format
msgid "&lt;one-to-one name=\"employee\" class=\"Employee\" constrained=\"true\"/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3504
#, no-c-format
msgid "Ensure that the primary keys of the related rows in the PERSON and EMPLOYEE tables are equal. You use a special Hibernate identifier generation strategy called <literal>foreign</literal>:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3508
#, no-c-format
msgid ""
      "&lt;class name=\"person\" table=\"PERSON\"&gt;\n"
      "    &lt;id name=\"id\" column=\"PERSON_ID\"&gt;\n"
      "        &lt;generator class=\"foreign\"&gt;\n"
      "            &lt;param name=\"property\"&gt;employee&lt;/param&gt;\n"
      "        &lt;/generator&gt;\n"
      "    &lt;/id&gt;\n"
      "    ...\n"
      "    &lt;one-to-one name=\"employee\"\n"
      "        class=\"Employee\"\n"
      "        constrained=\"true\"/&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3510
#, no-c-format
msgid "A newly saved instance of <literal>Person</literal> is assigned the same primary key value as the <literal>Employee</literal> instance referred with the <literal>employee</literal> property of that <literal>Person</literal>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3518
#, no-c-format
msgid "Natural-id"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3520
#, no-c-format
msgid "Although we recommend the use of surrogate keys as primary keys, you should try to identify natural keys for all entities. A natural key is a property or combination of properties that is unique and non-null. It is also immutable. Map the properties of the natural key as <classname>@NaturalId</classname> or map them inside the <literal>&lt;natural-id&gt;</literal> element. Hibernate will generate the necessary unique key and nullability constraints and, as a result, your mapping will be more self-documenting."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3529
#, no-c-format
msgid ""
      "@Entity\n"
      "public class Citizen {\n"
      "    @Id\n"
      "    @GeneratedValue\n"
      "    private Integer id;\n"
      "    private String firstname;\n"
      "    private String lastname;\n"
      "    \n"
      "    @NaturalId\n"
      "    @ManyToOne\n"
      "    private State state;\n"
      "\n"
      "    @NaturalId\n"
      "    private String ssn;\n"
      "    ...\n"
      "}\n"
      "\n"
      "\n"
      "\n"
      "//and later on query\n"
      "List results = s.createCriteria( Citizen.class )\n"
      "                .add( Restrictions.naturalId().set( \"ssn\", \"1234\" ).set( \"state\", ste ) )\n"
      "                .list();"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3531
#, no-c-format
msgid "Or in XML,"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3533
#, no-c-format
msgid ""
      "&lt;natural-id mutable=\"true|false\"/&gt;\n"
      "        &lt;property ... /&gt;\n"
      "        &lt;many-to-one ... /&gt;\n"
      "        ......\n"
      "&lt;/natural-id&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3535
#, no-c-format
msgid "It is recommended that you implement <literal>equals()</literal> and <literal>hashCode()</literal> to compare the natural key properties of the entity."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3539
#, no-c-format
msgid "This mapping is not intended for use with entities that have natural primary keys."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3544
#, no-c-format
msgid "<literal>mutable</literal> (optional - defaults to <literal>false</literal>): by default, natural identifier properties are assumed to be immutable (constant)."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3552
#, no-c-format
msgid "<title>Any</title>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3554
#, no-c-format
msgid "There is one more type of property mapping. The <classname>@Any</classname> mapping defines a polymorphic association to classes from multiple tables. This type of mapping requires more than one column. The first column contains the type of the associated entity. The remaining columns contain the identifier. It is impossible to specify a foreign key constraint for this kind of association. This is not the usual way of mapping polymorphic associations and you should use this only in special cases. For example, for audit logs, user session data, etc."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3564
#, no-c-format
msgid "The <classname>@Any</classname> annotation describes the column holding the metadata information. To link the value of the metadata information and an actual entity type, The <classname>@AnyDef</classname> and <classname>@AnyDefs</classname> annotations are used. The <literal>metaType</literal> attribute allows the application to specify a custom type that maps database column values to persistent classes that have identifier properties of the type specified by <literal>idType</literal>. You must specify the mapping from values of the <literal>metaType</literal> to class names."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3574
#, no-c-format
msgid ""
      "@Any( metaColumn = @Column( name = \"property_type\" ), fetch=FetchType.EAGER )\n"
      "@AnyMetaDef( \n"
      "    idType = \"integer\", \n"
      "    metaType = \"string\", \n"
      "    metaValues = {\n"
      "        @MetaValue( value = \"S\", targetEntity = StringProperty.class ),\n"
      "        @MetaValue( value = \"I\", targetEntity = IntegerProperty.class )\n"
      "    } )\n"
      "@JoinColumn( name = \"property_id\" )\n"
      "public Property getMainProperty() {\n"
      "    return mainProperty;\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3576
#, no-c-format
msgid "Note that <classname>@AnyDef</classname> can be mutualized and reused. It is recommended to place it as a package metadata in this case."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3580
#, no-c-format
msgid ""
      "//on a package\n"
      "@AnyMetaDef( name=\"property\" \n"
      "    idType = \"integer\", \n"
      "    metaType = \"string\", \n"
      "    metaValues = {\n"
      "        @MetaValue( value = \"S\", targetEntity = StringProperty.class ),\n"
      "        @MetaValue( value = \"I\", targetEntity = IntegerProperty.class )\n"
      "    } )\n"
      "package org.hibernate.test.annotations.any;\n"
      "\n"
      "\n"
      "//in a class\n"
      "    @Any( metaDef=\"property\", metaColumn = @Column( name = \"property_type\" ), fetch=FetchType.EAGER )\n"
      "    @JoinColumn( name = \"property_id\" )\n"
      "    public Property getMainProperty() {\n"
      "        return mainProperty;\n"
      "    }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3582
#, no-c-format
msgid "The hbm.xml equivalent is:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3584
#, no-c-format
msgid ""
      "&lt;any name=\"being\" id-type=\"long\" meta-type=\"string\"&gt;\n"
      "    &lt;meta-value value=\"TBL_ANIMAL\" class=\"Animal\"/&gt;\n"
      "    &lt;meta-value value=\"TBL_HUMAN\" class=\"Human\"/&gt;\n"
      "    &lt;meta-value value=\"TBL_ALIEN\" class=\"Alien\"/&gt;\n"
      "    &lt;column name=\"table_name\"/&gt;\n"
      "    &lt;column name=\"id\"/&gt;\n"
      "&lt;/any&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3587
#, no-c-format
msgid "You cannot mutualize the metadata in hbm.xml as you can in annotations."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3606
#, no-c-format
msgid ""
      "&lt;any\n"
      "        name=\"propertyName\"\n"
      "        id-type=\"idtypename\"\n"
      "        meta-type=\"metatypename\"\n"
      "        cascade=\"cascade_style\"\n"
      "        access=\"field|property|ClassName\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "&gt;\n"
      "        &lt;meta-value ... /&gt;\n"
      "        &lt;meta-value ... /&gt;\n"
      "        .....\n"
      "        &lt;column .... /&gt;\n"
      "        &lt;column .... /&gt;\n"
      "        .....\n"
      "&lt;/any&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3610
#, no-c-format
msgid "<literal>name</literal>: the property name."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3614
#, no-c-format
msgid "<literal>id-type</literal>: the identifier type."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3618
#, no-c-format
msgid "<literal>meta-type</literal> (optional - defaults to <literal>string</literal>): any type that is allowed for a discriminator mapping."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3624
#, no-c-format
msgid "<literal>cascade</literal> (optional- defaults to <literal>none</literal>): the cascade style."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3635
#, no-c-format
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies that updates to this property either do or do not require acquisition of the optimistic lock. It defines whether a version increment should occur if this property is dirty."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3646
#, no-c-format
msgid "Properties"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3648
#, no-c-format
msgid "The <literal>&lt;properties&gt;</literal> element allows the definition of a named, logical grouping of the properties of a class. The most important use of the construct is that it allows a combination of properties to be the target of a <literal>property-ref</literal>. It is also a convenient way to define a multi-column unique constraint. For example:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3668
#, no-c-format
msgid ""
      "&lt;properties\n"
      "        name=\"logicalName\"\n"
      "        insert=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        optimistic-lock=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "&gt;\n"
      "\n"
      "        &lt;property ...../&gt;\n"
      "        &lt;many-to-one .... /&gt;\n"
      "        ........\n"
      "&lt;/properties&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3672
#, no-c-format
msgid "<literal>name</literal>: the logical name of the grouping. It is <emphasis>not</emphasis> an actual property name."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3687
#, no-c-format
msgid "<literal>optimistic-lock</literal> (optional - defaults to <literal>true</literal>): specifies that updates to these properties either do or do not require acquisition of the optimistic lock. It determines if a version increment should occur when these properties are dirty."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3702
#, no-c-format
msgid "For example, if we have the following <literal>&lt;properties&gt;</literal> mapping:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3705
#, no-c-format
msgid ""
      "&lt;class name=\"Person\"&gt;\n"
      "    &lt;id name=\"personNumber\"/&gt;\n"
      "\n"
      "    ...\n"
      "    &lt;properties name=\"name\"\n"
      "            unique=\"true\" update=\"false\"&gt;\n"
      "        &lt;property name=\"firstName\"/&gt;\n"
      "        &lt;property name=\"initial\"/&gt;\n"
      "        &lt;property name=\"lastName\"/&gt;\n"
      "    &lt;/properties&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3707
#, no-c-format
msgid "You might have some legacy data association that refers to this unique key of the <literal>Person</literal> table, instead of to the primary key:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3711
#, no-c-format
msgid ""
      "&lt;many-to-one name=\"owner\"\n"
      "         class=\"Person\" property-ref=\"name\"&gt;\n"
      "    &lt;column name=\"firstName\"/&gt;\n"
      "    &lt;column name=\"initial\"/&gt;\n"
      "    &lt;column name=\"lastName\"/&gt;\n"
      "&lt;/many-to-one&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3714
#, no-c-format
msgid "When using annotations as a mapping strategy, such construct is not necessary as the binding between a column and its related column on the associated table is done directly"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3721
#, no-c-format
msgid "The use of this outside the context of mapping legacy data is not recommended."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3726
#, no-c-format
msgid "Some hbm.xml specificities"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3728
#, no-c-format
msgid "The hbm.xml structure has some specificities naturally not present when using annotations, let's describe them briefly."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3732
#, no-c-format
msgid "Doctype"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3734
#, no-c-format
msgid "All XML mappings should declare the doctype shown. The actual DTD can be found at the URL above, in the directory <literal>hibernate-x.x.x/src/org/hibernate </literal>, or in <literal>hibernate3.jar</literal>. Hibernate will always look for the DTD in its classpath first. If you experience lookups of the DTD using an Internet connection, check the DTD declaration against the contents of your classpath."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3743
#, no-c-format
msgid "EntityResolver"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3745
#, no-c-format
msgid "Hibernate will first attempt to resolve DTDs in its classpath. It does this is by registering a custom <literal>org.xml.sax.EntityResolver</literal> implementation with the SAXReader it uses to read in the xml files. This custom <literal>EntityResolver</literal> recognizes two different systemId namespaces:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3754
#, no-c-format
msgid "a <literal>hibernate namespace</literal> is recognized whenever the resolver encounters a systemId starting with <literal>http://www.hibernate.org/dtd/</literal>. The resolver attempts to resolve these entities via the classloader which loaded the Hibernate classes."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3762
#, no-c-format
msgid "a <literal>user namespace</literal> is recognized whenever the resolver encounters a systemId using a <literal>classpath://</literal> URL protocol. The resolver will attempt to resolve these entities via (1) the current thread context classloader and (2) the classloader which loaded the Hibernate classes."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3771
#, no-c-format
msgid "The following is an example of utilizing user namespacing:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3774
#, no-c-format
msgid ""
      "<xi:include href=\"../extras/namespacing.xml_sample\" parse=\"text\"\n"
      "              xmlns:xi=\"http://www.w3.org/2001/XInclude\" />"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3776
#, no-c-format
msgid "Where <literal>types.xml</literal> is a resource in the <literal>your.domain</literal> package and contains a custom <link linkend=\"mapping-types-custom\">typedef</link>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3783
#, no-c-format
msgid "Hibernate-mapping"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3785
#, no-c-format
msgid "This element has several optional attributes. The <literal>schema</literal> and <literal>catalog</literal> attributes specify that tables referred to in this mapping belong to the named schema and/or catalog. If they are specified, tablenames will be qualified by the given schema and catalog names. If they are missing, tablenames will be unqualified. The <literal>default-cascade</literal> attribute specifies what cascade style should be assumed for properties and collections that do not specify a <literal>cascade</literal> attribute. By default, the <literal>auto-import</literal> attribute allows you to use unqualified class names in the query language."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3814
#, no-c-format
msgid ""
      "&lt;hibernate-mapping\n"
      "         schema=\"schemaName\"\n"
      "         catalog=\"catalogName\"\n"
      "         default-cascade=\"cascade_style\"\n"
      "         default-access=\"field|property|ClassName\"\n"
      "         default-lazy=\"true|false\"\n"
      "         auto-import=\"true|false\"\n"
      "         package=\"package.name\"\n"
      " /&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3818
#, no-c-format
msgid "<literal>schema</literal> (optional): the name of a database schema."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3823
#, no-c-format
msgid "<literal>catalog</literal> (optional): the name of a database catalog."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3828
#, no-c-format
msgid "<literal>default-cascade</literal> (optional - defaults to <literal>none</literal>): a default cascade style."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3833
#, no-c-format
msgid "<literal>default-access</literal> (optional - defaults to <literal>property</literal>): the strategy Hibernate should use for accessing all properties. It can be a custom implementation of <literal>PropertyAccessor</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3840
#, no-c-format
msgid "<literal>default-lazy</literal> (optional - defaults to <literal>true</literal>): the default value for unspecified <literal>lazy</literal> attributes of class and collection mappings."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3847
#, no-c-format
msgid "<literal>auto-import</literal> (optional - defaults to <literal>true</literal>): specifies whether we can use unqualified class names of classes in this mapping in the query language."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3854
#, no-c-format
msgid "<literal>package</literal> (optional): specifies a package prefix to use for unqualified class names in the mapping document."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3861
#, no-c-format
msgid "If you have two persistent classes with the same unqualified name, you should set <literal>auto-import=\"false\"</literal>. An exception will result if you attempt to assign two classes to the same \"imported\" name."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3866
#, no-c-format
msgid "The <literal>hibernate-mapping</literal> element allows you to nest several persistent <literal>&lt;class&gt;</literal> mappings, as shown above. It is, however, good practice (and expected by some tools) to map only a single persistent class, or a single class hierarchy, in one mapping file and name it after the persistent superclass. For example, <literal>Cat.hbm.xml</literal>, <literal>Dog.hbm.xml</literal>, or if using inheritance, <literal>Animal.hbm.xml</literal>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3877
#, no-c-format
msgid "<title>Key</title>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3879
#, no-c-format
msgid "The <literal>&lt;key&gt;</literal> element is featured a few times within this guide. It appears anywhere the parent mapping element defines a join to a new table that references the primary key of the original table. It also defines the foreign key in the joined table:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3900
#, no-c-format
msgid ""
      "&lt;key\n"
      "        column=\"columnname\"\n"
      "        on-delete=\"noaction|cascade\"\n"
      "        property-ref=\"propertyName\"\n"
      "        not-null=\"true|false\"\n"
      "        update=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3910
#, no-c-format
msgid "<literal>on-delete</literal> (optional - defaults to <literal>noaction</literal>): specifies whether the foreign key constraint has database-level cascade delete enabled."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3916
#, no-c-format
msgid "<literal>property-ref</literal> (optional): specifies that the foreign key refers to columns that are not the primary key of the original table. It is provided for legacy data."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3922
#, no-c-format
msgid "<literal>not-null</literal> (optional): specifies that the foreign key columns are not nullable. This is implied whenever the foreign key is also part of the primary key."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3928
#, no-c-format
msgid "<literal>update</literal> (optional): specifies that the foreign key should never be updated. This is implied whenever the foreign key is also part of the primary key."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3934
#, no-c-format
msgid "<literal>unique</literal> (optional): specifies that the foreign key should have a unique constraint. This is implied whenever the foreign key is also the primary key."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3941
#, no-c-format
msgid "For systems where delete performance is important, we recommend that all keys should be defined <literal>on-delete=\"cascade\"</literal>. Hibernate uses a database-level <literal>ON CASCADE DELETE</literal> constraint, instead of many individual <literal>DELETE</literal> statements. Be aware that this feature bypasses Hibernate's usual optimistic locking strategy for versioned data."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3949
#, no-c-format
msgid "The <literal>not-null</literal> and <literal>update</literal> attributes are useful when mapping a unidirectional one-to-many association. If you map a unidirectional one-to-many association to a non-nullable foreign key, you <emphasis>must</emphasis> declare the key column using <literal>&lt;key not-null=\"true\"&gt;</literal>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3958
#, no-c-format
msgid "Import"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3960
#, no-c-format
msgid "If your application has two persistent classes with the same name, and you do not want to specify the fully qualified package name in Hibernate queries, classes can be \"imported\" explicitly, rather than relying upon <literal>auto-import=\"true\"</literal>. You can also import classes and interfaces that are not explicitly mapped:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3966
#, no-c-format
msgid "&lt;import class=\"java.lang.Object\" rename=\"Universe\"/&gt;"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3975
#, no-c-format
msgid ""
      "&lt;import\n"
      "        class=\"ClassName\"\n"
      "        rename=\"ShortName\"\n"
      "/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3979
#, no-c-format
msgid "<literal>class</literal>: the fully qualified class name of any Java class."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3984
#, no-c-format
msgid "<literal>rename</literal> (optional - defaults to the unqualified class name): a name that can be used in the query language."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3992
#, no-c-format
msgid "This feature is unique to hbm.xml and is not supported in annotations."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3998
#, no-c-format
msgid "Column and formula elements"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4000
#, no-c-format
msgid "Mapping elements which accept a <literal>column</literal> attribute will alternatively accept a <literal>&lt;column&gt;</literal> subelement. Likewise, <literal>&lt;formula&gt;</literal> is an alternative to the <literal>formula</literal> attribute. For example:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4006
#, no-c-format
msgid ""
      "&lt;column\n"
      "        name=\"column_name\"\n"
      "        length=\"N\"\n"
      "        precision=\"N\"\n"
      "        scale=\"N\"\n"
      "        not-null=\"true|false\"\n"
      "        unique=\"true|false\"\n"
      "        unique-key=\"multicolumn_unique_key_name\"\n"
      "        index=\"index_name\"\n"
      "        sql-type=\"sql_type_name\"\n"
      "        check=\"SQL expression\"\n"
      "        default=\"SQL expression\"\n"
      "        read=\"SQL expression\"\n"
      "        write=\"SQL expression\"/&gt;"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4008
#, no-c-format
msgid "&lt;formula&gt;SQL expression&lt;/formula&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4010
#, no-c-format
msgid "Most of the attributes on <literal>column</literal> provide a means of tailoring the DDL during automatic schema generation. The <literal>read</literal> and <literal>write</literal> attributes allow you to specify custom SQL that Hibernate will use to access the column's value. For more on this, see the discussion of <link linkend=\"mapping-column-read-and-write\">column read and write expressions</link>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4018
#, no-c-format
msgid "The <literal>column</literal> and <literal>formula</literal> elements can even be combined within the same property or association mapping to express, for example, exotic join conditions."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4022
#, no-c-format
msgid ""
      "&lt;many-to-one name=\"homeAddress\" class=\"Address\"\n"
      "        insert=\"false\" update=\"false\"&gt;\n"
      "    &lt;column name=\"person_id\" not-null=\"true\" length=\"10\"/&gt;\n"
      "    &lt;formula&gt;'MAILING'&lt;/formula&gt;\n"
      "&lt;/many-to-one&gt;"
msgstr ""

#. Tag: title
#: basic_mapping.xml:4028
#, no-c-format
msgid "Hibernate types"
msgstr ""

#. Tag: title
#: basic_mapping.xml:4031
#, no-c-format
msgid "Entities and values"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4033
#, no-c-format
msgid "In relation to the persistence service, Java language-level objects are classified into two groups:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4036
#, no-c-format
msgid "An <emphasis>entity</emphasis> exists independently of any other objects holding references to the entity. Contrast this with the usual Java model, where an unreferenced object is garbage collected. Entities must be explicitly saved and deleted. Saves and deletions, however, can be <emphasis>cascaded</emphasis> from a parent entity to its children. This is different from the ODMG model of object persistence by reachability and corresponds more closely to how application objects are usually used in large systems. Entities support circular and shared references. They can also be versioned."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4046
#, no-c-format
msgid "An entity's persistent state consists of references to other entities and instances of <emphasis>value</emphasis> types. Values are primitives: collections (not what is inside a collection), components and certain immutable objects. Unlike entities, values in particular collections and components, <emphasis>are</emphasis> persisted and deleted by reachability. Since value objects and primitives are persisted and deleted along with their containing entity, they cannot be independently versioned. Values have no independent identity, so they cannot be shared by two entities or collections."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4056
#, no-c-format
msgid "Until now, we have been using the term \"persistent class\" to refer to entities. We will continue to do that. Not all user-defined classes with a persistent state, however, are entities. A <emphasis>component</emphasis> is a user-defined class with value semantics. A Java property of type <literal>java.lang.String</literal> also has value semantics. Given this definition, all types (classes) provided by the JDK have value type semantics in Java, while user-defined types can be mapped with entity or value type semantics. This decision is up to the application developer. An entity class in a domain model will normally have shared references to a single instance of that class, while composition or aggregation usually translates to a value type."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4069
#, no-c-format
msgid "We will revisit both concepts throughout this reference guide."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4072
#, no-c-format
msgid "The challenge is to map the Java type system, and the developers' definition of entities and value types, to the SQL/database type system. The bridge between both systems is provided by Hibernate. For entities, <literal>&lt;class&gt;</literal>, <literal>&lt;subclass&gt;</literal> and so on are used. For value types we use <literal>&lt;property&gt;</literal>, <literal>&lt;component&gt;</literal>etc., that usually have a <literal>type</literal> attribute. The value of this attribute is the name of a Hibernate <emphasis>mapping type</emphasis>. Hibernate provides a range of mappings for standard JDK value types out of the box. You can write your own mapping types and implement your own custom conversion strategies."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4085
#, no-c-format
msgid "With the exception of collections, all built-in Hibernate types support null semantics."
msgstr ""

#. Tag: title
#: basic_mapping.xml:4090
#, no-c-format
msgid "Basic value types"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4092
#, no-c-format
msgid "The built-in <emphasis>basic mapping types</emphasis> can be roughly categorized into the following:"
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4095
#, no-c-format
msgid "integer, long, short, float, double, character, byte, boolean, yes_no, true_false"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4099
#, no-c-format
msgid "Type mappings from Java primitives or wrapper classes to appropriate (vendor-specific) SQL column types. <literal>boolean, yes_no</literal> and <literal>true_false</literal> are all alternative encodings for a Java <literal>boolean</literal> or <literal>java.lang.Boolean</literal>."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4109
#, no-c-format
msgid "string"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4112
#, no-c-format
msgid "A type mapping from <literal>java.lang.String</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>)."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4119
#, no-c-format
msgid "date, time, timestamp"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4122
#, no-c-format
msgid "Type mappings from <literal>java.util.Date</literal> and its subclasses to SQL types <literal>DATE</literal>, <literal>TIME</literal> and <literal>TIMESTAMP</literal> (or equivalent)."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4130
#, no-c-format
msgid "calendar, calendar_date"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4133
#, no-c-format
msgid "Type mappings from <literal>java.util.Calendar</literal> to SQL types <literal>TIMESTAMP</literal> and <literal>DATE</literal> (or equivalent)."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4140
#, no-c-format
msgid "big_decimal, big_integer"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4143
#, no-c-format
msgid "Type mappings from <literal>java.math.BigDecimal</literal> and <literal>java.math.BigInteger</literal> to <literal>NUMERIC</literal> (or Oracle <literal>NUMBER</literal>)."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4151
#, no-c-format
msgid "locale, timezone, currency"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4154
#, no-c-format
msgid "Type mappings from <literal>java.util.Locale</literal>, <literal>java.util.TimeZone</literal> and <literal>java.util.Currency</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>). Instances of <literal>Locale</literal> and <literal>Currency</literal> are mapped to their ISO codes. Instances of <literal>TimeZone</literal> are mapped to their <literal>ID</literal>."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4167
#, no-c-format
msgid "class"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4170
#, no-c-format
msgid "A type mapping from <literal>java.lang.Class</literal> to <literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>). A <literal>Class</literal> is mapped to its fully qualified name."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4178
#, no-c-format
msgid "binary"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4181
#, no-c-format
msgid "Maps byte arrays to an appropriate SQL binary type."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4186
#, no-c-format
msgid "text"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4189
#, no-c-format
msgid "Maps long Java strings to a SQL <literal>LONGVARCHAR</literal> or <literal>TEXT</literal> type."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4195
#, no-c-format
msgid "image"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4198
#, no-c-format
msgid "Maps long byte arrays to a SQL <literal>LONGVARBINARY</literal>."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4203
#, no-c-format
msgid "serializable"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4206
#, no-c-format
msgid "Maps serializable Java types to an appropriate SQL binary type. You can also indicate the Hibernate type <literal>serializable</literal> with the name of a serializable Java class or interface that does not default to a basic type."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4215
#, no-c-format
msgid "clob, blob"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4218
#, no-c-format
msgid "Type mappings for the JDBC classes <literal>java.sql.Clob</literal> and <literal>java.sql.Blob</literal>. These types can be inconvenient for some applications, since the blob or clob object cannot be reused outside of a transaction. Driver support is patchy and inconsistent."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4228
#, no-c-format
msgid "materialized_clob"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4231
#, no-c-format
msgid "Maps long Java strings to a SQL <literal>CLOB</literal> type. When read, the <literal>CLOB</literal> value is immediately materialized into a Java string. Some drivers require the <literal>CLOB</literal> value to be read within a transaction. Once materialized, the Java string is available outside of the transaction."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4241
#, no-c-format
msgid "materialized_blob"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4244
#, no-c-format
msgid "Maps long Java byte arrays to a SQL <literal>BLOB</literal> type. When read, the <literal>BLOB</literal> value is immediately materialized into a byte array. Some drivers require the <literal>BLOB</literal> value to be read within a transaction. Once materialized, the byte array is available outside of the transaction."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4254
#, no-c-format
msgid "imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, imm_serializable, imm_binary"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4258
#, no-c-format
msgid "Type mappings for what are considered mutable Java types. This is where Hibernate makes certain optimizations appropriate only for immutable Java types, and the application treats the object as immutable. For example, you should not call <literal>Date.setTime()</literal> for an instance mapped as <literal>imm_timestamp</literal>. To change the value of the property, and have that change made persistent, the application must assign a new, nonidentical, object to the property."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4270
#, no-c-format
msgid "Unique identifiers of entities and collections can be of any basic type except <literal>binary</literal>, <literal>blob</literal> and <literal>clob</literal>. Composite identifiers are also allowed. See below for more information."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4275
#, no-c-format
msgid "The basic value types have corresponding <literal>Type</literal> constants defined on <literal>org.hibernate.Hibernate</literal>. For example, <literal>Hibernate.STRING</literal> represents the <literal>string</literal> type."
msgstr ""

#. Tag: title
#: basic_mapping.xml:4282
#, no-c-format
msgid "Custom value types"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4284
#, no-c-format
msgid "It is relatively easy for developers to create their own value types. For example, you might want to persist properties of type <literal>java.lang.BigInteger</literal> to <literal>VARCHAR</literal> columns. Hibernate does not provide a built-in type for this. Custom types are not limited to mapping a property, or collection element, to a single table column. So, for example, you might have a Java property <literal>getName()</literal>/<literal>setName()</literal> of type <literal>java.lang.String</literal> that is persisted to the columns <literal>FIRST_NAME</literal>, <literal>INITIAL</literal>, <literal>SURNAME</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4295
#, no-c-format
msgid "To implement a custom type, implement either <literal>org.hibernate.UserType</literal> or <literal>org.hibernate.CompositeUserType</literal> and declare properties using the fully qualified classname of the type. View <literal>org.hibernate.test.DoubleStringType</literal> to see the kind of things that are possible."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4302
#, no-c-format
msgid ""
      "&lt;property name=\"twoStrings\" type=\"org.hibernate.test.DoubleStringType\"&gt;\n"
      "    &lt;column name=\"first_string\"/&gt;\n"
      "    &lt;column name=\"second_string\"/&gt;\n"
      "&lt;/property&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4304
#, no-c-format
msgid "Notice the use of <literal>&lt;column&gt;</literal> tags to map a property to multiple columns."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4307
#, no-c-format
msgid "The <literal>CompositeUserType</literal>, <literal>EnhancedUserType</literal>, <literal>UserCollectionType</literal>, and <literal>UserVersionType</literal> interfaces provide support for more specialized uses."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4313
#, no-c-format
msgid "You can even supply parameters to a <literal>UserType</literal> in the mapping file. To do this, your <literal>UserType</literal> must implement the <literal>org.hibernate.usertype.ParameterizedType</literal> interface. To supply parameters to your custom type, you can use the <literal>&lt;type&gt;</literal> element in your mapping files."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4320
#, no-c-format
msgid ""
      "&lt;property name=\"priority\"&gt;\n"
      "    &lt;type name=\"com.mycompany.usertypes.DefaultValueIntegerType\"&gt;\n"
      "        &lt;param name=\"default\"&gt;0&lt;/param&gt;\n"
      "    &lt;/type&gt;\n"
      "&lt;/property&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4322
#, no-c-format
msgid "The <literal>UserType</literal> can now retrieve the value for the parameter named <literal>default</literal> from the <literal>Properties</literal> object passed to it."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4326
#, no-c-format
msgid "If you regularly use a certain <literal>UserType</literal>, it is useful to define a shorter name for it. You can do this using the <literal>&lt;typedef&gt;</literal> element. Typedefs assign a name to a custom type, and can also contain a list of default parameter values if the type is parameterized."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4332
#, no-c-format
msgid ""
      "&lt;typedef class=\"com.mycompany.usertypes.DefaultValueIntegerType\" name=\"default_zero\"&gt;\n"
      "    &lt;param name=\"default\"&gt;0&lt;/param&gt;\n"
      "&lt;/typedef&gt;"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4334
#, no-c-format
msgid "&lt;property name=\"priority\" type=\"default_zero\"/&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4336
#, no-c-format
msgid "It is also possible to override the parameters supplied in a typedef on a case-by-case basis by using type parameters on the property mapping."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4340
#, no-c-format
msgid "Even though Hibernate's rich range of built-in types and support for components means you will rarely need to use a custom type, it is considered good practice to use custom types for non-entity classes that occur frequently in your application. For example, a <literal>MonetaryAmount</literal> class is a good candidate for a <literal>CompositeUserType</literal>, even though it could be mapped as a component. One reason for this is abstraction. With a custom type, your mapping documents would be protected against changes to the way monetary values are represented."
msgstr ""

#. Tag: title
#: basic_mapping.xml:4353
#, no-c-format
msgid "Mapping a class more than once"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4355
#, no-c-format
msgid "It is possible to provide more than one mapping for a particular persistent class. In this case, you must specify an <emphasis>entity name</emphasis> to disambiguate between instances of the two mapped entities. By default, the entity name is the same as the class name. Hibernate lets you specify the entity name when working with persistent objects, when writing queries, or when mapping associations to the named entity."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4363
#, no-c-format
msgid ""
      "&lt;class name=\"Contract\" table=\"Contracts\"\n"
      "        entity-name=\"CurrentContract\"&gt;\n"
      "    ...\n"
      "    &lt;set name=\"history\" inverse=\"true\"\n"
      "            order-by=\"effectiveEndDate desc\"&gt;\n"
      "        &lt;key column=\"currentContractId\"/&gt;\n"
      "        &lt;one-to-many entity-name=\"HistoricalContract\"/&gt;\n"
      "    &lt;/set&gt;\n"
      "&lt;/class&gt;\n"
      "\n"
      "&lt;class name=\"Contract\" table=\"ContractHistory\"\n"
      "        entity-name=\"HistoricalContract\"&gt;\n"
      "    ...\n"
      "    &lt;many-to-one name=\"currentContract\"\n"
      "            column=\"currentContractId\"\n"
      "            entity-name=\"CurrentContract\"/&gt;\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4365
#, no-c-format
msgid "Associations are now specified using <literal>entity-name</literal> instead of <literal>class</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4369 basic_mapping.xml:4497
#, no-c-format
msgid "This feature is not supported in Annotations"
msgstr ""

#. Tag: title
#: basic_mapping.xml:4374
#, no-c-format
msgid "SQL quoted identifiers"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4376
#, no-c-format
msgid "You can force Hibernate to quote an identifier in the generated SQL by enclosing the table or column name in backticks in the mapping document. Hibernate will use the correct quotation style for the SQL <literal>Dialect</literal>. This is usually double quotes, but the SQL Server uses brackets and MySQL uses backticks."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4382
#, no-c-format
msgid ""
      "@Entity @Table(name=\"`Line Item`\")\n"
      "class LineItem {\n"
      "   @id @Column(name=\"`Item Id`\") Integer id;\n"
      "   @Column(name=\"`Item #`\") int itemNumber\n"
      "}\n"
      "\n"
      "&lt;class name=\"LineItem\" table=\"`Line Item`\"&gt;\n"
      "    &lt;id name=\"id\" column=\"`Item Id`\"/&gt;&lt;generator class=\"assigned\"/&gt;&lt;/id&gt;\n"
      "    &lt;property name=\"itemNumber\" column=\"`Item #`\"/&gt;\n"
      "    ...\n"
      "&lt;/class&gt;"
msgstr ""

#. Tag: title
#: basic_mapping.xml:4386
#, no-c-format
msgid "Generated properties"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4388
#, no-c-format
msgid "Generated properties are properties that have their values generated by the database. Typically, Hibernate applications needed to <literal>refresh</literal> objects that contain any properties for which the database was generating values. Marking properties as generated, however, lets the application delegate this responsibility to Hibernate. When Hibernate issues an SQL INSERT or UPDATE for an entity that has defined generated properties, it immediately issues a select afterwards to retrieve the generated values."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4397
#, no-c-format
msgid "Properties marked as generated must additionally be non-insertable and non-updateable. Only <link linkend=\"mapping-declaration-version\">versions</link>, <link linkend=\"mapping-declaration-timestamp\">timestamps</link>, and <link linkend=\"mapping-declaration-property\">simple properties</link>, can be marked as generated."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4404
#, no-c-format
msgid "<literal>never</literal> (the default): the given property value is not generated within the database."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4407
#, no-c-format
msgid "<literal>insert</literal>: the given property value is generated on insert, but is not regenerated on subsequent updates. Properties like created-date fall into this category. Even though <link linkend=\"mapping-declaration-version\">version</link> and <link linkend=\"mapping-declaration-timestamp\">timestamp</link> properties can be marked as generated, this option is not available."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4414
#, no-c-format
msgid "<literal>always</literal>: the property value is generated both on insert and on update."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4417
#, no-c-format
msgid "To mark a property as generated, use <classname>@Generated</classname>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:4422
#, no-c-format
msgid "Column transformers: read and write expressions"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4424
#, no-c-format
msgid "Hibernate allows you to customize the SQL it uses to read and write the values of columns mapped to <link linkend=\"mapping-declaration-property\">simple properties</link>. For example, if your database provides a set of data encryption functions, you can invoke them for individual columns like this:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4430
#, no-c-format
msgid ""
      "@Entity\n"
      "class CreditCard {\n"
      "   @Column(name=\"credit_card_num\")\n"
      "   @ColumnTransformer(\n"
      "      read=\"decrypt(credit_card_num)\", \n"
      "      write=\"encrypt(?)\")\n"
      "   public String getCreditCardNumber() { return creditCardNumber; }\n"
      "   public void setCreditCardNumber(String number) { this.creditCardNumber = number; }\n"
      "   private String creditCardNumber;\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4432
#, no-c-format
msgid "or in XML"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4434
#, no-c-format
msgid ""
      "&lt;property name=\"creditCardNumber\"&gt;\n"
      "        &lt;column \n"
      "          name=\"credit_card_num\"\n"
      "          read=\"decrypt(credit_card_num)\"\n"
      "          write=\"encrypt(?)\"/&gt;\n"
      "&lt;/property&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4437
#, no-c-format
msgid "You can use the plural form <classname>@ColumnTransformers</classname> if more than one columns need to define either of these rules."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4442
#, no-c-format
msgid "If a property uses more that one column, you must use the <literal>forColumn</literal> attribute to specify which column, the expressions are targeting."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4446
#, no-c-format
msgid ""
      "@Entity\n"
      "class User {\n"
      "   @Type(type=\"com.acme.type.CreditCardType\")\n"
      "   @Columns( {\n"
      "      @Column(name=\"credit_card_num\"),\n"
      "      @Column(name=\"exp_date\") } )\n"
      "   @ColumnTransformer(\n"
      "      forColumn=\"credit_card_num\", \n"
      "      read=\"decrypt(credit_card_num)\", \n"
      "      write=\"encrypt(?)\")\n"
      "   public CreditCard getCreditCard() { return creditCard; }\n"
      "   public void setCreditCard(CreditCard card) { this.creditCard = card; }\n"
      "   private CreditCard creditCard;\n"
      "}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4448
#, no-c-format
msgid "Hibernate applies the custom expressions automatically whenever the property is referenced in a query. This functionality is similar to a derived-property <literal>formula</literal> with two differences:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4453
#, no-c-format
msgid "The property is backed by one or more columns that are exported as part of automatic schema generation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4458
#, no-c-format
msgid "The property is read-write, not read-only."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4462
#, no-c-format
msgid "The <literal>write</literal> expression, if specified, must contain exactly one '?' placeholder for the value."
msgstr ""

#. Tag: title
#: basic_mapping.xml:4467
#, no-c-format
msgid "Auxiliary database objects"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4469
#, no-c-format
msgid "Auxiliary database objects allow for the CREATE and DROP of arbitrary database objects. In conjunction with Hibernate's schema evolution tools, they have the ability to fully define a user schema within the Hibernate mapping files. Although designed specifically for creating and dropping things like triggers or stored procedures, any SQL command that can be run via a <literal>java.sql.Statement.execute()</literal> method is valid (for example, ALTERs, INSERTS, etc.). There are essentially two modes for defining auxiliary database objects:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4479
#, no-c-format
msgid "The first mode is to explicitly list the CREATE and DROP commands in the mapping file:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4482
#, no-c-format
msgid ""
      "&lt;hibernate-mapping&gt;\n"
      "    ...\n"
      "    &lt;database-object&gt;\n"
      "        &lt;create&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;\n"
      "        &lt;drop&gt;DROP TRIGGER my_trigger&lt;/drop&gt;\n"
      "    &lt;/database-object&gt;\n"
      "&lt;/hibernate-mapping&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4484
#, no-c-format
msgid "The second mode is to supply a custom class that constructs the CREATE and DROP commands. This custom class must implement the <literal>org.hibernate.mapping.AuxiliaryDatabaseObject</literal> interface."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4489
#, no-c-format
msgid ""
      "&lt;hibernate-mapping&gt;\n"
      "    ...\n"
      "    &lt;database-object&gt;\n"
      "        &lt;definition class=\"MyTriggerDefinition\"/&gt;\n"
      "    &lt;/database-object&gt;\n"
      "&lt;/hibernate-mapping&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4491
#, no-c-format
msgid "Additionally, these database objects can be optionally scoped so that they only apply when certain dialects are used."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4494
#, no-c-format
msgid ""
      "&lt;hibernate-mapping&gt;\n"
      "    ...\n"
      "    &lt;database-object&gt;\n"
      "        &lt;definition class=\"MyTriggerDefinition\"/&gt;\n"
      "        &lt;dialect-scope name=\"org.hibernate.dialect.Oracle9iDialect\"/&gt;\n"
      "        &lt;dialect-scope name=\"org.hibernate.dialect.Oracle10gDialect\"/&gt;\n"
      "    &lt;/database-object&gt;\n"
      "&lt;/hibernate-mapping&gt;"
msgstr ""

