# translation of basic_mapping.po to
# Xi Huang <xhuang@redhat.com>, 2006.
# Xi HUANG <xhuang@redhat.com>, 2007, 2009.
# translation of Collection_Mapping.po to
msgid ""
msgstr ""
"Project-Id-Version: basic_mapping\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2011-01-21 21:18+0000\n"
"PO-Revision-Date: 2010-03-15 08:56+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#: basic_mapping.xml:31
#, no-c-format
msgid "Basic O/R Mapping"
msgstr "对象/关系数据库映射基础（Basic O/R Mapping）"

#. Tag: title
#: basic_mapping.xml:34
#, no-c-format
msgid "Mapping declaration"
msgstr "映射定义（Mapping declaration）"

#. Tag: para
#: basic_mapping.xml:36
#, no-c-format
msgid "Object/relational mappings can be defined in three approaches:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:41
#, no-c-format
msgid "using Java 5 annotations (via the Java Persistence 2 annotations)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:46
#, no-c-format
msgid "using JPA 2 XML deployment descriptors (described in chapter XXX)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:51
#, no-c-format
msgid "using the Hibernate legacy XML files approach known as hbm.xml"
msgstr ""

#. Tag: para
#: basic_mapping.xml:56
#, no-c-format
msgid ""
"Annotations are split in two categories, the logical mapping annotations "
"(describing the object model, the association between two entities etc.) and "
"the physical mapping annotations (describing the physical schema, tables, "
"columns, indexes, etc). We will mix annotations from both categories in the "
"following code examples."
msgstr ""

#. Tag: para
#: basic_mapping.xml:62
#, no-c-format
msgid ""
"JPA annotations are in the <literal>javax.persistence.*</literal> package. "
"Hibernate specific extensions are in <literal>org.hibernate.annotations.*</"
"literal>. You favorite IDE can auto-complete annotations and their "
"attributes for you (even without a specific \"JPA\" plugin, since JPA "
"annotations are plain Java 5 annotations)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:69
#, fuzzy, no-c-format
msgid "Here is an example of mapping"
msgstr "下面是一个映射的例子："

#. Tag: programlisting
#: basic_mapping.xml:71
#, no-c-format
msgid ""
"package eg;\n"
"\n"
"@Entity \n"
"@Table(name=\"cats\") @Inheritance(strategy=SINGLE_TABLE)\n"
"@DiscriminatorValue(\"C\") @DiscriminatorColumn(name=\"subclass\", "
"discriminatorType=CHAR)\n"
"public class Cat {\n"
"   \n"
"   @Id @GeneratedValue\n"
"   public Integer getId() { return id; }\n"
"   public void setId(Integer id) { this.id = id; }\n"
"   private Integer id;\n"
"\n"
"   public BigDecimal getWeight() { return weight; }\n"
"   public void setWeight(BigDecimal weight) { this.weight = weight; }\n"
"   private BigDecimal weight;\n"
"\n"
"   @Temporal(DATE) @NotNull @Column(updatable=false)\n"
"   public Date getBirthdate() { return birthdate; }\n"
"   public void setBirthdate(Date birthdate) { this.birthdate = birthdate; }\n"
"   private Date birthdate;\n"
"\n"
"   @org.hibernate.annotations.Type(type=\"eg.types.ColorUserType\")\n"
"   @NotNull @Column(updatable=false)\n"
"   public ColorType getColor() { return color; }\n"
"   public void setColor(ColorType color) { this.color = color; }\n"
"   private ColorType color;\n"
"\n"
"   @NotNull @Column(updatable=false)\n"
"   public String getSex() { return sex; }\n"
"   public void setSex(String sex) { this.sex = sex; }\n"
"   private String sex;\n"
"\n"
"   @NotNull @Column(updatable=false)\n"
"   public Integer getLitterId() { return litterId; }\n"
"   public void setLitterId(Integer litterId) { this.litterId = litterId; }\n"
"   private Integer litterId;\n"
"\n"
"   @ManyToOne @JoinColumn(name=\"mother_id\", updatable=false)\n"
"   public Cat getMother() { return mother; }\n"
"   public void setMother(Cat mother) { this.mother = mother; }\n"
"   private Cat mother;\n"
"\n"
"   @OneToMany(mappedBy=\"mother\") @OrderBy(\"litterId\")\n"
"   public Set&lt;Cat&gt; getKittens() { return kittens; }\n"
"   public void setKittens(Set&lt;Cat&gt; kittens) { this.kittens = "
"kittens; }\n"
"   private Set&lt;Cat&gt; kittens = new HashSet&lt;Cat&gt;();\n"
"}\n"
"\n"
"@Entity @DiscriminatorValue(\"D\")\n"
"public class DomesticCat extends Cat {\n"
"\n"
"   public String getName() { return name; }\n"
"   public void setName(String name) { this.name = name }\n"
"   private String name;\n"
"}\n"
"\n"
"@Entity\n"
"public class Dog { ... }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:73
#, fuzzy, no-c-format
msgid ""
"The legacy hbm.xml approach uses an XML schema designed to be readable and "
"hand-editable. The mapping language is Java-centric, meaning that mappings "
"are constructed around persistent class declarations and not table "
"declarations."
msgstr ""
"对象和关系数据库之间的映射通常是用一个 XML 文档来定义的。这个映射文档被设计为"
"易读的，并且可以手工修改。映射语言是以 Java 为中心，这意味着映射文档是按照持"
"久化类的定义来创建的，而非表的定义。 "

#. Tag: para
#: basic_mapping.xml:78
#, no-c-format
msgid ""
"Please note that even though many Hibernate users choose to write the XML by "
"hand, a number of tools exist to generate the mapping document. These "
"include XDoclet, Middlegen and AndroMDA."
msgstr ""
"请注意，虽然很多 Hibernate 用户选择手写 XML 映射文档，但也有一些工具可以用来"
"生成映射文档，包括 XDoclet、Middlegen 和 AndroMDA。"

#. Tag: para
#: basic_mapping.xml:82
#, no-c-format
msgid "Here is an example mapping:"
msgstr "下面是一个映射的例子："

#. Tag: programlisting
#: basic_mapping.xml:84
#, fuzzy, no-c-format
msgid ""
"&lt;?xml version=\"1.0\"?&gt;\n"
"&lt;!DOCTYPE hibernate-mapping PUBLIC\n"
"      \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
"          \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n"
"\n"
"&lt;hibernate-mapping package=\"eg\"&gt;\n"
"\n"
"        &lt;class name=\"Cat\"\n"
"            table=\"cats\"\n"
"            discriminator-value=\"C\"&gt;\n"
"\n"
"                &lt;id name=\"id\"&gt;\n"
"                        &lt;generator class=\"native\"/&gt;\n"
"                &lt;/id&gt;\n"
"\n"
"                &lt;discriminator column=\"subclass\"\n"
"                     type=\"character\"/&gt;\n"
"\n"
"                &lt;property name=\"weight\"/&gt;\n"
"\n"
"                &lt;property name=\"birthdate\"\n"
"                    type=\"date\"\n"
"                    not-null=\"true\"\n"
"                    update=\"false\"/&gt;\n"
"\n"
"                &lt;property name=\"color\"\n"
"                    type=\"eg.types.ColorUserType\"\n"
"                    not-null=\"true\"\n"
"                    update=\"false\"/&gt;\n"
"\n"
"                &lt;property name=\"sex\"\n"
"                    not-null=\"true\"\n"
"                    update=\"false\"/&gt;\n"
"\n"
"                &lt;property name=\"litterId\"\n"
"                    column=\"litterId\"\n"
"                    update=\"false\"/&gt;\n"
"\n"
"                &lt;many-to-one name=\"mother\"\n"
"                    column=\"mother_id\"\n"
"                    update=\"false\"/&gt;\n"
"\n"
"                &lt;set name=\"kittens\"\n"
"                    inverse=\"true\"\n"
"                    order-by=\"litter_id\"&gt;\n"
"                        &lt;key column=\"mother_id\"/&gt;\n"
"                        &lt;one-to-many class=\"Cat\"/&gt;\n"
"                &lt;/set&gt;\n"
"\n"
"                &lt;subclass name=\"DomesticCat\"\n"
"                    discriminator-value=\"D\"&gt;\n"
"\n"
"                        &lt;property name=\"name\"\n"
"                            type=\"string\"/&gt;\n"
"\n"
"                &lt;/subclass&gt;\n"
"\n"
"        &lt;/class&gt;\n"
"\n"
"        &lt;class name=\"Dog\"&gt;\n"
"                &lt;!-- mapping for Dog could go here --&gt;\n"
"        &lt;/class&gt;\n"
"\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""
"<![CDATA[<?xml version=\"1.0\"?>\n"
"<!DOCTYPE hibernate-mapping PUBLIC\n"
"      \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
"          \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\">\n"
"\n"
"<hibernate-mapping package=\"eg\">\n"
"\n"
"        <class name=\"Cat\"\n"
"            table=\"cats\"\n"
"            discriminator-value=\"C\">\n"
"\n"
"                <id name=\"id\">\n"
"                        <generator class=\"native\"/>\n"
"                </id>\n"
"\n"
"                <discriminator column=\"subclass\"\n"
"                     type=\"character\"/>\n"
"\n"
"                <property name=\"weight\"/>\n"
"\n"
"                <property name=\"birthdate\"\n"
"                    type=\"date\"\n"
"                    not-null=\"true\"\n"
"                    update=\"false\"/>\n"
"\n"
"                <property name=\"color\"\n"
"                    type=\"eg.types.ColorUserType\"\n"
"                    not-null=\"true\"\n"
"                    update=\"false\"/>\n"
"\n"
"                <property name=\"sex\"\n"
"                    not-null=\"true\"\n"
"                    update=\"false\"/>\n"
"\n"
"                <property name=\"litterId\"\n"
"                    column=\"litterId\"\n"
"                    update=\"false\"/>\n"
"\n"
"                <many-to-one name=\"mother\"\n"
"                    column=\"mother_id\"\n"
"                    update=\"false\"/>\n"
"\n"
"                <set name=\"kittens\"\n"
"                    inverse=\"true\"\n"
"                    order-by=\"litter_id\">\n"
"                        <key column=\"mother_id\"/>\n"
"                        <one-to-many class=\"Cat\"/>\n"
"                </set>\n"
"\n"
"                <subclass name=\"DomesticCat\"\n"
"                    discriminator-value=\"D\">\n"
"\n"
"                        <property name=\"name\"\n"
"                            type=\"string\"/>\n"
"\n"
"                </subclass>\n"
"\n"
"        </class>\n"
"\n"
"        <class name=\"Dog\">\n"
"                <!-- mapping for Dog could go here -->\n"
"        </class>\n"
"\n"
"</hibernate-mapping>]]>"

#. Tag: para
#: basic_mapping.xml:86
#, fuzzy, no-c-format
msgid ""
"We will now discuss the concepts of the mapping documents (both annotations "
"and XML). We will only describe, however, the document elements and "
"attributes that are used by Hibernate at runtime. The mapping document also "
"contains some extra optional attributes and elements that affect the "
"database schemas exported by the schema export tool (for example, the "
"<literal> not-null</literal> attribute)."
msgstr ""
"我们现在开始讨论映射文档的内容。我们只描述 Hibernate 在运行时用到的文档元素和"
"属性。映射文档还包括一些额外的可选属性和元素，它们在使用 schema 导出工具的时"
"候会影响导出的数据库 schema 结果（比如，<literal>not-null</literal> 属性）。"

#. Tag: title
#: basic_mapping.xml:94
#, fuzzy, no-c-format
msgid "Entity"
msgstr "identity"

#. Tag: para
#: basic_mapping.xml:96
#, no-c-format
msgid ""
"An entity is a regular Java object (aka POJO) which will be persisted by "
"Hibernate."
msgstr ""

#. Tag: para
#: basic_mapping.xml:99
#, no-c-format
msgid ""
"To mark an object as an entity in annotations, use the <classname>@Entity</"
"classname> annotation."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:102
#, no-c-format
msgid ""
"@Entity\n"
"public class Flight implements Serializable {\n"
"    Long id;\n"
"\n"
"    @Id\n"
"    public Long getId() { return id; }\n"
"\n"
"    public void setId(Long id) { this.id = id; }\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:104
#, no-c-format
msgid ""
"That's pretty much it, the rest is optional. There are however any options "
"to tweak your entity mapping, let's explore them."
msgstr ""

#. Tag: para
#: basic_mapping.xml:107
#, no-c-format
msgid ""
"<classname>@Table</classname> lets you define the table the entity will be "
"persisted into. If undefined, the table name is the unqualified class name "
"of the entity. You can also optionally define the catalog, the schema as "
"well as unique constraints on the table."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:112
#, no-c-format
msgid ""
"@Entity\n"
"@Table(name=\"TBL_FLIGHT\", \n"
"       schema=\"AIR_COMMAND\", \n"
"       uniqueConstraints=\n"
"           @UniqueConstraint(\n"
"               name=\"flight_number\", \n"
"               columnNames={\"comp_prefix\", \"flight_number\"} ) )\n"
"public class Flight implements Serializable {\n"
"    @Column(name=\"comp_prefix\")\n"
"    public String getCompagnyPrefix() { return companyPrefix; }\n"
"\n"
"    @Column(name=\"flight_number\")\n"
"    public String getNumber() { return number; }\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:114
#, no-c-format
msgid ""
"The constraint name is optional (generated if left undefined). The column "
"names composing the constraint correspond to the column names as defined "
"before the Hibernate <classname>NamingStrategy</classname> is applied."
msgstr ""

#. Tag: para
#: basic_mapping.xml:119
#, no-c-format
msgid ""
"<literal>@Entity.name</literal> lets you define the shortcut name of the "
"entity you can used in JP-QL and HQL queries. It defaults to the unqualified "
"class name of the class."
msgstr ""

#. Tag: para
#: basic_mapping.xml:123
#, no-c-format
msgid ""
"Hibernate goes beyond the JPA specification and provide additional "
"configurations. Some of them are hosted on <classname>@org.hibernate."
"annotations.Entity</classname>:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:129
#, fuzzy, no-c-format
msgid ""
"<literal>dynamicInsert</literal> / <literal>dynamicUpdate</literal> "
"(defaults to false): specifies that <literal>INSERT</literal> / "
"<literal>UPDATE</literal> SQL should be generated at runtime and contain "
"only the columns whose values are not null. The <literal>dynamic-update</"
"literal> and <literal>dynamic-insert</literal> settings are not inherited by "
"subclasses. Although these settings can increase performance in some cases, "
"they can actually decrease performance in others."
msgstr ""
"请注意 <literal>dynamic-update</literal> 和 <literal>dynamic-insert</"
"literal> 的设置并不会继承到子类，所以在 <literal>&lt;subclass&gt;</literal> "
"或者 <literal>&lt;joined-subclass&gt;</literal> 元素中可能需要再次设置。这些"
"设置在某些情况下能够提高效率，而其他情况下则反而可能降低性能。"

#. Tag: para
#: basic_mapping.xml:140
#, fuzzy, no-c-format
msgid ""
"<literal>selectBeforeUpdate</literal> (defaults to false): specifies that "
"Hibernate should <emphasis>never</emphasis> perform an SQL <literal>UPDATE</"
"literal> unless it is certain that an object is actually modified. Only when "
"a transient object has been associated with a new session using "
"<literal>update()</literal>, will Hibernate perform an extra SQL "
"<literal>SELECT</literal> to determine if an <literal>UPDATE</literal> is "
"actually required. Use of <literal>select-before-update</literal> will "
"usually decrease performance. It is useful to prevent a database update "
"trigger being called unnecessarily if you reattach a graph of detached "
"instances to a <literal>Session</literal>."
msgstr ""
"<literal>select-before-update</literal>（可选，默认为 <literal>false</"
"literal>）：指定 Hibernate 除非确定对象真正被修改了（如果该值为 true — 译"
"注），否则<emphasis>不会</emphasis>执行 SQL <literal>UPDATE</literal> 操作。"
"在特定场合（实际上，它只在一个瞬时对象（transient object）关联到一个新的 "
"session 中时执行的 update() 中生效），这说明 Hibernate 会在 <literal>UPDATE</"
"literal> 之前执行一次额外的 SQL <literal>SELECT</literal> 操作来决定是否确实"
"需要执行 <literal>UPDATE</literal>。"

#. Tag: para
#: basic_mapping.xml:154
#, fuzzy, no-c-format
msgid ""
"<literal>polymorphisms</literal> (defaults to <literal>IMPLICIT</literal>): "
"determines whether implicit or explicit query polymorphisms is used. "
"<emphasis>Implicit</emphasis> polymorphisms means that instances of the "
"class will be returned by a query that names any superclass or implemented "
"interface or class, and that instances of any subclass of the class will be "
"returned by a query that names the class itself. <emphasis>Explicit</"
"emphasis> polymorphisms means that class instances will be returned only by "
"queries that explicitly name that class. Queries that name the class will "
"return only instances of subclasses mapped. For most purposes, the default "
"<literal>polymorphisms=IMPLICIT</literal> is appropriate. Explicit "
"polymorphisms is useful when two different classes are mapped to the same "
"table This allows a \"lightweight\" class that contains a subset of the "
"table columns."
msgstr ""
"<emphasis>Implicit</emphasis>（隐式）的多态是指，如果查询时给出的是任何超类、"
"该类实现的接口或者该类的名字，都会返回这个类的实例；如果查询中给出的是子类的"
"名字，则会返回子类的实例。<emphasis>Explicit</emphasis>（显式）的多态是指，只"
"有在查询时给出明确的该类名字时才会返回这个类的实例； 同时只有在这个 "
"<literal>&lt;class&gt;</literal> 的定义中作为 <literal>&lt;subclass&gt;</"
"literal> 或者 <literal>&lt;joined-subclass&gt;</literal> 出现的子类，才会可能"
"返回。在大多数情况下，默认的 <literal>polymorphism=\"implicit\"</literal> 都"
"是合适的。显式的多态在有两个不同的类映射到同一个表的时候很有用。（允许一个“轻"
"量级”的类，只包含部分表字段）。 "

#. Tag: para
#: basic_mapping.xml:171
#, fuzzy, no-c-format
msgid ""
"<literal>persister</literal>: specifies a custom <literal>ClassPersister</"
"literal>. The <literal>persister</literal> attribute lets you customize the "
"persistence strategy used for the class. You can, for example, specify your "
"own subclass of <literal>org.hibernate.persister.EntityPersister</literal>, "
"or you can even provide a completely new implementation of the interface "
"<literal>org.hibernate.persister.ClassPersister</literal> that implements, "
"for example, persistence via stored procedure calls, serialization to flat "
"files or LDAP. See <literal>org.hibernate.test.CustomPersister</literal> for "
"a simple example of \"persistence\" to a <literal>Hashtable</literal>."
msgstr ""
"<literal>persister</literal> 属性可以让你定制这个类使用的持久化策略。你可以指"
"定你自己实现 <literal>org.hibernate.persister.EntityPersister</literal> 的子"
"类，你甚至可以完全从头开始编写一个 <literal>org.hibernate.persister."
"ClassPersister</literal> 接口的实现，比如是用储存过程调用、序列化到文件或者 "
"LDAP 数据库来实现。参阅 <literal>org.hibernate.test.CustomPersister</"
"literal>，这是持久化到 <literal>Hashtable</literal> 的一个简单例子。 "

#. Tag: para
#: basic_mapping.xml:185
#, fuzzy, no-c-format
msgid ""
"<literal>optimisticLock</literal> (defaults to <literal>VERSION</literal>): "
"determines the optimistic locking strategy. If you enable "
"<literal>dynamicUpdate</literal>, you will have a choice of optimistic "
"locking strategies:"
msgstr ""
"如果你打开了<literal>dynamic-update</literal>，你可以选择几种乐观锁定的策略："

#. Tag: para
#: basic_mapping.xml:192
#, no-c-format
msgid "<literal>version</literal>: check the version/timestamp columns"
msgstr "<literal>version（版本检查）</literal>：检查 version/timestamp 字段"

#. Tag: para
#: basic_mapping.xml:197
#, no-c-format
msgid "<literal>all</literal>: check all columns"
msgstr "<literal>all（全部）</literal>：检查全部字段"

#. Tag: para
#: basic_mapping.xml:201
#, no-c-format
msgid ""
"<literal>dirty</literal>: check the changed columns, allowing some "
"concurrent updates"
msgstr ""
"<literal>dirty（脏检查）</literal>：只检察修改过的字段，允许某些并行更新"

#. Tag: para
#: basic_mapping.xml:206
#, no-c-format
msgid "<literal>none</literal>: do not use optimistic locking"
msgstr "<literal>none（不检查）</literal>：不使用乐观锁定"

#. Tag: para
#: basic_mapping.xml:211
#, no-c-format
msgid ""
"It is <emphasis>strongly</emphasis> recommended that you use version/"
"timestamp columns for optimistic locking with Hibernate. This strategy "
"optimizes performance and correctly handles modifications made to detached "
"instances (i.e. when <literal>Session.merge()</literal> is used)."
msgstr ""
"我们<emphasis>强烈</emphasis>建议你在 Hibernate 中使用 version/timestamp 字段"
"来进行乐观锁定。这个选择可以优化性能，且能够处理对脱管实例的修改（例如：在使"
"用 <literal>Session.merge()</literal> 的时候）。"

#. Tag: para
#: basic_mapping.xml:220
#, no-c-format
msgid ""
"Be sure to import <classname>@javax.persistence.Entity</classname> to mark a "
"class as an entity. It's a common mistake to import <classname>@org."
"hibernate.annotations.Entity</classname> by accident."
msgstr ""

#. Tag: para
#: basic_mapping.xml:227
#, fuzzy, no-c-format
msgid ""
"Some entities are not mutable. They cannot be updated or deleted by the "
"application. This allows Hibernate to make some minor performance "
"optimizations.. Use the <classname>@Immutable</classname> annotation."
msgstr ""
"不可变类，<literal>mutable=\"false\"</literal> 不可以被应用程序更新或者删除。"
"这允许 Hibernate 实现一些小小的性能优化。"

#. Tag: para
#: basic_mapping.xml:232
#, fuzzy, no-c-format
msgid ""
"You can also alter how Hibernate deals with lazy initialization for this "
"class. On <classname>@Proxy</classname>, use <literal>lazy</literal>=false "
"to disable lazy fetching (not recommended). You can also specify an "
"interface to use for lazy initializing proxies (defaults to the class "
"itself): use <literal>proxyClass</literal> on <classname>@Proxy</classname>. "
"Hibernate will initially return proxies (Javassist or CGLIB) that implement "
"the named interface. The persistent object will load when a method of the "
"proxy is invoked. See \"Initializing collections and proxies\" below."
msgstr ""
"可选的 <literal>proxy</literal> 属性允许延迟加载类的持久化实例。Hibernate 开"
"始会返回实现了这个命名接口的 CGLIB 代理。当代理的某个方法被实际调用的时候，真"
"实的持久化对象才会被装载。参见下面的“用于延迟装载的代理”。 "

#. Tag: para
#: basic_mapping.xml:243
#, no-c-format
msgid ""
"<classname>@BatchSize</classname> specifies a \"batch size\" for fetching "
"instances of this class by identifier. Not yet loaded instances are loaded "
"batch-size at a time (default 1)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:247
#, fuzzy, no-c-format
msgid ""
"You can specific an arbitrary SQL WHERE condition to be used when retrieving "
"objects of this class. Use <classname>@Where</classname> for that."
msgstr ""
"<literal>where</literal>（可选）指定一个附加的 SQL <literal>WHERE</literal> "
"条件，在抓取这个类的对象时会一直增加这个条件。 "

#. Tag: para
#: basic_mapping.xml:251
#, fuzzy, no-c-format
msgid ""
"In the same vein, <classname>@Check</classname> lets you define an SQL "
"expression used to generate a multi-row <emphasis>check</emphasis> "
"constraint for automatic schema generation."
msgstr ""
"<literal>check</literal>（可选）：这是一个 SQL 表达式， 用于为自动生成的 "
"schema 添加多行（multi-row）约束<emphasis>检查</emphasis>。 "

#. Tag: para
#: basic_mapping.xml:255
#, fuzzy, no-c-format
msgid ""
"There is no difference between a view and a base table for a Hibernate "
"mapping. This is transparent at the database level, although some DBMS do "
"not support views properly, especially with updates. Sometimes you want to "
"use a view, but you cannot create one in the database (i.e. with a legacy "
"schema). In this case, you can map an immutable and read-only entity to a "
"given SQL subselect expression using <classname>@org.hibernate.annotations."
"Subselect</classname>:"
msgstr ""
"对 Hibernate 映射来说视图和表是没有区别的，这是因为它们在数据层都是透明的"
"（ 注意：一些数据库不支持视图属性，特别是更新的时候）。有时你想使用视图，但却"
"不能在数据库中创建它（例如：在遗留的 schema 中）。这样的话，你可以映射一个不"
"可变的（immutable）并且是 只读的实体到一个给定的 SQL 子查询表达式： "

#. Tag: programlisting
#: basic_mapping.xml:263
#, fuzzy, no-c-format
msgid ""
"@Entity\n"
"@Subselect(\"select item.name, max(bid.amount), count(*) \"\n"
"        + \"from item \"\n"
"        + \"join bid on bid.item_id = item.id \"\n"
"        + \"group by item.name\")\n"
"@Synchronize( {\"item\", \"bid\"} ) //tables impacted\n"
"public class Summary {\n"
"    @Id\n"
"    public String getId() { return id; }\n"
"    ...\n"
"}"
msgstr ""
"<![CDATA[<class name=\"Summary\">\n"
"    <subselect>\n"
"        select item.name, max(bid.amount), count(*)\n"
"        from item\n"
"        join bid on bid.item_id = item.id\n"
"        group by item.name\n"
"    </subselect>\n"
"    <synchronize table=\"item\"/>\n"
"    <synchronize table=\"bid\"/>\n"
"    <id name=\"name\"/>\n"
"    ...\n"
"</class>]]>"

#. Tag: para
#: basic_mapping.xml:265
#, no-c-format
msgid ""
"Declare the tables to synchronize this entity with, ensuring that auto-flush "
"happens correctly and that queries against the derived entity do not return "
"stale data. The <literal>&lt;subselect&gt;</literal> is available both as an "
"attribute and a nested mapping element."
msgstr ""
"定义这个实体用到的表为同步（synchronize），确保自动刷新（auto-flush）正确执"
"行，并且依赖原实体的查询不会返回过期数据。在属性元素和嵌套映射元素中都可使用 "
"<literal>&lt;subselect&gt;</literal>。"

#. Tag: para
#: basic_mapping.xml:270
#, fuzzy, no-c-format
msgid ""
"We will now explore the same options using the hbm.xml structure. You can "
"declare a persistent class using the <literal>class</literal> element. For "
"example:"
msgstr "你可以使用 <literal>class</literal> 元素来定义一个持久化类。例如："

#. Tag: programlisting
#: basic_mapping.xml:319
#, fuzzy, no-c-format
msgid ""
"&lt;class\n"
"        name=\"ClassName\"\n"
"        table=\"tableName\"\n"
"        discriminator-value=\"discriminator_value\"\n"
"        mutable=\"true|false\"\n"
"        schema=\"owner\"\n"
"        catalog=\"catalog\"\n"
"        proxy=\"ProxyInterface\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        select-before-update=\"true|false\"\n"
"        polymorphism=\"implicit|explicit\"\n"
"        where=\"arbitrary sql where condition\"\n"
"        persister=\"PersisterClass\"\n"
"        batch-size=\"N\"\n"
"        optimistic-lock=\"none|version|dirty|all\"\n"
"        lazy=\"true|false\"\n"
"        entity-name=\"EntityName\"\n"
"        check=\"arbitrary sql check condition\"\n"
"        rowid=\"rowid\"\n"
"        subselect=\"SQL expression\"\n"
"        abstract=\"true|false\"\n"
"        node=\"element-name\"\n"
"/&gt;"
msgstr ""
"<![CDATA[<class\n"
"        name=\"ClassName\"\n"
"        table=\"tableName\"\n"
"        discriminator-value=\"discriminator_value\"\n"
"        mutable=\"true|false\"\n"
"        schema=\"owner\"\n"
"        catalog=\"catalog\"\n"
"        proxy=\"ProxyInterface\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        select-before-update=\"true|false\"\n"
"        polymorphism=\"implicit|explicit\"\n"
"        where=\"arbitrary sql where condition\"\n"
"        persister=\"PersisterClass\"\n"
"        batch-size=\"N\"\n"
"        optimistic-lock=\"none|version|dirty|all\"\n"
"        lazy=\"true|false\"\n"
"        entity-name=\"EntityName\"\n"
"        check=\"arbitrary sql check condition\"\n"
"        rowid=\"rowid\"\n"
"        subselect=\"SQL expression\"\n"
"        abstract=\"true|false\"\n"
"        node=\"element-name\"\n"
"/>]]>"

#. Tag: para
#: basic_mapping.xml:323
#, no-c-format
msgid ""
"<literal>name</literal> (optional): the fully qualified Java class name of "
"the persistent class or interface. If this attribute is missing, it is "
"assumed that the mapping is for a non-POJO entity."
msgstr ""
"<literal>name</literal>（可选）：持久化类（或者接口）的 Java 全限定名。 如果"
"这个属性不存在，Hibernate 将假定这是一个非 POJO 的实体映射。 "

#. Tag: para
#: basic_mapping.xml:330
#, no-c-format
msgid ""
"<literal>table</literal> (optional - defaults to the unqualified class "
"name): the name of its database table."
msgstr ""
"<literal>table</literal>（可选 — 默认是类的非全限定名）：对应的数据库表名。 "

#. Tag: para
#: basic_mapping.xml:335
#, no-c-format
msgid ""
"<literal>discriminator-value</literal> (optional - defaults to the class "
"name): a value that distinguishes individual subclasses that is used for "
"polymorphic behavior. Acceptable values include <literal>null</literal> and "
"<literal>not null</literal>."
msgstr ""
"<literal>discriminator-value</literal>（可选 — 默认和类名一样）：一个用于区分"
"不同的子类的值，在多态行为时使用。它可以接受的值包括 <literal>null</literal> "
"和 <literal>not null</literal>。 "

#. Tag: para
#: basic_mapping.xml:343
#, no-c-format
msgid ""
"<literal>mutable</literal> (optional - defaults to <literal>true</literal>): "
"specifies that instances of the class are (not) mutable."
msgstr ""
"<literal>mutable</literal>（可选，默认值为 <literal>true</literal>）：表明该"
"类的实例是可变的或者不可变的。 "

#. Tag: para
#: basic_mapping.xml:349 basic_mapping.xml:2948
#, no-c-format
msgid ""
"<literal>schema</literal> (optional): overrides the schema name specified by "
"the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr ""
"<literal>schema</literal>（可选）：覆盖在根 <literal>&lt;hibernate-"
"mapping&gt;</literal> 元素中指定的 schema 名字。 "

#. Tag: para
#: basic_mapping.xml:355 basic_mapping.xml:2954
#, no-c-format
msgid ""
"<literal>catalog</literal> (optional): overrides the catalog name specified "
"by the root <literal>&lt;hibernate-mapping&gt;</literal> element."
msgstr ""
"<literal>catalog</literal>（可选）：覆盖在根 <literal>&lt;hibernate-"
"mapping&gt;</literal> 元素中指定的 catalog 名字。 "

#. Tag: para
#: basic_mapping.xml:361
#, no-c-format
msgid ""
"<literal>proxy</literal> (optional): specifies an interface to use for lazy "
"initializing proxies. You can specify the name of the class itself."
msgstr ""
"<literal>proxy</literal>（可选）：指定一个接口，在延迟装载时作为代理使用。你"
"可以在这里使用该类自己的名字。 "

#. Tag: para
#: basic_mapping.xml:367
#, no-c-format
msgid ""
"<literal>dynamic-update</literal> (optional - defaults to <literal>false</"
"literal>): specifies that <literal>UPDATE</literal> SQL should be generated "
"at runtime and can contain only those columns whose values have changed."
msgstr ""
"<literal>dynamic-update</literal>（可选，默认为 <literal>false</literal>）："
"指定用于 <literal>UPDATE</literal> 的 SQL 将会在运行时动态生成，并且只更新那"
"些改变过的字段。 "

#. Tag: para
#: basic_mapping.xml:374
#, no-c-format
msgid ""
"<literal>dynamic-insert</literal> (optional - defaults to <literal>false</"
"literal>): specifies that <literal>INSERT</literal> SQL should be generated "
"at runtime and contain only the columns whose values are not null."
msgstr ""
"<literal>dynamic-insert</literal>（可选，默认为 <literal>false</literal>）："
"指定用于 <literal>INSERT</literal> 的 SQL 将会在运行时动态生成，并且只包含那"
"些非空值字段。 "

#. Tag: para
#: basic_mapping.xml:381
#, no-c-format
msgid ""
"<literal>select-before-update</literal> (optional - defaults to "
"<literal>false</literal>): specifies that Hibernate should <emphasis>never</"
"emphasis> perform an SQL <literal>UPDATE</literal> unless it is certain that "
"an object is actually modified. Only when a transient object has been "
"associated with a new session using <literal>update()</literal>, will "
"Hibernate perform an extra SQL <literal>SELECT</literal> to determine if an "
"<literal>UPDATE</literal> is actually required."
msgstr ""
"<literal>select-before-update</literal>（可选，默认为 <literal>false</"
"literal>）：指定 Hibernate 除非确定对象真正被修改了（如果该值为 true — 译"
"注），否则<emphasis>不会</emphasis>执行 SQL <literal>UPDATE</literal> 操作。"
"在特定场合（实际上，它只在一个瞬时对象（transient object）关联到一个新的 "
"session 中时执行的 update() 中生效），这说明 Hibernate 会在 <literal>UPDATE</"
"literal> 之前执行一次额外的 SQL <literal>SELECT</literal> 操作来决定是否确实"
"需要执行 <literal>UPDATE</literal>。"

#. Tag: para
#: basic_mapping.xml:393
#, fuzzy, no-c-format
msgid ""
"<literal>polymorphisms</literal> (optional - defaults to <literal>implicit</"
"literal>): determines whether implicit or explicit query polymorphisms is "
"used."
msgstr ""
"<literal>polymorphism（多态）</literal>（可选，默认值为 <literal>implicit "
"（隐式）</literal>）：界定是隐式还是显式的使用多态查询（这只在 Hibernate 的具"
"体表继承策略中用到 — 译注）。 "

#. Tag: para
#: basic_mapping.xml:399
#, no-c-format
msgid ""
"<literal>where</literal> (optional): specifies an arbitrary SQL "
"<literal>WHERE</literal> condition to be used when retrieving objects of "
"this class."
msgstr ""
"<literal>where</literal>（可选）指定一个附加的 SQL <literal>WHERE</literal> "
"条件，在抓取这个类的对象时会一直增加这个条件。 "

#. Tag: para
#: basic_mapping.xml:405
#, no-c-format
msgid ""
"<literal>persister</literal> (optional): specifies a custom "
"<literal>ClassPersister</literal>."
msgstr ""
"<literal>persister</literal>（可选）：指定一个定制的 "
"<literal>ClassPersister</literal>。 "

#. Tag: para
#: basic_mapping.xml:410
#, no-c-format
msgid ""
"<literal>batch-size</literal> (optional - defaults to <literal>1</literal>): "
"specifies a \"batch size\" for fetching instances of this class by "
"identifier."
msgstr ""
"<literal>batch-size</literal>（可选,默认是 <literal>1</literal>）指定一个用"
"于 根据标识符（identifier）抓取实例时使用的 \"batch size\"（批次抓取数量）。 "

#. Tag: para
#: basic_mapping.xml:416
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>version</"
"literal>): determines the optimistic locking strategy."
msgstr ""
"<literal>optimistic-lock（乐观锁定）</literal>（可选，默认是 "
"<literal>version</literal>）：决定乐观锁定的策略。 "

#. Tag: para
#: basic_mapping.xml:422
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional): lazy fetching can be disabled by setting "
"<literal>lazy=\"false\"</literal>."
msgstr ""
"<literal>lazy</literal>（可选）：通过设置 <literal>lazy=\"false\"</literal>，"
"所有的延迟加载（Lazy fetching）功能将被全部禁用（disabled）。"

#. Tag: para
#: basic_mapping.xml:427
#, fuzzy, no-c-format
msgid ""
"<literal>entity-name</literal> (optional - defaults to the class name): "
"Hibernate3 allows a class to be mapped multiple times, potentially to "
"different tables. It also allows entity mappings that are represented by "
"Maps or XML at the Java level. In these cases, you should provide an "
"explicit arbitrary name for the entity. See <xref linkend=\"persistent-"
"classes-dynamicmodels\"/> and <xref linkend=\"xml\"/> for more information."
msgstr ""
"<literal>entity-name</literal>（可选，默认为类名）：Hibernate3 允许一个类进行"
"多次映射（前提是映射到不同的表），并且允许使用 Maps 或 XML 代替 Java 层次的实"
"体映射（也就是实现动态领域模型，不用写持久化类－译注）。更多信息请看 <xref "
"linkend=\"persistent-classes-dynamicmodels\"/> 和 <xref linkend=\"xml\"/>。 "

#. Tag: para
#: basic_mapping.xml:437
#, no-c-format
msgid ""
"<literal>check</literal> (optional): an SQL expression used to generate a "
"multi-row <emphasis>check</emphasis> constraint for automatic schema "
"generation."
msgstr ""
"<literal>check</literal>（可选）：这是一个 SQL 表达式， 用于为自动生成的 "
"schema 添加多行（multi-row）约束<emphasis>检查</emphasis>。 "

#. Tag: para
#: basic_mapping.xml:443
#, no-c-format
msgid ""
"<literal>rowid</literal> (optional): Hibernate can use ROWIDs on databases. "
"On Oracle, for example, Hibernate can use the <literal>rowid</literal> extra "
"column for fast updates once this option has been set to <literal>rowid</"
"literal>. A ROWID is an implementation detail and represents the physical "
"location of a stored tuple."
msgstr ""
"<literal>rowid</literal>（可选）：Hibernate 可以使用数据库支持的所谓的 "
"ROWIDs，例如：Oracle 数据库，如果你设置这个可选的 <literal>rowid</literal>，"
"Hibernate 可以使用额外的字段 <literal>rowid</literal> 实现快速更新。ROWID 是"
"这个功能实现的重点，它代表了一个存储元组（tuple）的物理位置。 "

#. Tag: para
#: basic_mapping.xml:452
#, no-c-format
msgid ""
"<literal>subselect</literal> (optional): maps an immutable and read-only "
"entity to a database subselect. This is useful if you want to have a view "
"instead of a base table. See below for more information."
msgstr ""
"<literal>subselect</literal>（可选）：它将一个不可变（immutable）并且只读的实"
"体映射到一个数据库的子查询中。当你想用视图代替一张基本表的时候，这是有用的，"
"但最好不要这样做。更多的介绍请看下面内容。 "

#. Tag: para
#: basic_mapping.xml:459
#, no-c-format
msgid ""
"<literal>abstract</literal> (optional): is used to mark abstract "
"superclasses in <literal>&lt;union-subclass&gt;</literal> hierarchies."
msgstr ""
"<literal>abstract</literal>（可选）：用于在 <literal>&lt;union-subclass&gt;</"
"literal> 的层次结构（hierarchies）中标识抽象超类。"

#. Tag: para
#: basic_mapping.xml:466
#, no-c-format
msgid ""
"It is acceptable for the named persistent class to be an interface. You can "
"declare implementing classes of that interface using the <literal>&lt;"
"subclass&gt;</literal> element. You can persist any <emphasis>static</"
"emphasis> inner class. Specify the class name using the standard form i.e. "
"<literal>e.g.Foo$Bar</literal>."
msgstr ""
"若指明的持久化类实际上是一个接口，这也是完全可以接受的。之后你可以用元素 "
"<literal>&lt;subclass&gt;</literal> 来指定该接口的实际实现类。你可以持久化任"
"何 <emphasis>static</emphasis>（静态的）内部类。你应该使用标准的类名格式来指"
"定类名，比如：<literal>Foo$Bar</literal>。"

#. Tag: para
#: basic_mapping.xml:472
#, no-c-format
msgid "Here is how to do a virtual view (subselect) in XML:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:474
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Summary\"&gt;\n"
"    &lt;subselect&gt;\n"
"        select item.name, max(bid.amount), count(*)\n"
"        from item\n"
"        join bid on bid.item_id = item.id\n"
"        group by item.name\n"
"    &lt;/subselect&gt;\n"
"    &lt;synchronize table=\"item\"/&gt;\n"
"    &lt;synchronize table=\"bid\"/&gt;\n"
"    &lt;id name=\"name\"/&gt;\n"
"    ...\n"
"&lt;/class&gt;"
msgstr ""
"<![CDATA[<class name=\"Summary\">\n"
"    <subselect>\n"
"        select item.name, max(bid.amount), count(*)\n"
"        from item\n"
"        join bid on bid.item_id = item.id\n"
"        group by item.name\n"
"    </subselect>\n"
"    <synchronize table=\"item\"/>\n"
"    <synchronize table=\"bid\"/>\n"
"    <id name=\"name\"/>\n"
"    ...\n"
"</class>]]>"

#. Tag: para
#: basic_mapping.xml:476
#, no-c-format
msgid ""
"The <literal>&lt;subselect&gt;</literal> is available both as an attribute "
"and a nested mapping element."
msgstr ""

#. Tag: title
#: basic_mapping.xml:481
#, fuzzy, no-c-format
msgid "Identifiers"
msgstr "程序分配的标识符（Assigned Identifiers）"

#. Tag: para
#: basic_mapping.xml:483
#, fuzzy, no-c-format
msgid ""
"Mapped classes <emphasis>must</emphasis> declare the primary key column of "
"the database table. Most classes will also have a JavaBeans-style property "
"holding the unique identifier of an instance."
msgstr ""
"被映射的类<emphasis>必须</emphasis>定义对应数据库表主键字段。大多数类有一个 "
"JavaBeans 风格的属性， 为每一个实例包含唯一的标识。<literal>&lt;id&gt;</"
"literal> 元素定义了该属性到数据库表主键字段的映射。"

#. Tag: para
#: basic_mapping.xml:488
#, no-c-format
msgid "Mark the identifier property with <classname>@Id</classname>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:491
#, no-c-format
msgid ""
"@Entity\n"
"public class Person {\n"
"   @Id Integer getId() { ... }\n"
"   ...\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:493
#, fuzzy, no-c-format
msgid ""
"In hbm.xml, use the <literal>&lt;id&gt;</literal> element which defines the "
"mapping from that property to the primary key column."
msgstr ""
"注意使用 <literal>&lt;column&gt;</literal> 标签来把一个属性映射到多个字段的做"
"法。"

#. Tag: programlisting
#: basic_mapping.xml:509
#, fuzzy, no-c-format
msgid ""
"&lt;id\n"
"        name=\"propertyName\"\n"
"        type=\"typename\"\n"
"        column=\"column_name\"\n"
"        unsaved-value=\"null|any|none|undefined|id_value\"\n"
"        access=\"field|property|ClassName\"&gt;\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"\n"
"        &lt;generator class=\"generatorClass\"/&gt;\n"
"&lt;/id&gt;"
msgstr ""
"<![CDATA[<id\n"
"        name=\"propertyName\"\n"
"        type=\"typename\"\n"
"        column=\"column_name\"\n"
"        unsaved-value=\"null|any|none|undefined|id_value\"\n"
"        access=\"field|property|ClassName\">\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"\n"
"        <generator class=\"generatorClass\"/>\n"
"</id>]]>"

#. Tag: para
#: basic_mapping.xml:513
#, no-c-format
msgid ""
"<literal>name</literal> (optional): the name of the identifier property."
msgstr "<literal>name</literal>（可选）：标识属性的名字。 "

#. Tag: para
#: basic_mapping.xml:518 basic_mapping.xml:2152
#, no-c-format
msgid ""
"<literal>type</literal> (optional): a name that indicates the Hibernate type."
msgstr "<literal>type</literal>（可选）：一个 Hibernate 类型的名字。"

#. Tag: para
#: basic_mapping.xml:523
#, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): the "
"name of the primary key column."
msgstr "<literal>column</literal>（可选 — 默认为属性名）：主键字段的名字。 "

#. Tag: para
#: basic_mapping.xml:528
#, no-c-format
msgid ""
"<literal>unsaved-value</literal> (optional - defaults to a \"sensible\" "
"value): an identifier property value that indicates an instance is newly "
"instantiated (unsaved), distinguishing it from detached instances that were "
"saved or loaded in a previous session."
msgstr ""
"<literal>unsaved-value</literal>（可选 — 默认为一个切合实际（sensible）的"
"值）：一个特定的标识属性值，用来标志该实例是刚刚创建的，尚未保存。这可以把这"
"种实例和从以前的 session 中装载过（可能又做过修改--译者注）但未再次持久化的实"
"例区分开来。 "

#. Tag: para
#: basic_mapping.xml:536
#, no-c-format
msgid ""
"<literal>access</literal> (optional - defaults to <literal>property</"
"literal>): the strategy Hibernate should use for accessing the property "
"value."
msgstr ""
"<literal>access</literal>（可选 — 默认为 <literal>property</literal>）："
"Hibernate 用来访问属性值的策略。 "

#. Tag: para
#: basic_mapping.xml:543
#, no-c-format
msgid ""
"If the <literal>name</literal> attribute is missing, it is assumed that the "
"class has no identifier property."
msgstr "如果 <literal>name</literal> 属性不存在，会认为这个类没有标识属性。"

#. Tag: para
#: basic_mapping.xml:546
#, fuzzy, no-c-format
msgid ""
"The <literal>unsaved-value</literal> attribute is almost never needed in "
"Hibernate3 and indeed has no corresponding element in annotations."
msgstr "<literal>unsaved-value</literal> 属性在 Hibernate3 中几乎不再需要。"

#. Tag: para
#: basic_mapping.xml:550
#, fuzzy, no-c-format
msgid ""
"You can also declare the identifier as a composite identifier. This allows "
"access to legacy data with composite keys. Its use is strongly discouraged "
"for anything else."
msgstr ""
"还有一个另外的 <literal>&lt;composite-id&gt;</literal> 定义可以访问旧式的多主"
"键数据。我们非常不鼓励使用这种方式。"

#. Tag: title
#: basic_mapping.xml:555
#, fuzzy, no-c-format
msgid "Composite identifier"
msgstr "程序分配的标识符（Assigned Identifiers）"

#. Tag: para
#: basic_mapping.xml:557
#, no-c-format
msgid "You can define a composite primary key through several syntaxes:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:562
#, no-c-format
msgid ""
"use a component type to represent the identifier and map it as a property in "
"the entity: you then annotated the property as <classname>@EmbeddedId</"
"classname>. The component type has to be <classname>Serializable</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:569
#, no-c-format
msgid ""
"map multiple properties as <classname>@Id</classname> properties: the "
"identifier type is then the entity class itself and needs to be "
"<classname>Serializable</classname>. This approach is unfortunately not "
"standard and only supported by Hibernate."
msgstr ""

#. Tag: para
#: basic_mapping.xml:577
#, no-c-format
msgid ""
"map multiple properties as <classname>@Id</classname> properties and declare "
"an external class to be the identifier type. This class, which needs to be "
"<classname>Serializable</classname>, is declared on the entity via the "
"<classname>@IdClass</classname> annotation. The identifier type must contain "
"the same properties as the identifier properties of the entity: each "
"property name must be the same, its type must be the same as well if the "
"entity property is of a basic type, its type must be the type of the primary "
"key of the associated entity if the entity property is an association "
"(either a <classname>@OneToOne</classname> or a <classname>@ManyToOne</"
"classname>)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:592
#, no-c-format
msgid ""
"As you can see the last case is far from obvious. It has been inherited from "
"the dark ages of EJB 2 for backward compatibilities and we recommend you not "
"to use it (for simplicity sake)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:596
#, no-c-format
msgid "Let's explore all three cases using examples."
msgstr ""

#. Tag: title
#: basic_mapping.xml:599
#, no-c-format
msgid "id as a property using a component type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:601
#, no-c-format
msgid "Here is a simple example of <classname>@EmbeddedId</classname>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:604
#, no-c-format
msgid ""
"@Entity\n"
"class User {\n"
"   @EmbeddedId\n"
"   @AttributeOverride(name=\"firstName\", column=@Column(name=\"fld_firstname"
"\")\n"
"   UserId id;\n"
"\n"
"   Integer age;\n"
"}\n"
"\n"
"@Embeddable\n"
"class UserId implements Serializable {\n"
"   String firstName;\n"
"   String lastName;\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:606
#, no-c-format
msgid ""
"You can notice that the <classname>UserId</classname> class is serializable. "
"To override the column mapping, use <classname>@AttributeOverride</"
"classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:610
#, no-c-format
msgid ""
"An embedded id can itself contains the primary key of an associated entity."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:613
#, no-c-format
msgid ""
"@Entity\n"
"class Customer {\n"
"   @EmbeddedId CustomerId id;\n"
"   boolean preferredCustomer;\n"
"\n"
"   @MapsId(\"userId\")\n"
"   @JoinColumns({\n"
"      @JoinColumn(name=\"userfirstname_fk\", referencedColumnName=\"firstName"
"\"),\n"
"      @JoinColumn(name=\"userlastname_fk\", referencedColumnName=\"lastName"
"\")\n"
"   })\n"
"   @OneToOne User user;\n"
"}\n"
"\n"
"@Embeddable\n"
"class CustomerId implements Serializable {\n"
"   UserId userId;\n"
"   String customerNumber;\n"
"\n"
"   //implements equals and hashCode\n"
"}\n"
"\n"
"@Entity \n"
"class User {\n"
"   @EmbeddedId UserId id;\n"
"   Integer age;\n"
"}\n"
"\n"
"@Embeddable\n"
"class UserId implements Serializable {\n"
"   String firstName;\n"
"   String lastName;\n"
"\n"
"   //implements equals and hashCode\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:615
#, no-c-format
msgid ""
"In the embedded id object, the association is represented as the identifier "
"of the associated entity. But you can link its value to a regular "
"association in the entity via the <classname>@MapsId</classname> annotation. "
"The <classname>@MapsId</classname> value correspond to the property name of "
"the embedded id object containing the associated entity's identifier. In the "
"database, it means that the <literal>Customer.user</literal> and the "
"<literal>CustomerId.userId</literal> properties share the same underlying "
"column (<literal>user_fk</literal> in this case)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:627
#, no-c-format
msgid ""
"The component type used as identifier must implement <methodname>equals()</"
"methodname> and <methodname>hashCode()</methodname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:632
#, no-c-format
msgid ""
"In practice, your code only sets the <literal>Customer.user</literal> "
"property and the user id value is copied by Hibernate into the "
"<literal>CustomerId.userId</literal> property."
msgstr ""

#. Tag: para
#: basic_mapping.xml:638
#, no-c-format
msgid ""
"The id value can be copied as late as flush time, don't rely on it until "
"after flush time."
msgstr ""

#. Tag: para
#: basic_mapping.xml:642
#, no-c-format
msgid ""
"While not supported in JPA, Hibernate lets you place your association "
"directly in the embedded id component (instead of having to use the "
"<classname>@MapsId</classname> annotation)."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:646
#, no-c-format
msgid ""
"@Entity\n"
"class Customer {\n"
"   @EmbeddedId CustomerId id;\n"
"   boolean preferredCustomer;\n"
"}\n"
"\n"
"@Embeddable\n"
"class CustomerId implements Serializable {\n"
"   @OneToOne\n"
"   @JoinColumns({\n"
"      @JoinColumn(name=\"userfirstname_fk\", referencedColumnName=\"firstName"
"\"),\n"
"      @JoinColumn(name=\"userlastname_fk\", referencedColumnName=\"lastName"
"\")\n"
"   }) \n"
"   User user;\n"
"   String customerNumber;\n"
"\n"
"   //implements equals and hashCode\n"
"}\n"
"\n"
"@Entity \n"
"class User {\n"
"   @EmbeddedId UserId id;\n"
"   Integer age;\n"
"}\n"
"\n"
"@Embeddable\n"
"class UserId implements Serializable {\n"
"   String firstName;\n"
"   String lastName;\n"
"\n"
"\n"
"   //implements equals and hashCode\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:648
#, no-c-format
msgid "Let's now rewrite these examples using the hbm.xml syntax."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:651
#, fuzzy, no-c-format
msgid ""
"&lt;composite-id\n"
"        name=\"propertyName\"\n"
"        class=\"ClassName\"\n"
"        mapped=\"true|false\"\n"
"        access=\"field|property|ClassName\"\n"
"        node=\"element-name|.\"&gt;\n"
"\n"
"        &lt;key-property name=\"propertyName\" type=\"typename\" column="
"\"column_name\"/&gt;\n"
"        &lt;key-many-to-one name=\"propertyName\" class=\"ClassName\" column="
"\"column_name\"/&gt;\n"
"        ......\n"
"&lt;/composite-id&gt;"
msgstr ""
"<![CDATA[<composite-id\n"
"        name=\"propertyName\"\n"
"        class=\"ClassName\"\n"
"        mapped=\"true|false\"\n"
"        access=\"field|property|ClassName\">\n"
"        node=\"element-name|.\"\n"
"\n"
"        <key-property name=\"propertyName\" type=\"typename\" column="
"\"column_name\"/>\n"
"        <key-many-to-one name=\"propertyName class=\"ClassName\" column="
"\"column_name\"/>\n"
"        ......\n"
"</composite-id>]]>"

#. Tag: para
#: basic_mapping.xml:653
#, no-c-format
msgid "First a simple example:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:655
#, no-c-format
msgid ""
"&lt;class name=\"User\"&gt;\n"
"   &lt;composite-id name=\"id\" class=\"UserId\"&gt;\n"
"      &lt;key-property name=\"firstName\" column=\"fld_firstname\"/&gt;\n"
"      &lt;key-property name=\"lastName\"/&gt;\n"
"   &lt;/composite-id&gt;\n"
"&lt;/class&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:657
#, no-c-format
msgid "Then an example showing how an association can be mapped."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:660
#, no-c-format
msgid ""
"&lt;class name=\"Customer\"&gt;\n"
"   &lt;composite-id name=\"id\" class=\"CustomerId\"&gt;\n"
"      &lt;key-property name=\"firstName\" column=\"userfirstname_fk\"/&gt;\n"
"      &lt;key-property name=\"lastName\" column=\"userfirstname_fk\"/&gt;\n"
"      &lt;key-property name=\"customerNumber\"/&gt;\n"
"   &lt;/composite-id&gt;\n"
"\n"
"   &lt;property name=\"preferredCustomer\"/&gt;\n"
"\n"
"   &lt;many-to-one name=\"user\"&gt;\n"
"      &lt;column name=\"userfirstname_fk\" updatable=\"false\" insertable="
"\"false\"/&gt;\n"
"      &lt;column name=\"userlastname_fk\" updatable=\"false\" insertable="
"\"false\"/&gt;\n"
"   &lt;/many-to-one&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"User\"&gt;\n"
"   &lt;composite-id name=\"id\" class=\"UserId\"&gt;\n"
"      &lt;key-property name=\"firstName\"/&gt;\n"
"      &lt;key-property name=\"lastName\"/&gt;\n"
"   &lt;/composite-id&gt;\n"
"\n"
"   &lt;property name=\"age\"/&gt;\n"
"&lt;/class&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:662
#, no-c-format
msgid "Notice a few things in the previous example:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:666
#, no-c-format
msgid ""
"the order of the properties (and column) matters. It must be the same "
"between the association and the primary key of the associated entity"
msgstr ""

#. Tag: para
#: basic_mapping.xml:672
#, no-c-format
msgid ""
"the many to one uses the same columns as the primary key and thus must be "
"marked as read only (<literal>insertable</literal> and <literal>updatable</"
"literal> to false)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:679
#, no-c-format
msgid ""
"unlike with <classname>@MapsId</classname>, the id value of the associated "
"entity is not transparently copied, check the <literal>foreign</literal> id "
"generator for more information."
msgstr ""

#. Tag: para
#: basic_mapping.xml:686
#, no-c-format
msgid ""
"The last example shows how to map association directly in the embedded id "
"component."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:689
#, no-c-format
msgid ""
"&lt;class name=\"Customer\"&gt;\n"
"   &lt;composite-id name=\"id\" class=\"CustomerId\"&gt;\n"
"      &lt;key-many-to-one name=\"user\"&gt;\n"
"         &lt;column name=\"userfirstname_fk\"/&gt;\n"
"         &lt;column name=\"userlastname_fk\"/&gt;\n"
"      &lt;/key-many-to-one&gt;\n"
"      &lt;key-property name=\"customerNumber\"/&gt;\n"
"   &lt;/composite-id&gt;\n"
"\n"
"   &lt;property name=\"preferredCustomer\"/&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"User\"&gt;\n"
"   &lt;composite-id name=\"id\" class=\"UserId\"&gt;\n"
"      &lt;key-property name=\"firstName\"/&gt;\n"
"      &lt;key-property name=\"lastName\"/&gt;\n"
"   &lt;/composite-id&gt;\n"
"\n"
"   &lt;property name=\"age\"/&gt;\n"
"&lt;/class&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:691
#, no-c-format
msgid ""
"This is the recommended approach to map composite identifier. The following "
"options should not be considered unless some constraint are present."
msgstr ""

#. Tag: title
#: basic_mapping.xml:697
#, no-c-format
msgid "Multiple id properties without identifier type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:699
#, no-c-format
msgid ""
"Another, arguably more natural, approach is to place <classname>@Id</"
"classname> on multiple properties of your entity. This approach is only "
"supported by Hibernate (not JPA compliant) but does not require an extra "
"embeddable component."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:704
#, no-c-format
msgid ""
"@Entity\n"
"class Customer implements Serializable {\n"
"   @Id @OneToOne\n"
"   @JoinColumns({\n"
"      @JoinColumn(name=\"userfirstname_fk\", referencedColumnName=\"firstName"
"\"),\n"
"      @JoinColumn(name=\"userlastname_fk\", referencedColumnName=\"lastName"
"\")\n"
"   })\n"
"   User user;\n"
"  \n"
"   @Id String customerNumber;\n"
"\n"
"   boolean preferredCustomer;\n"
"\n"
"   //implements equals and hashCode\n"
"}\n"
"\n"
"@Entity \n"
"class User {\n"
"   @EmbeddedId UserId id;\n"
"   Integer age;\n"
"}\n"
"\n"
"@Embeddable\n"
"class UserId implements Serializable {\n"
"   String firstName;\n"
"   String lastName;\n"
"\n"
"   //implements equals and hashCode\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:706
#, no-c-format
msgid ""
"In this case <classname>Customer</classname> is its own identifier "
"representation: it must implement <classname>Serializable</classname> and "
"must implement <methodname>equals()</methodname> and <methodname>hashCode()</"
"methodname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:712
#, no-c-format
msgid "In hbm.xml, the same mapping is:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:714
#, no-c-format
msgid ""
"&lt;class name=\"Customer\"&gt;\n"
"   &lt;composite-id&gt;\n"
"      &lt;key-many-to-one name=\"user\"&gt;\n"
"         &lt;column name=\"userfirstname_fk\"/&gt;\n"
"         &lt;column name=\"userlastname_fk\"/&gt;\n"
"      &lt;/key-many-to-one&gt;\n"
"      &lt;key-property name=\"customerNumber\"/&gt;\n"
"   &lt;/composite-id&gt;\n"
"\n"
"   &lt;property name=\"preferredCustomer\"/&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"User\"&gt;\n"
"   &lt;composite-id name=\"id\" class=\"UserId\"&gt;\n"
"      &lt;key-property name=\"firstName\"/&gt;\n"
"      &lt;key-property name=\"lastName\"/&gt;\n"
"   &lt;/composite-id&gt;\n"
"\n"
"   &lt;property name=\"age\"/&gt;\n"
"&lt;/class&gt;"
msgstr ""

#. Tag: title
#: basic_mapping.xml:718
#, no-c-format
msgid "Multiple id properties with with a dedicated identifier type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:721
#, no-c-format
msgid ""
"<classname>@IdClass</classname> on an entity points to the class (component) "
"representing the identifier of the class. The properties marked "
"<classname>@Id</classname> on the entity must have their corresponding "
"property on the <classname>@IdClass</classname>. The return type of search "
"twin property must be either identical for basic properties or must "
"correspond to the identifier class of the associated entity for an "
"association."
msgstr ""

#. Tag: para
#: basic_mapping.xml:730
#, no-c-format
msgid ""
"This approach is inherited from the EJB 2 days and we recommend against its "
"use. But, after all it's your application and Hibernate supports it."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:735
#, no-c-format
msgid ""
"@Entity\n"
"@IdClass(CustomerId.class)\n"
"class Customer implements Serializable {\n"
"   @Id @OneToOne\n"
"   @JoinColumns({\n"
"      @JoinColumn(name=\"userfirstname_fk\", referencedColumnName=\"firstName"
"\"),\n"
"      @JoinColumn(name=\"userlastname_fk\", referencedColumnName=\"lastName"
"\")\n"
"   }) \n"
"   User user;\n"
"  \n"
"   @Id String customerNumber;\n"
"\n"
"   boolean preferredCustomer;\n"
"}\n"
"\n"
"class CustomerId implements Serializable {\n"
"   UserId user;\n"
"   String customerNumber;\n"
"\n"
"   //implements equals and hashCode\n"
"}\n"
"\n"
"@Entity \n"
"class User {\n"
"   @EmbeddedId UserId id;\n"
"   Integer age;\n"
"\n"
"   //implements equals and hashCode\n"
"}\n"
"\n"
"@Embeddable\n"
"class UserId implements Serializable {\n"
"   String firstName;\n"
"   String lastName;\n"
"\n"
"   //implements equals and hashCode\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:737
#, no-c-format
msgid ""
"<classname>Customer</classname> and <classname>CustomerId</classname> do "
"have the same properties <literal>customerNumber</literal> as well as "
"<literal>user</literal>. <classname>CustomerId</classname> must be "
"<classname>Serializable</classname> and implement <classname>equals()</"
"classname> and <classname>hashCode()</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:745
#, no-c-format
msgid ""
"While not JPA standard, Hibernate let's you declare the vanilla associated "
"property in the <classname>@IdClass</classname>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:749
#, no-c-format
msgid ""
"@Entity\n"
"@IdClass(CustomerId.class)\n"
"class Customer implements Serializable {\n"
"   @Id @OneToOne\n"
"   @JoinColumns({\n"
"      @JoinColumn(name=\"userfirstname_fk\", referencedColumnName=\"firstName"
"\"),\n"
"      @JoinColumn(name=\"userlastname_fk\", referencedColumnName=\"lastName"
"\")\n"
"   }) \n"
"   User user;\n"
"  \n"
"   @Id String customerNumber;\n"
"\n"
"   boolean preferredCustomer;\n"
"}\n"
"\n"
"class CustomerId implements Serializable {\n"
"   @OneToOne User user;\n"
"   String customerNumber;\n"
"\n"
"   //implements equals and hashCode\n"
"}\n"
"\n"
"@Entity \n"
"class User {\n"
"   @EmbeddedId UserId id;\n"
"   Integer age;\n"
"\n"
"   //implements equals and hashCode\n"
"}\n"
"\n"
"@Embeddable\n"
"class UserId implements Serializable {\n"
"  String firstName;\n"
"  String lastName;\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:751
#, no-c-format
msgid ""
"This feature is of limited interest though as you are likely to have chosen "
"the <classname>@IdClass</classname> approach to stay JPA compliant or you "
"have a quite twisted mind."
msgstr ""

#. Tag: para
#: basic_mapping.xml:755
#, no-c-format
msgid "Here are the equivalent on hbm.xml files:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:757
#, no-c-format
msgid ""
"&lt;class name=\"Customer\"&gt;\n"
"   &lt;composite-id class=\"CustomerId\" mapped=\"true\"&gt;\n"
"      &lt;key-many-to-one name=\"user\"&gt;\n"
"         &lt;column name=\"userfirstname_fk\"/&gt;\n"
"         &lt;column name=\"userlastname_fk\"/&gt;\n"
"      &lt;/key-many-to-one&gt;\n"
"      &lt;key-property name=\"customerNumber\"/&gt;\n"
"   &lt;/composite-id&gt;\n"
"\n"
"   &lt;property name=\"preferredCustomer\"/&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"User\"&gt;\n"
"   &lt;composite-id name=\"id\" class=\"UserId\"&gt;\n"
"      &lt;key-property name=\"firstName\"/&gt;\n"
"      &lt;key-property name=\"lastName\"/&gt;\n"
"   &lt;/composite-id&gt;\n"
"\n"
"   &lt;property name=\"age\"/&gt;\n"
"&lt;/class&gt;"
msgstr ""

#. Tag: title
#: basic_mapping.xml:762
#, fuzzy, no-c-format
msgid "Identifier generator"
msgstr "增强的标识符生成器"

#. Tag: para
#: basic_mapping.xml:764
#, no-c-format
msgid ""
"Hibernate can generate and populate identifier values for you automatically. "
"This is the recommended approach over \"business\" or \"natural\" id "
"(especially composite ids)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:768
#, no-c-format
msgid ""
"Hibernate offers various generation strategies, let's explore the most "
"common ones first that happens to be standardized by JPA:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:774
#, fuzzy, no-c-format
msgid ""
"IDENTITY: supports identity columns in DB2, MySQL, MS SQL Server, Sybase and "
"HypersonicSQL. The returned identifier is of type <literal>long</literal>, "
"<literal>short</literal> or <literal>int</literal>."
msgstr ""
"对 DB2，MySQL，MS SQL Server，Sybase 和 HypersonicSQL 的内置标识字段提供支"
"持。返回的标识符是 <literal>long</literal>，<literal>short</literal> 或者 "
"<literal>int</literal> 类型的。"

#. Tag: para
#: basic_mapping.xml:781
#, fuzzy, no-c-format
msgid ""
"SEQUENCE (called <literal>seqhilo</literal> in Hibernate): uses a hi/lo "
"algorithm to efficiently generate identifiers of type <literal>long</"
"literal>, <literal>short</literal> or <literal>int</literal>, given a named "
"database sequence."
msgstr ""
"使用一个高/低位算法来高效的生成 <literal>long</literal>，<literal>short</"
"literal> 或者 <literal>int</literal> 类型的标识符，给定一个数据库序列"
"（sequence)的名字。"

#. Tag: para
#: basic_mapping.xml:788
#, fuzzy, no-c-format
msgid ""
"TABLE (called <classname>MultipleHiLoPerTableGenerator</classname> in "
"Hibernate) : uses a hi/lo algorithm to efficiently generate identifiers of "
"type <literal>long</literal>, <literal>short</literal> or <literal>int</"
"literal>, given a table and column as a source of hi values. The hi/lo "
"algorithm generates identifiers that are unique only for a particular "
"database."
msgstr ""
"使用一个高/低位算法高效的生成 <literal>long</literal>，<literal>short</"
"literal> 或者 <literal>int</literal> 类型的标识符。给定一个表和字段（默认分别"
"是 <literal>hibernate_unique_key</literal> 和 <literal>next_hi</literal>）作"
"为高位值的来源。高/低位算法生成的标识符只在一个特定的数据库中是唯一的。"

#. Tag: para
#: basic_mapping.xml:798
#, fuzzy, no-c-format
msgid ""
"AUTO: selects <literal>IDENTITY</literal>, <literal>SEQUENCE</literal> or "
"<literal>TABLE</literal> depending upon the capabilities of the underlying "
"database."
msgstr ""
"根据底层数据库的能力选择 <literal>identity</literal>、<literal>sequence</"
"literal> 或者 <literal>hilo</literal> 中的一个。"

#. Tag: para
#: basic_mapping.xml:805
#, no-c-format
msgid ""
"We recommend all new projects to use the new enhanced identifier generators. "
"They are deactivated by default for entities using annotations but can be "
"activated using <code>hibernate.id.new_generator_mappings=true</code>. These "
"new generators are more efficient and closer to the JPA 2 specification "
"semantic."
msgstr ""

#. Tag: para
#: basic_mapping.xml:812
#, no-c-format
msgid ""
"However they are not backward compatible with existing Hibernate based "
"application (if a sequence or a table is used for id generation). See "
"XXXXXXX <xref linkend=\"ann-setup-properties\"/> for more information on how "
"to activate them."
msgstr ""

#. Tag: para
#: basic_mapping.xml:818
#, no-c-format
msgid ""
"To mark an id property as generated, use the <classname>@GeneratedValue</"
"classname> annotation. You can specify the strategy used (default to "
"<literal>AUTO</literal>) by setting <literal>strategy</literal>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:823
#, no-c-format
msgid ""
"@Entity\n"
"public class Customer {\n"
"   @Id @GeneratedValue\n"
"   Integer getId() { ... };\n"
"}\n"
"\n"
"@Entity \n"
"public class Invoice {\n"
"   @Id @GeneratedValue(strategy=GenerationType.IDENTITY)\n"
"   Integer getId() { ... };\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:825
#, no-c-format
msgid ""
"<literal>SEQUENCE</literal> and <literal>TABLE</literal> require additional "
"configurations that you can set using <classname>@SequenceGenerator</"
"classname> and <classname>@TableGenerator</classname>:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:832
#, fuzzy, no-c-format
msgid "<literal>name</literal>: name of the generator"
msgstr "<literal>name</literal>：属性名。"

#. Tag: para
#: basic_mapping.xml:836
#, fuzzy, no-c-format
msgid ""
"<literal>table</literal> / <literal>sequenceName</literal>: name of the "
"table or the sequence (defaulting respectively to "
"<literal>hibernate_sequences</literal> and <literal>hibernate_sequence</"
"literal>)"
msgstr ""
"<literal>sequence_name</literal>（可选 — 默认为 <literal>hibernate_sequence</"
"literal>）：序列或表的名字"

#. Tag: para
#: basic_mapping.xml:843
#, fuzzy, no-c-format
msgid "<literal>catalog</literal> / <literal>schema</literal>:"
msgstr "<literal>serializable</literal>"

#. Tag: para
#: basic_mapping.xml:848
#, fuzzy, no-c-format
msgid ""
"<literal>initialValue</literal>: the value from which the id is to start "
"generating"
msgstr "<literal>table</literal>：被连接表的名称。 "

#. Tag: para
#: basic_mapping.xml:853
#, no-c-format
msgid ""
"<literal>allocationSize</literal>: the amount to increment by when "
"allocating id numbers from the generator"
msgstr ""

#. Tag: para
#: basic_mapping.xml:858
#, no-c-format
msgid ""
"In addition, the <classname>TABLE</classname> strategy also let you "
"customize:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:863
#, fuzzy, no-c-format
msgid ""
"<literal>pkColumnName</literal>: the column name containing the entity "
"identifier"
msgstr "<literal>name</literal>：属性名。"

#. Tag: para
#: basic_mapping.xml:868
#, fuzzy, no-c-format
msgid ""
"<literal>valueColumnName</literal>: the column name containing the "
"identifier value"
msgstr "<literal>name</literal>（可选）：标识属性的名字。 "

#. Tag: para
#: basic_mapping.xml:873
#, fuzzy, no-c-format
msgid "<literal>pkColumnValue</literal>: the entity identifier"
msgstr "<literal>id-type</literal>：标识符类型"

#. Tag: para
#: basic_mapping.xml:878
#, no-c-format
msgid ""
"<literal>uniqueConstraints</literal>: any potential column constraint on the "
"table containing the ids"
msgstr ""

#. Tag: para
#: basic_mapping.xml:883
#, no-c-format
msgid ""
"To link a table or sequence generator definition with an actual generated "
"property, use the same name in both the definition <literal>name</literal> "
"and the generator value <literal>generator</literal> as shown below."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:888
#, no-c-format
msgid ""
"@Id \n"
"@GeneratedValue(\n"
"    strategy=GenerationType.SEQUENCE, \n"
"    generator=\"SEQ_GEN\")\n"
"@javax.persistence.SequenceGenerator(\n"
"    name=\"SEQ_GEN\",\n"
"    sequenceName=\"my_sequence\",\n"
"    allocationSize=20\n"
")\n"
"public Integer getId() { ... }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:890
#, no-c-format
msgid ""
"The scope of a generator definition can be the application or the class. "
"Class-defined generators are not visible outside the class and can override "
"application level generators. Application level generators are defined in "
"JPA's XML deployment descriptors (see XXXXXX <xref linkend=\"xml-overriding"
"\"/>):"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:896
#, no-c-format
msgid ""
"&lt;table-generator name=\"EMP_GEN\"\n"
"            table=\"GENERATOR_TABLE\"\n"
"            pk-column-name=\"key\"\n"
"            value-column-name=\"hi\"\n"
"            pk-column-value=\"EMP\"\n"
"            allocation-size=\"20\"/&gt;\n"
"\n"
"//and the annotation equivalent\n"
"\n"
"@javax.persistence.TableGenerator(\n"
"    name=\"EMP_GEN\",\n"
"    table=\"GENERATOR_TABLE\",\n"
"    pkColumnName = \"key\",\n"
"    valueColumnName = \"hi\"\n"
"    pkColumnValue=\"EMP\",\n"
"    allocationSize=20\n"
")\n"
"\n"
"&lt;sequence-generator name=\"SEQ_GEN\" \n"
"    sequence-name=\"my_sequence\"\n"
"    allocation-size=\"20\"/&gt;\n"
"\n"
"//and the annotation equivalent\n"
"\n"
"@javax.persistence.SequenceGenerator(\n"
"    name=\"SEQ_GEN\",\n"
"    sequenceName=\"my_sequence\",\n"
"    allocationSize=20\n"
")"
msgstr ""

#. Tag: para
#: basic_mapping.xml:898
#, no-c-format
msgid ""
"If a JPA XML descriptor (like <filename>META-INF/orm.xml</filename>) is used "
"to define the generators, <literal>EMP_GEN</literal> and <literal>SEQ_GEN</"
"literal> are application level generators."
msgstr ""

#. Tag: para
#: basic_mapping.xml:904
#, no-c-format
msgid ""
"Package level definition is not supported by the JPA specification. However, "
"you can use the <literal>@GenericGenerator</literal> at the package level "
"(see <xref linkend=\"entity-hibspec-identifier\"/>)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:910
#, no-c-format
msgid ""
"These are the four standard JPA generators. Hibernate goes beyond that and "
"provide additional generators or additional options as we will see below. "
"You can also write your own custom identifier generator by implementing "
"<classname>org.hibernate.id.IdentifierGenerator</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:916
#, no-c-format
msgid ""
"To define a custom generator, use the <classname>@GenericGenerator</"
"classname> annotation (and its plural counter part "
"<classname>@GenericGenerators</classname>) that describes the class of the "
"identifier generator or its short cut name (as described below) and a list "
"of key/value parameters. When using <classname>@GenericGenerator</classname> "
"and assigning it via <classname>@GeneratedValue.generator</classname>, the "
"<classname>@GeneratedValue.strategy</classname> is ignored: leave it blank."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:926
#, no-c-format
msgid ""
"@Id @GeneratedValue(generator=\"system-uuid\")\n"
"@GenericGenerator(name=\"system-uuid\", strategy = \"uuid\")\n"
"public String getId() {\n"
"\n"
"@Id @GeneratedValue(generator=\"trigger-generated\")\n"
"@GenericGenerator(\n"
"    name=\"trigger-generated\", \n"
"    strategy = \"select\",\n"
"    parameters = @Parameter(name=\"key\", value = \"socialSecurityNumber\")\n"
")\n"
"public String getId() {"
msgstr ""

#. Tag: para
#: basic_mapping.xml:928
#, fuzzy, no-c-format
msgid ""
"The hbm.xml approach uses the optional <literal>&lt;generator&gt;</literal> "
"child element inside <literal>&lt;id&gt;</literal>. If any parameters are "
"required to configure or initialize the generator instance, they are passed "
"using the <literal>&lt;param&gt;</literal> element."
msgstr ""
"可选的 <literal>&lt;generator&gt;</literal> 子元素是一个 Java 类的名字，用来"
"为该持久化类的实例生成唯一的标识。如果这个生成器实例需要某些配置值或者初始化"
"参数，用 <literal>&lt;param&gt;</literal> 元素来传递。"

#. Tag: programlisting
#: basic_mapping.xml:934
#, fuzzy, no-c-format
msgid ""
"&lt;id name=\"id\" type=\"long\" column=\"cat_id\"&gt;\n"
"        &lt;generator class=\"org.hibernate.id.TableHiLoGenerator\"&gt;\n"
"                &lt;param name=\"table\"&gt;uid_table&lt;/param&gt;\n"
"                &lt;param name=\"column\"&gt;next_hi_value_column&lt;/"
"param&gt;\n"
"        &lt;/generator&gt;\n"
"&lt;/id&gt;"
msgstr ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
"        <generator class=\"org.hibernate.id.TableHiLoGenerator\">\n"
"                <param name=\"table\">uid_table</param>\n"
"                <param name=\"column\">next_hi_value_column</param>\n"
"        </generator>\n"
"</id>]]>"

#. Tag: title
#: basic_mapping.xml:937
#, no-c-format
msgid "Various additional generators"
msgstr ""

#. Tag: para
#: basic_mapping.xml:939
#, no-c-format
msgid ""
"All generators implement the interface <literal>org.hibernate.id."
"IdentifierGenerator</literal>. This is a very simple interface. Some "
"applications can choose to provide their own specialized implementations, "
"however, Hibernate provides a range of built-in implementations. The "
"shortcut names for the built-in generators are as follows:"
msgstr ""
"所有的生成器都实现 <literal>org.hibernate.id.IdentifierGenerator</literal> 接"
"口。这是一个非常简单的接口；某些应用程序可以选择提供他们自己特定的实现。当"
"然，Hibernate 提供了很多内置的实现。下面是一些内置生成器的快捷名字：  "

#. Tag: literal
#: basic_mapping.xml:946
#, no-c-format
msgid "increment"
msgstr "increment"

#. Tag: para
#: basic_mapping.xml:949
#, no-c-format
msgid ""
"generates identifiers of type <literal>long</literal>, <literal>short</"
"literal> or <literal>int</literal> that are unique only when no other "
"process is inserting data into the same table. <emphasis>Do not use in a "
"cluster.</emphasis>"
msgstr ""
"用于为 <literal>long</literal>, <literal>short</literal> 或者 <literal>int</"
"literal> 类型生成 唯一标识。只有在没有其他进程往同一张表中插入数据时才能使"
"用。<emphasis>在集群下不要使用。</emphasis>"

#. Tag: literal
#: basic_mapping.xml:958
#, no-c-format
msgid "identity"
msgstr "identity"

#. Tag: para
#: basic_mapping.xml:961
#, no-c-format
msgid ""
"supports identity columns in DB2, MySQL, MS SQL Server, Sybase and "
"HypersonicSQL. The returned identifier is of type <literal>long</literal>, "
"<literal>short</literal> or <literal>int</literal>."
msgstr ""
"对 DB2，MySQL，MS SQL Server，Sybase 和 HypersonicSQL 的内置标识字段提供支"
"持。返回的标识符是 <literal>long</literal>，<literal>short</literal> 或者 "
"<literal>int</literal> 类型的。"

#. Tag: literal
#: basic_mapping.xml:969
#, no-c-format
msgid "sequence"
msgstr "sequence"

#. Tag: para
#: basic_mapping.xml:972
#, no-c-format
msgid ""
"uses a sequence in DB2, PostgreSQL, Oracle, SAP DB, McKoi or a generator in "
"Interbase. The returned identifier is of type <literal>long</literal>, "
"<literal>short</literal> or <literal>int</literal>"
msgstr ""
"在 DB2，PostgreSQL，Oracle，SAP DB，McKoi 中使用序列（sequence）， 而在 "
"Interbase 中使用生成器（generator）。返回的标识符是 <literal>long</literal>，"
"<literal>short</literal> 或者 <literal>int</literal> 类型的。"

#. Tag: literal
#: basic_mapping.xml:980
#, no-c-format
msgid "hilo"
msgstr "hilo"

#. Tag: para
#: basic_mapping.xml:984
#, no-c-format
msgid ""
"uses a hi/lo algorithm to efficiently generate identifiers of type "
"<literal>long</literal>, <literal>short</literal> or <literal>int</literal>, "
"given a table and column (by default <literal>hibernate_unique_key</literal> "
"and <literal>next_hi</literal> respectively) as a source of hi values. The "
"hi/lo algorithm generates identifiers that are unique only for a particular "
"database."
msgstr ""
"使用一个高/低位算法高效的生成 <literal>long</literal>，<literal>short</"
"literal> 或者 <literal>int</literal> 类型的标识符。给定一个表和字段（默认分别"
"是 <literal>hibernate_unique_key</literal> 和 <literal>next_hi</literal>）作"
"为高位值的来源。高/低位算法生成的标识符只在一个特定的数据库中是唯一的。"

#. Tag: literal
#: basic_mapping.xml:996
#, no-c-format
msgid "seqhilo"
msgstr "seqhilo"

#. Tag: para
#: basic_mapping.xml:999
#, no-c-format
msgid ""
"uses a hi/lo algorithm to efficiently generate identifiers of type "
"<literal>long</literal>, <literal>short</literal> or <literal>int</literal>, "
"given a named database sequence."
msgstr ""
"使用一个高/低位算法来高效的生成 <literal>long</literal>，<literal>short</"
"literal> 或者 <literal>int</literal> 类型的标识符，给定一个数据库序列"
"（sequence)的名字。"

#. Tag: literal
#: basic_mapping.xml:1007
#, fuzzy, no-c-format
msgid "uuid"
msgstr "guid"

#. Tag: para
#: basic_mapping.xml:1010
#, no-c-format
msgid ""
"Generates a 128-bit UUID based on a custom algorithm. The value generated is "
"represented as a string of 32 hexidecimal digits. Users can also configure "
"it to use a separator (config parameter \"separator\") which separates the "
"hexidecimal digits into 8{sep}8{sep}4{sep}8{sep}4. Note specifically that "
"this is different than the IETF RFC 4122 representation of 8-4-4-4-12. If "
"you need RFC 4122 compliant UUIDs, consider using \"uuid2\" generator "
"discussed below."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1023
#, fuzzy, no-c-format
msgid "uuid2"
msgstr "guid"

#. Tag: para
#: basic_mapping.xml:1026
#, no-c-format
msgid ""
"Generates a IETF RFC 4122 compliant (variant 2) 128-bit UUID. The exact "
"\"version\" (the RFC term) generated depends on the pluggable \"generation "
"strategy\" used (see below). Capable of generating values as <classname>java."
"util.UUID</classname>, <classname>java.lang.String</classname> or as a byte "
"array of length 16 (<literal>byte[16]</literal>). The \"generation strategy"
"\" is defined by the interface <interfacename>org.hibernate.id."
"UUIDGenerationStrategy</interfacename>. The generator defines 2 "
"configuration parameters for defining which generation strategy to use:"
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1038
#, no-c-format
msgid "uuid_gen_strategy_class"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1041
#, no-c-format
msgid "Names the UUIDGenerationStrategy class to use"
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1047
#, no-c-format
msgid "uuid_gen_strategy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1050
#, no-c-format
msgid "Names the UUIDGenerationStrategy instance to use"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1056
#, no-c-format
msgid "Out of the box, comes with the following strategies:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1059
#, no-c-format
msgid ""
"<classname>org.hibernate.id.uuid.StandardRandomStrategy</classname> (the "
"default) - generates \"version 3\" (aka, \"random\") UUID values via the "
"<methodname>randomUUID</methodname> method of <classname>java.util.UUID</"
"classname>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1067
#, no-c-format
msgid ""
"<classname>org.hibernate.id.uuid.CustomVersionOneStrategy</classname> - "
"generates \"version 1\" UUID values, using IP address since mac address not "
"available. If you need mac address to be used, consider leveraging one of "
"the existing third party UUID generators which sniff out mac address and "
"integrating it via the <interfacename>org.hibernate.id."
"UUIDGenerationStrategy</interfacename> contract. Two such libraries known at "
"time of this writing include <ulink url=\"http://johannburkard.de/software/"
"uuid/\">http://johannburkard.de/software/uuid/</ulink> and <ulink url="
"\"http://commons.apache.org/sandbox/id/uuid.html\">http://commons.apache.org/"
"sandbox/id/uuid.html</ulink>"
msgstr ""

#. Tag: literal
#: basic_mapping.xml:1085
#, no-c-format
msgid "guid"
msgstr "guid"

#. Tag: para
#: basic_mapping.xml:1088
#, no-c-format
msgid "uses a database-generated GUID string on MS SQL Server and MySQL."
msgstr "在 MS SQL Server 和 MySQL 中使用数据库生成的 GUID 字符串。"

#. Tag: literal
#: basic_mapping.xml:1094
#, no-c-format
msgid "native"
msgstr "native"

#. Tag: para
#: basic_mapping.xml:1097
#, no-c-format
msgid ""
"selects <literal>identity</literal>, <literal>sequence</literal> or "
"<literal>hilo</literal> depending upon the capabilities of the underlying "
"database."
msgstr ""
"根据底层数据库的能力选择 <literal>identity</literal>、<literal>sequence</"
"literal> 或者 <literal>hilo</literal> 中的一个。"

#. Tag: literal
#: basic_mapping.xml:1105
#, no-c-format
msgid "assigned"
msgstr "assigned"

#. Tag: para
#: basic_mapping.xml:1108
#, no-c-format
msgid ""
"lets the application assign an identifier to the object before <literal>save"
"()</literal> is called. This is the default strategy if no <literal>&lt;"
"generator&gt;</literal> element is specified."
msgstr ""
"让应用程序在调用 <literal>save()</literal> 之前为对象分配一个标识符。这是 "
"<literal>&lt;generator&gt;</literal> 元素没有指定时的默认生成策略。"

#. Tag: literal
#: basic_mapping.xml:1117
#, no-c-format
msgid "select"
msgstr "select"

#. Tag: para
#: basic_mapping.xml:1120
#, no-c-format
msgid ""
"retrieves a primary key, assigned by a database trigger, by selecting the "
"row by some unique key and retrieving the primary key value."
msgstr "通过数据库触发器选择一些唯一主键的行并返回主键值来分配一个主键。 "

#. Tag: literal
#: basic_mapping.xml:1127
#, no-c-format
msgid "foreign"
msgstr "foreign"

#. Tag: para
#: basic_mapping.xml:1130
#, no-c-format
msgid ""
"uses the identifier of another associated object. It is usually used in "
"conjunction with a <literal>&lt;one-to-one&gt;</literal> primary key "
"association."
msgstr ""
"使用另外一个相关联的对象的标识符。它通常和 <literal>&lt;one-to-one&gt;</"
"literal> 联合起来使用。"

#. Tag: literal
#: basic_mapping.xml:1138
#, fuzzy, no-c-format
msgid "sequence-identity"
msgstr "<literal>sequence-identity</literal>"

#. Tag: para
#: basic_mapping.xml:1141
#, no-c-format
msgid ""
"a specialized sequence generation strategy that utilizes a database sequence "
"for the actual value generation, but combines this with JDBC3 "
"getGeneratedKeys to return the generated identifier value as part of the "
"insert statement execution. This strategy is only supported on Oracle 10g "
"drivers targeted for JDK 1.4. Comments on these insert statements are "
"disabled due to a bug in the Oracle drivers."
msgstr ""
"一种特别的序列生成策略，它使用数据库序列来生成实际值，但将它和 JDBC3 的 "
"getGeneratedKeys 结合在一起，使得在插入语句执行的时候就返回生成的值。目前为止"
"只有面向 JDK 1.4 的 Oracle 10g 驱动支持这一策略。由于 Oracle 驱动程序的一个 "
"bug，这些插入语句的注释被关闭了。"

#. Tag: title
#: basic_mapping.xml:1155
#, no-c-format
msgid "Hi/lo algorithm"
msgstr "高/低位算法（Hi/Lo Algorithm）"

#. Tag: para
#: basic_mapping.xml:1157
#, no-c-format
msgid ""
"The <literal>hilo</literal> and <literal>seqhilo</literal> generators "
"provide two alternate implementations of the hi/lo algorithm. The first "
"implementation requires a \"special\" database table to hold the next "
"available \"hi\" value. Where supported, the second uses an Oracle-style "
"sequence."
msgstr ""
"<literal>hilo</literal> 和 <literal>seqhilo</literal> 生成器给出了两种 hi/lo "
"算法的实现， 这是一种很令人满意的标识符生成算法。第一种实现需要一个“特殊”的数"
"据库表来保存下一个可用的“hi”值。 第二种实现使用一个 Oracle 风格的序列（在被支"
"持的情况下）。 "

#. Tag: programlisting
#: basic_mapping.xml:1163
#, fuzzy, no-c-format
msgid ""
"&lt;id name=\"id\" type=\"long\" column=\"cat_id\"&gt;\n"
"        &lt;generator class=\"hilo\"&gt;\n"
"                &lt;param name=\"table\"&gt;hi_value&lt;/param&gt;\n"
"                &lt;param name=\"column\"&gt;next_value&lt;/param&gt;\n"
"                &lt;param name=\"max_lo\"&gt;100&lt;/param&gt;\n"
"        &lt;/generator&gt;\n"
"&lt;/id&gt;"
msgstr ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
"        <generator class=\"hilo\">\n"
"                <param name=\"table\">hi_value</param>\n"
"                <param name=\"column\">next_value</param>\n"
"                <param name=\"max_lo\">100</param>\n"
"        </generator>\n"
"</id>]]>"

#. Tag: programlisting
#: basic_mapping.xml:1165
#, fuzzy, no-c-format
msgid ""
"&lt;id name=\"id\" type=\"long\" column=\"cat_id\"&gt;\n"
"        &lt;generator class=\"seqhilo\"&gt;\n"
"                &lt;param name=\"sequence\"&gt;hi_value&lt;/param&gt;\n"
"                &lt;param name=\"max_lo\"&gt;100&lt;/param&gt;\n"
"        &lt;/generator&gt;\n"
"&lt;/id&gt;"
msgstr ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"cat_id\">\n"
"        <generator class=\"seqhilo\">\n"
"                <param name=\"sequence\">hi_value</param>\n"
"                <param name=\"max_lo\">100</param>\n"
"        </generator>\n"
"</id>]]>"

#. Tag: para
#: basic_mapping.xml:1167
#, no-c-format
msgid ""
"Unfortunately, you cannot use <literal>hilo</literal> when supplying your "
"own <literal>Connection</literal> to Hibernate. When Hibernate uses an "
"application server datasource to obtain connections enlisted with JTA, you "
"must configure the <literal>hibernate.transaction.manager_lookup_class</"
"literal>."
msgstr ""
"可惜的是，你在为 Hibernate 自行提供 <literal>Connection</literal> 时无法使用 "
"<literal>hilo</literal>。 当 Hibernate 使用 JTA 获取应用服务器的数据源连接"
"时，你必须正确地配置 <literal>hibernate.transaction.manager_lookup_class</"
"literal>。"

#. Tag: title
#: basic_mapping.xml:1175
#, no-c-format
msgid "UUID algorithm"
msgstr "UUID 算法（UUID Algorithm ）"

#. Tag: para
#: basic_mapping.xml:1177
#, no-c-format
msgid ""
"The UUID contains: IP address, startup time of the JVM that is accurate to a "
"quarter second, system time and a counter value that is unique within the "
"JVM. It is not possible to obtain a MAC address or memory address from Java "
"code, so this is the best option without using JNI."
msgstr ""
"UUID 包含：IP 地址、JVM 的启动时间（精确到 1/4 秒）、系统时间和一个计数器值"
"（在 JVM 中唯一）。 在 Java 代码中不可能获得 MAC 地址或者内存地址，所以这已经"
"是我们在不使用 JNI 的前提下的能做的最好实现了。"

#. Tag: title
#: basic_mapping.xml:1185
#, no-c-format
msgid "Identity columns and sequences"
msgstr "标识字段和序列（Identity columns and Sequences）"

#. Tag: para
#: basic_mapping.xml:1187
#, no-c-format
msgid ""
"For databases that support identity columns (DB2, MySQL, Sybase, MS SQL), "
"you can use <literal>identity</literal> key generation. For databases that "
"support sequences (DB2, Oracle, PostgreSQL, Interbase, McKoi, SAP DB) you "
"can use <literal>sequence</literal> style key generation. Both of these "
"strategies require two SQL queries to insert a new object. For example:"
msgstr ""
"对于内部支持标识字段的数据库（DB2、MySQL、Sybase 和 MS SQL），你可以使用 "
"<literal>identity</literal> 关键字生成。对于内部支持序列的数据库（DB2、"
"Oracle、PostgreSQL、Interbase、McKoi 和 SAP DB），你可以使用 "
"<literal>sequence</literal> 风格的关键字生成。这两种方式对于插入一个新的对象"
"都需要两次 SQL 查询。例如："

#. Tag: programlisting
#: basic_mapping.xml:1195
#, fuzzy, no-c-format
msgid ""
"&lt;id name=\"id\" type=\"long\" column=\"person_id\"&gt;\n"
"        &lt;generator class=\"sequence\"&gt;\n"
"                &lt;param name=\"sequence\"&gt;person_id_sequence&lt;/"
"param&gt;\n"
"        &lt;/generator&gt;\n"
"&lt;/id&gt;"
msgstr ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
"        <generator class=\"sequence\">\n"
"                <param name=\"sequence\">person_id_sequence</param>\n"
"        </generator>\n"
"</id>]]>"

#. Tag: programlisting
#: basic_mapping.xml:1197
#, fuzzy, no-c-format
msgid ""
"&lt;id name=\"id\" type=\"long\" column=\"person_id\" unsaved-value=\"0"
"\"&gt;\n"
"        &lt;generator class=\"identity\"/&gt;\n"
"&lt;/id&gt;"
msgstr ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\" unsaved-value=\"0"
"\">\n"
"        <generator class=\"identity\"/>\n"
"</id>]]>"

#. Tag: para
#: basic_mapping.xml:1199
#, no-c-format
msgid ""
"For cross-platform development, the <literal>native</literal> strategy will, "
"depending on the capabilities of the underlying database, choose from the "
"<literal>identity</literal>, <literal>sequence</literal> and <literal>hilo</"
"literal> strategies."
msgstr ""
"对于跨平台开发，<literal>native</literal> 策略会从 <literal>identity</"
"literal>、<literal>sequence</literal> 和 <literal>hilo</literal> 中进行选择，"
"选择哪一个，这取决于底层数据库的支持能力。"

#. Tag: title
#: basic_mapping.xml:1207
#, no-c-format
msgid "Assigned identifiers"
msgstr "程序分配的标识符（Assigned Identifiers）"

#. Tag: para
#: basic_mapping.xml:1209
#, fuzzy, no-c-format
msgid ""
"If you want the application to assign identifiers, as opposed to having "
"Hibernate generate them, you can use the <literal>assigned</literal> "
"generator. This special generator uses the identifier value already assigned "
"to the object's identifier property. The generator is used when the primary "
"key is a natural key instead of a surrogate key. This is the default "
"behavior if you do not specify <classname>@GeneratedValue</classname> nor "
"<literal>&lt;generator&gt;</literal> elements."
msgstr ""
"如果你需要应用程序分配一个标示符（而非 Hibernate 来生成），你可以使用 "
"<literal>assigned</literal> 生成器。这种特殊的生成器会使用已经分配给对象的标"
"识符属性的标识符值。 这个生成器使用一个自然键（natural key，有商业意义的列－"
"译注）作为主键，而不是使用一个代理键（ surrogate key，没有商业意义的列－译"
"注）。这是没有指定 <literal>&lt;generator&gt;</literal> 元素时的默认行为。"

#. Tag: para
#: basic_mapping.xml:1218
#, no-c-format
msgid ""
"The <literal>assigned</literal> generator makes Hibernate use "
"<literal>unsaved-value=\"undefined\"</literal>. This forces Hibernate to go "
"to the database to determine if an instance is transient or detached, unless "
"there is a version or timestamp property, or you define <literal>Interceptor."
"isUnsaved()</literal>."
msgstr ""
"当选择 <literal>assigned</literal> 生成器时，除非有一个 version 或 timestamp "
"属性，或者你定义了 <literal>Interceptor.isUnsaved()</literal>，否则需要让 "
"Hiberante 使用 <literal>unsaved-value=\"undefined\"</literal>，强制 "
"Hibernatet 查询数据库来确定一个实例是瞬时的（transient） 还是脱管的"
"（detached）。"

#. Tag: title
#: basic_mapping.xml:1226
#, no-c-format
msgid "Primary keys assigned by triggers"
msgstr "触发器实现的主键生成器（Primary keys assigned by triggers）"

#. Tag: para
#: basic_mapping.xml:1228
#, no-c-format
msgid ""
"Hibernate does not generate DDL with triggers. It is for legacy schemas only."
msgstr "仅仅用于遗留的 schema 中（Hibernate 不能用触发器生成 DDL）。"

#. Tag: programlisting
#: basic_mapping.xml:1231
#, fuzzy, no-c-format
msgid ""
"&lt;id name=\"id\" type=\"long\" column=\"person_id\"&gt;\n"
"        &lt;generator class=\"select\"&gt;\n"
"                &lt;param name=\"key\"&gt;socialSecurityNumber&lt;/"
"param&gt;\n"
"        &lt;/generator&gt;\n"
"&lt;/id&gt;"
msgstr ""
"<![CDATA[<id name=\"id\" type=\"long\" column=\"person_id\">\n"
"        <generator class=\"select\">\n"
"                <param name=\"key\">socialSecurityNumber</param>\n"
"        </generator>\n"
"</id>]]>"

#. Tag: para
#: basic_mapping.xml:1233
#, no-c-format
msgid ""
"In the above example, there is a unique valued property named "
"<literal>socialSecurityNumber</literal>. It is defined by the class, as a "
"natural key and a surrogate key named <literal>person_id</literal>, whose "
"value is generated by a trigger."
msgstr ""
"在上面的例子中，类定义了一个命名为 <literal>socialSecurityNumber</literal> 的"
"具有唯一值的属性，它是一个自然键（natural key），命名为 <literal>person_id</"
"literal> 的代理键（surrogate key）的值由触发器生成。"

#. Tag: title
#: basic_mapping.xml:1241
#, no-c-format
msgid "Identity copy (foreign generator)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1243
#, no-c-format
msgid ""
"Finally, you can ask Hibernate to copy the identifier from another "
"associated entity. In the Hibernate jargon, it is known as a foreign "
"generator but the JPA mapping reads better and is encouraged."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1248
#, no-c-format
msgid ""
"@Entity\n"
"class MedicalHistory implements Serializable {\n"
"  @Id @OneToOne\n"
"  @JoinColumn(name = \"person_id\")\n"
"  Person patient;\n"
"}\n"
"\n"
"@Entity\n"
"public class Person implements Serializable {\n"
"  @Id @GeneratedValue Integer id;\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1250
#, fuzzy, no-c-format
msgid "Or alternatively"
msgstr "其他元数据（Metadata）"

#. Tag: programlisting
#: basic_mapping.xml:1252
#, no-c-format
msgid ""
"@Entity\n"
"class MedicalHistory implements Serializable {\n"
"  @Id Integer id;\n"
"\n"
"  @MapsId @OneToOne\n"
"  @JoinColumn(name = \"patient_id\")\n"
"  Person patient;\n"
"}\n"
"\n"
"@Entity\n"
"class Person {\n"
"  @Id @GeneratedValue Integer id;\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1254
#, no-c-format
msgid "In hbm.xml use the following approach:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1256
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"MedicalHistory\"&gt;\n"
"   &lt;id name=\"id\"&gt;\n"
"      &lt;generator class=\"foreign\"&gt;\n"
"         &lt;param name=\"property\"&gt;patient&lt;/param&gt;\n"
"      &lt;/generator&gt;\n"
"   &lt;/id&gt;\n"
"   &lt;one-to-one name=\"patient\" class=\"Person\" constrained=\"true\"/"
"&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"person\" table=\"PERSON\"&gt;\n"
"    &lt;id name=\"id\" column=\"PERSON_ID\"&gt;\n"
"        &lt;generator class=\"foreign\"&gt;\n"
"            &lt;param name=\"property\"&gt;employee&lt;/param&gt;\n"
"        &lt;/generator&gt;\n"
"    &lt;/id&gt;\n"
"    ...\n"
"    &lt;one-to-one name=\"employee\"\n"
"        class=\"Employee\"\n"
"        constrained=\"true\"/&gt;\n"
"&lt;/class&gt;"

#. Tag: title
#: basic_mapping.xml:1261
#, no-c-format
msgid "Enhanced identifier generators"
msgstr "增强的标识符生成器"

#. Tag: para
#: basic_mapping.xml:1263
#, no-c-format
msgid ""
"Starting with release 3.2.3, there are 2 new generators which represent a re-"
"thinking of 2 different aspects of identifier generation. The first aspect "
"is database portability; the second is optimization Optimization means that "
"you do not have to query the database for every request for a new identifier "
"value. These two new generators are intended to take the place of some of "
"the named generators described above, starting in 3.3.x. However, they are "
"included in the current releases and can be referenced by FQN."
msgstr ""
"从 3.2.3 版本开始，有两个代表不同标识符生成概念的新的生成器。第一个概念是数据"
"库移植性；第二个是优化。优化表示你不需对每个新标识符的请求都查询数据库。从 "
"3.3.x 开始，这两个新的生成器都是用来取代上面所述的生成器的。然而，它们也包括"
"在当前版本里且可以由 FQN 进行引用。"

#. Tag: para
#: basic_mapping.xml:1272
#, no-c-format
msgid ""
"The first of these new generators is <literal>org.hibernate.id.enhanced."
"SequenceStyleGenerator</literal> which is intended, firstly, as a "
"replacement for the <literal>sequence</literal> generator and, secondly, as "
"a better portability generator than <literal>native</literal>. This is "
"because <literal>native</literal> generally chooses between "
"<literal>identity</literal> and <literal>sequence</literal> which have "
"largely different semantics that can cause subtle issues in applications "
"eyeing portability. <literal>org.hibernate.id.enhanced."
"SequenceStyleGenerator</literal>, however, achieves portability in a "
"different manner. It chooses between a table or a sequence in the database "
"to store its incrementing values, depending on the capabilities of the "
"dialect being used. The difference between this and <literal>native</"
"literal> is that table-based and sequence-based storage have the same exact "
"semantic. In fact, sequences are exactly what Hibernate tries to emulate "
"with its table-based generators. This generator has a number of "
"configuration parameters:"
msgstr ""
"这些生成器的第一个是 <literal>org.hibernate.id.enhanced."
"SequenceStyleGenerator</literal>，首先，它是作为 <literal>sequence</literal> "
"生成器的替代物，其次，它是比 <literal>native</literal> 具有更好移植性的生成"
"器。这是因为 <literal>native</literal> 通常在 <literal>identity</literal> 和 "
"<literal>sequence</literal> 之间选择，它有差别很大的 semantic，在移植时会导致"
"潜在的问题。然而，<literal>org.hibernate.id.enhanced.SequenceStyleGenerator</"
"literal> 以不同的方式实现移植性。它根据所使用的方言的能力，在数据库表或序列之"
"间选择以存储其增量。这和 <literal>native</literal> 的区别是基于表或序列的存储"
"具有恰好相同的 semantic。实际上，序列就是 Hibernate 试图用基于表的生成器来模"
"拟的。这个生成器有如下的配置参数："

#. Tag: para
#: basic_mapping.xml:1291
#, no-c-format
msgid ""
"<literal>sequence_name</literal> (optional, defaults to "
"<literal>hibernate_sequence</literal>): the name of the sequence or table to "
"be used."
msgstr ""
"<literal>sequence_name</literal>（可选 — 默认为 <literal>hibernate_sequence</"
"literal>）：序列或表的名字"

#. Tag: para
#: basic_mapping.xml:1297
#, no-c-format
msgid ""
"<literal>initial_value</literal> (optional, defaults to <literal>1</"
"literal>): the initial value to be retrieved from the sequence/table. In "
"sequence creation terms, this is analogous to the clause typically named "
"\"STARTS WITH\"."
msgstr ""
"<literal>initial_value</literal>（可选，默认为 <literal>1</literal>）：从序"
"列/表里获取的初始值。按照序列创建的术语，这等同于子句 \"STARTS WITH\"。"

#. Tag: para
#: basic_mapping.xml:1304
#, no-c-format
msgid ""
"<literal>increment_size</literal> (optional - defaults to <literal>1</"
"literal>): the value by which subsequent calls to the sequence/table should "
"differ. In sequence creation terms, this is analogous to the clause "
"typically named \"INCREMENT BY\"."
msgstr ""
"<literal>increment_size</literal>（可选 - 缺省为 <literal>1</literal>）：对序"
"列/表的调用应该区分的值。按照序列创建的术语，这等同于子句 \"INCREMENT BY\"。"

#. Tag: para
#: basic_mapping.xml:1312
#, no-c-format
msgid ""
"<literal>force_table_use</literal> (optional - defaults to <literal>false</"
"literal>): should we force the use of a table as the backing structure even "
"though the dialect might support sequence?"
msgstr ""
"<literal>force_table_use</literal>（可选 - 缺省为 <literal>false</"
"literal>）：即使方言可能支持序列，是否也应该强制把表用作后台结构。"

#. Tag: para
#: basic_mapping.xml:1319
#, no-c-format
msgid ""
"<literal>value_column</literal> (optional - defaults to <literal>next_val</"
"literal>): only relevant for table structures, it is the name of the column "
"on the table which is used to hold the value."
msgstr ""
"<literal>value_column</literal>（可选 - 缺省为 <literal>next_val</"
"literal>）：只和表结构相关，它是用于保存值的字段的名称。"

#. Tag: para
#: basic_mapping.xml:1326
#, fuzzy, no-c-format
msgid ""
"<literal>optimizer</literal> (optional - defaults to <literal>none</"
"literal>): See"
msgstr ""
"<literal>cascade</literal>（可选 — 默认是<literal>none</literal>）：级联的类"
"型。"

#. Tag: para
#: basic_mapping.xml:1332
#, no-c-format
msgid ""
"The second of these new generators is <literal>org.hibernate.id.enhanced."
"TableGenerator</literal>, which is intended, firstly, as a replacement for "
"the <literal>table</literal> generator, even though it actually functions "
"much more like <literal>org.hibernate.id.MultipleHiLoPerTableGenerator</"
"literal>, and secondly, as a re-implementation of <literal>org.hibernate.id."
"MultipleHiLoPerTableGenerator</literal> that utilizes the notion of "
"pluggable optimizers. Essentially this generator defines a table capable of "
"holding a number of different increment values simultaneously by using "
"multiple distinctly keyed rows. This generator has a number of configuration "
"parameters:"
msgstr ""
"新生成器的第二个是 <literal>org.hibernate.id.enhanced.TableGenerator</"
"literal>，它的目的首先是替代 <literal>table</literal> 生成器，即使它实际上比 "
"<literal>org.hibernate.id.MultipleHiLoPerTableGenerator</literal> 功能要强得"
"多；其次，作为利用可插拔 optimizer 的 <literal>org.hibernate.id."
"MultipleHiLoPerTableGenerator</literal> 的替代品。基本上这个生成器定义了一个"
"可以利用多个不同的键值记录存储大量不同增量值的表。这个生成器有如下的配置参"
"数："

#. Tag: para
#: basic_mapping.xml:1345
#, no-c-format
msgid ""
"<literal>table_name</literal> (optional - defaults to "
"<literal>hibernate_sequences</literal>): the name of the table to be used."
msgstr ""
"<literal>table_name</literal>（可选 — 默认是 <literal>hibernate_sequences</"
"literal>）：所用的表的名称。"

#. Tag: para
#: basic_mapping.xml:1351
#, no-c-format
msgid ""
"<literal>value_column_name</literal> (optional - defaults to "
"<literal>next_val</literal>): the name of the column on the table that is "
"used to hold the value."
msgstr ""
"<literal>value_column_name</literal>（可选 — 默认为 <literal>next_val</"
"literal>）：用于存储这些值的表的字段的名字。"

#. Tag: para
#: basic_mapping.xml:1357
#, no-c-format
msgid ""
"<literal>segment_column_name</literal> (optional - defaults to "
"<literal>sequence_name</literal>): the name of the column on the table that "
"is used to hold the \"segment key\". This is the value which identifies "
"which increment value to use."
msgstr ""
"<literal>segment_column_name</literal>（可选，默认为 <literal>sequence_name</"
"literal>）：用于保存 \"segment key\" 的字段的名称。这是标识使用哪个增量值的"
"值。"

#. Tag: para
#: basic_mapping.xml:1365
#, no-c-format
msgid ""
"<literal>segment_value</literal> (optional - defaults to <literal>default</"
"literal>): The \"segment key\" value for the segment from which we want to "
"pull increment values for this generator."
msgstr ""
"<literal>segment_value</literal>（可选，默认为 <literal>default</literal>）："
"我们为这个生成器获取增量值的 segment 的 \"segment key\"。"

#. Tag: para
#: basic_mapping.xml:1372
#, no-c-format
msgid ""
"<literal>segment_value_length</literal> (optional - defaults to "
"<literal>255</literal>): Used for schema generation; the column size to "
"create this segment key column."
msgstr ""
"<literal>segment_value_length</literal>（可选 — 默认为 <literal>255</"
"literal>）：用于 schema 生成；创建 Segment Key 字段的字段大小。"

#. Tag: para
#: basic_mapping.xml:1378
#, no-c-format
msgid ""
"<literal>initial_value</literal> (optional - defaults to <literal>1</"
"literal>): The initial value to be retrieved from the table."
msgstr ""
"<literal>initial_value</literal>（可选 — 默认是 <literal>1</literal>）：从表"
"里获取的初始值。"

#. Tag: para
#: basic_mapping.xml:1384
#, no-c-format
msgid ""
"<literal>increment_size</literal> (optional - defaults to <literal>1</"
"literal>): The value by which subsequent calls to the table should differ."
msgstr ""
"<literal>increment_size</literal>（可选 — 默认是 <literal>1</literal>）：对表"
"随后的调用应该区分的值。"

#. Tag: para
#: basic_mapping.xml:1390
#, fuzzy, no-c-format
msgid ""
"<literal>optimizer</literal> (optional - defaults to <literal>??</literal>): "
"See <xref linkend=\"mapping-declaration-id-enhanced-optimizers\"/>."
msgstr ""
"<literal>optimizer</literal>（可选 — 默认是 <literal> </literal>）：请参考 "
"<xref linkend=\"mapping-declaration-id-enhanced-optimizers\" />。"

#. Tag: title
#: basic_mapping.xml:1397
#, no-c-format
msgid "Identifier generator optimization"
msgstr "标识符生成器的优化"

#. Tag: para
#: basic_mapping.xml:1399
#, fuzzy, no-c-format
msgid ""
"For identifier generators that store values in the database, it is "
"inefficient for them to hit the database on each and every call to generate "
"a new identifier value. Instead, you can group a bunch of them in memory and "
"only hit the database when you have exhausted your in-memory value group. "
"This is the role of the pluggable optimizers. Currently only the two "
"enhanced generators (<xref linkend=\"mapping-declaration-id-enhanced\"/> "
"support this operation."
msgstr ""
"对于在数据库里存储值的标识符生成器，生成新标识符时的每次调用都访问数据库是低"
"效的。因此，你可以把它们在内存里分组并只有在快用光内存时才访问数据库。这是可"
"插拔 optimizer 的任务。目前只有两个增强型的生成器支持这个操作（<xref linkend="
"\"mapping-declaration-id-enhanced\"/>）。 "

#. Tag: para
#: basic_mapping.xml:1410
#, no-c-format
msgid ""
"<literal>none</literal> (generally this is the default if no optimizer was "
"specified): this will not perform any optimizations and hit the database for "
"each and every request."
msgstr ""
"<literal>none</literal>（如果没有指定 optimizer，通常这是缺省配置）：这不会执"
"行任何优化，在每次请求时都访问数据库。"

#. Tag: para
#: basic_mapping.xml:1417
#, no-c-format
msgid ""
"<literal>hilo</literal>: applies a hi/lo algorithm around the database "
"retrieved values. The values from the database for this optimizer are "
"expected to be sequential. The values retrieved from the database structure "
"for this optimizer indicates the \"group number\". The "
"<literal>increment_size</literal> is multiplied by that value in memory to "
"define a group \"hi value\"."
msgstr ""
"<literal>hilo</literal>：对从数据库获取的值应用 hi/lo 算法。用于这个 "
"optimizer 的从数据库获取的值应该是有序的。它们表明“组编号”。"
"<literal>increment_size</literal> 将乘以内存里的值来定义组的“hi 值”。"

#. Tag: para
#: basic_mapping.xml:1427
#, no-c-format
msgid ""
"<literal>pooled</literal>: as with the case of <literal>hilo</literal>, this "
"optimizer attempts to minimize the number of hits to the database. Here, "
"however, we simply store the starting value for the \"next group\" into the "
"database structure rather than a sequential value in combination with an in-"
"memory grouping algorithm. Here, <literal>increment_size</literal> refers to "
"the values coming from the database."
msgstr ""
"<literal>pooled</literal>：和 <literal>hilo</literal> 一样，这个 optimizer 试"
"图最小化对数据库的访问。然而，我们只是简单地把“下一组”的起始值而不是把序列值"
"和分组算法的组合存入到数据库结构里。在这里，<literal>increment_size</"
"literal> 表示数据库里的值。"

#. Tag: title
#: basic_mapping.xml:1441
#, fuzzy, no-c-format
msgid "Partial identifier generation"
msgstr "增强的标识符生成器"

#. Tag: para
#: basic_mapping.xml:1443
#, no-c-format
msgid ""
"Hibernate supports the automatic generation of some of the identifier "
"properties. Simply use the <classname>@GeneratedValue</classname> annotation "
"on one or several id properties."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1449
#, no-c-format
msgid ""
"The Hibernate team has always felt such a construct as fundamentally wrong. "
"Try hard to fix your data model before using this feature."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1454
#, no-c-format
msgid ""
"@Entity\n"
"public class CustomerInventory implements Serializable {\n"
"  @Id\n"
"  @TableGenerator(name = \"inventory\",\n"
"    table = \"U_SEQUENCES\",\n"
"    pkColumnName = \"S_ID\",\n"
"    valueColumnName = \"S_NEXTNUM\",\n"
"    pkColumnValue = \"inventory\",\n"
"    allocationSize = 1000)\n"
"  @GeneratedValue(strategy = GenerationType.TABLE, generator = \"inventory"
"\")\n"
"  Integer id;\n"
"\n"
"\n"
"  @Id @ManyToOne(cascade = CascadeType.MERGE)\n"
"  Customer customer;\n"
"}\n"
"\n"
"@Entity\n"
"public class Customer implements Serializable {\n"
"   @Id\n"
"   private int id;\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1456
#, no-c-format
msgid ""
"You can also generate properties inside an <classname>@EmbeddedId</"
"classname> class."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1462
#, no-c-format
msgid "Optimistic locking properties (optional)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1464
#, no-c-format
msgid ""
"When using long transactions or conversations that span several database "
"transactions, it is useful to store versioning data to ensure that if the "
"same entity is updated by two conversations, the last to commit changes will "
"be informed and not override the other conversation's work. It guarantees "
"some isolation while still allowing for good scalability and works "
"particularly well in read-often write-sometimes situations."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1472
#, no-c-format
msgid "You can use two approaches: a dedicated version number or a timestamp."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1475
#, no-c-format
msgid ""
"A version or timestamp property should never be null for a detached "
"instance. Hibernate will detect any instance with a null version or "
"timestamp as transient, irrespective of what other <literal>unsaved-value</"
"literal> strategies are specified. <emphasis>Declaring a nullable version or "
"timestamp property is an easy way to avoid problems with transitive "
"reattachment in Hibernate. It is especially useful for people using assigned "
"identifiers or composite keys</emphasis>."
msgstr ""
"一个脱管（detached）实例的 version 或 timestamp 属性不能为空（null），因为 "
"Hibernate 不管  <literal>unsaved-value</literal> 被指定为何种策略，它将任何属"
"性为空的 version 或 timestamp 实例看作为瞬时（transient）实例。 <emphasis>避"
"免 Hibernate 中的传递重附（transitive reattachment）问题的一个简单方法是 定义"
"一个不能为空的 version 或 timestamp 属性，特别是在人们使用程序分配的标识符"
"（assigned identifiers） 或复合主键时非常有用</emphasis>。"

#. Tag: title
#: basic_mapping.xml:1485
#, no-c-format
msgid "Version number"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1487
#, no-c-format
msgid ""
"You can add optimistic locking capability to an entity using the "
"<literal>@Version</literal> annotation:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1490
#, no-c-format
msgid ""
"@Entity\n"
"public class Flight implements Serializable {\n"
"...\n"
"    @Version\n"
"    @Column(name=\"OPTLOCK\")\n"
"    public Integer getVersion() { ... }\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1492
#, no-c-format
msgid ""
"The version property will be mapped to the <literal>OPTLOCK</literal> "
"column, and the entity manager will use it to detect conflicting updates "
"(preventing lost updates you might otherwise see with the last-commit-wins "
"strategy)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1497
#, no-c-format
msgid ""
"The version column may be a numeric. Hibernate supports any kind of type "
"provided that you define and implement the appropriate "
"<classname>UserVersionType</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1501
#, no-c-format
msgid ""
"The application must not alter the version number set up by Hibernate in any "
"way. To artificially increase the version number, check in Hibernate Entity "
"Manager's reference documentation <literal>LockModeType."
"OPTIMISTIC_FORCE_INCREMENT</literal> or <literal>LockModeType."
"PESSIMISTIC_FORCE_INCREMENT</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1507
#, no-c-format
msgid ""
"If the version number is generated by the database (via a trigger for "
"example), make sure to use <code>@org.hibernate.annotations.Generated"
"(GenerationTime.ALWAYS).</code>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1511
#, no-c-format
msgid "To declare a version property in hbm.xml, use:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1530
#, fuzzy, no-c-format
msgid ""
"&lt;version\n"
"        column=\"version_column\"\n"
"        name=\"propertyName\"\n"
"        type=\"typename\"\n"
"        access=\"field|property|ClassName\"\n"
"        unsaved-value=\"null|negative|undefined\"\n"
"        generated=\"never|always\"\n"
"        insert=\"true|false\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"/&gt;"
msgstr ""
"<![CDATA[<version\n"
"        column=\"version_column\"\n"
"        name=\"propertyName\"\n"
"        type=\"typename\"\n"
"        access=\"field|property|ClassName\"\n"
"        unsaved-value=\"null|negative|undefined\"\n"
"        generated=\"never|always\"\n"
"        insert=\"true|false\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"/>]]>"

#. Tag: para
#: basic_mapping.xml:1534
#, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): the "
"name of the column holding the version number."
msgstr ""
"<literal>column</literal>（可选 — 默认为属性名）：指定持有版本号的字段名。 "

#. Tag: para
#: basic_mapping.xml:1540
#, no-c-format
msgid ""
"<literal>name</literal>: the name of a property of the persistent class."
msgstr "<literal>name</literal>：持久化类的属性名。 "

#. Tag: para
#: basic_mapping.xml:1545
#, no-c-format
msgid ""
"<literal>type</literal> (optional - defaults to <literal>integer</literal>): "
"the type of the version number."
msgstr ""
"<literal>type</literal>（可选 — 默认是 <literal>integer</literal>）：版本号的"
"类型。 "

#. Tag: para
#: basic_mapping.xml:1551
#, no-c-format
msgid ""
"<literal>access</literal> (optional - defaults to <literal>property</"
"literal>): the strategy Hibernate uses to access the property value."
msgstr ""
"<literal>access</literal>（可选 — 默认为 <literal>property</literal>）："
"Hibernate 用来访问属性值的策略。 "

#. Tag: para
#: basic_mapping.xml:1557
#, no-c-format
msgid ""
"<literal>unsaved-value</literal> (optional - defaults to <literal>undefined</"
"literal>): a version property value that indicates that an instance is newly "
"instantiated (unsaved), distinguishing it from detached instances that were "
"saved or loaded in a previous session. <literal>Undefined</literal> "
"specifies that the identifier property value should be used."
msgstr ""
"<literal>unsaved-value</literal>（可选 — 默认是 <literal>undefined</"
"literal>）：用于标明某个实例时刚刚被实例化的（尚未保存）版本属性值，依靠这个"
"值就可以把这种情况 和已经在先前的 session 中保存或装载的脱管（detached）实例"
"区分开来。（<literal>undefined</literal> 指明应被使用的标识属性值。） "

#. Tag: para
#: basic_mapping.xml:1567
#, no-c-format
msgid ""
"<literal>generated</literal> (optional - defaults to <literal>never</"
"literal>): specifies that this version property value is generated by the "
"database. See the discussion of <link linkend=\"mapping-generated"
"\">generated properties</link> for more information."
msgstr ""
"<literal>generated</literal>（可选 — 默认是 <literal>never</literal>）：表明"
"此版本属性值是否实际上是由数据库生成的。请参阅  <link linkend=\"mapping-"
"generated\">generated properties</link> 部分的讨论。 "

#. Tag: para
#: basic_mapping.xml:1575
#, no-c-format
msgid ""
"<literal>insert</literal> (optional - defaults to <literal>true</literal>): "
"specifies whether the version column should be included in SQL insert "
"statements. It can be set to <literal>false</literal> if the database column "
"is defined with a default value of <literal>0</literal>."
msgstr ""
"<literal>insert</literal>（可选 — 默认是 <literal>true</literal>）：表明此版"
"本列应该包含在 SQL 插入语句中。只有当数据库字段有默认值 <literal>0</literal> "
"的时候，才可以设置为 <literal>false</literal>。 "

#. Tag: title
#: basic_mapping.xml:1586
#, fuzzy, no-c-format
msgid "Timestamp"
msgstr "timestamp（可选) "

#. Tag: para
#: basic_mapping.xml:1588
#, fuzzy, no-c-format
msgid ""
"Alternatively, you can use a timestamp. Timestamps are a less safe "
"implementation of optimistic locking. However, sometimes an application "
"might use the timestamps in other ways as well."
msgstr ""
"可选的 <literal>&lt;timestamp&gt;</literal> 元素指明了表中包含时间戳数据。这"
"用来作为版本的替代。时间戳本质上是一种对乐观锁定的一种不是特别安全的实现。当"
"然，有时候应用程序可能在其他方面使用时间戳。 "

#. Tag: para
#: basic_mapping.xml:1592
#, no-c-format
msgid ""
"Simply mark a property of type <classname>Date</classname> or "
"<classname>Calendar</classname> as <classname>@Version</classname>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1596
#, no-c-format
msgid ""
"@Entity\n"
"public class Flight implements Serializable {\n"
"...\n"
"    @Version\n"
"    public Date getLastUpdate() { ... }\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1598
#, no-c-format
msgid ""
"When using timestamp versioning you can tell Hibernate where to retrieve the "
"timestamp value from - database or JVM - by optionally adding the "
"<classname>@org.hibernate.annotations.Source</classname> annotation to the "
"property. Possible values for the value attribute of the annotation are "
"<classname>org.hibernate.annotations.SourceType.VM</classname> and "
"<classname>org.hibernate.annotations.SourceType.DB</classname>. The default "
"is <classname>SourceType.DB</classname> which is also used in case there is "
"no <classname>@Source</classname> annotation at all."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1609
#, no-c-format
msgid ""
"Like in the case of version numbers, the timestamp can also be generated by "
"the database instead of Hibernate. To do that, use <code>@org.hibernate."
"annotations.Generated(GenerationTime.ALWAYS).</code>"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1613
#, fuzzy, no-c-format
msgid "In hbm.xml, use the <literal>&lt;timestamp&gt;</literal> element:"
msgstr "例如，如果我们有如下的 <literal>&lt;properties&gt;</literal> 映射："

#. Tag: programlisting
#: basic_mapping.xml:1631
#, fuzzy, no-c-format
msgid ""
"&lt;timestamp\n"
"        column=\"timestamp_column\"\n"
"        name=\"propertyName\"\n"
"        access=\"field|property|ClassName\"\n"
"        unsaved-value=\"null|undefined\"\n"
"        source=\"vm|db\"\n"
"        generated=\"never|always\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"/&gt;"
msgstr ""
"<![CDATA[<timestamp\n"
"        column=\"timestamp_column\"\n"
"        name=\"propertyName\"\n"
"        access=\"field|property|ClassName\"\n"
"        unsaved-value=\"null|undefined\"\n"
"        source=\"vm|db\"\n"
"        generated=\"never|always\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"/>]]>"

#. Tag: para
#: basic_mapping.xml:1635
#, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): the "
"name of a column holding the timestamp."
msgstr ""
"<literal>column</literal>（可选 — 默认为属性名）：存有时间戳的字段名。 "

#. Tag: para
#: basic_mapping.xml:1641
#, no-c-format
msgid ""
"<literal>name</literal>: the name of a JavaBeans style property of Java type "
"<literal>Date</literal> or <literal>Timestamp</literal> of the persistent "
"class."
msgstr ""
"<literal>name</literal>：在持久化类中的 JavaBeans 风格的属性名，其 Java 类型"
"是 <literal>Date</literal> 或者 <literal>Timestamp</literal> 的。 "

#. Tag: para
#: basic_mapping.xml:1647 basic_mapping.xml:2174 basic_mapping.xml:2391
#: basic_mapping.xml:3262 basic_mapping.xml:3456 basic_mapping.xml:3629
#, no-c-format
msgid ""
"<literal>access</literal> (optional - defaults to <literal>property</"
"literal>): the strategy Hibernate uses for accessing the property value."
msgstr ""
"<literal>access</literal>（可选 — 默认为 <literal>property</literal>）："
"Hibernate 用来访问属性值的策略。 "

#. Tag: para
#: basic_mapping.xml:1653
#, no-c-format
msgid ""
"<literal>unsaved-value</literal> (optional - defaults to <literal>null</"
"literal>): a version property value that indicates that an instance is newly "
"instantiated (unsaved), distinguishing it from detached instances that were "
"saved or loaded in a previous session. <literal>Undefined</literal> "
"specifies that the identifier property value should be used."
msgstr ""
"<literal>unsaved-value</literal>（可选 — 默认是 <literal>null</literal>）：用"
"于标明某个实例时刚刚被实例化的（尚未保存）版本属性值，依靠这个值就可以把这种"
"情况和已经在先前的 session 中保存或装载的脱管（detached）实例区分开来。"
"（<literal>undefined</literal> 指明使用标识属性值进行这种判断。） "

#. Tag: para
#: basic_mapping.xml:1663
#, no-c-format
msgid ""
"<literal>source</literal> (optional - defaults to <literal>vm</literal>): "
"Where should Hibernate retrieve the timestamp value from? From the database, "
"or from the current JVM? Database-based timestamps incur an overhead because "
"Hibernate must hit the database in order to determine the \"next value\". It "
"is safer to use in clustered environments. Not all <literal>Dialects</"
"literal> are known to support the retrieval of the database's current "
"timestamp. Others may also be unsafe for usage in locking due to lack of "
"precision (Oracle 8, for example)."
msgstr ""
"<literal>source</literal>（可选 — 默认是 <literal>vm</literal>）：Hibernate "
"如何才能获取到时间戳的值呢？从数据库，还是当前 JVM？从数据库获取会带来一些负"
"担，因为 Hibernate 必须访问数据库来获得“下一个值”，但是在集群环境中会更安全"
"些。还要注意，并不是所有的 <literal>Dialect（方言）</literal>都支持获得数据库"
"的当前时间戳的，而支持的数据库中又有一部分因为精度不足，用于锁定是不安全的"
"（例如 Oracle 8）。 "

#. Tag: para
#: basic_mapping.xml:1676
#, no-c-format
msgid ""
"<literal>generated</literal> (optional - defaults to <literal>never</"
"literal>): specifies that this timestamp property value is actually "
"generated by the database. See the discussion of <link linkend=\"mapping-"
"generated\">generated properties</link> for more information."
msgstr ""
"<literal>generated</literal>（可选 - 默认是 <literal>never</literal>）：指出"
"时间戳值是否实际上是由数据库生成的。请参阅 <link linkend=\"mapping-generated"
"\">generated properties</link> 的讨论。 "

#. Tag: title
#: basic_mapping.xml:1686
#, no-c-format
msgid "Note"
msgstr "注意"

#. Tag: para
#: basic_mapping.xml:1688
#, no-c-format
msgid ""
"<literal>&lt;Timestamp&gt;</literal> is equivalent to <literal>&lt;version "
"type=\"timestamp\"&gt;</literal>. And <literal>&lt;timestamp source=\"db"
"\"&gt;</literal> is equivalent to <literal>&lt;version type=\"dbtimestamp"
"\"&gt;</literal>"
msgstr ""
"注意，<literal>&lt;timestamp&gt;</literal> 和 <literal>&lt;version type="
"\"timestamp\"&gt;</literal> 是等价的。并且 <literal>&lt;timestamp source=\"db"
"\"&gt;</literal> 和 <literal>&lt;version type=\"dbtimestamp\"&gt;</literal> "
"是等价的。 "

#. Tag: title
#: basic_mapping.xml:1697
#, no-c-format
msgid "Property"
msgstr "Property"

#. Tag: para
#: basic_mapping.xml:1699
#, no-c-format
msgid ""
"You need to decide which property needs to be made persistent in a given "
"entity. This differs slightly between the annotation driven metadata and the "
"hbm.xml files."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1704
#, no-c-format
msgid "Property mapping with annotations"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1706
#, no-c-format
msgid ""
"In the annotations world, every non static non transient property (field or "
"method depending on the access type) of an entity is considered persistent, "
"unless you annotate it as <literal>@Transient</literal>. Not having an "
"annotation for your property is equivalent to the appropriate "
"<literal>@Basic</literal> annotation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1713
#, no-c-format
msgid ""
"The <literal>@Basic</literal> annotation allows you to declare the fetching "
"strategy for a property. If set to <literal>LAZY</literal>, specifies that "
"this property should be fetched lazily when the instance variable is first "
"accessed. It requires build-time bytecode instrumentation, if your classes "
"are not instrumented, property level lazy loading is silently ignored. The "
"default is <literal>EAGER</literal>. You can also mark a property as not "
"optional thanks to the <classname>@Basic.optional</classname> attribute. "
"This will ensure that the underlying column are not nullable (if possible). "
"Note that a better approach is to use the <classname>@NotNull</classname> "
"annotation of the Bean Validation specification."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1726
#, no-c-format
msgid "Let's look at a few examples:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1728
#, no-c-format
msgid ""
"public transient int counter; //transient property\n"
"\n"
"private String firstname; //persistent property\n"
"\n"
"@Transient\n"
"String getLengthInMeter() { ... } //transient property\n"
"\n"
"String getName() {... } // persistent property\n"
"\n"
"@Basic\n"
"int getLength() { ... } // persistent property\n"
"\n"
"@Basic(fetch = FetchType.LAZY)\n"
"String getDetailedComment() { ... } // persistent property\n"
"\n"
"@Temporal(TemporalType.TIME)\n"
"java.util.Date getDepartureTime() { ... } // persistent property           \n"
"\n"
"@Enumerated(EnumType.STRING)\n"
"Starred getNote() { ... } //enum persisted as String in database"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1730
#, no-c-format
msgid ""
"<literal>counter</literal>, a transient field, and <literal>lengthInMeter</"
"literal>, a method annotated as <literal>@Transient</literal>, and will be "
"ignored by the Hibernate. <literal>name</literal>, <literal>length</"
"literal>, and <literal>firstname</literal> properties are mapped persistent "
"and eagerly fetched (the default for simple properties). The "
"<literal>detailedComment</literal> property value will be lazily fetched "
"from the database once a lazy property of the entity is accessed for the "
"first time. Usually you don't need to lazy simple properties (not to be "
"confused with lazy association fetching). The recommended alternative is to "
"use the projection capability of JP-QL (Java Persistence Query Language) or "
"Criteria queries."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1743
#, no-c-format
msgid ""
"JPA support property mapping of all basic types supported by Hibernate (all "
"basic Java types , their respective wrappers and serializable classes). "
"Hibernate Annotations supports out of the box enum type mapping either into "
"a ordinal column (saving the enum ordinal) or a string based column (saving "
"the enum string representation): the persistence representation, defaulted "
"to ordinal, can be overridden through the <literal>@Enumerated</literal> "
"annotation as shown in the <literal>note</literal> property example."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1753
#, no-c-format
msgid ""
"In plain Java APIs, the temporal precision of time is not defined. When "
"dealing with temporal data you might want to describe the expected precision "
"in database. Temporal data can have <literal>DATE</literal>, <literal>TIME</"
"literal>, or <literal>TIMESTAMP</literal> precision (ie the actual date, "
"only the time, or both). Use the <literal>@Temporal</literal> annotation to "
"fine tune that."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1761
#, no-c-format
msgid ""
"<literal>@Lob</literal> indicates that the property should be persisted in a "
"Blob or a Clob depending on the property type: <classname>java.sql.Clob</"
"classname>, <classname>Character[]</classname>, <classname>char[]</"
"classname> and java.lang.<classname>String</classname> will be persisted in "
"a Clob. <classname>java.sql.Blob</classname>, <classname>Byte[]</classname>, "
"<classname>byte[] </classname>and <classname>Serializable</classname> type "
"will be persisted in a Blob."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1770
#, no-c-format
msgid ""
"@Lob\n"
"public String getFullText() {\n"
"    return fullText;\n"
"}\n"
"\n"
"@Lob\n"
"public byte[] getFullCode() {\n"
"    return fullCode;\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1772
#, no-c-format
msgid ""
"If the property type implements <classname>java.io.Serializable</classname> "
"and is not a basic type, and if the property is not annotated with "
"<literal>@Lob</literal>, then the Hibernate <literal>serializable</literal> "
"type is used."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1779
#, no-c-format
msgid "Type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1781
#, no-c-format
msgid ""
"You can also manually specify a type using the <literal>@org.hibernate."
"annotations.Type</literal> and some parameters if needed. <classname>@Type."
"type</classname> could be:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1788 basic_mapping.xml:2220
#, no-c-format
msgid ""
"The name of a Hibernate basic type: <literal>integer, string, character, "
"date, timestamp, float, binary, serializable, object, blob</literal> etc."
msgstr ""
"Hibernate 基本类型名（比如：<literal>integer, string, character,date, "
"timestamp, float, binary, serializable, object, blob</literal>）。 "

#. Tag: para
#: basic_mapping.xml:1794 basic_mapping.xml:2226
#, no-c-format
msgid ""
"The name of a Java class with a default basic type: <literal>int, float, "
"char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
"literal> etc."
msgstr ""
"一个 Java 类的名字，这个类属于一种默认基础类型（比如：<literal>int, float,"
"char, java.lang.String, java.util.Date, java.lang.Integer, java.sql.Clob</"
"literal>)。 "

#. Tag: para
#: basic_mapping.xml:1800 basic_mapping.xml:2232
#, no-c-format
msgid "The name of a serializable Java class."
msgstr "一个可以序列化的 Java 类的名字。"

#. Tag: para
#: basic_mapping.xml:1804 basic_mapping.xml:2236
#, no-c-format
msgid ""
"The class name of a custom type: <literal>com.illflow.type.MyCustomType</"
"literal> etc."
msgstr ""
"一个自定义类型的类的名字。（比如：<literal>com.illflow.type.MyCustomType</"
"literal>)。 "

#. Tag: para
#: basic_mapping.xml:1809
#, fuzzy, no-c-format
msgid ""
"If you do not specify a type, Hibernate will use reflection upon the named "
"property and guess the correct Hibernate type. Hibernate will attempt to "
"interpret the name of the return class of the property getter using, in "
"order, rules 2, 3, and 4."
msgstr ""
"如果你没有指定类型，Hibernarte 会使用反射来得到这个名字的属性，以此来猜测正确"
"的 Hibernate 类型。Hibernate 会按照规则 2，3，4 的顺序对属性读取器（getter方"
"法）的返回类进行解释。然而，这还不够。 在某些情况下你仍然需要 <literal>type</"
"literal> 属性。（比如，为了区别<literal>Hibernate.DATE</literal> 和"
"<literal>Hibernate.TIMESTAMP</literal>,或者为了指定一个自定义类型。） "

#. Tag: para
#: basic_mapping.xml:1814
#, no-c-format
msgid ""
"<literal>@org.hibernate.annotations.TypeDef</literal> and <literal>@org."
"hibernate.annotations.TypeDefs</literal> allows you to declare type "
"definitions. These annotations can be placed at the class or package level. "
"Note that these definitions are global for the session factory (even when "
"defined at the class level). If the type is used on a single entity, you can "
"place the definition on the entity itself. Otherwise, it is recommended to "
"place the definition at the package level. In the example below, when "
"Hibernate encounters a property of class <literal>PhoneNumer</literal>, it "
"delegates the persistence strategy to the custom mapping type "
"<literal>PhoneNumberType</literal>. However, properties belonging to other "
"classes, too, can delegate their persistence strategy to "
"<literal>PhoneNumberType</literal>, by explicitly using the <literal>@Type</"
"literal> annotation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1830
#, no-c-format
msgid ""
"Package level annotations are placed in a file named <filename>package-info."
"java</filename> in the appropriate package. Place your annotations before "
"the package declaration."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1835
#, no-c-format
msgid ""
"@TypeDef(\n"
"   name = \"phoneNumber\",\n"
"   defaultForType = PhoneNumber.class,\n"
"   typeClass = PhoneNumberType.class\n"
")\n"
"\n"
"@Entity\n"
"public class ContactDetails {\n"
"   [...]\n"
"   private PhoneNumber localPhoneNumber;\n"
"   @Type(type=\"phoneNumber\")\n"
"   private OverseasPhoneNumber overseasPhoneNumber;\n"
"   [...]\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1837
#, no-c-format
msgid ""
"The following example shows the usage of the <literal>parameters</literal> "
"attribute to customize the TypeDef."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1841
#, no-c-format
msgid ""
"//in org/hibernate/test/annotations/entity/package-info.java\n"
"@TypeDefs(\n"
"    {\n"
"    @TypeDef(\n"
"        name=\"caster\",\n"
"        typeClass = CasterStringType.class,\n"
"        parameters = {\n"
"            @Parameter(name=\"cast\", value=\"lower\")\n"
"        }\n"
"    )\n"
"    }\n"
")\n"
"package org.hibernate.test.annotations.entity;\n"
"\n"
"//in org/hibernate/test/annotations/entity/Forest.java\n"
"public class Forest {\n"
"    @Type(type=\"caster\")\n"
"    public String getSmallText() {\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1843
#, no-c-format
msgid ""
"When using composite user type, you will have to express column definitions. "
"The <literal>@Columns</literal> has been introduced for that purpose."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1847
#, no-c-format
msgid ""
"@Type(type=\"org.hibernate.test.annotations.entity.MonetaryAmountUserType"
"\")\n"
"@Columns(columns = {\n"
"    @Column(name=\"r_amount\"),\n"
"    @Column(name=\"r_currency\")\n"
"})\n"
"public MonetaryAmount getAmount() {\n"
"    return amount;\n"
"}\n"
"\n"
"\n"
"public class MonetaryAmount implements Serializable {\n"
"    private BigDecimal amount;\n"
"    private Currency currency;\n"
"    ...\n"
"}"
msgstr ""

#. Tag: title
#: basic_mapping.xml:1851
#, no-c-format
msgid "Access type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1853
#, no-c-format
msgid ""
"By default the access type of a class hierarchy is defined by the position "
"of the <classname>@Id</classname> or <classname>@EmbeddedId</classname> "
"annotations. If these annotations are on a field, then only fields are "
"considered for persistence and the state is accessed via the field. If there "
"annotations are on a getter, then only the getters are considered for "
"persistence and the state is accessed via the getter/setter. That works well "
"in practice and is the recommended approach."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1861
#, no-c-format
msgid ""
"The placement of annotations within a class hierarchy has to be consistent "
"(either field or on property) to be able to determine the default access "
"type. It is recommended to stick to one single annotation placement strategy "
"throughout your whole application."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1868
#, no-c-format
msgid "However in some situations, you need to:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1872
#, no-c-format
msgid "force the access type of the entity hierarchy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1876
#, no-c-format
msgid "override the access type of a specific entity in the class hierarchy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1881
#, no-c-format
msgid "override the access type of an embeddable type"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1885
#, no-c-format
msgid ""
"The best use case is an embeddable class used by several entities that might "
"not use the same access type. In this case it is better to force the access "
"type at the embeddable class level."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1890
#, no-c-format
msgid ""
"To force the access type on a given class, use the <classname>@Access</"
"classname> annotation as showed below:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1893
#, no-c-format
msgid ""
"@Entity\n"
"public class Order {\n"
"   @Id private Long id;\n"
"   public Long getId() { return id; }\n"
"   public void setId(Long id) { this.id = id; }\n"
"\n"
"   @Embedded private Address address;\n"
"   public Address getAddress() { return address; }\n"
"   public void setAddress() { this.address = address; }\n"
"}\n"
"\n"
"@Entity\n"
"public class User {\n"
"   private Long id;\n"
"   @Id public Long getId() { return id; }\n"
"   public void setId(Long id) { this.id = id; }\n"
"\n"
"   private Address address;\n"
"   @Embedded public Address getAddress() { return address; }\n"
"   public void setAddress() { this.address = address; }\n"
"}\n"
"\n"
"@Embeddable\n"
"@Access(AcessType.PROPERTY)\n"
"public class Address {\n"
"   private String street1;\n"
"   public String getStreet1() { return street1; }\n"
"   public void setStreet1() { this.street1 = street1; }\n"
"\n"
"   private hashCode; //not persistent\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1895
#, no-c-format
msgid ""
"You can also override the access type of a single property while keeping the "
"other properties standard."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1898
#, no-c-format
msgid ""
"@Entity\n"
"public class Order {\n"
"   @Id private Long id;\n"
"   public Long getId() { return id; }\n"
"   public void setId(Long id) { this.id = id; }\n"
"   @Transient private String userId;\n"
"   @Transient private String orderId;\n"
"\n"
"   @Access(AccessType.PROPERTY)\n"
"   public String getOrderNumber() { return userId + \":\" + orderId; }\n"
"   public void setOrderNumber() { this.userId = ...; this.orderId = ...; }\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1900
#, no-c-format
msgid ""
"In this example, the default access type is <classname>FIELD</classname> "
"except for the <literal>orderNumber</literal> property. Note that the "
"corresponding field, if any must be marked as <classname>@Transient</"
"classname> or <code>transient</code>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1907
#, no-c-format
msgid "@org.hibernate.annotations.AccessType"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1909
#, no-c-format
msgid ""
"The annotation <classname>@org.hibernate.annotations.AccessType</classname> "
"should be considered deprecated for FIELD and PROPERTY access. It is still "
"useful however if you need to use a custom access type."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1918
#, no-c-format
msgid "Optimistic lock"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1920
#, no-c-format
msgid ""
"It is sometimes useful to avoid increasing the version number even if a "
"given property is dirty (particularly collections). You can do that by "
"annotating the property (or collection) with <literal>@OptimisticLock"
"(excluded=true)</literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1925
#, no-c-format
msgid ""
"More formally, specifies that updates to this property do not require "
"acquisition of the optimistic lock."
msgstr ""

#. Tag: title
#: basic_mapping.xml:1930
#, no-c-format
msgid "Declaring column attributes"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1932
#, no-c-format
msgid ""
"The column(s) used for a property mapping can be defined using the "
"<literal>@Column</literal> annotation. Use it to override default values "
"(see the JPA specification for more information on the defaults). You can "
"use this annotation at the property level for properties that are:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1940
#, no-c-format
msgid "not annotated at all"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1944
#, fuzzy, no-c-format
msgid "annotated with <literal>@Basic</literal>"
msgstr "<literal>assigned</literal>"

#. Tag: para
#: basic_mapping.xml:1948
#, fuzzy, no-c-format
msgid "annotated with <literal>@Version</literal>"
msgstr "<literal>string</literal>"

#. Tag: para
#: basic_mapping.xml:1952
#, fuzzy, no-c-format
msgid "annotated with <literal>@Lob</literal>"
msgstr "<literal>hilo</literal>"

#. Tag: para
#: basic_mapping.xml:1956
#, fuzzy, no-c-format
msgid "annotated with <literal>@Temporal</literal>"
msgstr "<literal>serializable</literal>"

#. Tag: programlisting
#: basic_mapping.xml:1960
#, no-c-format
msgid ""
"@Entity\n"
"public class Flight implements Serializable {\n"
"...\n"
"@Column(updatable = false, name = \"flight_name\", nullable = false, "
"length=50)\n"
"public String getName() { ... }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1962
#, no-c-format
msgid ""
"The <literal>name</literal> property is mapped to the <literal>flight_name</"
"literal> column, which is not nullable, has a length of 50 and is not "
"updatable (making the property immutable)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:1967
#, no-c-format
msgid ""
"This annotation can be applied to regular properties as well as "
"<literal>@Id</literal> or <literal>@Version</literal> properties."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:1994
#, no-c-format
msgid ""
"@Column(\n"
"    name=\"columnName\";\n"
"    boolean unique() default false;\n"
"    boolean nullable() default true;\n"
"    boolean insertable() default true;\n"
"    boolean updatable() default true;\n"
"    String columnDefinition() default \"\";\n"
"    String table() default \"\";\n"
"    int length() default 255;\n"
"    int precision() default 0; // decimal precision\n"
"    int scale() default 0; // decimal scale"
msgstr ""

#. Tag: para
#: basic_mapping.xml:1998
#, fuzzy, no-c-format
msgid ""
"<literal>name</literal> (optional): the column name (default to the property "
"name)"
msgstr "<literal>name</literal>（可选）：标识属性的名字。 "

#. Tag: para
#: basic_mapping.xml:2003
#, fuzzy, no-c-format
msgid ""
"<literal>unique</literal> (optional): set a unique constraint on this column "
"or not (default false)"
msgstr ""
"<literal>unique</literal>（可选）：使用 DDL 为该字段添加唯一的约束。同样，允"
"许它作为 <literal>property-ref</literal> 引用的目标。 "

#. Tag: para
#: basic_mapping.xml:2008
#, fuzzy, no-c-format
msgid ""
"<literal>nullable</literal> (optional): set the column as nullable (default "
"true)."
msgstr "<literal>name</literal>（可选）：标识属性的名字。 "

#. Tag: para
#: basic_mapping.xml:2013
#, fuzzy, no-c-format
msgid ""
"<literal>insertable</literal> (optional): whether or not the column will be "
"part of the insert statement (default true)"
msgstr "<literal>name</literal>（可选）：标识属性的名字。 "

#. Tag: para
#: basic_mapping.xml:2019
#, fuzzy, no-c-format
msgid ""
"<literal>updatable</literal> (optional): whether or not the column will be "
"part of the update statement (default true)"
msgstr "<literal>catalog</literal>（可选）：数据库 catalog 的名称。 "

#. Tag: para
#: basic_mapping.xml:2025
#, no-c-format
msgid ""
"<literal>columnDefinition</literal> (optional): override the sql DDL "
"fragment for this particular column (non portable)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2031
#, fuzzy, no-c-format
msgid ""
"<literal>table</literal> (optional): define the targeted table (default "
"primary table)"
msgstr "<literal>catalog</literal>（可选）：数据库 catalog 的名称。 "

#. Tag: para
#: basic_mapping.xml:2036
#, no-c-format
msgid ""
"<literal><literal>length</literal></literal> (optional): column length "
"(default 255)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2041
#, no-c-format
msgid ""
"<literal><literal>precision</literal></literal> (optional): column decimal "
"precision (default 0)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2046
#, no-c-format
msgid ""
"<literal><literal>scale</literal></literal> (optional): column decimal scale "
"if useful (default 0)"
msgstr ""

#. Tag: title
#: basic_mapping.xml:2054
#, no-c-format
msgid "Formula"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2056
#, no-c-format
msgid ""
"Sometimes, you want the Database to do some computation for you rather than "
"in the JVM, you might also create some kind of virtual column. You can use a "
"SQL fragment (aka formula) instead of mapping a property into a column. This "
"kind of property is read only (its value is calculated by your formula "
"fragment)."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2062
#, no-c-format
msgid ""
"@Formula(\"obj_length * obj_height * obj_width\")\n"
"public long getObjectVolume()"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2064
#, no-c-format
msgid ""
"The SQL fragment can be as complex as you want and even include subselects."
msgstr ""

#. Tag: title
#: basic_mapping.xml:2069
#, no-c-format
msgid "Non-annotated property defaults"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2071
#, no-c-format
msgid "If a property is not annotated, the following rules apply:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2074
#, no-c-format
msgid "If the property is of a single type, it is mapped as @Basic"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2079
#, no-c-format
msgid ""
"Otherwise, if the type of the property is annotated as @Embeddable, it is "
"mapped as @Embedded"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2084
#, no-c-format
msgid ""
"Otherwise, if the type of the property is <classname>Serializable</"
"classname>, it is mapped as <classname>@Basic</classname> in a column "
"holding the object in its serialized version"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2091
#, no-c-format
msgid ""
"Otherwise, if the type of the property is <classname>java.sql.Clob</"
"classname> or <classname>java.sql.Blob</classname>, it is mapped as "
"<classname>@Lob</classname> with the appropriate <classname>LobType</"
"classname>"
msgstr ""

#. Tag: title
#: basic_mapping.xml:2102
#, no-c-format
msgid "Property mapping with hbm.xml"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2104
#, no-c-format
msgid ""
"The <literal>&lt;property&gt;</literal> element declares a persistent "
"JavaBean style property of the class."
msgstr ""
"<literal>&lt;property&gt;</literal> 元素为类定义了一个持久化的、JavaBean 风格"
"的属性。 "

#. Tag: programlisting
#: basic_mapping.xml:2136
#, fuzzy, no-c-format
msgid ""
"&lt;property\n"
"        name=\"propertyName\"\n"
"        column=\"column_name\"\n"
"        type=\"typename\"\n"
"        update=\"true|false\"\n"
"        insert=\"true|false\"\n"
"        formula=\"arbitrary SQL expression\"\n"
"        access=\"field|property|ClassName\"\n"
"        lazy=\"true|false\"\n"
"        unique=\"true|false\"\n"
"        not-null=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        generated=\"never|insert|always\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"        index=\"index_name\"\n"
"        unique_key=\"unique_key_id\"\n"
"        length=\"L\"\n"
"        precision=\"P\"\n"
"        scale=\"S\"\n"
"/&gt;"
msgstr ""
"<![CDATA[<property\n"
"        name=\"propertyName\"\n"
"        column=\"column_name\"\n"
"        type=\"typename\"\n"
"        update=\"true|false\"\n"
"        insert=\"true|false\"\n"
"        formula=\"arbitrary SQL expression\"\n"
"        access=\"field|property|ClassName\"\n"
"        lazy=\"true|false\"\n"
"        unique=\"true|false\"\n"
"        not-null=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        generated=\"never|insert|always\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"        index=\"index_name\"\n"
"        unique_key=\"unique_key_id\"\n"
"        length=\"L\"\n"
"        precision=\"P\"\n"
"        scale=\"S\"\n"
"/>]]>"

#. Tag: para
#: basic_mapping.xml:2140
#, no-c-format
msgid ""
"<literal>name</literal>: the name of the property, with an initial lowercase "
"letter."
msgstr "<literal>name</literal>：属性的名字，以小写字母开头。"

#. Tag: para
#: basic_mapping.xml:2145
#, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to the property name): the "
"name of the mapped database table column. This can also be specified by "
"nested <literal>&lt;column&gt;</literal> element(s)."
msgstr ""
"<literal>column</literal>（可选 — 默认为属性名字）：对应的数据库字段名。 也可"
"以通过嵌套的 <literal>&lt;column&gt;</literal> 元素指定。 "

#. Tag: para
#: basic_mapping.xml:2157
#, no-c-format
msgid ""
"<literal>update, insert</literal> (optional - defaults to <literal>true</"
"literal>): specifies that the mapped columns should be included in SQL "
"<literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. "
"Setting both to <literal>false</literal> allows a pure \"derived\" property "
"whose value is initialized from some other property that maps to the same "
"column(s), or by a trigger or other application."
msgstr ""
"<literal>update, insert</literal>（可选 — 默认为 <literal>true</literal>）： "
"表明用于　<literal>UPDATE</literal> 和/或 <literal>INSERT</literal> 的 SQL 语"
"句中是否包含这个被映射了的字段。这二者如果都设置为 <literal>false</literal> "
"则表明这是一个“外源性（derived）”的属性，它的值来源于映射到同一个（或多个） "
"字段的某些其他属性，或者通过一个 trigger（触发器）或其他程序生成。 "

#. Tag: para
#: basic_mapping.xml:2167
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): an SQL expression that defines the "
"value for a <emphasis>computed</emphasis> property. Computed properties do "
"not have a column mapping of their own."
msgstr ""
"<literal>formula</literal>（可选）：一个 SQL 表达式，定义了这个<emphasis>计"
"算 （computed）</emphasis> 属性的值。计算属性没有和它对应的数据库字段。"

#. Tag: para
#: basic_mapping.xml:2180
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
"specifies that this property should be fetched lazily when the instance "
"variable is first accessed. It requires build-time bytecode instrumentation."
msgstr ""
"<literal>lazy</literal>（可选 — 默认为 <literal>false</literal>）：指定 指定"
"实例变量第一次被访问时，这个属性是否延迟抓取（fetched lazily）（ 需要运行时字"
"节码增强）。 "

#. Tag: para
#: basic_mapping.xml:2187
#, no-c-format
msgid ""
"<literal>unique</literal> (optional): enables the DDL generation of a unique "
"constraint for the columns. Also, allow this to be the target of a "
"<literal>property-ref</literal>."
msgstr ""
"<literal>unique</literal>（可选）：使用 DDL 为该字段添加唯一的约束。同样，允"
"许它作为 <literal>property-ref</literal> 引用的目标。 "

#. Tag: para
#: basic_mapping.xml:2194
#, no-c-format
msgid ""
"<literal>not-null</literal> (optional): enables the DDL generation of a "
"nullability constraint for the columns."
msgstr ""
"<literal>not-null</literal>（可选）：使用 DDL 为该字段添加可否为空"
"（nullability）的约束。 "

#. Tag: para
#: basic_mapping.xml:2199 basic_mapping.xml:3282
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that updates to this property do or do not require "
"acquisition of the optimistic lock. In other words, it determines if a "
"version increment should occur when this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal>（可选 — 默认为 <literal>true</literal>）："
"指定这个属性在做更新时是否需要获得乐观锁定（optimistic lock）。换句话说，它决"
"定这个属性发生脏数据时版本（version）的值是否增长。 "

#. Tag: para
#: basic_mapping.xml:2207
#, no-c-format
msgid ""
"<literal>generated</literal> (optional - defaults to <literal>never</"
"literal>): specifies that this property value is actually generated by the "
"database. See the discussion of <link linkend=\"mapping-generated"
"\">generated properties</link> for more information."
msgstr ""
"<literal>generated</literal>（可选 — 默认为 <literal>never</literal>）：表明"
"此属性值是否实际上是由数据库生成的。请参阅 <link linkend=\"mapping-generated"
"\">generated properties</link> 的讨论。 "

#. Tag: para
#: basic_mapping.xml:2216
#, no-c-format
msgid "<emphasis>typename</emphasis> could be:"
msgstr "<emphasis>typename</emphasis> 可以是如下几种："

#. Tag: para
#: basic_mapping.xml:2241
#, no-c-format
msgid ""
"If you do not specify a type, Hibernate will use reflection upon the named "
"property and guess the correct Hibernate type. Hibernate will attempt to "
"interpret the name of the return class of the property getter using, in "
"order, rules 2, 3, and 4. In certain cases you will need the <literal>type</"
"literal> attribute. For example, to distinguish between <literal>Hibernate."
"DATE</literal> and <literal>Hibernate.TIMESTAMP</literal>, or to specify a "
"custom type."
msgstr ""
"如果你没有指定类型，Hibernarte 会使用反射来得到这个名字的属性，以此来猜测正确"
"的 Hibernate 类型。Hibernate 会按照规则 2，3，4 的顺序对属性读取器（getter方"
"法）的返回类进行解释。然而，这还不够。 在某些情况下你仍然需要 <literal>type</"
"literal> 属性。（比如，为了区别<literal>Hibernate.DATE</literal> 和"
"<literal>Hibernate.TIMESTAMP</literal>,或者为了指定一个自定义类型。） "

#. Tag: para
#: basic_mapping.xml:2250
#, no-c-format
msgid ""
"The <literal>access</literal> attribute allows you to control how Hibernate "
"accesses the property at runtime. By default, Hibernate will call the "
"property get/set pair. If you specify <literal>access=\"field\"</literal>, "
"Hibernate will bypass the get/set pair and access the field directly using "
"reflection. You can specify your own strategy for property access by naming "
"a class that implements the interface <literal>org.hibernate.property."
"PropertyAccessor</literal>."
msgstr ""
"<literal>access</literal> 属性用来让你控制 Hibernate 如何在运行时访问属性。在"
"默认情况下，Hibernate 会使用属性的 get/set 方法对（pair）。如果你指明 "
"<literal>access=\"field\"</literal>，Hibernate 会忽略 get/set 方法对，直接使"
"用反射来访问成员变量。你也可以指定你自己的策略，这就需要你自己实现 "
"<literal>org.hibernate.property.access.spi.PropertyAccessStrategy</literal> 接口，再在 access "
"中设置你自定义策略类的名字。 "

#. Tag: para
#: basic_mapping.xml:2259
#, no-c-format
msgid ""
"A powerful feature is derived properties. These properties are by definition "
"read-only. The property value is computed at load time. You declare the "
"computation as an SQL expression. This then translates to a <literal>SELECT</"
"literal> clause subquery in the SQL query that loads an instance:"
msgstr ""
"衍生属性（derive propertie）是一个特别强大的特征。这些属性应该定义为只读，属"
"性值在装载时计算生成。 你用一个 SQL 表达式生成计算的结果，它会在这个实例转载"
"时翻译成一个 SQL 查询的 <literal>SELECT</literal> 子查询语句。 "

#. Tag: programlisting
#: basic_mapping.xml:2265
#, fuzzy, no-c-format
msgid ""
"&lt;property name=\"totalPrice\"\n"
"    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product "
"p\n"
"                WHERE li.productId = p.productId\n"
"                AND li.customerId = customerId\n"
"                AND li.orderNumber = orderNumber )\"/&gt;"
msgstr ""
"&lt;property name=\"totalPrice\"\n"
"    formula=\"( SELECT SUM (li.quantity*p.price) FROM LineItem li, Product "
"p\n"
"                WHERE li.productId = p.productId\n"
"                AND li.customerId = customerId\n"
"                AND li.orderNumber = orderNumber )\"/&gt;"

#. Tag: para
#: basic_mapping.xml:2267
#, no-c-format
msgid ""
"You can reference the entity table by not declaring an alias on a particular "
"column. This would be <literal>customerId</literal> in the given example. "
"You can also use the nested <literal>&lt;formula&gt;</literal> mapping "
"element if you do not want to use the attribute."
msgstr ""
"注意，你可以使用实体自己的表，而不用为这个特别的列定义别名（上面例子中的 "
"<literal>customerId</literal>）。同时注意，如果你不喜欢使用属性， 你可以使用"
"嵌套的 <literal>&lt;formula&gt;</literal> 映射元素。 "

#. Tag: title
#: basic_mapping.xml:2276
#, no-c-format
msgid "Embedded objects (aka components)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2278
#, fuzzy, no-c-format
msgid ""
"Embeddable objects (or components) are objects whose properties are mapped "
"to the same table as the owning entity's table. Components can, in turn, "
"declare their own properties, components or collections"
msgstr ""
"<literal>&lt;component&gt;</literal> 元素把子对象的一些元素与父类对应的表的一"
"些字段映射起来。然后组件可以定义它们自己的属性、组件或者集合。参见后面"
"的“Components”一章。 "

#. Tag: para
#: basic_mapping.xml:2283
#, no-c-format
msgid ""
"It is possible to declare an embedded component inside an entity and even "
"override its column mapping. Component classes have to be annotated at the "
"class level with the <literal>@Embeddable</literal> annotation. It is "
"possible to override the column mapping of an embedded object for a "
"particular entity using the <literal>@Embedded</literal> and "
"<literal>@AttributeOverride</literal> annotation in the associated property:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2291
#, no-c-format
msgid ""
"@Entity\n"
"public class Person implements Serializable {\n"
"\n"
"    // Persistent component using defaults\n"
"    Address homeAddress;\n"
"\n"
"    @Embedded\n"
"    @AttributeOverrides( {\n"
"            @AttributeOverride(name=\"iso2\", column = @Column(name="
"\"bornIso2\") ),\n"
"            @AttributeOverride(name=\"name\", column = @Column(name="
"\"bornCountryName\") )\n"
"    } )\n"
"    Country bornIn;\n"
"    ...\n"
"}"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2293
#, no-c-format
msgid ""
"@Embeddable\n"
"public class Address implements Serializable {\n"
"    String city;\n"
"    Country nationality; //no overriding here\n"
"}"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2295
#, no-c-format
msgid ""
"@Embeddable\n"
"public class Country implements Serializable {\n"
"    private String iso2;\n"
"    @Column(name=\"countryName\") private String name;\n"
"\n"
"    public String getIso2() { return iso2; }\n"
"    public void setIso2(String iso2) { this.iso2 = iso2; }\n"
"\n"
"    \n"
"    public String getName() { return name; }\n"
"    public void setName(String name) { this.name = name; }\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2297
#, no-c-format
msgid ""
"An embeddable object inherits the access type of its owning entity (note "
"that you can override that using the <literal>@Access</literal> annotation)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2301
#, no-c-format
msgid ""
"The <literal>Person</literal> entity has two component properties, "
"<literal>homeAddress</literal> and <literal>bornIn</literal>. "
"<literal>homeAddress</literal> property has not been annotated, but "
"Hibernate will guess that it is a persistent component by looking for the "
"<literal>@Embeddable</literal> annotation in the Address class. We also "
"override the mapping of a column name (to <literal>bornCountryName</"
"literal>) with the <literal>@Embedded</literal> and "
"<literal>@AttributeOverride </literal>annotations for each mapped attribute "
"of <literal>Country</literal>. As you can see, <literal>Country </literal>is "
"also a nested component of <literal>Address</literal>, again using auto-"
"detection by Hibernate and JPA defaults. Overriding columns of embedded "
"objects of embedded objects is through dotted expressions."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2316
#, no-c-format
msgid ""
"@Embedded\n"
"    @AttributeOverrides( {\n"
"            @AttributeOverride(name=\"city\", column = @Column(name="
"\"fld_city\") ),\n"
"            @AttributeOverride(name=\"nationality.iso2\", column = @Column"
"(name=\"nat_Iso2\") ),\n"
"            @AttributeOverride(name=\"nationality.name\", column = @Column"
"(name=\"nat_CountryName\") )\n"
"            //nationality columns in homeAddress are overridden\n"
"    } )\n"
"    Address homeAddress;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2318
#, no-c-format
msgid ""
"Hibernate Annotations supports something that is not explicitly supported by "
"the JPA specification. You can annotate a embedded object with the "
"<literal>@MappedSuperclass</literal> annotation to make the superclass "
"properties persistent (see <literal>@MappedSuperclass</literal> for more "
"informations)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2324
#, no-c-format
msgid ""
"You can also use association annotations in an embeddable object (ie "
"<literal>@OneToOne</literal>, <classname>@ManyToOne</classname>, "
"<classname>@OneToMany</classname> or <literal>@ManyToMany</literal>). To "
"override the association columns you can use <literal>@AssociationOverride</"
"literal>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2330
#, no-c-format
msgid ""
"If you want to have the same embeddable object type twice in the same "
"entity, the column name defaulting will not work as several embedded objects "
"would share the same set of columns. In plain JPA, you need to override at "
"least one set of columns. Hibernate, however, allows you to enhance the "
"default naming mechanism through the <classname>NamingStrategy</classname> "
"interface. You can write a strategy that prevent name clashing in such a "
"situation. <classname>DefaultComponentSafeNamingStrategy</classname> is an "
"example of this."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2340
#, no-c-format
msgid ""
"If a property of the embedded object points back to the owning entity, "
"annotate it with the <classname>@Parent</classname> annotation. Hibernate "
"will make sure this property is properly loaded with the entity reference."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2345
#, no-c-format
msgid "In XML, use the <literal>&lt;component&gt;</literal> element."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2367
#, fuzzy, no-c-format
msgid ""
"&lt;component\n"
"        name=\"propertyName\"\n"
"        class=\"className\"\n"
"        insert=\"true|false\"\n"
"        update=\"true|false\"\n"
"        access=\"field|property|ClassName\"\n"
"        lazy=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        unique=\"true|false\"\n"
"        node=\"element-name|.\"\n"
"&gt;\n"
"\n"
"        &lt;property ...../&gt;\n"
"        &lt;many-to-one .... /&gt;\n"
"        ........\n"
"&lt;/component&gt;"
msgstr ""
"&lt;component \n"
"        name=\"propertyName\" \n"
"        class=\"className\"\n"
"        insert=\"true|false\"\n"
"        update=\"true|false\"\n"
"        access=\"field|property|ClassName\"\n"
"        lazy=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        unique=\"true|false\"\n"
"        node=\"element-name|.\"\n"
"&gt;\n"
"        \n"
"        &lt;property ...../&gt;\n"
"        &lt;many-to-one .... /&gt;\n"
"        ........\n"
"&lt;/component&gt;"

#. Tag: para
#: basic_mapping.xml:2371 basic_mapping.xml:3217 basic_mapping.xml:3417
#, no-c-format
msgid "<literal>name</literal>: the name of the property."
msgstr "<literal>name</literal>：属性名。"

#. Tag: para
#: basic_mapping.xml:2375
#, no-c-format
msgid ""
"<literal>class</literal> (optional - defaults to the property type "
"determined by reflection): the name of the component (child) class."
msgstr ""
"<literal>class</literal>（可选 — 默认为通过反射得到的属性类型）：组件（子）类"
"的名字。 "

#. Tag: para
#: basic_mapping.xml:2381 basic_mapping.xml:3677
#, no-c-format
msgid ""
"<literal>insert</literal>: do the mapped columns appear in SQL "
"<literal>INSERTs</literal>?"
msgstr ""
"<literal>insert</literal>：被映射的字段是否出现在 SQL 的 <literal>INSERT</"
"literal> 语句中？ "

#. Tag: para
#: basic_mapping.xml:2386 basic_mapping.xml:3682
#, no-c-format
msgid ""
"<literal>update</literal>: do the mapped columns appear in SQL "
"<literal>UPDATEs</literal>?"
msgstr ""
"<literal>update</literal>：被映射的字段是否出现在 SQL 的 <literal>UPDATE</"
"literal> 语句中？ "

#. Tag: para
#: basic_mapping.xml:2397
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>false</literal>): "
"specifies that this component should be fetched lazily when the instance "
"variable is first accessed. It requires build-time bytecode instrumentation."
msgstr ""
"<literal>lazy</literal>（可选 — 默认是 <literal>false</literal>）：表明此组件"
"应在实例变量第一次被访问的时候延迟加载（需要编译时字节码装置器）。"

#. Tag: para
#: basic_mapping.xml:2404
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that updates to this component either do or do not "
"require acquisition of the optimistic lock. It determines if a version "
"increment should occur when this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal>（可选 — 默认是 <literal>true</literal>）："
"表明更新此组件是否需要获取乐观锁。换句话说，当这个属性变脏时，是否增加版本号"
"（Version）。"

#. Tag: para
#: basic_mapping.xml:2412 basic_mapping.xml:3695
#, no-c-format
msgid ""
"<literal>unique</literal> (optional - defaults to <literal>false</literal>): "
"specifies that a unique constraint exists upon all mapped columns of the "
"component."
msgstr ""
"<literal>unique</literal>（可选 — 默认是 <literal>false</literal>）：表明组件"
"映射的所有字段上都有唯一性约束。"

#. Tag: para
#: basic_mapping.xml:2419
#, no-c-format
msgid ""
"The child <literal>&lt;property&gt;</literal> tags map properties of the "
"child class to table columns."
msgstr ""
"其 <literal>&lt;property&gt;</literal> 子标签为子类的一些属性与表字段之间建立"
"映射。"

#. Tag: para
#: basic_mapping.xml:2422
#, no-c-format
msgid ""
"The <literal>&lt;component&gt;</literal> element allows a <literal>&lt;"
"parent&gt;</literal> subelement that maps a property of the component class "
"as a reference back to the containing entity."
msgstr ""
"<literal>&lt;component&gt;</literal> 元素允许加入一个 <literal>&lt;parent&gt;"
"</literal> 子元素，在组件类内部就可以有一个指向其容器的实体的反向引用。"

#. Tag: para
#: basic_mapping.xml:2426
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;dynamic-component&gt;</literal> element allows a "
"<literal>Map</literal> to be mapped as a component, where the property names "
"refer to keys of the map. See <xref linkend=\"components-dynamic\"/> for "
"more information. This feature is not supported in annotations."
msgstr ""
"<literal>&lt;dynamic-component&gt;</literal> 元素允许把一个 <literal>Map</"
"literal> 映射为组件，其属性名对应 map 的键值。参见 <xref linkend="
"\"components-dynamic\"/>。 "

#. Tag: title
#: basic_mapping.xml:2434
#, no-c-format
msgid "Inheritance strategy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2436
#, no-c-format
msgid ""
"Java is a language supporting polymorphism: a class can inherit from "
"another. Several strategies are possible to persist a class hierarchy:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2442
#, no-c-format
msgid ""
"Single table per class hierarchy strategy: a single table hosts all the "
"instances of a class hierarchy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2447
#, no-c-format
msgid ""
"Joined subclass strategy: one table per class and subclass is present and "
"each table persist the properties specific to a given subclass. The state of "
"the entity is then stored in its corresponding class table and all its "
"superclasses"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2454
#, no-c-format
msgid ""
"Table per class strategy: one table per concrete class and subclass is "
"present and each table persist the properties of the class and its "
"superclasses. The state of the entity is then stored entirely in the "
"dedicated table for its class."
msgstr ""

#. Tag: title
#: basic_mapping.xml:2462
#, no-c-format
msgid "Single table per class hierarchy strategy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2464
#, no-c-format
msgid ""
"With this approach the properties of all the subclasses in a given mapped "
"class hierarchy are stored in a single table."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2467
#, fuzzy, no-c-format
msgid ""
"Each subclass declares its own persistent properties and subclasses. Version "
"and id properties are assumed to be inherited from the root class. Each "
"subclass in a hierarchy must define a unique discriminator value. If this is "
"not specified, the fully qualified Java class name is used."
msgstr ""
"每个子类都应该定义它自己的持久化属性和子类。<literal>&lt;version&gt;</"
"literal> 和 <literal>&lt;id&gt;</literal> 属性可以从根父类继承下来。在一棵继"
"承树上的每个子类都必须定义一个唯一的 <literal>discriminator-value</literal>。"
"如果没有指定，就会使用 Java 类的全限定名。 "

#. Tag: programlisting
#: basic_mapping.xml:2473 basic_mapping.xml:2581
#, no-c-format
msgid ""
"@Entity\n"
"@Inheritance(strategy=InheritanceType.SINGLE_TABLE)\n"
"@DiscriminatorColumn(\n"
"    name=\"planetype\",\n"
"    discriminatorType=DiscriminatorType.STRING\n"
")\n"
"@DiscriminatorValue(\"Plane\")\n"
"public class Plane { ... }\n"
"\n"
"@Entity\n"
"@DiscriminatorValue(\"A320\")\n"
"public class A320 extends Plane { ... }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2475
#, fuzzy, no-c-format
msgid ""
"In hbm.xml, for the table-per-class-hierarchy mapping strategy, the "
"<literal>&lt;subclass&gt;</literal> declaration is used. For example:"
msgstr ""
"最后，多态持久化需要为父类的每个子类都进行定义。对于“每一棵类继承树对应一个"
"表”的策略来说，就需要使用 <literal>&lt;subclass&gt;</literal> 定义。 "

#. Tag: programlisting
#: basic_mapping.xml:2490
#, fuzzy, no-c-format
msgid ""
"&lt;subclass\n"
"        name=\"ClassName\"\n"
"        discriminator-value=\"discriminator_value\"\n"
"        proxy=\"ProxyInterface\"\n"
"        lazy=\"true|false\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name\"\n"
"        extends=\"SuperclassName\"&gt;\n"
"\n"
"        &lt;property .... /&gt;\n"
"        .....\n"
"&lt;/subclass&gt;"
msgstr ""
"&lt;subclass\n"
"        name=\"ClassName\"\n"
"        discriminator-value=\"discriminator_value\"\n"
"        proxy=\"ProxyInterface\"\n"
"        lazy=\"true|false\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name\"\n"
"        extends=\"SuperclassName\"&gt;\n"
"\n"
"        &lt;property .... /&gt;\n"
"        .....\n"
"&lt;/subclass&gt;"

#. Tag: para
#: basic_mapping.xml:2494 basic_mapping.xml:2692 basic_mapping.xml:2756
#, no-c-format
msgid ""
"<literal>name</literal>: the fully qualified class name of the subclass."
msgstr "<literal>name</literal>：子类的全限定名。 "

#. Tag: para
#: basic_mapping.xml:2499
#, no-c-format
msgid ""
"<literal>discriminator-value</literal> (optional - defaults to the class "
"name): a value that distinguishes individual subclasses."
msgstr ""
"<literal>discriminator-value（辨别标志）</literal>（可选 — 默认为类名）：一个"
"用于区分每个独立的子类的值。 "

#. Tag: para
#: basic_mapping.xml:2505
#, no-c-format
msgid ""
"<literal>proxy</literal> (optional): specifies a class or interface used for "
"lazy initializing proxies."
msgstr ""
"<literal>proxy</literal>（可选）：指定一个类或者接口，在延迟装载时作为代理使"
"用。 "

#. Tag: para
#: basic_mapping.xml:2510
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>true</literal>): "
"setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr ""
"<literal>lazy</literal>（可选，默认是 <literal>true</literal>）：设置为 "
"<literal>lazy=\"false\"</literal> 禁止使用延迟装载。 "

#. Tag: para
#: basic_mapping.xml:2518 basic_mapping.xml:2721 basic_mapping.xml:2782
#, fuzzy, no-c-format
msgid ""
"For information about inheritance mappings see <xref linkend=\"inheritance\"/"
">."
msgstr "更多关于继承映射的信息，参考 <xref linkend=\"inheritance\"/>。 "

#. Tag: title
#: basic_mapping.xml:2522
#, no-c-format
msgid "Discriminator"
msgstr "鉴别器（discriminator） "

#. Tag: para
#: basic_mapping.xml:2524
#, fuzzy, no-c-format
msgid ""
"Discriminators are required for polymorphic persistence using the table-per-"
"class-hierarchy mapping strategy. It declares a discriminator column of the "
"table. The discriminator column contains marker values that tell the "
"persistence layer what subclass to instantiate for a particular row. "
"Hibernate Core supports the follwoing restricted set of types as "
"discriminator column: <literal>string</literal>, <literal>character</"
"literal>, <literal>integer</literal>, <literal>byte</literal>, "
"<literal>short</literal>, <literal>boolean</literal>, <literal>yes_no</"
"literal>, <literal>true_false</literal>."
msgstr ""
"在\"一棵对象继承树对应一个表\"的策略中，<literal>&lt;discriminator&gt;</"
"literal> 元素是必需的，它定义了表的鉴别器字段。鉴别器字段包含标志值，用于告知"
"持久化层应该为某个特定的行创建哪一个子类的实例。如下这些受到限制的类型可以使"
"用：<literal>string</literal>、<literal>character</literal>、"
"<literal>integer</literal>、<literal>byte</literal>、<literal>short</"
"literal>、<literal>boolean</literal>、<literal>yes_no</literal>、"
"<literal>true_false</literal>。"

#. Tag: para
#: basic_mapping.xml:2535
#, no-c-format
msgid ""
"Use the <classname>@DiscriminatorColumn</classname> to define the "
"discriminator column as well as the discriminator type. <note> "
"<para><classname>The enum DiscriminatorType</classname> used in "
"<classname>javax.persitence.DiscriminatorColumn</classname> only contains "
"the values <constant>STRING</constant>, <constant>CHAR</constant> and "
"<constant>INTEGER</constant> which means that not all Hibernate supported "
"types are available via the <classname>@DiscriminatorColumn</classname> "
"annotation.</para> </note>You can also use <classname>@DiscriminatorFormula</"
"classname> to express in SQL a virtual discriminator column. This is "
"particularly useful when the discriminator value can be extracted from one "
"or more columns of the table. Both <classname>@DiscriminatorColumn</"
"classname> and <classname>@DiscriminatorFormula</classname> are to be set on "
"the root entity (once per persisted hierarchy)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2552
#, no-c-format
msgid ""
"<classname>@org.hibernate.annotations.DiscriminatorOptions</classname> "
"allows to optionally specify Hibernate specific discriminator options which "
"are not standardized in JPA. The available options are <literal>force</"
"literal> and <literal>insert</literal>. The <literal>force</literal> "
"attribute is useful if the table contains rows with \"extra\" discriminator "
"values that are not mapped to a persistent class. This could for example "
"occur when working with a legacy database. If <literal>force</literal> is "
"set to <constant>true</constant> Hibernate will specify the allowed "
"discriminator values in the <literal>SELECT</literal> query, even when "
"retrieving all instances of the root class. The second option - "
"<literal>insert</literal> - tells Hibernate whether or not to include the "
"discriminator column in SQL <literal>INSERTs</literal>. Usually the column "
"should be part of the <literal>INSERT</literal> statement, but if your "
"discriminator column is also part of a mapped composite identifier you have "
"to set this option to <constant>false</constant>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2569
#, no-c-format
msgid ""
"There is also a <classname>@org.hibernate.annotations.ForceDiscriminator</"
"classname> annotation which is deprecated since version 3.6. Use "
"<classname>@DiscriminatorOptions</classname> instead."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2575
#, no-c-format
msgid ""
"Finally, use <classname>@DiscriminatorValue</classname> on each class of the "
"hierarchy to specify the value stored in the discriminator column for a "
"given entity. If you do not set <classname>@DiscriminatorValue</classname> "
"on a class, the fully qualified class name is used."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2583
#, no-c-format
msgid ""
"In hbm.xml, the <literal>&lt;discriminator&gt;</literal> element is used to "
"define the discriminator column or formula:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2600
#, fuzzy, no-c-format
msgid ""
"&lt;discriminator\n"
"        column=\"discriminator_column\"\n"
"        type=\"discriminator_type\"\n"
"        force=\"true|false\"\n"
"        insert=\"true|false\"\n"
"        formula=\"arbitrary sql expression\"\n"
"/&gt;"
msgstr ""
"<![CDATA[<discriminator\n"
"        column=\"discriminator_column\"\n"
"        type=\"discriminator_type\"\n"
"        force=\"true|false\"\n"
"        insert=\"true|false\"\n"
"        formula=\"arbitrary sql expression\"\n"
"/>]]>"

#. Tag: para
#: basic_mapping.xml:2604
#, no-c-format
msgid ""
"<literal>column</literal> (optional - defaults to <literal>class</literal>): "
"the name of the discriminator column."
msgstr ""
"<literal>column</literal>（可选 — 默认为 <literal>class</literal>）"
"discriminator 器字段的名字。"

#. Tag: para
#: basic_mapping.xml:2610
#, no-c-format
msgid ""
"<literal>type</literal> (optional - defaults to <literal>string</literal>): "
"a name that indicates the Hibernate type"
msgstr ""
"<literal>type</literal>（可选 — 默认为 <literal>string</literal>）一个 "
"Hibernate 字段类型的名字 "

#. Tag: para
#: basic_mapping.xml:2616
#, no-c-format
msgid ""
"<literal>force</literal> (optional - defaults to <literal>false</literal>): "
"\"forces\" Hibernate to specify the allowed discriminator values, even when "
"retrieving all instances of the root class."
msgstr ""
"<literal>force(强制)</literal>（可选 — 默认为 <literal>false</literal>）\"强"
"制\" Hibernate 指定允许的鉴别器值,即使当取得的所有实例都是根类的。 "

#. Tag: para
#: basic_mapping.xml:2623
#, no-c-format
msgid ""
"<literal>insert</literal> (optional - defaults to <literal>true</literal>): "
"set this to <literal>false</literal> if your discriminator column is also "
"part of a mapped composite identifier. It tells Hibernate not to include the "
"column in SQL <literal>INSERTs</literal>."
msgstr ""
"<literal>insert</literal>（可选 - 默认为<literal>true</literal>）如果你的鉴别"
"器字段也是映射为复合标识（composite identifier）的一部分，则需将这个值设为 "
"<literal>false</literal>。（告诉 Hibernate 在做 SQL <literal>INSERT</"
"literal> 时不包含该列） "

#. Tag: para
#: basic_mapping.xml:2631
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): an arbitrary SQL expression that is "
"executed when a type has to be evaluated. It allows content-based "
"discrimination."
msgstr ""
"<literal>formula</literal>（可选）一个 SQL 表达式，在类型判断（判断是父类还是"
"具体子类 — 译注）时执行。可用于基于内容的鉴别器。 "

#. Tag: para
#: basic_mapping.xml:2638
#, no-c-format
msgid ""
"Actual values of the discriminator column are specified by the "
"<literal>discriminator-value</literal> attribute of the <literal>&lt;"
"class&gt;</literal> and <literal>&lt;subclass&gt;</literal> elements."
msgstr ""
"鉴别器字段的实际值是根据 <literal>&lt;class&gt;</literal> 和 <literal>&lt;"
"subclass&gt;</literal> 元素中的 <literal>discriminator-value</literal> 属性得"
"来的。"

#. Tag: para
#: basic_mapping.xml:2643
#, no-c-format
msgid ""
"The <literal>formula</literal> attribute allows you to declare an arbitrary "
"SQL expression that will be used to evaluate the type of a row. For example:"
msgstr ""
"使用 <literal>formula</literal> 属性你可以定义一个 SQL 表达式，用来判断一行数"
"据的类型。"

#. Tag: programlisting
#: basic_mapping.xml:2647
#, fuzzy, no-c-format
msgid ""
"&lt;discriminator\n"
"    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
"    type=\"integer\"/&gt;"
msgstr ""
"<![CDATA[<discriminator\n"
"    formula=\"case when CLASS_TYPE in ('a', 'b', 'c') then 0 else 1 end\"\n"
"    type=\"integer\"/>]]>"

#. Tag: title
#: basic_mapping.xml:2652
#, fuzzy, no-c-format
msgid "Joined subclass strategy"
msgstr "连接的子类（joined-subclass） "

#. Tag: para
#: basic_mapping.xml:2654
#, fuzzy, no-c-format
msgid ""
"Each subclass can also be mapped to its own table. This is called the table-"
"per-subclass mapping strategy. An inherited state is retrieved by joining "
"with the table of the superclass. A discriminator column is not required for "
"this mapping strategy. Each subclass must, however, declare a table column "
"holding the object identifier. The primary key of this table is also a "
"foreign key to the superclass table and described by the "
"<classname>@PrimaryKeyJoinColumn</classname>s or the <literal>&lt;key&gt;</"
"literal> element."
msgstr ""
"此外，每个子类可能被映射到他自己的表中（每个子类一个表的策略）。被继承的状态"
"通过和超类的表关联得到。我们使用 <literal>&lt;joined-subclass&gt;</literal> "
"元素。 "

#. Tag: programlisting
#: basic_mapping.xml:2664
#, no-c-format
msgid ""
"@Entity @Table(name=\"CATS\")\n"
"@Inheritance(strategy=InheritanceType.JOINED)\n"
"public class Cat implements Serializable { \n"
"    @Id @GeneratedValue(generator=\"cat-uuid\") \n"
"    @GenericGenerator(name=\"cat-uuid\", strategy=\"uuid\")\n"
"    String getId() { return id; }\n"
"\n"
"    ...\n"
"}\n"
"\n"
"@Entity @Table(name=\"DOMESTIC_CATS\")\n"
"@PrimaryKeyJoinColumn(name=\"CAT\")\n"
"public class DomesticCat extends Cat { \n"
"    public String getName() { return name; }\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2667
#, no-c-format
msgid ""
"The table name still defaults to the non qualified class name. Also if "
"<classname>@PrimaryKeyJoinColumn</classname> is not set, the primary key / "
"foreign key columns are assumed to have the same names as the primary key "
"columns of the primary table of the superclass."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2674
#, fuzzy, no-c-format
msgid ""
"In hbm.xml, use the <literal>&lt;joined-subclass&gt;</literal> element. For "
"example:"
msgstr "你可以使用 <literal>class</literal> 元素来定义一个持久化类。例如："

#. Tag: programlisting
#: basic_mapping.xml:2688
#, fuzzy, no-c-format
msgid ""
"&lt;joined-subclass\n"
"        name=\"ClassName\"\n"
"        table=\"tablename\"\n"
"        proxy=\"ProxyInterface\"\n"
"        lazy=\"true|false\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        schema=\"schema\"\n"
"        catalog=\"catalog\"\n"
"        extends=\"SuperclassName\"\n"
"        persister=\"ClassName\"\n"
"        subselect=\"SQL expression\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name\"&gt;\n"
"\n"
"        &lt;key .... &gt;\n"
"\n"
"        &lt;property .... /&gt;\n"
"        .....\n"
"&lt;/joined-subclass&gt;"
msgstr ""
"&lt;joined-subclass\n"
"        name=\"ClassName\"\n"
"        table=\"tablename\"\n"
"        proxy=\"ProxyInterface\"\n"
"        lazy=\"true|false\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        schema=\"schema\"\n"
"        catalog=\"catalog\"\n"
"        extends=\"SuperclassName\"\n"
"        persister=\"ClassName\"\n"
"        subselect=\"SQL expression\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name\"&gt;\n"
"\n"
"        &lt;key .... &gt;\n"
"\n"
"        &lt;property .... /&gt;\n"
"        .....\n"
"&lt;/joined-subclass&gt;"

#. Tag: para
#: basic_mapping.xml:2697 basic_mapping.xml:2761
#, no-c-format
msgid "<literal>table</literal>: the name of the subclass table."
msgstr "<literal>table</literal>：子类的表名。"

#. Tag: para
#: basic_mapping.xml:2702 basic_mapping.xml:2766
#, no-c-format
msgid ""
"<literal>proxy</literal> (optional): specifies a class or interface to use "
"for lazy initializing proxies."
msgstr ""
"<literal>proxy</literal>（可选）：指定一个类或者接口，在延迟装载时作为代理使"
"用。 "

#. Tag: para
#: basic_mapping.xml:2707 basic_mapping.xml:2771
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional, defaults to <literal>true</literal>): "
"setting <literal>lazy=\"false\"</literal> disables the use of lazy fetching."
msgstr ""
"<literal>lazy</literal>（可选，默认是 <literal>true</literal>）：设置为 "
"<literal>lazy=\"false\"</literal> 禁止使用延迟装载。 "

#. Tag: para
#: basic_mapping.xml:2715
#, no-c-format
msgid ""
"Use the <literal>&lt;key&gt;</literal> element to declare the primary key / "
"foreign key column. The mapping at the start of the chapter would then be re-"
"written as:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2719
#, fuzzy, no-c-format
msgid ""
"&lt;?xml version=\"1.0\"?&gt;\n"
"&lt;!DOCTYPE hibernate-mapping PUBLIC\n"
"        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
"        \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;\n"
"\n"
"&lt;hibernate-mapping package=\"eg\"&gt;\n"
"\n"
"        &lt;class name=\"Cat\" table=\"CATS\"&gt;\n"
"                &lt;id name=\"id\" column=\"uid\" type=\"long\"&gt;\n"
"                        &lt;generator class=\"hilo\"/&gt;\n"
"                &lt;/id&gt;\n"
"                &lt;property name=\"birthdate\" type=\"date\"/&gt;\n"
"                &lt;property name=\"color\" not-null=\"true\"/&gt;\n"
"                &lt;property name=\"sex\" not-null=\"true\"/&gt;\n"
"                &lt;property name=\"weight\"/&gt;\n"
"                &lt;many-to-one name=\"mate\"/&gt;\n"
"                &lt;set name=\"kittens\"&gt;\n"
"                        &lt;key column=\"MOTHER\"/&gt;\n"
"                        &lt;one-to-many class=\"Cat\"/&gt;\n"
"                &lt;/set&gt;\n"
"                &lt;joined-subclass name=\"DomesticCat\" table="
"\"DOMESTIC_CATS\"&gt;\n"
"                    &lt;key column=\"CAT\"/&gt;\n"
"                    &lt;property name=\"name\" type=\"string\"/&gt;\n"
"                &lt;/joined-subclass&gt;\n"
"        &lt;/class&gt;\n"
"\n"
"        &lt;class name=\"eg.Dog\"&gt;\n"
"                &lt;!-- mapping for Dog could go here --&gt;\n"
"        &lt;/class&gt;\n"
"\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""
"&lt;?xml version=\"1.0\"?&gt;\n"
"&lt;!DOCTYPE hibernate-mapping PUBLIC\n"
"        \"-//Hibernate/Hibernate Mapping DTD//EN\"\n"
"        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\"&gt;\n"
"\n"
"&lt;hibernate-mapping package=\"eg\"&gt;\n"
"\n"
"        &lt;class name=\"Cat\" table=\"CATS\"&gt;\n"
"                &lt;id name=\"id\" column=\"uid\" type=\"long\"&gt;\n"
"                        &lt;generator class=\"hilo\"/&gt;\n"
"                &lt;/id&gt;\n"
"                &lt;property name=\"birthdate\" type=\"date\"/&gt;\n"
"                &lt;property name=\"color\" not-null=\"true\"/&gt;\n"
"                &lt;property name=\"sex\" not-null=\"true\"/&gt;\n"
"                &lt;property name=\"weight\"/&gt;\n"
"                &lt;many-to-one name=\"mate\"/&gt;\n"
"                &lt;set name=\"kittens\"&gt;\n"
"                        &lt;key column=\"MOTHER\"/&gt;\n"
"                        &lt;one-to-many class=\"Cat\"/&gt;\n"
"                &lt;/set&gt;\n"
"                &lt;joined-subclass name=\"DomesticCat\" table="
"\"DOMESTIC_CATS\"&gt;\n"
"                    &lt;key column=\"CAT\"/&gt;\n"
"                    &lt;property name=\"name\" type=\"string\"/&gt;\n"
"                &lt;/joined-subclass&gt;\n"
"        &lt;/class&gt;\n"
"\n"
"        &lt;class name=\"eg.Dog\"&gt;\n"
"                &lt;!-- mapping for Dog could go here --&gt;\n"
"        &lt;/class&gt;\n"
"\n"
"&lt;/hibernate-mapping&gt;"

#. Tag: title
#: basic_mapping.xml:2726
#, no-c-format
msgid "Table per class strategy"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2728
#, fuzzy, no-c-format
msgid ""
"A third option is to map only the concrete classes of an inheritance "
"hierarchy to tables. This is called the table-per-concrete-class strategy. "
"Each table defines all persistent states of the class, including the "
"inherited state. In Hibernate, it is not necessary to explicitly map such "
"inheritance hierarchies. You can map each class as a separate entity root. "
"However, if you wish use polymorphic associations (e.g. an association to "
"the superclass of your hierarchy), you need to use the union subclass "
"mapping."
msgstr ""
"第三种选择是仅仅映射类继承树中具体类部分到表中（每个具体类一张表的策略）。其"
"中，每张表定义了类的所有持久化状态，包括继承的状态。在 Hibernate 中，并不需要"
"完全显式地映射这样的继承树。你可以简单地使用单独的 <literal>&lt;class&gt;</"
"literal> 定义映射每个类。然而，如果你想使用多态关联（例如，一个对类继承树中超"
"类的关联），你需要使用 <literal>&lt;union-subclass&gt;</literal> 映射。 "

#. Tag: programlisting
#: basic_mapping.xml:2737
#, no-c-format
msgid ""
"@Entity\n"
"@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\n"
"public class Flight implements Serializable { ... }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2739
#, no-c-format
msgid "Or in hbm.xml:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2752
#, fuzzy, no-c-format
msgid ""
"&lt;union-subclass\n"
"        name=\"ClassName\"\n"
"        table=\"tablename\"\n"
"        proxy=\"ProxyInterface\"\n"
"        lazy=\"true|false\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        schema=\"schema\"\n"
"        catalog=\"catalog\"\n"
"        extends=\"SuperclassName\"\n"
"        abstract=\"true|false\"\n"
"        persister=\"ClassName\"\n"
"        subselect=\"SQL expression\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name\"&gt;\n"
"\n"
"        &lt;property .... /&gt;\n"
"        .....\n"
"&lt;/union-subclass&gt;"
msgstr ""
"&lt;union-subclass\n"
"        name=\"ClassName\"\n"
"        table=\"tablename\"\n"
"        proxy=\"ProxyInterface\"\n"
"        lazy=\"true|false\"\n"
"        dynamic-update=\"true|false\"\n"
"        dynamic-insert=\"true|false\"\n"
"        schema=\"schema\"\n"
"        catalog=\"catalog\"\n"
"        extends=\"SuperclassName\"\n"
"        abstract=\"true|false\"\n"
"        persister=\"ClassName\"\n"
"        subselect=\"SQL expression\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name\"&gt;\n"
"\n"
"        &lt;property .... /&gt;\n"
"        .....\n"
"&lt;/union-subclass&gt;"

#. Tag: para
#: basic_mapping.xml:2779
#, no-c-format
msgid ""
"No discriminator column or key column is required for this mapping strategy."
msgstr "这种映射策略不需要指定辨别标志（discriminator）字段。"

#. Tag: title
#: basic_mapping.xml:2787
#, no-c-format
msgid "Inherit properties from superclasses"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2789
#, no-c-format
msgid ""
"This is sometimes useful to share common properties through a technical or a "
"business superclass without including it as a regular mapped entity (ie no "
"specific table for this entity). For that purpose you can map them as "
"<literal>@MappedSuperclass</literal>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2794
#, no-c-format
msgid ""
"@MappedSuperclass\n"
"public class BaseEntity {\n"
"    @Basic\n"
"    @Temporal(TemporalType.TIMESTAMP)\n"
"    public Date getLastUpdate() { ... }\n"
"    public String getLastUpdater() { ... }\n"
"    ...\n"
"}\n"
"\n"
"@Entity class Order extends BaseEntity {\n"
"    @Id public Integer getId() { ... }\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2796
#, no-c-format
msgid ""
"In database, this hierarchy will be represented as an <literal>Order</"
"literal> table having the <literal>id</literal>, <literal>lastUpdate</"
"literal> and <literal>lastUpdater</literal> columns. The embedded superclass "
"property mappings are copied into their entity subclasses. Remember that the "
"embeddable superclass is not the root of the hierarchy though."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2804
#, no-c-format
msgid ""
"Properties from superclasses not mapped as <literal>@MappedSuperclass</"
"literal> are ignored."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2809
#, no-c-format
msgid ""
"The default access type (field or methods) is used, unless you use the "
"<literal>@Access</literal> annotation."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2814
#, no-c-format
msgid ""
"The same notion can be applied to <literal>@Embeddable</literal> objects to "
"persist properties from their superclasses. You also need to use "
"<literal>@MappedSuperclass</literal> to do that (this should not be "
"considered as a standard EJB3 feature though)"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2822
#, no-c-format
msgid ""
"It is allowed to mark a class as <literal>@MappedSuperclass</literal> in the "
"middle of the mapped inheritance hierarchy."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2828
#, no-c-format
msgid ""
"Any class in the hierarchy non annotated with <literal>@MappedSuperclass</"
"literal> nor <literal>@Entity</literal> will be ignored."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2833
#, no-c-format
msgid ""
"You can override columns defined in entity superclasses at the root entity "
"level using the <literal>@AttributeOverride</literal> annotation."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2837
#, no-c-format
msgid ""
"@MappedSuperclass\n"
"public class FlyingObject implements Serializable {\n"
"\n"
"    public int getAltitude() {\n"
"        return altitude;\n"
"    }\n"
"\n"
"    @Transient\n"
"    public int getMetricAltitude() {\n"
"        return metricAltitude;\n"
"    }\n"
"\n"
"    @ManyToOne\n"
"    public PropulsionType getPropulsion() {\n"
"        return metricAltitude;\n"
"    }\n"
"    ...\n"
"}\n"
"\n"
"@Entity\n"
"@AttributeOverride( name=\"altitude\", column = @Column(name=\"fld_altitude"
"\") )\n"
"@AssociationOverride( \n"
"   name=\"propulsion\", \n"
"   joinColumns = @JoinColumn(name=\"fld_propulsion_fk\") \n"
")\n"
"public class Plane extends FlyingObject {\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2839
#, no-c-format
msgid ""
"The <literal>altitude</literal> property will be persisted in an "
"<literal>fld_altitude</literal> column of table <literal>Plane</literal> and "
"the propulsion association will be materialized in a "
"<literal>fld_propulsion_fk</literal> foreign key column."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2845
#, no-c-format
msgid ""
"You can define <literal>@AttributeOverride</literal>(s) and "
"<literal>@AssociationOverride</literal>(s) on <literal>@Entity</literal> "
"classes, <literal>@MappedSuperclass</literal> classes and properties "
"pointing to an <literal>@Embeddable</literal> object."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2851
#, no-c-format
msgid ""
"In hbm.xml, simply map the properties of the superclass in the <literal>&lt;"
"class&gt;</literal> element of the entity that needs to inherit them."
msgstr ""

#. Tag: title
#: basic_mapping.xml:2857
#, no-c-format
msgid "Mapping one entity to several tables"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2859
#, no-c-format
msgid ""
"While not recommended for a fresh schema, some legacy databases force your "
"to map a single entity on several tables."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2862
#, no-c-format
msgid ""
"Using the <literal>@SecondaryTable</literal> or <literal>@SecondaryTables</"
"literal> class level annotations. To express that a column is in a "
"particular table, use the <literal>table</literal> parameter of "
"<literal>@Column</literal> or <literal>@JoinColumn</literal>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2868
#, no-c-format
msgid ""
"@Entity\n"
"@Table(name=\"MainCat\")\n"
"@SecondaryTables({\n"
"    @SecondaryTable(name=\"Cat1\", pkJoinColumns={\n"
"        @PrimaryKeyJoinColumn(name=\"cat_id\", referencedColumnName=\"id\")\n"
"    ),\n"
"    @SecondaryTable(name=\"Cat2\", uniqueConstraints={@UniqueConstraint"
"(columnNames={\"storyPart2\"})})\n"
"})\n"
"public class Cat implements Serializable {\n"
"\n"
"    private Integer id;\n"
"    private String name;\n"
"    private String storyPart1;\n"
"    private String storyPart2;\n"
"\n"
"    @Id @GeneratedValue\n"
"    public Integer getId() {\n"
"        return id;\n"
"    }\n"
"\n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
"    \n"
"    @Column(table=\"Cat1\")\n"
"    public String getStoryPart1() {\n"
"        return storyPart1;\n"
"    }\n"
"\n"
"    @Column(table=\"Cat2\")\n"
"    public String getStoryPart2() {\n"
"        return storyPart2;\n"
"    }\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2870
#, no-c-format
msgid ""
"In this example, <literal>name</literal> will be in <literal>MainCat</"
"literal>. <literal>storyPart1</literal> will be in <literal>Cat1</literal> "
"and <literal>storyPart2</literal> will be in <literal>Cat2</literal>. "
"<literal>Cat1</literal> will be joined to <literal>MainCat</literal> using "
"the <literal>cat_id</literal> as a foreign key, and <literal>Cat2</literal> "
"using <literal>id</literal> (ie the same column name, the <literal>MainCat</"
"literal> id column has). Plus a unique constraint on <literal>storyPart2</"
"literal> has been set."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2880
#, no-c-format
msgid ""
"There is also additional tuning accessible via the <classname>@org.hibernate."
"annotations.Table</classname> annotation:"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2886
#, fuzzy, no-c-format
msgid ""
"<literal>fetch</literal>: If set to JOIN, the default, Hibernate will use an "
"inner join to retrieve a secondary table defined by a class or its "
"superclasses and an outer join for a secondary table defined by a subclass. "
"If set to <classname>SELECT</classname> then Hibernate will use a sequential "
"select for a secondary table defined on a subclass, which will be issued "
"only if a row turns out to represent an instance of the subclass. Inner "
"joins will still be used to retrieve a secondary defined by the class and "
"its superclasses."
msgstr ""
"<literal>fetch</literal>（可选 — 默认是 <literal>join</literal>）：如果设置为"
"默认值 <literal>join</literal>，Hibernate 将使用一个内连接来得到这个类或其超"
"类定义的 <literal>&lt;join&gt;</literal>，而使用一个外连接来得到其子类定义的 "
"<literal>&lt;join&gt;</literal>。如果设置为 <literal>select</literal>，则 "
"Hibernate 将为子类定义的 <literal>&lt;join&gt;</literal> 使用顺序选择。这仅在"
"一行数据表示一个子类的对象的时候才会发生。对这个类和其超类定义的 "
"<literal>&lt;join&gt;</literal>，依然会使用内连接得到。 "

#. Tag: para
#: basic_mapping.xml:2898
#, fuzzy, no-c-format
msgid ""
"<literal>inverse</literal>: If true, Hibernate will not try to insert or "
"update the properties defined by this join. Default to false."
msgstr ""
"<literal>inverse</literal>（可选 — 默认是 <literal>false</literal>）：如果打"
"开，Hibernate 不会插入或者更新此连接定义的属性。 "

#. Tag: para
#: basic_mapping.xml:2904
#, fuzzy, no-c-format
msgid ""
"<literal>optional</literal>: If enabled (the default), Hibernate will insert "
"a row only if the properties defined by this join are non-null and will "
"always use an outer join to retrieve the properties."
msgstr ""
"<literal>optional</literal>（可选 — 默认是 <literal>false</literal>）：如果打"
"开，Hibernate 只会在此连接定义的属性非空时插入一行数据，并且总是使用一个外连"
"接来得到这些属性。 "

#. Tag: para
#: basic_mapping.xml:2911
#, no-c-format
msgid ""
"<literal>foreignKey</literal>: defines the Foreign Key name of a secondary "
"table pointing back to the primary table."
msgstr ""

#. Tag: para
#: basic_mapping.xml:2916
#, no-c-format
msgid ""
"Make sure to use the secondary table name in the <methodname>appliesto</"
"methodname> property"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:2919
#, no-c-format
msgid ""
"@Entity\n"
"@Table(name=\"MainCat\")\n"
"@SecondaryTable(name=\"Cat1\")\n"
"@org.hibernate.annotations.Table(\n"
"   appliesTo=\"Cat1\",\n"
"   fetch=FetchMode.SELECT,\n"
"   optional=true)\n"
"public class Cat implements Serializable {\n"
"\n"
"    private Integer id;\n"
"    private String name;\n"
"    private String storyPart1;\n"
"    private String storyPart2;\n"
"\n"
"    @Id @GeneratedValue\n"
"    public Integer getId() {\n"
"        return id;\n"
"    }\n"
"\n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
"    \n"
"    @Column(table=\"Cat1\")\n"
"    public String getStoryPart1() {\n"
"        return storyPart1;\n"
"    }\n"
"\n"
"    @Column(table=\"Cat2\")\n"
"    public String getStoryPart2() {\n"
"        return storyPart2;\n"
"    }\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:2921
#, fuzzy, no-c-format
msgid "In hbm.xml, use the <literal>&lt;join&gt;</literal> element."
msgstr "例如，如果我们有如下的 <literal>&lt;properties&gt;</literal> 映射："

#. Tag: programlisting
#: basic_mapping.xml:2939
#, fuzzy, no-c-format
msgid ""
"&lt;join\n"
"        table=\"tablename\"\n"
"        schema=\"owner\"\n"
"        catalog=\"catalog\"\n"
"        fetch=\"join|select\"\n"
"        inverse=\"true|false\"\n"
"        optional=\"true|false\"&gt;\n"
"\n"
"        &lt;key ... /&gt;\n"
"\n"
"        &lt;property ... /&gt;\n"
"        ...\n"
"&lt;/join&gt;"
msgstr ""
"&lt;join\n"
"        table=\"tablename\"\n"
"        schema=\"owner\"\n"
"        catalog=\"catalog\"\n"
"        fetch=\"join|select\"\n"
"        inverse=\"true|false\"\n"
"        optional=\"true|false\"&gt;\n"
"        \n"
"        &lt;key ... /&gt;\n"
"        \n"
"        &lt;property ... /&gt;\n"
"        ...\n"
"&lt;/join&gt;"

#. Tag: para
#: basic_mapping.xml:2943
#, no-c-format
msgid "<literal>table</literal>: the name of the joined table."
msgstr "<literal>table</literal>：被连接表的名称。 "

#. Tag: para
#: basic_mapping.xml:2960
#, no-c-format
msgid ""
"<literal>fetch</literal> (optional - defaults to <literal>join</literal>): "
"if set to <literal>join</literal>, the default, Hibernate will use an inner "
"join to retrieve a <literal>&lt;join&gt;</literal> defined by a class or its "
"superclasses. It will use an outer join for a <literal>&lt;join&gt;</"
"literal> defined by a subclass. If set to <literal>select</literal> then "
"Hibernate will use a sequential select for a <literal>&lt;join&gt;</literal> "
"defined on a subclass. This will be issued only if a row represents an "
"instance of the subclass. Inner joins will still be used to retrieve a "
"<literal>&lt;join&gt;</literal> defined by the class and its superclasses."
msgstr ""
"<literal>fetch</literal>（可选 — 默认是 <literal>join</literal>）：如果设置为"
"默认值 <literal>join</literal>，Hibernate 将使用一个内连接来得到这个类或其超"
"类定义的 <literal>&lt;join&gt;</literal>，而使用一个外连接来得到其子类定义的 "
"<literal>&lt;join&gt;</literal>。如果设置为 <literal>select</literal>，则 "
"Hibernate 将为子类定义的 <literal>&lt;join&gt;</literal> 使用顺序选择。这仅在"
"一行数据表示一个子类的对象的时候才会发生。对这个类和其超类定义的 "
"<literal>&lt;join&gt;</literal>，依然会使用内连接得到。 "

#. Tag: para
#: basic_mapping.xml:2975
#, no-c-format
msgid ""
"<literal>inverse</literal> (optional - defaults to <literal>false</"
"literal>): if enabled, Hibernate will not insert or update the properties "
"defined by this join."
msgstr ""
"<literal>inverse</literal>（可选 — 默认是 <literal>false</literal>）：如果打"
"开，Hibernate 不会插入或者更新此连接定义的属性。 "

#. Tag: para
#: basic_mapping.xml:2981
#, no-c-format
msgid ""
"<literal>optional</literal> (optional - defaults to <literal>false</"
"literal>): if enabled, Hibernate will insert a row only if the properties "
"defined by this join are non-null. It will always use an outer join to "
"retrieve the properties."
msgstr ""
"<literal>optional</literal>（可选 — 默认是 <literal>false</literal>）：如果打"
"开，Hibernate 只会在此连接定义的属性非空时插入一行数据，并且总是使用一个外连"
"接来得到这些属性。 "

#. Tag: para
#: basic_mapping.xml:2989
#, no-c-format
msgid ""
"For example, address information for a person can be mapped to a separate "
"table while preserving value type semantics for all properties:"
msgstr ""
"例如，一个人（person）的地址（address）信息可以被映射到单独的表中（并保留所有"
"属性的值类型语义）： "

#. Tag: programlisting
#: basic_mapping.xml:2993
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Person\"\n"
"    table=\"PERSON\"&gt;\n"
"\n"
"    &lt;id name=\"id\" column=\"PERSON_ID\"&gt;...&lt;/id&gt;\n"
"\n"
"    &lt;join table=\"ADDRESS\"&gt;\n"
"        &lt;key column=\"ADDRESS_ID\"/&gt;\n"
"        &lt;property name=\"address\"/&gt;\n"
"        &lt;property name=\"zip\"/&gt;\n"
"        &lt;property name=\"country\"/&gt;\n"
"    &lt;/join&gt;\n"
"    ..."
msgstr ""
"&lt;class name=\"Person\"\n"
"    table=\"PERSON\"&gt;\n"
"\n"
"    &lt;id name=\"id\" column=\"PERSON_ID\"&gt;...&lt;/id&gt;\n"
"\n"
"    &lt;join table=\"ADDRESS\"&gt;\n"
"        &lt;key column=\"ADDRESS_ID\"/&gt;\n"
"        &lt;property name=\"address\"/&gt;\n"
"        &lt;property name=\"zip\"/&gt;\n"
"        &lt;property name=\"country\"/&gt;\n"
"    &lt;/join&gt;\n"
"    ..."

#. Tag: para
#: basic_mapping.xml:2995
#, no-c-format
msgid ""
"This feature is often only useful for legacy data models. We recommend fewer "
"tables than classes and a fine-grained domain model. However, it is useful "
"for switching between inheritance mapping strategies in a single hierarchy, "
"as explained later."
msgstr ""
"此特性常常对遗留数据模型有用，我们推荐表个数比类个数少，以及细粒度的领域模"
"型。然而，在单独的继承树上切换继承映射策略是有用的，后面会解释这点。 "

#. Tag: title
#: basic_mapping.xml:3003
#, no-c-format
msgid "Mapping one to one and one to many associations"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3005
#, no-c-format
msgid ""
"To link one entity to an other, you need to map the association property as "
"a to one association. In the relational model, you can either use a foreign "
"key or an association table, or (a bit less common) share the same primary "
"key value between the two entities."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3010
#, no-c-format
msgid ""
"To mark an association, use either <classname>@ManyToOne</classname> or "
"<classname>@OnetoOne</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3014
#, no-c-format
msgid ""
"<literal>@ManyToOne</literal> and <classname>@OneToOne</classname> have a "
"parameter named <literal>targetEntity</literal> which describes the target "
"entity name. You usually don't need this parameter since the default value "
"(the type of the property that stores the association) is good in almost all "
"cases. However this is useful when you want to use interfaces as the return "
"type instead of the regular entity."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3021
#, no-c-format
msgid ""
"Setting a value of the <literal>cascade</literal> attribute to any "
"meaningful value other than nothing will propagate certain operations to the "
"associated object. The meaningful values are divided into three categories."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3028
#, no-c-format
msgid ""
"basic operations, which include: <literal>persist, merge, delete, save-"
"update, evict, replicate, lock and refresh</literal>;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3034
#, fuzzy, no-c-format
msgid ""
"special values: <literal>delete-orphan</literal> or <literal>all</literal> ;"
msgstr ""
"注意这里关联是如何用 <literal>entity-name</literal> 来代替 <literal>class</"
"literal> 的。 "

#. Tag: para
#: basic_mapping.xml:3039
#, no-c-format
msgid ""
"comma-separated combinations of operation names: <literal>cascade=\"persist,"
"merge,evict\"</literal> or <literal>cascade=\"all,delete-orphan\"</literal>. "
"See <xref linkend=\"objectstate-transitive\"/> for a full explanation. Note "
"that single valued many-to-one associations do not support orphan delete."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3048
#, no-c-format
msgid ""
"By default, single point associations are eagerly fetched in JPA 2. You can "
"mark it as lazily fetched by using <classname>@ManyToOne(fetch=FetchType."
"LAZY) </classname>in which case Hibernate will proxy the association and "
"load it when the state of the associated entity is reached. You can force "
"Hibernate not to use a proxy by using <classname>@LazyToOne(NO_PROXY)</"
"classname>. In this case, the property is fetched lazily when the instance "
"variable is first accessed. This requires build-time bytecode "
"instrumentation. lazy=\"false\" specifies that the association will always "
"be eagerly fetched."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3058
#, no-c-format
msgid ""
"With the default JPA options, single-ended associations are loaded with a "
"subsequent select if set to <literal>LAZY</literal>, or a SQL JOIN is used "
"for <literal>EAGER</literal> associations. You can however adjust the "
"fetching strategy, ie how data is fetched by using <literal>@Fetch</"
"literal>. <literal>FetchMode</literal> can be <literal>SELECT</literal> (a "
"select is triggered when the association needs to be loaded) or "
"<literal>JOIN</literal> (use a SQL JOIN to load the association while "
"loading the owner entity). <literal>JOIN</literal> overrides any lazy "
"attribute (an association loaded through a <literal>JOIN</literal> strategy "
"cannot be lazy)."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3070
#, fuzzy, no-c-format
msgid "Using a foreign key or an association table"
msgstr "惟一外键关联"

#. Tag: para
#: basic_mapping.xml:3072
#, fuzzy, no-c-format
msgid "An ordinary association to another persistent class is declared using a"
msgstr ""
"持久化对象之间一对一的关联关系是通过 <literal>one-to-one</literal> 元素定义"
"的。"

#. Tag: para
#: basic_mapping.xml:3077
#, no-c-format
msgid ""
"<classname>@ManyToOne</classname> if several entities can point to the the "
"target entity"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3082
#, no-c-format
msgid ""
"<classname>@OneToOne</classname> if only a single entity can point to the "
"the target entity"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3087
#, no-c-format
msgid ""
"and a foreign key in one table is referencing the primary key column(s) of "
"the target table."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3090
#, no-c-format
msgid ""
"@Entity\n"
"public class Flight implements Serializable {\n"
"    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )\n"
"    @JoinColumn(name=\"COMP_ID\")\n"
"    public Company getCompany() {\n"
"        return company;\n"
"    }\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3092
#, no-c-format
msgid ""
"The <literal>@JoinColumn</literal> attribute is optional, the default value"
"(s) is the concatenation of the name of the relationship in the owner side, "
"<keycap>_</keycap> (underscore), and the name of the primary key column in "
"the owned side. In this example <literal>company_id</literal> because the "
"property name is <literal>company</literal> and the column id of Company is "
"<literal>id</literal>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3100
#, no-c-format
msgid ""
"@Entity\n"
"public class Flight implements Serializable {\n"
"    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE}, "
"targetEntity=CompanyImpl.class )\n"
"    @JoinColumn(name=\"COMP_ID\")\n"
"    public Company getCompany() {\n"
"        return company;\n"
"    }\n"
"    ...\n"
"}\n"
"\n"
"public interface Company {\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3102
#, no-c-format
msgid ""
"You can also map a to one association through an association table. This "
"association table described by the <literal>@JoinTable</literal> annotation "
"will contains a foreign key referencing back the entity table (through "
"<literal>@JoinTable.joinColumns</literal>) and a a foreign key referencing "
"the target entity table (through <literal>@JoinTable.inverseJoinColumns</"
"literal>)."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3110
#, no-c-format
msgid ""
"@Entity\n"
"public class Flight implements Serializable {\n"
"    @ManyToOne( cascade = {CascadeType.PERSIST, CascadeType.MERGE} )\n"
"    @JoinTable(name=\"Flight_Company\",\n"
"        joinColumns = @JoinColumn(name=\"FLIGHT_ID\"),\n"
"        inverseJoinColumns = @JoinColumn(name=\"COMP_ID\")\n"
"    )\n"
"    public Company getCompany() {\n"
"        return company;\n"
"    }\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3113
#, no-c-format
msgid ""
"You can use a SQL fragment to simulate a physical join column using the "
"<classname>@JoinColumnOrFormula</classname> / "
"<classname>@JoinColumnOrformulas</classname> annotations (just like you can "
"use a SQL fragment to simulate a property column via the "
"<classname>@Formula</classname> annotation)."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3119
#, no-c-format
msgid ""
"@Entity\n"
"public class Ticket implements Serializable {\n"
"    @ManyToOne\n"
"    @JoinColumnOrFormula(formula=\"(firstname + ' ' + lastname)\")\n"
"    public Person getOwner() {\n"
"        return person;\n"
"    }\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3122
#, no-c-format
msgid ""
"You can mark an association as mandatory by using the "
"<literal>optional=false</literal> attribute. We recommend to use Bean "
"Validation's <classname>@NotNull</classname> annotation as a better "
"alternative however. As a consequence, the foreign key column(s) will be "
"marked as not nullable (if possible)."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3128
#, no-c-format
msgid ""
"When Hibernate cannot resolve the association because the expected "
"associated element is not in database (wrong id on the association column), "
"an exception is raised. This might be inconvenient for legacy and badly "
"maintained schemas. You can ask Hibernate to ignore such elements instead of "
"raising an exception using the <literal>@NotFound</literal> annotation."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3136
#, no-c-format
msgid "@NotFound annotation"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3138
#, no-c-format
msgid ""
"@Entity\n"
"public class Child {\n"
"    ...\n"
"    @ManyToOne\n"
"    @NotFound(action=NotFoundAction.IGNORE)\n"
"    public Parent getParent() { ... }\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3141
#, no-c-format
msgid ""
"Sometimes you want to delegate to your database the deletion of cascade when "
"a given entity is deleted. In this case Hibernate generates a cascade delete "
"constraint at the database level."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3146
#, no-c-format
msgid "@OnDelete annotation"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3148
#, no-c-format
msgid ""
"@Entity\n"
"public class Child {\n"
"    ...\n"
"    @ManyToOne\n"
"    @OnDelete(action=OnDeleteAction.CASCADE)\n"
"    public Parent getParent() { ... }\n"
"    ...\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3151
#, no-c-format
msgid ""
"Foreign key constraints, while generated by Hibernate, have a fairly "
"unreadable name. You can override the constraint name using "
"<literal>@ForeignKey</literal>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3156
#, fuzzy, no-c-format
msgid "@ForeignKey annotation"
msgstr "惟一外键关联"

#. Tag: programlisting
#: basic_mapping.xml:3158
#, no-c-format
msgid ""
"@Entity\n"
"public class Child {\n"
"    ...\n"
"    @ManyToOne\n"
"    @ForeignKey(name=\"FK_PARENT\")\n"
"    public Parent getParent() { ... }\n"
"    ...\n"
"}\n"
"\n"
"alter table Child add constraint FK_PARENT foreign key (parent_id) "
"references Parent"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3161
#, no-c-format
msgid ""
"Sometimes, you want to link one entity to an other not by the target entity "
"primary key but by a different unique key. You can achieve that by "
"referencing the unique key column(s) in <methodname>@JoinColumn."
"referenceColumnName</methodname>."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3166 basic_mapping.xml:3718
#, no-c-format
msgid ""
"@Entity\n"
"class Person {\n"
"   @Id Integer personNumber;\n"
"   String firstName;\n"
"   @Column(name=\"I\")\n"
"   String initial;\n"
"   String lastName;\n"
"}\n"
"\n"
"@Entity\n"
"class Home {\n"
"   @ManyToOne\n"
"   @JoinColumns({\n"
"      @JoinColumn(name=\"first_name\", referencedColumnName=\"firstName\"),\n"
"      @JoinColumn(name=\"init\", referencedColumnName=\"I\"),\n"
"      @JoinColumn(name=\"last_name\", referencedColumnName=\"lastName\"),\n"
"   })\n"
"   Person owner\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3168
#, no-c-format
msgid ""
"This is not encouraged however and should be reserved to legacy mappings."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3171
#, no-c-format
msgid ""
"In hbm.xml, mapping an association is similar. The main difference is that a "
"<classname>@OneToOne</classname> is mapped as <literal>&lt;many-to-one "
"unique=\"true\"/&gt;</literal>, let's dive into the subject."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3213
#, fuzzy, no-c-format
msgid ""
"&lt;many-to-one\n"
"        name=\"propertyName\"\n"
"        column=\"column_name\"\n"
"        class=\"ClassName\"\n"
"        cascade=\"cascade_style\"\n"
"        fetch=\"join|select\"\n"
"        update=\"true|false\"\n"
"        insert=\"true|false\"\n"
"        property-ref=\"propertyNameFromAssociatedClass\"\n"
"        access=\"field|property|ClassName\"\n"
"        unique=\"true|false\"\n"
"        not-null=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        lazy=\"proxy|no-proxy|false\"\n"
"        not-found=\"ignore|exception\"\n"
"        entity-name=\"EntityName\"\n"
"        formula=\"arbitrary SQL expression\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"        embed-xml=\"true|false\"\n"
"        index=\"index_name\"\n"
"        unique_key=\"unique_key_id\"\n"
"        foreign-key=\"foreign_key_name\"\n"
"/&gt;"
msgstr ""
"&lt;many-to-one\n"
"        name=\"propertyName\"\n"
"        column=\"column_name\"\n"
"        class=\"ClassName\"\n"
"        cascade=\"cascade_style\"\n"
"        fetch=\"join|select\"\n"
"        update=\"true|false\"\n"
"        insert=\"true|false\"\n"
"        property-ref=\"propertyNameFromAssociatedClass\"\n"
"        access=\"field|property|ClassName\"\n"
"        unique=\"true|false\"\n"
"        not-null=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        lazy=\"proxy|no-proxy|false\"\n"
"        not-found=\"ignore|exception\"\n"
"        entity-name=\"EntityName\"\n"
"        formula=\"arbitrary SQL expression\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"        embed-xml=\"true|false\"\n"
"        index=\"index_name\"\n"
"        unique_key=\"unique_key_id\"\n"
"        foreign-key=\"foreign_key_name\"\n"
"/&gt;"

#. Tag: para
#: basic_mapping.xml:3221 basic_mapping.xml:3904
#, no-c-format
msgid ""
"<literal>column</literal> (optional): the name of the foreign key column. "
"This can also be specified by nested <literal>&lt;column&gt;</literal> "
"element(s)."
msgstr ""
"<literal>column</literal>（可选）：外键字段的名称。也可以通过嵌套的  "
"<literal>&lt;column&gt;</literal> 指定。 "

#. Tag: para
#: basic_mapping.xml:3227 basic_mapping.xml:3421
#, no-c-format
msgid ""
"<literal>class</literal> (optional - defaults to the property type "
"determined by reflection): the name of the associated class."
msgstr ""
"<literal>class</literal>（可选 — 默认是通过反射得到的属性类型）：被关联的类的"
"名字。  "

#. Tag: para
#: basic_mapping.xml:3233 basic_mapping.xml:3427
#, no-c-format
msgid ""
"<literal>cascade</literal> (optional): specifies which operations should be "
"cascaded from the parent object to the associated object."
msgstr ""
"<literal>cascade（级联）</literal>（可选）表明操作是否从父对象级联到被关联的"
"对象。 "

#. Tag: para
#: basic_mapping.xml:3239 basic_mapping.xml:3443
#, no-c-format
msgid ""
"<literal>fetch</literal> (optional - defaults to <literal>select</literal>): "
"chooses between outer-join fetching or sequential select fetching."
msgstr ""
"<literal>fetch</literal>（可选 — 默认为 <literal>select</literal>）：在外连接"
"抓取（outer-join fetching）和序列选择抓取（sequential select fetching）两者中"
"选择其一。 "

#. Tag: para
#: basic_mapping.xml:3245
#, no-c-format
msgid ""
"<literal>update, insert</literal> (optional - defaults to <literal>true</"
"literal>): specifies that the mapped columns should be included in SQL "
"<literal>UPDATE</literal> and/or <literal>INSERT</literal> statements. "
"Setting both to <literal>false</literal> allows a pure \"derived\" "
"association whose value is initialized from another property that maps to "
"the same column(s), or by a trigger or other application."
msgstr ""
"<literal>update, insert</literal>（可选 — 默认为 <literal>true</literal>）指"
"定对应的字段是否包含在用于 <literal>UPDATE</literal> 和/或 <literal>INSERT</"
"literal> 的 SQL 语句中。如果二者都是<literal>false</literal>,则这是一个纯粹"
"的 “外源性（derived）”关联，它的值是通过映射到同一个（或多个）字段的某些其他"
"属性得到 或者通过 trigger（触发器）、或其他程序生成。 "

#. Tag: para
#: basic_mapping.xml:3255
#, no-c-format
msgid ""
"<literal>property-ref</literal> (optional): the name of a property of the "
"associated class that is joined to this foreign key. If not specified, the "
"primary key of the associated class is used."
msgstr ""
"<literal>property-ref</literal>：（可选）被关联到此外键的类中的对应属性的名"
"字。如果没有指定，被关联类的主键将被使用。 "

#. Tag: para
#: basic_mapping.xml:3268
#, no-c-format
msgid ""
"<literal>unique</literal> (optional): enables the DDL generation of a unique "
"constraint for the foreign-key column. By allowing this to be the target of "
"a <literal>property-ref</literal>, you can make the association multiplicity "
"one-to-one."
msgstr ""
"<literal>unique</literal>（可选）：使用 DDL 为外键字段生成一个唯一约束。此"
"外， 这也可以用作 <literal>property-ref</literal> 的目标属性。这使关联同时具"
"有一对一的效果。 "

#. Tag: para
#: basic_mapping.xml:3276
#, no-c-format
msgid ""
"<literal>not-null</literal> (optional): enables the DDL generation of a "
"nullability constraint for the foreign key columns."
msgstr ""
"<literal>not-null</literal>（可选）：使用 DDL 为外键字段生成一个非空约束。 "

#. Tag: para
#: basic_mapping.xml:3290
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): "
"by default, single point associations are proxied. <literal>lazy=\"no-proxy"
"\"</literal> specifies that the property should be fetched lazily when the "
"instance variable is first accessed. This requires build-time bytecode "
"instrumentation. <literal>lazy=\"false\"</literal> specifies that the "
"association will always be eagerly fetched."
msgstr ""
"<literal>lazy</literal>（可选 — 默认为 <literal>proxy</literal>）：默认情况"
"下，单点关联是经过代理的。<literal>lazy=\"no-proxy\"</literal> 指定此属性应该"
"在实例变量第一次被访问时应该延迟抓取（fetche lazily）（需要运行时字节码的增"
"强）。<literal>lazy=\"false\"</literal> 指定此关联总是被预先抓取。 "

#. Tag: para
#: basic_mapping.xml:3300
#, no-c-format
msgid ""
"<literal>not-found</literal> (optional - defaults to <literal>exception</"
"literal>): specifies how foreign keys that reference missing rows will be "
"handled. <literal>ignore</literal> will treat a missing row as a null "
"association."
msgstr ""
"<literal>not-found</literal>（可选 - 默认为<literal>exception</literal>）：指"
"定如何处理引用缺失行的外键：<literal>ignore</literal> 会把缺失的行作为一个空"
"关联处理。 "

#. Tag: para
#: basic_mapping.xml:3308 basic_mapping.xml:3484
#, no-c-format
msgid ""
"<literal>entity-name</literal> (optional): the entity name of the associated "
"class."
msgstr "<literal>entity-name</literal>（可选）：被关联的类的实体名。 "

#. Tag: para
#: basic_mapping.xml:3313
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): an SQL expression that defines the "
"value for a <emphasis>computed</emphasis> foreign key."
msgstr ""
"<literal>formula</literal>（可选）：SQL 表达式，用于定义 <emphasis>computed"
"（计算出的）</emphasis>外键值。"

#. Tag: para
#: basic_mapping.xml:3320
#, fuzzy, no-c-format
msgid ""
"Setting a value of the <literal>cascade</literal> attribute to any "
"meaningful value other than <literal>none</literal> will propagate certain "
"operations to the associated object. The meaningful values are divided into "
"three categories. First, basic operations, which include: <literal>persist, "
"merge, delete, save-update, evict, replicate, lock and refresh</literal>; "
"second, special values: <literal>delete-orphan</literal>; and third,"
"<literal>all</literal> comma-separated combinations of operation names: "
"<literal>cascade=\"persist,merge,evict\"</literal> or <literal>cascade=\"all,"
"delete-orphan\"</literal>. See <xref linkend=\"objectstate-transitive\"/> "
"for a full explanation. Note that single valued, many-to-one and one-to-one, "
"associations do not support orphan delete."
msgstr ""
"<literal>cascade</literal> 属性设置为除了<literal>none</literal> 以外任何有意"
"义的值，它将把特定的操作传递到关联对象中。这个值就代表着 Hibernate 基本操作的"
"名称，<literal>persist, merge, delete, save-update, evict, replicate, lock, "
"refresh</literal>，以及特别的值 <literal>delete-orphan</literal> 和 "
"<literal>all</literal>，并且可以用逗号分隔符来组合这些操作，例如，"
"<literal>cascade=\"persist,merge,evict\"</literal> 或  <literal>cascade="
"\"all,delete-orphan\"</literal>。更全面的解释请参考 <xref linkend="
"\"objectstate-transitive\"/>。注意，单值关联（many-to-one 和 one-to-one 关"
"联）不支持删除孤儿（orphan delete，删除不再被引用的值）。 "

#. Tag: para
#: basic_mapping.xml:3334
#, no-c-format
msgid ""
"Here is an example of a typical <literal>many-to-one</literal> declaration:"
msgstr "一个典型的简单 <literal>many-to-one</literal> 定义例子： "

#. Tag: programlisting
#: basic_mapping.xml:3337
#, fuzzy, no-c-format
msgid ""
"&lt;many-to-one name=\"product\" class=\"Product\" column=\"PRODUCT_ID\"/&gt;"
msgstr ""
"&lt;many-to-one name=\"product\" class=\"Product\" column=\"PRODUCT_ID\"/&gt;"

#. Tag: para
#: basic_mapping.xml:3339
#, no-c-format
msgid ""
"The <literal>property-ref</literal> attribute should only be used for "
"mapping legacy data where a foreign key refers to a unique key of the "
"associated table other than the primary key. This is a complicated and "
"confusing relational model. For example, if the <literal>Product</literal> "
"class had a unique serial number that is not the primary key. The "
"<literal>unique</literal> attribute controls Hibernate's DDL generation with "
"the SchemaExport tool."
msgstr ""
"<literal>property-ref</literal> 属性只应该用来对付遗留下来的数据库系统，可能"
"有外键指向对方关联表的是个非主键字段（但是应该是一个惟一关键字）的情况下。这"
"是一种十分丑陋的关系模型。比如说，假设 <literal>Product</literal> 类有一个惟"
"一的序列号，它并不是主键。（<literal>unique</literal> 属性控制 Hibernate 通"
"过 SchemaExport 工具进行的 DDL 生成。） "

#. Tag: programlisting
#: basic_mapping.xml:3347
#, fuzzy, no-c-format
msgid ""
"&lt;property name=\"serialNumber\" unique=\"true\" type=\"string\" column="
"\"SERIAL_NUMBER\"/&gt;"
msgstr ""
"&lt;property name=\"serialNumber\" unique=\"true\" type=\"string\" column="
"\"SERIAL_NUMBER\"/&gt;"

#. Tag: para
#: basic_mapping.xml:3349
#, no-c-format
msgid "Then the mapping for <literal>OrderItem</literal> might use:"
msgstr "那么关于 <literal>OrderItem</literal> 的映射可能是："

#. Tag: programlisting
#: basic_mapping.xml:3352
#, fuzzy, no-c-format
msgid ""
"&lt;many-to-one name=\"product\" property-ref=\"serialNumber\" column="
"\"PRODUCT_SERIAL_NUMBER\"/&gt;"
msgstr ""
"&lt;many-to-one name=\"product\" property-ref=\"serialNumber\" column="
"\"PRODUCT_SERIAL_NUMBER\"/&gt;"

#. Tag: para
#: basic_mapping.xml:3354
#, no-c-format
msgid "This is not encouraged, however."
msgstr "当然，我们决不鼓励这种用法。 "

#. Tag: para
#: basic_mapping.xml:3356
#, no-c-format
msgid ""
"If the referenced unique key comprises multiple properties of the associated "
"entity, you should map the referenced properties inside a named <literal>&lt;"
"properties&gt;</literal> element."
msgstr ""
"如果被引用的唯一主键由关联实体的多个属性组成，你应该在名称为 <literal>&lt;"
"properties&gt;</literal> 的元素 里面映射所有关联的属性。"

#. Tag: para
#: basic_mapping.xml:3360
#, no-c-format
msgid ""
"If the referenced unique key is the property of a component, you can specify "
"a property path:"
msgstr "假若被引用的唯一主键是组件的属性，你可以指定属性路径： "

#. Tag: programlisting
#: basic_mapping.xml:3363
#, fuzzy, no-c-format
msgid ""
"&lt;many-to-one name=\"owner\" property-ref=\"identity.ssn\" column="
"\"OWNER_SSN\"/&gt;"
msgstr ""
"&lt;many-to-one name=\"owner\" property-ref=\"identity.ssn\" column="
"\"OWNER_SSN\"/&gt;"

#. Tag: title
#: basic_mapping.xml:3367
#, no-c-format
msgid "Sharing the primary key with the associated entity"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3369
#, no-c-format
msgid ""
"The second approach is to ensure an entity and its associated entity share "
"the same primary key. In this case the primary key column is also a foreign "
"key and there is no extra column. These associations are always one to one."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3375
#, fuzzy, no-c-format
msgid "One to One association"
msgstr "惟一外键关联"

#. Tag: programlisting
#: basic_mapping.xml:3377
#, no-c-format
msgid ""
"@Entity\n"
"public class Body {\n"
"    @Id\n"
"    public Long getId() { return id; }\n"
"\n"
"    @OneToOne(cascade = CascadeType.ALL)\n"
"    @MapsId\n"
"    public Heart getHeart() {\n"
"        return heart;\n"
"    }\n"
"    ...\n"
"}   \n"
"\n"
"@Entity\n"
"public class Heart {\n"
"    @Id\n"
"    public Long getId() { ...}\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3381
#, no-c-format
msgid ""
"Many people got confused by these primary key based one to one associations. "
"They can only be lazily loaded if Hibernate knows that the other side of the "
"association is always present. To indicate to Hibernate that it is the case, "
"use <classname>@OneToOne(optional=false)</classname>."
msgstr ""

#. Tag: para
#: basic_mapping.xml:3388
#, no-c-format
msgid "In hbm.xml, use the following mapping."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3413
#, fuzzy, no-c-format
msgid ""
"&lt;one-to-one\n"
"        name=\"propertyName\"\n"
"        class=\"ClassName\"\n"
"        cascade=\"cascade_style\"\n"
"        constrained=\"true|false\"\n"
"        fetch=\"join|select\"\n"
"        property-ref=\"propertyNameFromAssociatedClass\"\n"
"        access=\"field|property|ClassName\"\n"
"        formula=\"any SQL expression\"\n"
"        lazy=\"proxy|no-proxy|false\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"        embed-xml=\"true|false\"\n"
"        foreign-key=\"foreign_key_name\"\n"
"/&gt;"
msgstr ""
"&lt;one-to-one\n"
"        name=\"propertyName\"\n"
"        class=\"ClassName\"\n"
"        cascade=\"cascade_style\"\n"
"        constrained=\"true|false\"\n"
"        fetch=\"join|select\"\n"
"        property-ref=\"propertyNameFromAssociatedClass\"\n"
"        access=\"field|property|ClassName\"\n"
"        formula=\"any SQL expression\"\n"
"        lazy=\"proxy|no-proxy|false\"\n"
"        entity-name=\"EntityName\"\n"
"        node=\"element-name|@attribute-name|element/@attribute|.\"\n"
"        embed-xml=\"true|false\"\n"
"        foreign-key=\"foreign_key_name\"\n"
"/&gt;"

#. Tag: para
#: basic_mapping.xml:3433
#, no-c-format
msgid ""
"<literal>constrained</literal> (optional): specifies that a foreign key "
"constraint on the primary key of the mapped table and references the table "
"of the associated class. This option affects the order in which <literal>save"
"()</literal> and <literal>delete()</literal> are cascaded, and determines "
"whether the association can be proxied. It is also used by the schema export "
"tool."
msgstr ""
"<literal>constrained（约束）</literal>（可选）表明该类对应的表对应的数据库"
"表，和被关联的对象所对应的数据库表之间，通过一个外键引用对主键进行约束。这个"
"选项影响 <literal>save()</literal> 和 <literal>delete()</literal> 在级联执行"
"时的先后顺序以及决定该关联能否被委托（也在 schema export tool 中被使用）。 "

#. Tag: para
#: basic_mapping.xml:3449
#, no-c-format
msgid ""
"<literal>property-ref</literal> (optional): the name of a property of the "
"associated class that is joined to the primary key of this class. If not "
"specified, the primary key of the associated class is used."
msgstr ""
"<literal>property-ref</literal>：（可选）指定关联类的属性名，这个属性将会和本"
"类的主键相对应。如果没有指定，会使用对方关联类的主键。 "

#. Tag: para
#: basic_mapping.xml:3462
#, no-c-format
msgid ""
"<literal>formula</literal> (optional): almost all one-to-one associations "
"map to the primary key of the owning entity. If this is not the case, you "
"can specify another column, columns or expression to join on using an SQL "
"formula. See <literal>org.hibernate.test.onetooneformula</literal> for an "
"example."
msgstr ""
"<literal>formula </literal>（可选）：绝大多数一对一的关联都指向其实体的主键。"
"在一些少见的情况中，你可能会指向其他的一个或多个字段，或者是一个表达式，这些"
"情况下，你可以用一个 SQL 公式来表示。（可以在 org.hibernate.test."
"onetooneformula 找到例子） "

#. Tag: para
#: basic_mapping.xml:3471
#, no-c-format
msgid ""
"<literal>lazy</literal> (optional - defaults to <literal>proxy</literal>): "
"by default, single point associations are proxied. <literal>lazy=\"no-proxy"
"\"</literal> specifies that the property should be fetched lazily when the "
"instance variable is first accessed. It requires build-time bytecode "
"instrumentation. <literal>lazy=\"false\"</literal> specifies that the "
"association will always be eagerly fetched. <emphasis>Note that if "
"<literal>constrained=\"false\"</literal>, proxying is impossible and "
"Hibernate will eagerly fetch the association</emphasis>."
msgstr ""
"<literal>lazy</literal>（可选 — 默认为 <literal>proxy</literal>）：默认情况"
"下，单点关联是经过代理的。<literal>lazy=\"no-proxy\"</literal>指定此属性应该"
"在实例变量第一次被访问时应该延迟抓取（fetche lazily）（需要运行时字节码的增"
"强）。 <literal>lazy=\"false\"</literal>指定此关联总是被预先抓取。<emphasis>"
"注意，如果<literal>constrained=\"false\"</literal>, 不可能使用代理，Hibernate"
"会采取预先抓取</emphasis>。"

#. Tag: para
#: basic_mapping.xml:3490
#, no-c-format
msgid ""
"Primary key associations do not need an extra table column. If two rows are "
"related by the association, then the two table rows share the same primary "
"key value. To relate two objects by a primary key association, ensure that "
"they are assigned the same identifier value."
msgstr ""
"主键关联不需要额外的表字段；如果两行是通过这种一对一关系相关联的，那么这两行"
"就共享同样的主关键字值。所以如果你希望两个对象通过主键一对一关联，你必须确认"
"它们被赋予同样的标识值。"

#. Tag: para
#: basic_mapping.xml:3496
#, no-c-format
msgid ""
"For a primary key association, add the following mappings to "
"<literal>Employee</literal> and <literal>Person</literal> respectively:"
msgstr ""
"比如说，对下面的 <literal>Employee</literal> 和 <literal>Person</literal> 进"
"行主键一对一关联："

#. Tag: programlisting
#: basic_mapping.xml:3500
#, fuzzy, no-c-format
msgid "&lt;one-to-one name=\"person\" class=\"Person\"/&gt;"
msgstr "&lt;one-to-one name=\"person\" class=\"Person\"/&gt;"

#. Tag: programlisting
#: basic_mapping.xml:3502
#, fuzzy, no-c-format
msgid ""
"&lt;one-to-one name=\"employee\" class=\"Employee\" constrained=\"true\"/&gt;"
msgstr ""
"&lt;one-to-one name=\"employee\" class=\"Employee\" constrained=\"true\"/&gt;"

#. Tag: para
#: basic_mapping.xml:3504
#, no-c-format
msgid ""
"Ensure that the primary keys of the related rows in the PERSON and EMPLOYEE "
"tables are equal. You use a special Hibernate identifier generation strategy "
"called <literal>foreign</literal>:"
msgstr ""
"现在我们必须确保 PERSON 和 EMPLOYEE 中相关的字段是相等的。我们使用一个被成为 "
"<literal>foreign</literal> 的特殊的 hibernate 标识符生成策略： "

#. Tag: programlisting
#: basic_mapping.xml:3508
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"person\" table=\"PERSON\"&gt;\n"
"    &lt;id name=\"id\" column=\"PERSON_ID\"&gt;\n"
"        &lt;generator class=\"foreign\"&gt;\n"
"            &lt;param name=\"property\"&gt;employee&lt;/param&gt;\n"
"        &lt;/generator&gt;\n"
"    &lt;/id&gt;\n"
"    ...\n"
"    &lt;one-to-one name=\"employee\"\n"
"        class=\"Employee\"\n"
"        constrained=\"true\"/&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"person\" table=\"PERSON\"&gt;\n"
"    &lt;id name=\"id\" column=\"PERSON_ID\"&gt;\n"
"        &lt;generator class=\"foreign\"&gt;\n"
"            &lt;param name=\"property\"&gt;employee&lt;/param&gt;\n"
"        &lt;/generator&gt;\n"
"    &lt;/id&gt;\n"
"    ...\n"
"    &lt;one-to-one name=\"employee\"\n"
"        class=\"Employee\"\n"
"        constrained=\"true\"/&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: basic_mapping.xml:3510
#, no-c-format
msgid ""
"A newly saved instance of <literal>Person</literal> is assigned the same "
"primary key value as the <literal>Employee</literal> instance referred with "
"the <literal>employee</literal> property of that <literal>Person</literal>."
msgstr ""
"一个刚刚保存的 <literal>Person</literal> 实例被赋予和该 <literal>Person</"
"literal> 的 <literal>employee</literal> 属性所指向的 <literal>Employee</"
"literal> 实例同样的关键字值。 "

#. Tag: title
#: basic_mapping.xml:3518
#, no-c-format
msgid "Natural-id"
msgstr "自然 ID（natural-id） "

#. Tag: para
#: basic_mapping.xml:3520
#, fuzzy, no-c-format
msgid ""
"Although we recommend the use of surrogate keys as primary keys, you should "
"try to identify natural keys for all entities. A natural key is a property "
"or combination of properties that is unique and non-null. It is also "
"immutable. Map the properties of the natural key as <classname>@NaturalId</"
"classname> or map them inside the <literal>&lt;natural-id&gt;</literal> "
"element. Hibernate will generate the necessary unique key and nullability "
"constraints and, as a result, your mapping will be more self-documenting."
msgstr ""
"我们建议使用代用键（键值不具备实际意义）作为主键，我们仍然应该尝试为所有的实"
"体采用自然的键值作为（附加——译者注）标示。自然键（natural key）是单个或组合属"
"性，他们必须唯一且非空。如果它还是不可变的那就更理想了。在 <literal>&lt;"
"natural-id&gt;</literal> 元素中列出自然键的属性。Hibernate 会帮你生成必须的唯"
"一键值和非空约束，你的映射会更加的明显易懂（原文是 self-documenting，自我注"
"解）。 "

#. Tag: programlisting
#: basic_mapping.xml:3529
#, no-c-format
msgid ""
"@Entity\n"
"public class Citizen {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    private Integer id;\n"
"    private String firstname;\n"
"    private String lastname;\n"
"    \n"
"    @NaturalId\n"
"    @ManyToOne\n"
"    private State state;\n"
"\n"
"    @NaturalId\n"
"    private String ssn;\n"
"    ...\n"
"}\n"
"\n"
"\n"
"\n"
"//and later on query\n"
"List results = s.createCriteria( Citizen.class )\n"
"                .add( Restrictions.naturalId().set( \"ssn\", \"1234\" ).set"
"( \"state\", ste ) )\n"
"                .list();"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3531
#, no-c-format
msgid "Or in XML,"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3533
#, fuzzy, no-c-format
msgid ""
"&lt;natural-id mutable=\"true|false\"/&gt;\n"
"        &lt;property ... /&gt;\n"
"        &lt;many-to-one ... /&gt;\n"
"        ......\n"
"&lt;/natural-id&gt;"
msgstr ""
"&lt;natural-id mutable=\"true|false\"/&gt;\n"
"        &lt;property ... /&gt;\n"
"        &lt;many-to-one ... /&gt;\n"
"        ......\n"
"&lt;/natural-id&gt;"

#. Tag: para
#: basic_mapping.xml:3535
#, no-c-format
msgid ""
"It is recommended that you implement <literal>equals()</literal> and "
"<literal>hashCode()</literal> to compare the natural key properties of the "
"entity."
msgstr ""
"我们强烈建议你实现 <literal>equals()</literal> 和 <literal>hashCode()</"
"literal> 方法,来比较实体的自然键属性。 "

#. Tag: para
#: basic_mapping.xml:3539
#, no-c-format
msgid ""
"This mapping is not intended for use with entities that have natural primary "
"keys."
msgstr "这一映射不是为了把自然键作为主键而准备的。 "

#. Tag: para
#: basic_mapping.xml:3544
#, no-c-format
msgid ""
"<literal>mutable</literal> (optional - defaults to <literal>false</"
"literal>): by default, natural identifier properties are assumed to be "
"immutable (constant)."
msgstr ""
"<literal>mutable</literal>（可选，默认为 <literal>false</literal>）：默认情况"
"下，自然标识属性被假定为不可变的（常量）。 "

#. Tag: title
#: basic_mapping.xml:3552
#, fuzzy, no-c-format
msgid "<title>Any</title>"
msgstr "<title>any</title>"

#. Tag: para
#: basic_mapping.xml:3554
#, fuzzy, no-c-format
msgid ""
"There is one more type of property mapping. The <classname>@Any</classname> "
"mapping defines a polymorphic association to classes from multiple tables. "
"This type of mapping requires more than one column. The first column "
"contains the type of the associated entity. The remaining columns contain "
"the identifier. It is impossible to specify a foreign key constraint for "
"this kind of association. This is not the usual way of mapping polymorphic "
"associations and you should use this only in special cases. For example, for "
"audit logs, user session data, etc."
msgstr ""
"这是属性映射的又一种类型。<literal>&lt;any&gt;</literal> 映射元素定义了一种从"
"多个表到类的多态关联。这种类型的映射常常需要多于一个字段。第一个字段持有被关"
"联实体的类型，其他的字段持有标识符。对这种类型的关联来说，不可能指定一个外键"
"约束，所以这当然不是映射（多态）关联的通常的方式。你只应该在非常特殊的情况下"
"使用它(比如，审计 log，用户会话数据等等)。 "

#. Tag: para
#: basic_mapping.xml:3564
#, fuzzy, no-c-format
msgid ""
"The <classname>@Any</classname> annotation describes the column holding the "
"metadata information. To link the value of the metadata information and an "
"actual entity type, The <classname>@AnyDef</classname> and "
"<classname>@AnyDefs</classname> annotations are used. The <literal>metaType</"
"literal> attribute allows the application to specify a custom type that maps "
"database column values to persistent classes that have identifier properties "
"of the type specified by <literal>idType</literal>. You must specify the "
"mapping from values of the <literal>metaType</literal> to class names."
msgstr ""
"<literal>meta-type</literal> 属性使得应用程序能指定一个将数据库字段的值映射到"
"持久化类的自定义类型。这个持久化类包含有用 <literal>id-type</literal> 指定的"
"标识符属性。你必须指定从 meta-type 的值到类名的映射。 "

#. Tag: programlisting
#: basic_mapping.xml:3574
#, no-c-format
msgid ""
"@Any( metaColumn = @Column( name = \"property_type\" ), fetch=FetchType."
"EAGER )\n"
"@AnyMetaDef( \n"
"    idType = \"integer\", \n"
"    metaType = \"string\", \n"
"    metaValues = {\n"
"        @MetaValue( value = \"S\", targetEntity = StringProperty.class ),\n"
"        @MetaValue( value = \"I\", targetEntity = IntegerProperty.class )\n"
"    } )\n"
"@JoinColumn( name = \"property_id\" )\n"
"public Property getMainProperty() {\n"
"    return mainProperty;\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3576
#, no-c-format
msgid ""
"Note that <classname>@AnyDef</classname> can be mutualized and reused. It is "
"recommended to place it as a package metadata in this case."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3580
#, no-c-format
msgid ""
"//on a package\n"
"@AnyMetaDef( name=\"property\" \n"
"    idType = \"integer\", \n"
"    metaType = \"string\", \n"
"    metaValues = {\n"
"        @MetaValue( value = \"S\", targetEntity = StringProperty.class ),\n"
"        @MetaValue( value = \"I\", targetEntity = IntegerProperty.class )\n"
"    } )\n"
"package org.hibernate.test.annotations.any;\n"
"\n"
"\n"
"//in a class\n"
"    @Any( metaDef=\"property\", metaColumn = @Column( name = \"property_type"
"\" ), fetch=FetchType.EAGER )\n"
"    @JoinColumn( name = \"property_id\" )\n"
"    public Property getMainProperty() {\n"
"        return mainProperty;\n"
"    }"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3582
#, no-c-format
msgid "The hbm.xml equivalent is:"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3584
#, fuzzy, no-c-format
msgid ""
"&lt;any name=\"being\" id-type=\"long\" meta-type=\"string\"&gt;\n"
"    &lt;meta-value value=\"TBL_ANIMAL\" class=\"Animal\"/&gt;\n"
"    &lt;meta-value value=\"TBL_HUMAN\" class=\"Human\"/&gt;\n"
"    &lt;meta-value value=\"TBL_ALIEN\" class=\"Alien\"/&gt;\n"
"    &lt;column name=\"table_name\"/&gt;\n"
"    &lt;column name=\"id\"/&gt;\n"
"&lt;/any&gt;"
msgstr ""
"&lt;any name=\"being\" id-type=\"long\" meta-type=\"string\"&gt;\n"
"    &lt;meta-value value=\"TBL_ANIMAL\" class=\"Animal\"/&gt;\n"
"    &lt;meta-value value=\"TBL_HUMAN\" class=\"Human\"/&gt;\n"
"    &lt;meta-value value=\"TBL_ALIEN\" class=\"Alien\"/&gt;\n"
"    &lt;column name=\"table_name\"/&gt;\n"
"    &lt;column name=\"id\"/&gt;\n"
"&lt;/any&gt;"

#. Tag: para
#: basic_mapping.xml:3587
#, no-c-format
msgid "You cannot mutualize the metadata in hbm.xml as you can in annotations."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:3606
#, fuzzy, no-c-format
msgid ""
"&lt;any\n"
"        name=\"propertyName\"\n"
"        id-type=\"idtypename\"\n"
"        meta-type=\"metatypename\"\n"
"        cascade=\"cascade_style\"\n"
"        access=\"field|property|ClassName\"\n"
"        optimistic-lock=\"true|false\"\n"
"&gt;\n"
"        &lt;meta-value ... /&gt;\n"
"        &lt;meta-value ... /&gt;\n"
"        .....\n"
"        &lt;column .... /&gt;\n"
"        &lt;column .... /&gt;\n"
"        .....\n"
"&lt;/any&gt;"
msgstr ""
"&lt;any\n"
"        name=\"propertyName\"\n"
"        id-type=\"idtypename\"\n"
"        meta-type=\"metatypename\"\n"
"        cascade=\"cascade_style\"\n"
"        access=\"field|property|ClassName\"\n"
"        optimistic-lock=\"true|false\"\n"
"&gt;\n"
"        &lt;meta-value ... /&gt;\n"
"        &lt;meta-value ... /&gt;\n"
"        .....\n"
"        &lt;column .... /&gt;\n"
"        &lt;column .... /&gt;\n"
"        .....\n"
"&lt;/any&gt;"

#. Tag: para
#: basic_mapping.xml:3610
#, no-c-format
msgid "<literal>name</literal>: the property name."
msgstr "<literal>name</literal>：属性名"

#. Tag: para
#: basic_mapping.xml:3614
#, no-c-format
msgid "<literal>id-type</literal>: the identifier type."
msgstr "<literal>id-type</literal>：标识符类型"

#. Tag: para
#: basic_mapping.xml:3618
#, no-c-format
msgid ""
"<literal>meta-type</literal> (optional - defaults to <literal>string</"
"literal>): any type that is allowed for a discriminator mapping."
msgstr ""
"<literal>meta-type</literal>（可选 -默认是 <literal>string</literal>）：允许"
"辨别标志(discriminator)映射的任何类型。 "

#. Tag: para
#: basic_mapping.xml:3624
#, no-c-format
msgid ""
"<literal>cascade</literal> (optional- defaults to <literal>none</literal>): "
"the cascade style."
msgstr ""
"<literal>cascade</literal>（可选 — 默认是<literal>none</literal>）：级联的类"
"型。"

#. Tag: para
#: basic_mapping.xml:3635
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that updates to this property either do or do not "
"require acquisition of the optimistic lock. It defines whether a version "
"increment should occur if this property is dirty."
msgstr ""
"<literal>optimistic-lock</literal>（可选 — 默认是 <literal>true</literal>）："
"表明更新此组件是否需要获取乐观锁。换句话说，当这个属性变脏时，是否增加版本号"
"（Version）。"

#. Tag: title
#: basic_mapping.xml:3646
#, no-c-format
msgid "Properties"
msgstr "属性（Properties）"

#. Tag: para
#: basic_mapping.xml:3648
#, no-c-format
msgid ""
"The <literal>&lt;properties&gt;</literal> element allows the definition of a "
"named, logical grouping of the properties of a class. The most important use "
"of the construct is that it allows a combination of properties to be the "
"target of a <literal>property-ref</literal>. It is also a convenient way to "
"define a multi-column unique constraint. For example:"
msgstr ""
"<literal>&lt;properties&gt;</literal> 元素允许定义一个命名的逻辑分组"
"（grouping）包含一个类中的多个属性。这个元素最重要的用处是允许多个属性的组合"
"作为 <literal>property-ref</literal> 的目标（target）。这也是定义多字段唯一约"
"束的一种方便途径。例如："

#. Tag: programlisting
#: basic_mapping.xml:3668
#, fuzzy, no-c-format
msgid ""
"&lt;properties\n"
"        name=\"logicalName\"\n"
"        insert=\"true|false\"\n"
"        update=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        unique=\"true|false\"\n"
"&gt;\n"
"\n"
"        &lt;property ...../&gt;\n"
"        &lt;many-to-one .... /&gt;\n"
"        ........\n"
"&lt;/properties&gt;"
msgstr ""
"&lt;properties \n"
"        name=\"logicalName\" \n"
"        insert=\"true|false\"\n"
"        update=\"true|false\"\n"
"        optimistic-lock=\"true|false\"\n"
"        unique=\"true|false\"\n"
"&gt;\n"
"        \n"
"        &lt;property ...../&gt;\n"
"        &lt;many-to-one .... /&gt;\n"
"        ........\n"
"&lt;/properties&gt;"

#. Tag: para
#: basic_mapping.xml:3672
#, no-c-format
msgid ""
"<literal>name</literal>: the logical name of the grouping. It is "
"<emphasis>not</emphasis> an actual property name."
msgstr ""
"<literal>name</literal>：分组的逻辑名称 — <emphasis>不是</emphasis> 实际属性"
"的名称。 "

#. Tag: para
#: basic_mapping.xml:3687
#, no-c-format
msgid ""
"<literal>optimistic-lock</literal> (optional - defaults to <literal>true</"
"literal>): specifies that updates to these properties either do or do not "
"require acquisition of the optimistic lock. It determines if a version "
"increment should occur when these properties are dirty."
msgstr ""
"<literal>optimistic-lock</literal>（可选 — 默认是 <literal>true</literal>）："
"表明更新此组件是否需要获取乐观锁。换句话说，当这个属性变脏时，是否增加版本号"
"（Version）。"

#. Tag: para
#: basic_mapping.xml:3702
#, no-c-format
msgid ""
"For example, if we have the following <literal>&lt;properties&gt;</literal> "
"mapping:"
msgstr "例如，如果我们有如下的 <literal>&lt;properties&gt;</literal> 映射："

#. Tag: programlisting
#: basic_mapping.xml:3705
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Person\"&gt;\n"
"    &lt;id name=\"personNumber\"/&gt;\n"
"\n"
"    ...\n"
"    &lt;properties name=\"name\"\n"
"            unique=\"true\" update=\"false\"&gt;\n"
"        &lt;property name=\"firstName\"/&gt;\n"
"        &lt;property name=\"initial\"/&gt;\n"
"        &lt;property name=\"lastName\"/&gt;\n"
"    &lt;/properties&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Person\"&gt;\n"
"    &lt;id name=\"personNumber\"/&gt;\n"
"    ...\n"
"    &lt;properties name=\"name\" \n"
"            unique=\"true\" update=\"false\"&gt;\n"
"        &lt;property name=\"firstName\"/&gt;\n"
"        &lt;property name=\"initial\"/&gt;\n"
"        &lt;property name=\"lastName\"/&gt;\n"
"    &lt;/properties&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: basic_mapping.xml:3707
#, no-c-format
msgid ""
"You might have some legacy data association that refers to this unique key "
"of the <literal>Person</literal> table, instead of to the primary key:"
msgstr ""
"然后，我们可能有一些遗留的数据关联，引用 <literal>Person</literal> 表的这个唯"
"一键，而不是主键："

#. Tag: programlisting
#: basic_mapping.xml:3711
#, fuzzy, no-c-format
msgid ""
"&lt;many-to-one name=\"owner\"\n"
"         class=\"Person\" property-ref=\"name\"&gt;\n"
"    &lt;column name=\"firstName\"/&gt;\n"
"    &lt;column name=\"initial\"/&gt;\n"
"    &lt;column name=\"lastName\"/&gt;\n"
"&lt;/many-to-one&gt;"
msgstr ""
"&lt;many-to-one name=\"person\" \n"
"         class=\"Person\" property-ref=\"name\"&gt;\n"
"    &lt;column name=\"firstName\"/&gt;\n"
"    &lt;column name=\"initial\"/&gt;\n"
"    &lt;column name=\"lastName\"/&gt;\n"
"&lt;/many-to-one&gt;"

#. Tag: para
#: basic_mapping.xml:3714
#, no-c-format
msgid ""
"When using annotations as a mapping strategy, such construct is not "
"necessary as the binding between a column and its related column on the "
"associated table is done directly"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3721
#, no-c-format
msgid ""
"The use of this outside the context of mapping legacy data is not "
"recommended."
msgstr "我们并不推荐这样使用，除非在映射遗留数据的情况下。 "

#. Tag: title
#: basic_mapping.xml:3726
#, no-c-format
msgid "Some hbm.xml specificities"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3728
#, no-c-format
msgid ""
"The hbm.xml structure has some specificities naturally not present when "
"using annotations, let's describe them briefly."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3732
#, no-c-format
msgid "Doctype"
msgstr "Doctype"

#. Tag: para
#: basic_mapping.xml:3734
#, no-c-format
msgid ""
"All XML mappings should declare the doctype shown. The actual DTD can be "
"found at the URL above, in the directory <literal>hibernate-x.x.x/src/org/"
"hibernate </literal>, or in <literal>hibernate3.jar</literal>. Hibernate "
"will always look for the DTD in its classpath first. If you experience "
"lookups of the DTD using an Internet connection, check the DTD declaration "
"against the contents of your classpath."
msgstr ""
"所有的 XML 映射都需要定义如上所示的 doctype。DTD 可以从上述 URL 中获取，也可"
"以从 <literal>hibernate-x.x.x/src/org/hibernate </literal> 目录中、或 "
"<literal>hibernate.jar</literal> 文件中找到。Hibernate 总是会首先在它的 "
"classptah 中搜索 DTD 文件。如果你发现它是通过连接 Internet 查找 DTD 文件，就"
"对照你的 classpath 目录检查 XML 文件里的 DTD 声明。"

#. Tag: title
#: basic_mapping.xml:3743
#, no-c-format
msgid "EntityResolver"
msgstr "EntityResolver"

#. Tag: para
#: basic_mapping.xml:3745
#, no-c-format
msgid ""
"Hibernate will first attempt to resolve DTDs in its classpath. It does this "
"is by registering a custom <literal>org.xml.sax.EntityResolver</literal> "
"implementation with the SAXReader it uses to read in the xml files. This "
"custom <literal>EntityResolver</literal> recognizes two different systemId "
"namespaces:"
msgstr ""
"Hibernate 首先试图在其 classpath 中解析 DTD。这是依靠在系统中注册的 "
"<literal>org.xml.sax.EntityResolver</literal> 的一个具体实现，SAXReader 依靠"
"它来读取 xml 文件。这个自定义的 <literal>EntityResolver</literal> 能辨认两种"
"不同的 systenId 命名空间："

#. Tag: para
#: basic_mapping.xml:3754
#, fuzzy, no-c-format
msgid ""
"a <literal>hibernate namespace</literal> is recognized whenever the resolver "
"encounters a systemId starting with <literal>http://www.hibernate.org/dtd/</"
"literal>. The resolver attempts to resolve these entities via the "
"classloader which loaded the Hibernate classes."
msgstr ""
"若 resolver 遇到了一个以 <literal>http://hibernate.sourceforge.net/</"
"literal> 为开头的 systemId，它会辨认出是 <literal>hibernate namespace</"
"literal>，resolver 就试图通过加载 Hibernate 类的 classloader 来查找这些实"
"体。 "

#. Tag: para
#: basic_mapping.xml:3762
#, no-c-format
msgid ""
"a <literal>user namespace</literal> is recognized whenever the resolver "
"encounters a systemId using a <literal>classpath://</literal> URL protocol. "
"The resolver will attempt to resolve these entities via (1) the current "
"thread context classloader and (2) the classloader which loaded the "
"Hibernate classes."
msgstr ""
"若 resolver 遇到了一个使用 <literal>classpath://</literal> URL 协议的 "
"systemId，它会辨认出这是 <literal>user namespace</literal>，resolver 试图通过"
"（1) 当前线程上下文的 classloader 和（2) 加载 Hibernate class 的 classloader "
"来查找这些实体。"

#. Tag: para
#: basic_mapping.xml:3771
#, no-c-format
msgid "The following is an example of utilizing user namespacing:"
msgstr "下面是一个使用用户命名空间（user namespace）的例子："

#. Tag: programlisting
#: basic_mapping.xml:3774
#, no-c-format
msgid ""
"<xi:include href=\"../extras/namespacing.xml_sample\" parse=\"text\"\n"
"              xmlns:xi=\"http://www.w3.org/2001/XInclude\" />"
msgstr ""

#. Tag: para
#: basic_mapping.xml:3776
#, no-c-format
msgid ""
"Where <literal>types.xml</literal> is a resource in the <literal>your."
"domain</literal> package and contains a custom <link linkend=\"mapping-types-"
"custom\">typedef</link>."
msgstr ""
"这里的 <literal>types.xml</literal> 是 <literal>your.domain</literal> 包中的"
"一个资源，它包含了一个自定义的 <link linkend=\"mapping-types-custom"
"\">typedef</link>。 "

#. Tag: title
#: basic_mapping.xml:3783
#, no-c-format
msgid "Hibernate-mapping"
msgstr "Hibernate-mapping"

#. Tag: para
#: basic_mapping.xml:3785
#, no-c-format
msgid ""
"This element has several optional attributes. The <literal>schema</literal> "
"and <literal>catalog</literal> attributes specify that tables referred to in "
"this mapping belong to the named schema and/or catalog. If they are "
"specified, tablenames will be qualified by the given schema and catalog "
"names. If they are missing, tablenames will be unqualified. The "
"<literal>default-cascade</literal> attribute specifies what cascade style "
"should be assumed for properties and collections that do not specify a "
"<literal>cascade</literal> attribute. By default, the <literal>auto-import</"
"literal> attribute allows you to use unqualified class names in the query "
"language."
msgstr ""
"这个元素包括一些可选的属性。<literal>schema</literal> 和 <literal>catalog</"
"literal> 属性， 指明了这个映射所连接（refer）的表所在的 schema 和/或 catalog "
"名称。假若指定了这个属性，表名会加上所指定的 schema 和 catalog 的名字扩展为全"
"限定名。假若没有指定，表名就不会使用全限定名。<literal>default-cascade</"
"literal> 指定了未明确注明 <literal>cascade</literal> 属性的 Java 属性和 集合"
"类 Hibernate 会采取什么样的默认级联风格。<literal>auto-import</literal> 属性"
"默认让我们在查询语言中可以使用非全限定名的类名。"

#. Tag: programlisting
#: basic_mapping.xml:3814
#, fuzzy, no-c-format
msgid ""
"&lt;hibernate-mapping\n"
"         schema=\"schemaName\"\n"
"         catalog=\"catalogName\"\n"
"         default-cascade=\"cascade_style\"\n"
"         default-access=\"field|property|ClassName\"\n"
"         default-lazy=\"true|false\"\n"
"         auto-import=\"true|false\"\n"
"         package=\"package.name\"\n"
" /&gt;"
msgstr ""
"<![CDATA[<hibernate-mapping\n"
"         schema=\"schemaName\"\n"
"         catalog=\"catalogName\"\n"
"         default-cascade=\"cascade_style\"\n"
"         default-access=\"field|property|ClassName\"\n"
"         default-lazy=\"true|false\"\n"
"         auto-import=\"true|false\"\n"
"         package=\"package.name\"\n"
" />]]>"

#. Tag: para
#: basic_mapping.xml:3818
#, no-c-format
msgid "<literal>schema</literal> (optional): the name of a database schema."
msgstr "<literal>schema</literal>（可选）：数据库 schema 的名称。"

#. Tag: para
#: basic_mapping.xml:3823
#, no-c-format
msgid "<literal>catalog</literal> (optional): the name of a database catalog."
msgstr "<literal>catalog</literal>（可选）：数据库 catalog 的名称。 "

#. Tag: para
#: basic_mapping.xml:3828
#, no-c-format
msgid ""
"<literal>default-cascade</literal> (optional - defaults to <literal>none</"
"literal>): a default cascade style."
msgstr ""
"<literal>default-cascade</literal>（可选 — 默认为 <literal>none</literal>）："
"默认的级联风格。 "

#. Tag: para
#: basic_mapping.xml:3833
#, no-c-format
msgid ""
"<literal>default-access</literal> (optional - defaults to <literal>property</"
"literal>): the strategy Hibernate should use for accessing all properties. "
"It can be a custom implementation of <literal>PropertyAccessor</literal>."
msgstr ""
"<literal>default-access</literal>（可选 — 默认为 <literal>property</"
"literal>）：Hibernate 用来访问所有属性的策略。可以通过实现 "
"<literal>PropertyAccessor</literal> 接口自定义。 "

#. Tag: para
#: basic_mapping.xml:3840
#, no-c-format
msgid ""
"<literal>default-lazy</literal> (optional - defaults to <literal>true</"
"literal>): the default value for unspecified <literal>lazy</literal> "
"attributes of class and collection mappings."
msgstr ""
"<literal>default-lazy</literal>（可选 — 默认为 <literal>true</literal>）：指"
"定了未明确注明 <literal>lazy</literal> 属性的 Java 属性和集合类，Hibernate 会"
"采取什么样的默认加载风格。 "

#. Tag: para
#: basic_mapping.xml:3847
#, no-c-format
msgid ""
"<literal>auto-import</literal> (optional - defaults to <literal>true</"
"literal>): specifies whether we can use unqualified class names of classes "
"in this mapping in the query language."
msgstr ""
"<literal>auto-import</literal>（可选 — 默认为 <literal>true</literal>）：指定"
"我们是否可以在查询语言中使用非全限定的类名（仅限于本映射文件中的类）。 "

#. Tag: para
#: basic_mapping.xml:3854
#, no-c-format
msgid ""
"<literal>package</literal> (optional): specifies a package prefix to use for "
"unqualified class names in the mapping document."
msgstr ""
"<literal>package</literal>（可选）：指定一个包前缀，如果在映射文档中没有指定"
"全限定的类名，就使用这个作为包名。 "

#. Tag: para
#: basic_mapping.xml:3861
#, no-c-format
msgid ""
"If you have two persistent classes with the same unqualified name, you "
"should set <literal>auto-import=\"false\"</literal>. An exception will "
"result if you attempt to assign two classes to the same \"imported\" name."
msgstr ""
"假若你有两个持久化类，它们的非全限定名是一样的（就是两个类的名字一样，所在的"
"包不一样 — 译者注），你应该设置 <literal>auto-import=\"false\"</literal>。如"
"果你把一个“导入过”的名字同时对应两个类，Hibernate 会抛出一个异常。"

#. Tag: para
#: basic_mapping.xml:3866
#, no-c-format
msgid ""
"The <literal>hibernate-mapping</literal> element allows you to nest several "
"persistent <literal>&lt;class&gt;</literal> mappings, as shown above. It is, "
"however, good practice (and expected by some tools) to map only a single "
"persistent class, or a single class hierarchy, in one mapping file and name "
"it after the persistent superclass. For example, <literal>Cat.hbm.xml</"
"literal>, <literal>Dog.hbm.xml</literal>, or if using inheritance, "
"<literal>Animal.hbm.xml</literal>."
msgstr ""
"注意 <literal>hibernate-mapping</literal> 元素允许你嵌套多个如上所示的 "
"<literal>&lt;class&gt;</literal> 映射。但是最好的做法（也许一些工具需要的）是"
"一个持久化类（或一个类的继承层次）对应一个映射文件，并以持久化的超类名称命"
"名，例如：<literal>Cat.hbm.xml</literal>、<literal>Dog.hbm.xml</literal>，或"
"者如果使用继承，<literal>Animal.hbm.xml</literal>。"

#. Tag: title
#: basic_mapping.xml:3877
#, fuzzy, no-c-format
msgid "<title>Key</title>"
msgstr "<title>键（key）</title>"

#. Tag: para
#: basic_mapping.xml:3879
#, fuzzy, no-c-format
msgid ""
"The <literal>&lt;key&gt;</literal> element is featured a few times within "
"this guide. It appears anywhere the parent mapping element defines a join to "
"a new table that references the primary key of the original table. It also "
"defines the foreign key in the joined table:"
msgstr ""
"我们目前已经见到过 <literal>&lt;key&gt;</literal> 元素多次了。这个元素在父映"
"射元素定义了对新表的连接，并且在被连接表中定义了一个外键引用原表的主键的情况"
"下经常使用。 "

#. Tag: programlisting
#: basic_mapping.xml:3900
#, fuzzy, no-c-format
msgid ""
"&lt;key\n"
"        column=\"columnname\"\n"
"        on-delete=\"noaction|cascade\"\n"
"        property-ref=\"propertyName\"\n"
"        not-null=\"true|false\"\n"
"        update=\"true|false\"\n"
"        unique=\"true|false\"\n"
"/&gt;"
msgstr ""
"&lt;key\n"
"        column=\"columnname\"\n"
"        on-delete=\"noaction|cascade\"\n"
"        property-ref=\"propertyName\"\n"
"        not-null=\"true|false\"\n"
"        update=\"true|false\"\n"
"        unique=\"true|false\"\n"
"/&gt;"

#. Tag: para
#: basic_mapping.xml:3910
#, no-c-format
msgid ""
"<literal>on-delete</literal> (optional - defaults to <literal>noaction</"
"literal>): specifies whether the foreign key constraint has database-level "
"cascade delete enabled."
msgstr ""
"<literal>on-delete</literal>（可选，默认是 <literal>noaction</literal>）：表"
"明外键关联是否打开数据库级别的级联删除。 "

#. Tag: para
#: basic_mapping.xml:3916
#, no-c-format
msgid ""
"<literal>property-ref</literal> (optional): specifies that the foreign key "
"refers to columns that are not the primary key of the original table. It is "
"provided for legacy data."
msgstr ""
"<literal>property-ref</literal>（可选）：表明外键引用的字段不是原表的主键（提"
"供给遗留数据）。 "

#. Tag: para
#: basic_mapping.xml:3922
#, no-c-format
msgid ""
"<literal>not-null</literal> (optional): specifies that the foreign key "
"columns are not nullable. This is implied whenever the foreign key is also "
"part of the primary key."
msgstr ""
"<literal>not-null</literal>（可选）：表明外键的字段不可为空（这意味着无论何时"
"外键都是主键的一部分）。 "

#. Tag: para
#: basic_mapping.xml:3928
#, no-c-format
msgid ""
"<literal>update</literal> (optional): specifies that the foreign key should "
"never be updated. This is implied whenever the foreign key is also part of "
"the primary key."
msgstr ""
"<literal>update</literal>（可选）：表明外键决不应该被更新（这意味着无论何时外"
"键都是主键的一部分）。 "

#. Tag: para
#: basic_mapping.xml:3934
#, no-c-format
msgid ""
"<literal>unique</literal> (optional): specifies that the foreign key should "
"have a unique constraint. This is implied whenever the foreign key is also "
"the primary key."
msgstr ""
"<literal>unique</literal>（可选）：表明外键应有唯一性约束（这意味着无论何时外"
"键都是主键的一部分）。 "

#. Tag: para
#: basic_mapping.xml:3941
#, no-c-format
msgid ""
"For systems where delete performance is important, we recommend that all "
"keys should be defined <literal>on-delete=\"cascade\"</literal>. Hibernate "
"uses a database-level <literal>ON CASCADE DELETE</literal> constraint, "
"instead of many individual <literal>DELETE</literal> statements. Be aware "
"that this feature bypasses Hibernate's usual optimistic locking strategy for "
"versioned data."
msgstr ""
"对那些看重删除性能的系统，我们推荐所有的键都应该定义为 <literal>on-delete="
"\"cascade\"</literal>，这样 Hibernate 将使用数据库级的 <literal>ON CASCADE "
"DELETE</literal> 约束，而不是多个 <literal>DELETE</literal> 语句。注意，这个"
"特性会绕过 Hibernate 通常对版本数据（versioned data）采用的乐观锁策略。 "

#. Tag: para
#: basic_mapping.xml:3949
#, no-c-format
msgid ""
"The <literal>not-null</literal> and <literal>update</literal> attributes are "
"useful when mapping a unidirectional one-to-many association. If you map a "
"unidirectional one-to-many association to a non-nullable foreign key, you "
"<emphasis>must</emphasis> declare the key column using <literal>&lt;key not-"
"null=\"true\"&gt;</literal>."
msgstr ""
"<literal>not-null</literal> 和 <literal>update</literal> 属性在映射单向一对多"
"关联的时候有用。如果你映射一个单向一对多关联到非空的（non-nullable）外键，你"
"<emphasis>必须</emphasis> 用 <literal>&lt;key not-null=\"true\"&gt;</"
"literal> 定义此键字段。 "

#. Tag: title
#: basic_mapping.xml:3958
#, no-c-format
msgid "Import"
msgstr "引用（import） "

#. Tag: para
#: basic_mapping.xml:3960
#, no-c-format
msgid ""
"If your application has two persistent classes with the same name, and you "
"do not want to specify the fully qualified package name in Hibernate "
"queries, classes can be \"imported\" explicitly, rather than relying upon "
"<literal>auto-import=\"true\"</literal>. You can also import classes and "
"interfaces that are not explicitly mapped:"
msgstr ""
"假设你的应用程序有两个同样名字的持久化类，但是你不想在 Hibernate 查询中使用他"
"们的全限定名。除了依赖 <literal>auto-import=\"true\"</literal> 以外，类也可以"
"被显式地“import（引用）”。你甚至可以引用没有被明确映射的类和接口。 "

#. Tag: programlisting
#: basic_mapping.xml:3966
#, fuzzy, no-c-format
msgid "&lt;import class=\"java.lang.Object\" rename=\"Universe\"/&gt;"
msgstr "&lt;import class=\"java.lang.Object\" rename=\"Universe\"/&gt;"

#. Tag: programlisting
#: basic_mapping.xml:3975
#, fuzzy, no-c-format
msgid ""
"&lt;import\n"
"        class=\"ClassName\"\n"
"        rename=\"ShortName\"\n"
"/&gt;"
msgstr ""
"&lt;import\n"
"        class=\"ClassName\"\n"
"        rename=\"ShortName\"\n"
"/&gt;"

#. Tag: para
#: basic_mapping.xml:3979
#, no-c-format
msgid ""
"<literal>class</literal>: the fully qualified class name of any Java class."
msgstr "<literal>class</literal>：任何 Java 类的全限定名。 "

#. Tag: para
#: basic_mapping.xml:3984
#, no-c-format
msgid ""
"<literal>rename</literal> (optional - defaults to the unqualified class "
"name): a name that can be used in the query language."
msgstr ""
"<literal>rename</literal>（可选 — 默认为类的全限定名）：在查询语句中可以使用"
"的名字。 "

#. Tag: para
#: basic_mapping.xml:3992
#, no-c-format
msgid "This feature is unique to hbm.xml and is not supported in annotations."
msgstr ""

#. Tag: title
#: basic_mapping.xml:3998
#, no-c-format
msgid "Column and formula elements"
msgstr "字段和规则元素（column and formula elements） "

#. Tag: para
#: basic_mapping.xml:4000
#, no-c-format
msgid ""
"Mapping elements which accept a <literal>column</literal> attribute will "
"alternatively accept a <literal>&lt;column&gt;</literal> subelement. "
"Likewise, <literal>&lt;formula&gt;</literal> is an alternative to the "
"<literal>formula</literal> attribute. For example:"
msgstr ""
"任何接受 <literal>column</literal> 属性的映射元素都可以选择接受 <literal>&lt;"
"column&gt;</literal> 子元素。同样的，<literal>formula</literal> 子元素也可以"
"替换 <literal>&lt;formula&gt;</literal> 属性。 "

#. Tag: programlisting
#: basic_mapping.xml:4006
#, fuzzy, no-c-format
msgid ""
"&lt;column\n"
"        name=\"column_name\"\n"
"        length=\"N\"\n"
"        precision=\"N\"\n"
"        scale=\"N\"\n"
"        not-null=\"true|false\"\n"
"        unique=\"true|false\"\n"
"        unique-key=\"multicolumn_unique_key_name\"\n"
"        index=\"index_name\"\n"
"        sql-type=\"sql_type_name\"\n"
"        check=\"SQL expression\"\n"
"        default=\"SQL expression\"\n"
"        read=\"SQL expression\"\n"
"        write=\"SQL expression\"/&gt;"
msgstr ""
"&lt;column\n"
"        name=\"column_name\"\n"
"        length=\"N\"\n"
"        precision=\"N\"\n"
"        scale=\"N\"\n"
"        not-null=\"true|false\"\n"
"        unique=\"true|false\"\n"
"        unique-key=\"multicolumn_unique_key_name\"\n"
"        index=\"index_name\"\n"
"        sql-type=\"sql_type_name\"\n"
"        check=\"SQL expression\"\n"
"        default=\"SQL expression\"/&gt;"

#. Tag: programlisting
#: basic_mapping.xml:4008
#, fuzzy, no-c-format
msgid "&lt;formula&gt;SQL expression&lt;/formula&gt;"
msgstr "&lt;formula&gt;SQL expression&lt;/formula&gt;"

#. Tag: para
#: basic_mapping.xml:4010
#, no-c-format
msgid ""
"Most of the attributes on <literal>column</literal> provide a means of "
"tailoring the DDL during automatic schema generation. The <literal>read</"
"literal> and <literal>write</literal> attributes allow you to specify custom "
"SQL that Hibernate will use to access the column's value. For more on this, "
"see the discussion of <link linkend=\"mapping-column-read-and-write\">column "
"read and write expressions</link>."
msgstr ""
"<literal>column</literal> 上的大多数属性都提供了在自动模式生成过程中对 DDL 进"
"行裁剪的方法。<literal>read</literal> 和 <literal>write</literal> 属性允许你"
"指定 Hibernate 用于访问字段值的自定义的 SQL。关于更多的内容，请参考 <link "
"linkend=\"mapping-column-read-and-write\">column read and write expressions</"
"link>。"

#. Tag: para
#: basic_mapping.xml:4018
#, no-c-format
msgid ""
"The <literal>column</literal> and <literal>formula</literal> elements can "
"even be combined within the same property or association mapping to express, "
"for example, exotic join conditions."
msgstr ""
"<literal>column</literal> 和 <literal>formula</literal> 属性甚至可以在同一个"
"属性或关联映射中被合并来表达，例如，一些奇异的连接条件。"

#. Tag: programlisting
#: basic_mapping.xml:4022
#, fuzzy, no-c-format
msgid ""
"&lt;many-to-one name=\"homeAddress\" class=\"Address\"\n"
"        insert=\"false\" update=\"false\"&gt;\n"
"    &lt;column name=\"person_id\" not-null=\"true\" length=\"10\"/&gt;\n"
"    &lt;formula&gt;'MAILING'&lt;/formula&gt;\n"
"&lt;/many-to-one&gt;"
msgstr ""
"&lt;many-to-one name=\"homeAddress\" class=\"Address\"\n"
"        insert=\"false\" update=\"false\"&gt;\n"
"    &lt;column name=\"person_id\" not-null=\"true\" length=\"10\"/&gt;\n"
"    &lt;formula&gt;'MAILING'&lt;/formula&gt;\n"
"&lt;/many-to-one&gt;"

#. Tag: title
#: basic_mapping.xml:4028
#, no-c-format
msgid "Hibernate types"
msgstr "Hibernate 的类型 "

#. Tag: title
#: basic_mapping.xml:4031
#, no-c-format
msgid "Entities and values"
msgstr "实体（Entities）和值（values）"

#. Tag: para
#: basic_mapping.xml:4033
#, no-c-format
msgid ""
"In relation to the persistence service, Java language-level objects are "
"classified into two groups:"
msgstr "和持久化服务相比，Java 级别的对象分为两个组别："

#. Tag: para
#: basic_mapping.xml:4036
#, no-c-format
msgid ""
"An <emphasis>entity</emphasis> exists independently of any other objects "
"holding references to the entity. Contrast this with the usual Java model, "
"where an unreferenced object is garbage collected. Entities must be "
"explicitly saved and deleted. Saves and deletions, however, can be "
"<emphasis>cascaded</emphasis> from a parent entity to its children. This is "
"different from the ODMG model of object persistence by reachability and "
"corresponds more closely to how application objects are usually used in "
"large systems. Entities support circular and shared references. They can "
"also be versioned."
msgstr ""
"<emphasis>实体entity</emphasis> 独立于任何持有实体引用的对象。与通常的 Java "
"模型相比，不再被引用的对象会被当作垃圾收集掉。实体必须被显式的保存和删除（除"
"非保存和删除是从父实体向子实体引发的<emphasis>级联</emphasis>）。这和 ODMG 模"
"型中关于对象通过可触及保持持久性有一些不同 — 比较起来更加接近应用程序对象通常"
"在一个大系统中的使用方法。实体支持循环引用和交叉引用，它们也可以加上版本信"
"息。 "

#. Tag: para
#: basic_mapping.xml:4046
#, no-c-format
msgid ""
"An entity's persistent state consists of references to other entities and "
"instances of <emphasis>value</emphasis> types. Values are primitives: "
"collections (not what is inside a collection), components and certain "
"immutable objects. Unlike entities, values in particular collections and "
"components, <emphasis>are</emphasis> persisted and deleted by reachability. "
"Since value objects and primitives are persisted and deleted along with "
"their containing entity, they cannot be independently versioned. Values have "
"no independent identity, so they cannot be shared by two entities or "
"collections."
msgstr ""
"一个实体的持久状态包含指向其他实体和<emphasis>值</emphasis>类型实例的引用。值"
"可以是原始类型，集合（不是集合中的对象），组件或者特定的不可变对象。与实体不"
"同，值（特别是集合和组件）是通过可触及性来进行持久化和删除的。因为值对象（和"
"原始类型数据）是随着包含他们的实体而被持久化和删除的，他们不能被独立的加上版"
"本信息。值没有独立的标识，所以他们不能被两个实体或者集合共享。 "

#. Tag: para
#: basic_mapping.xml:4056
#, no-c-format
msgid ""
"Until now, we have been using the term \"persistent class\" to refer to "
"entities. We will continue to do that. Not all user-defined classes with a "
"persistent state, however, are entities. A <emphasis>component</emphasis> is "
"a user-defined class with value semantics. A Java property of type "
"<literal>java.lang.String</literal> also has value semantics. Given this "
"definition, all types (classes) provided by the JDK have value type "
"semantics in Java, while user-defined types can be mapped with entity or "
"value type semantics. This decision is up to the application developer. An "
"entity class in a domain model will normally have shared references to a "
"single instance of that class, while composition or aggregation usually "
"translates to a value type."
msgstr ""
"直到现在，我们都一直使用术语“持久类”（persistent class）来代表实体。我们仍然"
"会这么做。然而严格说来，不是所有的用户自定义的，带有持久化状态的类都是实体。"
"<emphasis>组件</emphasis>就是用户自定义类，却是值语义的。<literal>java.lang."
"String</literal> 类型的 java 属性也是值语义的。给了这个定义以后，我们可以说所"
"有 JDK 提供的类型（类）都是值类型的语义，而用于自定义类型可能被映射为实体类型"
"或值类型语义。采用哪种类型的语义取决于开发人员。在领域模型中，寻找实体类的一"
"个好线索是共享引用指向这个类的单一实例，而组合或聚合通常被转化为值类型。 "

#. Tag: para
#: basic_mapping.xml:4069
#, no-c-format
msgid "We will revisit both concepts throughout this reference guide."
msgstr "我们会在本文档中重复碰到这两个概念。 "

#. Tag: para
#: basic_mapping.xml:4072
#, no-c-format
msgid ""
"The challenge is to map the Java type system, and the developers' definition "
"of entities and value types, to the SQL/database type system. The bridge "
"between both systems is provided by Hibernate. For entities, <literal>&lt;"
"class&gt;</literal>, <literal>&lt;subclass&gt;</literal> and so on are used. "
"For value types we use <literal>&lt;property&gt;</literal>, <literal>&lt;"
"component&gt;</literal>etc., that usually have a <literal>type</literal> "
"attribute. The value of this attribute is the name of a Hibernate "
"<emphasis>mapping type</emphasis>. Hibernate provides a range of mappings "
"for standard JDK value types out of the box. You can write your own mapping "
"types and implement your own custom conversion strategies."
msgstr ""
"挑战在于将 java 类型系统(和开发者定义的实体和值类型)映射到 SQL/数据库类型系"
"统。Hibernate 提供了连接两个系统之间的桥梁：对于实体类型，我们使用 "
"<literal>&lt;class&gt;</literal>，<literal>&lt;subclass&gt;</literal> 等等。"
"对于值类型，我们使用 <literal>&lt;property&gt;</literal>，<literal>&lt;"
"component&gt;</literal> 及其他，通常跟随着 <literal>type</literal> 属性。这个"
"属性的值是Hibernate 的<emphasis>映射类型</emphasis>的名字。Hibernate 提供了许"
"多现成的映射（标准的 JDK 值类型）。你也可以编写自己的映射类型并实现自定义的变"
"换策略，随后我们会看到这点。 "

#. Tag: para
#: basic_mapping.xml:4085
#, no-c-format
msgid ""
"With the exception of collections, all built-in Hibernate types support null "
"semantics."
msgstr ""
"所有的 Hibernate 内建类型，除了 collections 以外，都支持空（null）语义。 "

#. Tag: title
#: basic_mapping.xml:4090
#, no-c-format
msgid "Basic value types"
msgstr "基本值类型"

#. Tag: para
#: basic_mapping.xml:4092
#, no-c-format
msgid ""
"The built-in <emphasis>basic mapping types</emphasis> can be roughly "
"categorized into the following:"
msgstr "内置的 <emphasis>basic mapping types</emphasis> 可以大致地分类为："

#. Tag: literal
#: basic_mapping.xml:4095
#, fuzzy, no-c-format
msgid ""
"integer, long, short, float, double, character, byte, boolean, yes_no, "
"true_false"
msgstr ""
"<literal>integer, long, short, float, double, character, byte, boolean, "
"yes_no, true_false</literal>"

#. Tag: para
#: basic_mapping.xml:4099
#, no-c-format
msgid ""
"Type mappings from Java primitives or wrapper classes to appropriate (vendor-"
"specific) SQL column types. <literal>boolean, yes_no</literal> and "
"<literal>true_false</literal> are all alternative encodings for a Java "
"<literal>boolean</literal> or <literal>java.lang.Boolean</literal>."
msgstr ""
"这些类型都对应 Java 的原始类型或者其封装类，来符合（特定厂商的）SQL 字段类"
"型。<literal>boolean, yes_no</literal> 和 <literal>true_false</literal> 都是 "
"Java 中 <literal>boolean</literal> 或者 <literal>java.lang.Boolean</literal> "
"的另外说法。"

#. Tag: literal
#: basic_mapping.xml:4109
#, no-c-format
msgid "string"
msgstr "string"

#. Tag: para
#: basic_mapping.xml:4112
#, no-c-format
msgid ""
"A type mapping from <literal>java.lang.String</literal> to <literal>VARCHAR</"
"literal> (or Oracle <literal>VARCHAR2</literal>)."
msgstr ""
"从 <literal>java.lang.String</literal> 到 <literal>VARCHAR</literal>（或者 "
"Oracle 的 <literal>VARCHAR2</literal>）的映射。"

#. Tag: literal
#: basic_mapping.xml:4119
#, fuzzy, no-c-format
msgid "date, time, timestamp"
msgstr "<literal>date, time, timestamp</literal>"

#. Tag: para
#: basic_mapping.xml:4122
#, no-c-format
msgid ""
"Type mappings from <literal>java.util.Date</literal> and its subclasses to "
"SQL types <literal>DATE</literal>, <literal>TIME</literal> and "
"<literal>TIMESTAMP</literal> (or equivalent)."
msgstr ""
"从 <literal>java.util.Date</literal> 和其子类到 SQL 类型 <literal>DATE</"
"literal>，<literal>TIME</literal> 和 <literal>TIMESTAMP</literal>（或等价类"
"型）的映射。"

#. Tag: literal
#: basic_mapping.xml:4130
#, fuzzy, no-c-format
msgid "calendar, calendar_date"
msgstr "<literal>calendar, calendar_date</literal>"

#. Tag: para
#: basic_mapping.xml:4133
#, no-c-format
msgid ""
"Type mappings from <literal>java.util.Calendar</literal> to SQL types "
"<literal>TIMESTAMP</literal> and <literal>DATE</literal> (or equivalent)."
msgstr ""
"从 <literal>java.util.Calendar</literal> 到 SQL 类型 <literal>TIMESTAMP</"
"literal> 和 <literal>DATE</literal>（或等价类型）的映射。"

#. Tag: literal
#: basic_mapping.xml:4140
#, fuzzy, no-c-format
msgid "big_decimal, big_integer"
msgstr "<literal>big_decimal, big_integer</literal>"

#. Tag: para
#: basic_mapping.xml:4143
#, no-c-format
msgid ""
"Type mappings from <literal>java.math.BigDecimal</literal> and <literal>java."
"math.BigInteger</literal> to <literal>NUMERIC</literal> (or Oracle "
"<literal>NUMBER</literal>)."
msgstr ""
"从 <literal>java.math.BigDecimal</literal> 和 <literal>java.math.BigInteger</"
"literal> 到 <literal>NUMERIC</literal>（或者 Oracle 的 <literal>NUMBER</"
"literal>类型）的映射。"

#. Tag: literal
#: basic_mapping.xml:4151
#, fuzzy, no-c-format
msgid "locale, timezone, currency"
msgstr "<literal>locale, timezone, currency</literal>"

#. Tag: para
#: basic_mapping.xml:4154
#, no-c-format
msgid ""
"Type mappings from <literal>java.util.Locale</literal>, <literal>java.util."
"TimeZone</literal> and <literal>java.util.Currency</literal> to "
"<literal>VARCHAR</literal> (or Oracle <literal>VARCHAR2</literal>). "
"Instances of <literal>Locale</literal> and <literal>Currency</literal> are "
"mapped to their ISO codes. Instances of <literal>TimeZone</literal> are "
"mapped to their <literal>ID</literal>."
msgstr ""
"从 <literal>java.util.Locale</literal>，<literal>java.util.TimeZone</"
"literal>  和 <literal>java.util.Currency</literal> 到 <literal>VARCHAR</"
"literal>（或者 Oracle 的 <literal>VARCHAR2</literal> 类型）的映射。"
"<literal>Locale</literal> 和 <literal>Currency</literal> 的实例被映射为它们"
"的 ISO 代码。<literal>TimeZone</literal> 的实例被影射为它的 <literal>ID</"
"literal>。"

#. Tag: literal
#: basic_mapping.xml:4167
#, fuzzy, no-c-format
msgid "class"
msgstr "子类（subclass）"

#. Tag: para
#: basic_mapping.xml:4170
#, no-c-format
msgid ""
"A type mapping from <literal>java.lang.Class</literal> to <literal>VARCHAR</"
"literal> (or Oracle <literal>VARCHAR2</literal>). A <literal>Class</literal> "
"is mapped to its fully qualified name."
msgstr ""
"从 <literal>java.lang.Class</literal> 到 <literal>VARCHAR</literal>（或者 "
"Oracle 的 <literal>VARCHAR2</literal> 类型）的映射。<literal>Class</literal> "
"被映射为它的全限定名。"

#. Tag: literal
#: basic_mapping.xml:4178
#, no-c-format
msgid "binary"
msgstr "binary"

#. Tag: para
#: basic_mapping.xml:4181
#, no-c-format
msgid "Maps byte arrays to an appropriate SQL binary type."
msgstr "把字节数组（byte arrays）映射为对应的 SQL 二进制类型。"

#. Tag: literal
#: basic_mapping.xml:4186
#, no-c-format
msgid "text"
msgstr "text"

#. Tag: para
#: basic_mapping.xml:4189
#, fuzzy, no-c-format
msgid ""
"Maps long Java strings to a SQL <literal>LONGVARCHAR</literal> or "
"<literal>TEXT</literal> type."
msgstr ""
"把长 Java 字符串映射为 SQL 的 <literal>CLOB</literal> 或者 <literal>TEXT</"
"literal> 类型。"

#. Tag: literal
#: basic_mapping.xml:4195
#, no-c-format
msgid "image"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4198
#, fuzzy, no-c-format
msgid "Maps long byte arrays to a SQL <literal>LONGVARBINARY</literal>."
msgstr ""
"把长 Java 字符串映射为 SQL 的 <literal>CLOB</literal> 或者 <literal>TEXT</"
"literal> 类型。"

#. Tag: literal
#: basic_mapping.xml:4203
#, no-c-format
msgid "serializable"
msgstr "serializable"

#. Tag: para
#: basic_mapping.xml:4206
#, no-c-format
msgid ""
"Maps serializable Java types to an appropriate SQL binary type. You can also "
"indicate the Hibernate type <literal>serializable</literal> with the name of "
"a serializable Java class or interface that does not default to a basic type."
msgstr ""
"把可序列化的 Java 类型映射到对应的 SQL 二进制类型。你也可以为一个并非默认为基"
"本类型的可序列化 Java 类或者接口指定 Hibernate 类型 <literal>serializable</"
"literal>。 "

#. Tag: literal
#: basic_mapping.xml:4215
#, no-c-format
msgid "clob, blob"
msgstr "clob, blob"

#. Tag: para
#: basic_mapping.xml:4218
#, no-c-format
msgid ""
"Type mappings for the JDBC classes <literal>java.sql.Clob</literal> and "
"<literal>java.sql.Blob</literal>. These types can be inconvenient for some "
"applications, since the blob or clob object cannot be reused outside of a "
"transaction. Driver support is patchy and inconsistent."
msgstr ""
"JDBC 类 <literal>java.sql.Clob</literal> 和 <literal>java.sql.Blob</literal>"
"的映射。某些程序可能不适合使用这个类型，因为 blob 和 clob 对象可能在一个事务"
"之外是无法重用的。（而且, 驱动程序对这种类型的支持充满着补丁和前后矛盾。） "

#. Tag: literal
#: basic_mapping.xml:4228
#, no-c-format
msgid "materialized_clob"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4231
#, no-c-format
msgid ""
"Maps long Java strings to a SQL <literal>CLOB</literal> type. When read, the "
"<literal>CLOB</literal> value is immediately materialized into a Java "
"string. Some drivers require the <literal>CLOB</literal> value to be read "
"within a transaction. Once materialized, the Java string is available "
"outside of the transaction."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4241
#, fuzzy, no-c-format
msgid "materialized_blob"
msgstr "serializable"

#. Tag: para
#: basic_mapping.xml:4244
#, no-c-format
msgid ""
"Maps long Java byte arrays to a SQL <literal>BLOB</literal> type. When read, "
"the <literal>BLOB</literal> value is immediately materialized into a byte "
"array. Some drivers require the <literal>BLOB</literal> value to be read "
"within a transaction. Once materialized, the byte array is available outside "
"of the transaction."
msgstr ""

#. Tag: literal
#: basic_mapping.xml:4254
#, fuzzy, no-c-format
msgid ""
"imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, "
"imm_serializable, imm_binary"
msgstr ""
"<literal>imm_date, imm_time, imm_timestamp, imm_calendar, imm_calendar_date, "
"imm_serializable, imm_binary</literal>"

#. Tag: para
#: basic_mapping.xml:4258
#, no-c-format
msgid ""
"Type mappings for what are considered mutable Java types. This is where "
"Hibernate makes certain optimizations appropriate only for immutable Java "
"types, and the application treats the object as immutable. For example, you "
"should not call <literal>Date.setTime()</literal> for an instance mapped as "
"<literal>imm_timestamp</literal>. To change the value of the property, and "
"have that change made persistent, the application must assign a new, "
"nonidentical, object to the property."
msgstr ""
"一般来说，映射类型被假定为是可变的 Java 类型，只有对不可变 Java 类型，"
"Hibernate 会采取特定的优化措施，应用程序会把这些对象作为不可变对象处理。比"
"如，你不应该对作为 <literal>imm_timestamp</literal> 映射的 Date 执行 "
"<literal>Date.setTime()</literal>。要改变属性的值，并且保存这一改变，应用程序"
"必须对这一属性重新设置一个新的（不一样的）对象。 "

#. Tag: para
#: basic_mapping.xml:4270
#, no-c-format
msgid ""
"Unique identifiers of entities and collections can be of any basic type "
"except <literal>binary</literal>, <literal>blob</literal> and <literal>clob</"
"literal>. Composite identifiers are also allowed. See below for more "
"information."
msgstr ""
"实体及其集合的唯一标识可以是除了 <literal>binary</literal>、 <literal>blob</"
"literal> 和 <literal>clob</literal> 之外的任何基础类型。（联合标识也是允许"
"的，后面会说到。）"

#. Tag: para
#: basic_mapping.xml:4275
#, no-c-format
msgid ""
"The basic value types have corresponding <literal>Type</literal> constants "
"defined on <literal>org.hibernate.Hibernate</literal>. For example, "
"<literal>Hibernate.STRING</literal> represents the <literal>string</literal> "
"type."
msgstr ""
"在 <literal>org.hibernate.Hibernate</literal> 中，定义了基础类型对应的 "
"<literal>Type</literal> 常量。比如，<literal>Hibernate.STRING</literal> 代表 "
"<literal>string</literal> 类型。"

#. Tag: title
#: basic_mapping.xml:4282
#, no-c-format
msgid "Custom value types"
msgstr "自定义值类型"

#. Tag: para
#: basic_mapping.xml:4284
#, no-c-format
msgid ""
"It is relatively easy for developers to create their own value types. For "
"example, you might want to persist properties of type <literal>java.lang."
"BigInteger</literal> to <literal>VARCHAR</literal> columns. Hibernate does "
"not provide a built-in type for this. Custom types are not limited to "
"mapping a property, or collection element, to a single table column. So, for "
"example, you might have a Java property <literal>getName()</literal>/"
"<literal>setName()</literal> of type <literal>java.lang.String</literal> "
"that is persisted to the columns <literal>FIRST_NAME</literal>, "
"<literal>INITIAL</literal>, <literal>SURNAME</literal>."
msgstr ""
"开发者创建属于他们自己的值类型也是很容易的。比如说，你可能希望持久化 "
"<literal>java.lang.BigInteger</literal> 类型的属性，持久化成为 "
"<literal>VARCHAR</literal> 字段。Hibernate没有内置这样一种类型。自定义类型能"
"够映射一个属性(或集合元素)到不止一个数据库表字段。比如说，你可能有这样的 "
"Java 属性：<literal>getName()</literal>/<literal>setName()</literal>，这是 "
"<literal>java.lang.String</literal> 类型的，对应的持久化到三个字段："
"<literal>FIRST_NAME</literal>，<literal>INITIAL</literal>，<literal>SURNAME</"
"literal>。 "

#. Tag: para
#: basic_mapping.xml:4295
#, no-c-format
msgid ""
"To implement a custom type, implement either <literal>org.hibernate."
"UserType</literal> or <literal>org.hibernate.CompositeUserType</literal> and "
"declare properties using the fully qualified classname of the type. View "
"<literal>org.hibernate.test.DoubleStringType</literal> to see the kind of "
"things that are possible."
msgstr ""
"要实现一个自定义类型，可以实现 <literal>org.hibernate.UserType</literal> 或 "
"<literal>org.hibernate.CompositeUserType</literal> 中的任一个，并且使用类型"
"的 Java 全限定类名来定义属性。请查看 <literal>org.hibernate.test."
"DoubleStringType</literal> 这个例子，看看它是怎么做的。 "

#. Tag: programlisting
#: basic_mapping.xml:4302
#, fuzzy, no-c-format
msgid ""
"&lt;property name=\"twoStrings\" type=\"org.hibernate.test.DoubleStringType"
"\"&gt;\n"
"    &lt;column name=\"first_string\"/&gt;\n"
"    &lt;column name=\"second_string\"/&gt;\n"
"&lt;/property&gt;"
msgstr ""
"&lt;property name=\"twoStrings\" type=\"org.hibernate.test.DoubleStringType"
"\"&gt;\n"
"    &lt;column name=\"first_string\"/&gt;\n"
"    &lt;column name=\"second_string\"/&gt;\n"
"&lt;/property&gt;"

#. Tag: para
#: basic_mapping.xml:4304
#, no-c-format
msgid ""
"Notice the use of <literal>&lt;column&gt;</literal> tags to map a property "
"to multiple columns."
msgstr ""
"注意使用 <literal>&lt;column&gt;</literal> 标签来把一个属性映射到多个字段的做"
"法。"

#. Tag: para
#: basic_mapping.xml:4307
#, no-c-format
msgid ""
"The <literal>CompositeUserType</literal>, <literal>EnhancedUserType</"
"literal>, <literal>UserCollectionType</literal>, and "
"<literal>UserVersionType</literal> interfaces provide support for more "
"specialized uses."
msgstr ""
"<literal>CompositeUserType</literal>，<literal>EnhancedUserType</literal>，"
"<literal>UserCollectionType</literal> 和 <literal>UserVersionType</literal> "
"接口为更特殊的使用方式提供支持。"

#. Tag: para
#: basic_mapping.xml:4313
#, no-c-format
msgid ""
"You can even supply parameters to a <literal>UserType</literal> in the "
"mapping file. To do this, your <literal>UserType</literal> must implement "
"the <literal>org.hibernate.usertype.ParameterizedType</literal> interface. "
"To supply parameters to your custom type, you can use the <literal>&lt;"
"type&gt;</literal> element in your mapping files."
msgstr ""
"你甚至可以在一个映射文件中提供参数给一个 <literal>UserType</literal>。 为了这"
"样做，你的 <literal>UserType</literal> 必须实现 <literal>org.hibernate."
"usertype.ParameterizedType</literal> 接口。为了给自定义类型提供参数，你可以在"
"映射文件中使用 <literal>&lt;type&gt;</literal> 元素。 "

#. Tag: programlisting
#: basic_mapping.xml:4320
#, fuzzy, no-c-format
msgid ""
"&lt;property name=\"priority\"&gt;\n"
"    &lt;type name=\"com.mycompany.usertypes.DefaultValueIntegerType\"&gt;\n"
"        &lt;param name=\"default\"&gt;0&lt;/param&gt;\n"
"    &lt;/type&gt;\n"
"&lt;/property&gt;"
msgstr ""
"&lt;property name=\"priority\"&gt;\n"
"    &lt;type name=\"com.mycompany.usertypes.DefaultValueIntegerType\"&gt;\n"
"        &lt;param name=\"default\"&gt;0&lt;/param&gt;\n"
"    &lt;/type&gt;\n"
"&lt;/property&gt;"

#. Tag: para
#: basic_mapping.xml:4322
#, no-c-format
msgid ""
"The <literal>UserType</literal> can now retrieve the value for the parameter "
"named <literal>default</literal> from the <literal>Properties</literal> "
"object passed to it."
msgstr ""
"现在，<literal>UserType</literal> 可以从传入的 <literal>Properties</literal> "
"对象中得到 <literal>default</literal> 参数的值。"

#. Tag: para
#: basic_mapping.xml:4326
#, no-c-format
msgid ""
"If you regularly use a certain <literal>UserType</literal>, it is useful to "
"define a shorter name for it. You can do this using the <literal>&lt;"
"typedef&gt;</literal> element. Typedefs assign a name to a custom type, and "
"can also contain a list of default parameter values if the type is "
"parameterized."
msgstr ""
"如果你非常频繁地使用某一 <literal>UserType</literal>，可以为他定义一个简称。"
"这可以通过使用 <literal>&lt;typedef&gt;</literal> 元素来实现。Typedefs 为一自"
"定义类型赋予一个名称，并且如果此类型是参数化的，还可以包含一系列默认的参数"
"值。 "

#. Tag: programlisting
#: basic_mapping.xml:4332
#, fuzzy, no-c-format
msgid ""
"&lt;typedef class=\"com.mycompany.usertypes.DefaultValueIntegerType\" name="
"\"default_zero\"&gt;\n"
"    &lt;param name=\"default\"&gt;0&lt;/param&gt;\n"
"&lt;/typedef&gt;"
msgstr ""
"&lt;typedef class=\"com.mycompany.usertypes.DefaultValueIntegerType\" name="
"\"default_zero\"&gt;\n"
"    &lt;param name=\"default\"&gt;0&lt;/param&gt;\n"
"&lt;/typedef&gt;"

#. Tag: programlisting
#: basic_mapping.xml:4334
#, fuzzy, no-c-format
msgid "&lt;property name=\"priority\" type=\"default_zero\"/&gt;"
msgstr "&lt;property name=\"priority\" type=\"default_zero\"/&gt;"

#. Tag: para
#: basic_mapping.xml:4336
#, no-c-format
msgid ""
"It is also possible to override the parameters supplied in a typedef on a "
"case-by-case basis by using type parameters on the property mapping."
msgstr ""
"也可以根据具体案例通过属性映射中的类型参数覆盖在 typedef 中提供的参数。"

#. Tag: para
#: basic_mapping.xml:4340
#, no-c-format
msgid ""
"Even though Hibernate's rich range of built-in types and support for "
"components means you will rarely need to use a custom type, it is considered "
"good practice to use custom types for non-entity classes that occur "
"frequently in your application. For example, a <literal>MonetaryAmount</"
"literal> class is a good candidate for a <literal>CompositeUserType</"
"literal>, even though it could be mapped as a component. One reason for this "
"is abstraction. With a custom type, your mapping documents would be "
"protected against changes to the way monetary values are represented."
msgstr ""
"尽管 Hibernate 内建的丰富的类型和对组件的支持意味着你可能很少 <emphasis>需要"
"</emphasis>使用自定义类型。不过，为那些在你的应用中经常出现的(非实体)类使用自"
"定义类型也是一个好方法。例如，一个 <literal>MonetaryAmount</literal> 类使用 "
"<literal>CompositeUserType</literal> 来映射是不错的选择，虽然他可以很容易地被"
"映射成组件。这样做的动机之一是抽象。使用自定义类型，以后假若你改变表示金额的"
"方法时，它可以保证映射文件不需要修改。 "

#. Tag: title
#: basic_mapping.xml:4353
#, no-c-format
msgid "Mapping a class more than once"
msgstr "多次映射同一个类"

#. Tag: para
#: basic_mapping.xml:4355
#, no-c-format
msgid ""
"It is possible to provide more than one mapping for a particular persistent "
"class. In this case, you must specify an <emphasis>entity name</emphasis> to "
"disambiguate between instances of the two mapped entities. By default, the "
"entity name is the same as the class name. Hibernate lets you specify the "
"entity name when working with persistent objects, when writing queries, or "
"when mapping associations to the named entity."
msgstr ""
"对特定的持久化类，映射多次是允许的。这种情形下，你必须指定 <emphasis>entity "
"name</emphasis> 来区别不同映射实体的对象实例。（默认情况下，实体名字和类名是"
"相同的。） Hibernate 在操作持久化对象、编写查询条件，或者把关联映射到指定实体"
"时，允许你指定这个 entity name（实体名字）。 "

#. Tag: programlisting
#: basic_mapping.xml:4363
#, fuzzy, no-c-format
msgid ""
"&lt;class name=\"Contract\" table=\"Contracts\"\n"
"        entity-name=\"CurrentContract\"&gt;\n"
"    ...\n"
"    &lt;set name=\"history\" inverse=\"true\"\n"
"            order-by=\"effectiveEndDate desc\"&gt;\n"
"        &lt;key column=\"currentContractId\"/&gt;\n"
"        &lt;one-to-many entity-name=\"HistoricalContract\"/&gt;\n"
"    &lt;/set&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"Contract\" table=\"ContractHistory\"\n"
"        entity-name=\"HistoricalContract\"&gt;\n"
"    ...\n"
"    &lt;many-to-one name=\"currentContract\"\n"
"            column=\"currentContractId\"\n"
"            entity-name=\"CurrentContract\"/&gt;\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"Contract\" table=\"Contracts\" \n"
"        entity-name=\"CurrentContract\"&gt;\n"
"    ...\n"
"    &lt;set name=\"history\" inverse=\"true\" \n"
"            order-by=\"effectiveEndDate desc\"&gt;\n"
"        &lt;key column=\"currentContractId\"/&gt;\n"
"        &lt;one-to-many entity-name=\"HistoricalContract\"/&gt;\n"
"    &lt;/set&gt;\n"
"&lt;/class&gt;\n"
"\n"
"&lt;class name=\"Contract\" table=\"ContractHistory\" \n"
"        entity-name=\"HistoricalContract\"&gt;\n"
"    ...\n"
"    &lt;many-to-one name=\"currentContract\" \n"
"            column=\"currentContractId\" \n"
"            entity-name=\"CurrentContract\"/&gt;\n"
"&lt;/class&gt;"

#. Tag: para
#: basic_mapping.xml:4365
#, no-c-format
msgid ""
"Associations are now specified using <literal>entity-name</literal> instead "
"of <literal>class</literal>."
msgstr ""
"注意这里关联是如何用 <literal>entity-name</literal> 来代替 <literal>class</"
"literal> 的。 "

#. Tag: para
#: basic_mapping.xml:4369 basic_mapping.xml:4497
#, no-c-format
msgid "This feature is not supported in Annotations"
msgstr ""

#. Tag: title
#: basic_mapping.xml:4374
#, no-c-format
msgid "SQL quoted identifiers"
msgstr "SQL 中引号包围的标识符"

#. Tag: para
#: basic_mapping.xml:4376
#, no-c-format
msgid ""
"You can force Hibernate to quote an identifier in the generated SQL by "
"enclosing the table or column name in backticks in the mapping document. "
"Hibernate will use the correct quotation style for the SQL <literal>Dialect</"
"literal>. This is usually double quotes, but the SQL Server uses brackets "
"and MySQL uses backticks."
msgstr ""
"你可通过在映射文档中使用反向引号（`）把表名或者字段名包围起来，以强制 "
"Hibernate 在生成的 SQL 中把标识符用引号包围起来。Hibernate 会使用相应的 "
"SQL<literal>Dialect</literal>（方言）来使用正确的引号风格(通常是双引号，但是"
"在 SQL Server 中是括号，MySQL 中是反向引号)。 "

#. Tag: programlisting
#: basic_mapping.xml:4382
#, fuzzy, no-c-format
msgid ""
"@Entity @Table(name=\"`Line Item`\")\n"
"class LineItem {\n"
"   @id @Column(name=\"`Item Id`\") Integer id;\n"
"   @Column(name=\"`Item #`\") int itemNumber\n"
"}\n"
"\n"
"&lt;class name=\"LineItem\" table=\"`Line Item`\"&gt;\n"
"    &lt;id name=\"id\" column=\"`Item Id`\"/&gt;&lt;generator class="
"\"assigned\"/&gt;&lt;/id&gt;\n"
"    &lt;property name=\"itemNumber\" column=\"`Item #`\"/&gt;\n"
"    ...\n"
"&lt;/class&gt;"
msgstr ""
"&lt;class name=\"LineItem\" table=\"`Line Item`\"&gt;\n"
"    &lt;id name=\"id\" column=\"`Item Id`\"/&gt;&lt;generator class="
"\"assigned\"/&gt;&lt;/id&gt;\n"
"    &lt;property name=\"itemNumber\" column=\"`Item #`\"/&gt;\n"
"    ...\n"
"&lt;/class&gt;"

#. Tag: title
#: basic_mapping.xml:4386
#, no-c-format
msgid "Generated properties"
msgstr "数据库生成属性（Generated Properties） "

#. Tag: para
#: basic_mapping.xml:4388
#, no-c-format
msgid ""
"Generated properties are properties that have their values generated by the "
"database. Typically, Hibernate applications needed to <literal>refresh</"
"literal> objects that contain any properties for which the database was "
"generating values. Marking properties as generated, however, lets the "
"application delegate this responsibility to Hibernate. When Hibernate issues "
"an SQL INSERT or UPDATE for an entity that has defined generated properties, "
"it immediately issues a select afterwards to retrieve the generated values."
msgstr ""
"Generated properties 指的是其值由数据库生成的属性。一般来说，如果对象有任何属"
"性由数据库生成值，Hibernate 应用程序需要进行<literal>刷新（refresh）</"
"literal>。但如果把属性标明为 generated，就可以转由 Hibernate 来负责这个动作。"
"实际上。对定义了 generated properties 的实体,每当 Hibernate 执行一条 SQL "
"INSERT 或者 UPDATE 语句，会立刻执行一条 select 来获得生成的值。 "

#. Tag: para
#: basic_mapping.xml:4397
#, no-c-format
msgid ""
"Properties marked as generated must additionally be non-insertable and non-"
"updateable. Only <link linkend=\"mapping-declaration-version\">versions</"
"link>, <link linkend=\"mapping-declaration-timestamp\">timestamps</link>, "
"and <link linkend=\"mapping-declaration-property\">simple properties</link>, "
"can be marked as generated."
msgstr ""
"被标明为 generated 的属性还必须是 non-insertable 和 non-updateable 的。只有 "
"<link linkend=\"mapping-declaration-version\">versions</link>、<link linkend="
"\"mapping-declaration-timestamp\">timestamps</link> 和 <link linkend="
"\"mapping-declaration-property\">simple properties</link> 可以被标明为 "
"generated。 "

#. Tag: para
#: basic_mapping.xml:4404
#, no-c-format
msgid ""
"<literal>never</literal> (the default): the given property value is not "
"generated within the database."
msgstr "<literal>never</literal>（默认）标明此属性值不是从数据库中生成。 "

#. Tag: para
#: basic_mapping.xml:4407
#, no-c-format
msgid ""
"<literal>insert</literal>: the given property value is generated on insert, "
"but is not regenerated on subsequent updates. Properties like created-date "
"fall into this category. Even though <link linkend=\"mapping-declaration-"
"version\">version</link> and <link linkend=\"mapping-declaration-timestamp"
"\">timestamp</link> properties can be marked as generated, this option is "
"not available."
msgstr ""
"<literal>insert</literal> — 标明此属性值在 insert 的时候生成，但是不会在随后"
"的 update 时重新生成。比如说创建日期就归属于这类。注意虽然 <link linkend="
"\"mapping-declaration-version\">version</link> 和 <link linkend=\"mapping-"
"declaration-timestamp\">timestamp</link> 属性可以被标注为 generated，但是不适"
"用这个选项。"

#. Tag: para
#: basic_mapping.xml:4414
#, no-c-format
msgid ""
"<literal>always</literal>: the property value is generated both on insert "
"and on update."
msgstr ""
"<literal>always</literal> — 标明此属性值在 insert 和 update 时都会被生成。 "

#. Tag: para
#: basic_mapping.xml:4417
#, no-c-format
msgid "To mark a property as generated, use <classname>@Generated</classname>."
msgstr ""

#. Tag: title
#: basic_mapping.xml:4422
#, fuzzy, no-c-format
msgid "Column transformers: read and write expressions"
msgstr "字段的读写表达式"

#. Tag: para
#: basic_mapping.xml:4424
#, fuzzy, no-c-format
msgid ""
"Hibernate allows you to customize the SQL it uses to read and write the "
"values of columns mapped to <link linkend=\"mapping-declaration-property"
"\">simple properties</link>. For example, if your database provides a set of "
"data encryption functions, you can invoke them for individual columns like "
"this:"
msgstr ""
"Hibernate 允许你自定义 SQL 以读写映射<link linkend=\"mapping-declaration-"
"property\">简单属性</link>的字段值。例如，如果你的数据库提供了一套数据加密方"
"法，你可以在单个字段上调用它们：<programlisting role=\"XML\">&lt;property "
"name=\"creditCardNumber\"&gt; &lt;column name=\"credit_card_num\" read="
"\"decrypt(credit_card_num)\" write=\"encrypt(?)\"/&gt; &lt;/property&gt;</"
"programlisting>"

#. Tag: programlisting
#: basic_mapping.xml:4430
#, no-c-format
msgid ""
"@Entity\n"
"class CreditCard {\n"
"   @Column(name=\"credit_card_num\")\n"
"   @ColumnTransformer(\n"
"      read=\"decrypt(credit_card_num)\", \n"
"      write=\"encrypt(?)\")\n"
"   public String getCreditCardNumber() { return creditCardNumber; }\n"
"   public void setCreditCardNumber(String number) { this.creditCardNumber = "
"number; }\n"
"   private String creditCardNumber;\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4432
#, no-c-format
msgid "or in XML"
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4434
#, no-c-format
msgid ""
"&lt;property name=\"creditCardNumber\"&gt;\n"
"        &lt;column \n"
"          name=\"credit_card_num\"\n"
"          read=\"decrypt(credit_card_num)\"\n"
"          write=\"encrypt(?)\"/&gt;\n"
"&lt;/property&gt;"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4437
#, no-c-format
msgid ""
"You can use the plural form <classname>@ColumnTransformers</classname> if "
"more than one columns need to define either of these rules."
msgstr ""

#. Tag: para
#: basic_mapping.xml:4442
#, no-c-format
msgid ""
"If a property uses more that one column, you must use the "
"<literal>forColumn</literal> attribute to specify which column, the "
"expressions are targeting."
msgstr ""

#. Tag: programlisting
#: basic_mapping.xml:4446
#, no-c-format
msgid ""
"@Entity\n"
"class User {\n"
"   @Type(type=\"com.acme.type.CreditCardType\")\n"
"   @Columns( {\n"
"      @Column(name=\"credit_card_num\"),\n"
"      @Column(name=\"exp_date\") } )\n"
"   @ColumnTransformer(\n"
"      forColumn=\"credit_card_num\", \n"
"      read=\"decrypt(credit_card_num)\", \n"
"      write=\"encrypt(?)\")\n"
"   public CreditCard getCreditCard() { return creditCard; }\n"
"   public void setCreditCard(CreditCard card) { this.creditCard = card; }\n"
"   private CreditCard creditCard;\n"
"}"
msgstr ""

#. Tag: para
#: basic_mapping.xml:4448
#, no-c-format
msgid ""
"Hibernate applies the custom expressions automatically whenever the property "
"is referenced in a query. This functionality is similar to a derived-"
"property <literal>formula</literal> with two differences:"
msgstr ""
"每当属性在查询里被引用时，Hibernate 都自动应用自定义的表达式。这种功能和 "
"derived-property <literal>formula</literal> 相似，但有两个不同的地方："

#. Tag: para
#: basic_mapping.xml:4453
#, no-c-format
msgid ""
"The property is backed by one or more columns that are exported as part of "
"automatic schema generation."
msgstr "属性由一个或多个属性组成，它作为自动模式生成的一部分导出。"

#. Tag: para
#: basic_mapping.xml:4458
#, no-c-format
msgid "The property is read-write, not read-only."
msgstr "属性是可读写的，非只读的。"

#. Tag: para
#: basic_mapping.xml:4462
#, no-c-format
msgid ""
"The <literal>write</literal> expression, if specified, must contain exactly "
"one '?' placeholder for the value."
msgstr ""
"如果指定了 <literal>write</literal> 表达式，它必须只包含一个“?”占位符。"

#. Tag: title
#: basic_mapping.xml:4467
#, no-c-format
msgid "Auxiliary database objects"
msgstr "辅助数据库对象（Auxiliary Database Objects） "

#. Tag: para
#: basic_mapping.xml:4469
#, no-c-format
msgid ""
"Auxiliary database objects allow for the CREATE and DROP of arbitrary "
"database objects. In conjunction with Hibernate's schema evolution tools, "
"they have the ability to fully define a user schema within the Hibernate "
"mapping files. Although designed specifically for creating and dropping "
"things like triggers or stored procedures, any SQL command that can be run "
"via a <literal>java.sql.Statement.execute()</literal> method is valid (for "
"example, ALTERs, INSERTS, etc.). There are essentially two modes for "
"defining auxiliary database objects:"
msgstr ""
"允许 CREATE 和 DROP 任意数据库对象，与 Hibernate 的 schema 交互工具组合起来，"
"可以提供在 Hibernate 映射文件中完全定义用户 schema 的能力。虽然这是为创建和销"
"毁 trigger（触发器）或stored procedure（存储过程）等特别设计的，实际上任何可"
"以在 <literal>java.sql.Statement.execute()</literal> 方法中执行的 SQL 命令都"
"可以在此使用（比如ALTER, INSERT，等等）。本质上有两种模式来定义辅助数据库对"
"象... "

#. Tag: para
#: basic_mapping.xml:4479
#, no-c-format
msgid ""
"The first mode is to explicitly list the CREATE and DROP commands in the "
"mapping file:"
msgstr "第一种模式是在映射文件中显式声明 CREATE 和 DROP 命令： "

#. Tag: programlisting
#: basic_mapping.xml:4482
#, fuzzy, no-c-format
msgid ""
"&lt;hibernate-mapping&gt;\n"
"    ...\n"
"    &lt;database-object&gt;\n"
"        &lt;create&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;\n"
"        &lt;drop&gt;DROP TRIGGER my_trigger&lt;/drop&gt;\n"
"    &lt;/database-object&gt;\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""
"&lt;hibernate-mapping&gt;\n"
"    ...\n"
"    &lt;database-object&gt;\n"
"        &lt;create&gt;CREATE TRIGGER my_trigger ...&lt;/create&gt;\n"
"        &lt;drop&gt;DROP TRIGGER my_trigger&lt;/drop&gt;\n"
"    &lt;/database-object&gt;\n"
"&lt;/hibernate-mapping&gt;"

#. Tag: para
#: basic_mapping.xml:4484
#, no-c-format
msgid ""
"The second mode is to supply a custom class that constructs the CREATE and "
"DROP commands. This custom class must implement the <literal>org.hibernate."
"mapping.AuxiliaryDatabaseObject</literal> interface."
msgstr ""
"第二种模式是提供一个类，这个类知道如何组织 CREATE 和 DROP 命令。这个特别类必"
"须实现 <literal>org.hibernate.mapping.AuxiliaryDatabaseObject</literal> 接"
"口。 "

#. Tag: programlisting
#: basic_mapping.xml:4489
#, fuzzy, no-c-format
msgid ""
"&lt;hibernate-mapping&gt;\n"
"    ...\n"
"    &lt;database-object&gt;\n"
"        &lt;definition class=\"MyTriggerDefinition\"/&gt;\n"
"    &lt;/database-object&gt;\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""
"&lt;hibernate-mapping&gt;\n"
"    ...\n"
"    &lt;database-object&gt;\n"
"        &lt;definition class=\"MyTriggerDefinition\"/&gt;\n"
"    &lt;/database-object&gt;\n"
"&lt;/hibernate-mapping&gt;"

#. Tag: para
#: basic_mapping.xml:4491
#, no-c-format
msgid ""
"Additionally, these database objects can be optionally scoped so that they "
"only apply when certain dialects are used."
msgstr "还有，这些数据库对象可以特别指定为仅在特定的方言中才使用。 "

#. Tag: programlisting
#: basic_mapping.xml:4494
#, fuzzy, no-c-format
msgid ""
"&lt;hibernate-mapping&gt;\n"
"    ...\n"
"    &lt;database-object&gt;\n"
"        &lt;definition class=\"MyTriggerDefinition\"/&gt;\n"
"        &lt;dialect-scope name=\"org.hibernate.dialect.Oracle9iDialect\"/"
"&gt;\n"
"        &lt;dialect-scope name=\"org.hibernate.dialect.Oracle10gDialect\"/"
"&gt;\n"
"    &lt;/database-object&gt;\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""
"&lt;hibernate-mapping&gt;\n"
"    ...\n"
"    &lt;database-object&gt;\n"
"        &lt;definition class=\"MyTriggerDefinition\"/&gt;\n"
"        &lt;dialect-scope name=\"org.hibernate.dialect.Oracle9Dialect\"/"
"&gt;\n"
"        &lt;dialect-scope name=\"org.hibernate.dialect.OracleDialect\"/&gt;\n"
"    &lt;/database-object&gt;\n"
"&lt;/hibernate-mapping&gt;"

#~ msgid ""
#~ "The <literal>force</literal> attribute is only useful if the table "
#~ "contains rows with \"extra\" discriminator values that are not mapped to "
#~ "a persistent class. This will not usually be the case."
#~ msgstr ""
#~ "<literal>force</literal> 属性仅仅在这种情况下有用的：表中包含没有被映射到"
#~ "持久化类的附加辨别器值。这种情况不会经常遇到。 "

#~ msgid "Class"
#~ msgstr "类"

#~ msgid ""
#~ "Use of <literal>select-before-update</literal> will usually decrease "
#~ "performance. It is useful to prevent a database update trigger being "
#~ "called unnecessarily if you reattach a graph of detached instances to a "
#~ "<literal>Session</literal>."
#~ msgstr ""
#~ "使用 <literal>select-before-update</literal> 通常会降低性能。如果你重新连"
#~ "接一个脱管（detached）对象实例 到一个 <literal>Session</literal> 中时，它"
#~ "可以防止数据库不必要的触发 update。这就很有用了。"

#~ msgid "id"
#~ msgstr "id"

#~ msgid "Generator"
#~ msgstr "Generator"

#~ msgid "<literal>increment</literal>"
#~ msgstr "<literal>increment</literal>"

#~ msgid "<literal>identity</literal>"
#~ msgstr "<literal>identity</literal>"

#~ msgid "<literal>sequence</literal>"
#~ msgstr "<literal>sequence</literal>"

#~ msgid "<literal>seqhilo</literal>"
#~ msgstr "<literal>seqhilo</literal>"

#~ msgid "<literal>uuid</literal>"
#~ msgstr "<literal>uuid</literal>"

#~ msgid ""
#~ "uses a 128-bit UUID algorithm to generate identifiers of type string that "
#~ "are unique within a network (the IP address is used). The UUID is encoded "
#~ "as a string of 32 hexadecimal digits in length."
#~ msgstr ""
#~ "用一个 128-bit 的 UUID 算法生成字符串类型的标识符，这在一个网络中是唯一的"
#~ "（使用了 IP 地址）。UUID 被编码为一个 32 位 16 进制数字的字符串。 "

#~ msgid "<literal>guid</literal>"
#~ msgstr "<literal>guid</literal>"

#~ msgid "<literal>native</literal>"
#~ msgstr "<literal>native</literal>"

#~ msgid "<literal>select</literal>"
#~ msgstr "<literal>select</literal>"

#~ msgid "<literal>foreign</literal>"
#~ msgstr "<literal>foreign</literal>"

#~ msgid ""
#~ "<literal>optimizer</literal> (optional - defaults to <literal>none</"
#~ "literal>): See <xref linkend=\"mapping-declaration-id-enhanced-optimizers"
#~ "\" />"
#~ msgstr ""
#~ "<literal>optimizer</literal>（可选 — 默认是<literal>none</literal>）：请参"
#~ "考 <xref linkend=\"mapping-declaration-id-enhanced-optimizers\" />。"

#~ msgid "composite-id"
#~ msgstr "composite-id"

#~ msgid ""
#~ "A table with a composite key can be mapped with multiple properties of "
#~ "the class as identifier properties. The <literal>&lt;composite-id&gt;</"
#~ "literal> element accepts <literal>&lt;key-property&gt;</literal> property "
#~ "mappings and <literal>&lt;key-many-to-one&gt;</literal> mappings as child "
#~ "elements."
#~ msgstr ""
#~ "如果表使用联合主键，你可以映射类的多个属性为标识符属性。<literal>&lt;"
#~ "composite-id&gt;</literal> 元素接受 <literal>&lt;key-property&gt;</"
#~ "literal> 属性映射和 <literal>&lt;key-many-to-one&gt;</literal> 属性映射作"
#~ "为子元素。 "

#~ msgid ""
#~ "The persistent class <emphasis>must</emphasis> override <literal>equals()"
#~ "</literal> and <literal>hashCode()</literal> to implement composite "
#~ "identifier equality. It must also implement <literal>Serializable</"
#~ "literal>."
#~ msgstr ""
#~ "你的持久化类<emphasis>必须</emphasis>覆盖 <literal>equals()</literal> 和 "
#~ "<literal>hashCode()</literal> 方法，来实现组合的标识符的相等判断。实现 "
#~ "<literal>Serializable</literal> 接口也是必须的。"

#~ msgid ""
#~ "Unfortunately, this approach means that a persistent object is its own "
#~ "identifier. There is no convenient \"handle\" other than the object "
#~ "itself. You must instantiate an instance of the persistent class itself "
#~ "and populate its identifier properties before you can <literal>load()</"
#~ "literal> the persistent state associated with a composite key. We call "
#~ "this approach an <emphasis>embedded</emphasis> composite identifier, and "
#~ "discourage it for serious applications."
#~ msgstr ""
#~ "不幸的是，这种组合关键字的方法意味着一个持久化类是它自己的标识。除了对象自"
#~ "己之外，没有什么方便的“把手”可用。你必须初始化持久化类的实例，填充它的标识"
#~ "符属性，再 <literal>load()</literal> 组合关键字关联的持久状态。我们把这种"
#~ "方法称为 <emphasis>embedded（嵌入式）</emphasis>的组合标识符，在重要的应用"
#~ "中不鼓励使用这种用法。 "

#~ msgid ""
#~ "A second approach is what we call a <emphasis>mapped</emphasis> composite "
#~ "identifier, where the identifier properties named inside the <literal>&lt;"
#~ "composite-id&gt;</literal> element are duplicated on both the persistent "
#~ "class and a separate identifier class."
#~ msgstr ""
#~ "第二种方法我们称为 <emphasis>mapped（映射式）</emphasis>组合标识符"
#~ "（mapped composite identifier），<literal>&lt;composite-id&gt;</literal> "
#~ "元素中列出的标识属性不但在持久化类出现，还形成一个独立的标识符类。"

#~ msgid ""
#~ "In this example, both the composite identifier class, "
#~ "<literal>MedicareId</literal>, and the entity class itself have "
#~ "properties named <literal>medicareNumber</literal> and "
#~ "<literal>dependent</literal>. The identifier class must override "
#~ "<literal>equals()</literal> and <literal>hashCode()</literal> and "
#~ "implement <literal>Serializable</literal>. The main disadvantage of this "
#~ "approach is code duplication."
#~ msgstr ""
#~ "在这个例子中，组合标识符类 <literal>MedicareId</literal> 和实体类都含有 "
#~ "<literal>medicareNumber</literal> 和 <literal>dependent</literal> 属性。标"
#~ "识符类必须重载 <literal>equals()</literal> 和 <literal>hashCode()</"
#~ "literal> 并且实现 <literal>Serializable</literal> 接口。这种方法的缺点是出"
#~ "现了明显的代码重复。"

#~ msgid ""
#~ "The following attributes are used to specify a mapped composite "
#~ "identifier:"
#~ msgstr "下面列出的属性是用来指定一个映射式组合标识符的："

#~ msgid ""
#~ "<literal>mapped</literal> (optional - defaults to <literal>false</"
#~ "literal>): indicates that a mapped composite identifier is used, and that "
#~ "the contained property mappings refer to both the entity class and the "
#~ "composite identifier class."
#~ msgstr ""
#~ "<literal>mapped</literal>（可选，默认为 <literal>false</literal>）：指明使"
#~ "用一个映射式组合标识符，其包含的属性映射同时在实体类和组合标识符类中出"
#~ "现。 "

#~ msgid ""
#~ "<literal>class</literal> (optional - but required for a mapped composite "
#~ "identifier): the class used as a composite identifier."
#~ msgstr ""
#~ "<literal>class</literal>（可选,但对映射式组合标识符必须指定）：作为组合标"
#~ "识符类使用的类名。"

#~ msgid ""
#~ "We will describe a third, even more convenient approach, where the "
#~ "composite identifier is implemented as a component class in <xref linkend="
#~ "\"components-compositeid\" />. The attributes described below apply only "
#~ "to this alternative approach:"
#~ msgstr ""
#~ "在 <xref linkend=\"components-compositeid\"/> 一节中,我们会描述第三种方式,"
#~ "那就是把组合标识符实现为一个组件（component）类,这是更方便的方法。下面的属"
#~ "性仅对第三种方法有效： "

#~ msgid ""
#~ "<literal>name</literal> (optional - required for this approach): a "
#~ "property of component type that holds the composite identifier. Please "
#~ "see chapter 9 for more information."
#~ msgstr ""
#~ "<literal>name</literal>（可选,但对这种方法而言必须）：包含此组件标识符的组"
#~ "件类型的名字（参阅第 9 章）。"

#~ msgid ""
#~ "<literal>class</literal> (optional - defaults to the property type "
#~ "determined by reflection): the component class used as a composite "
#~ "identifier. Please see the next section for more information."
#~ msgstr ""
#~ "<literal>class</literal>（可选 — 默认会用反射来自动判定属性类型 ）：用来作"
#~ "为组合标识符的组件类的类名（参阅下一节）。 "

#~ msgid ""
#~ "The third approach, an <emphasis>identifier component</emphasis>, is "
#~ "recommended for almost all applications."
#~ msgstr ""
#~ "第三种方式，被称为 <emphasis>identifier component（标识符组件）</emphasis>"
#~ "是我们对几乎所有应用都推荐使用的方式。 "

#~ msgid "Version (optional)"
#~ msgstr "版本（version）（可选） "

#~ msgid ""
#~ "The <literal>&lt;version&gt;</literal> element is optional and indicates "
#~ "that the table contains versioned data. This is particularly useful if "
#~ "you plan to use <emphasis>long transactions</emphasis>. See below for "
#~ "more information:"
#~ msgstr ""
#~ "<literal>&lt;version&gt;</literal> 元素是可选的，表明表中包含附带版本信息"
#~ "的数据。这在你准备使用<emphasis> 长事务（long transactions）</emphasis>的"
#~ "时候特别有用。下面是更多信息："

#~ msgid ""
#~ "Version numbers can be of Hibernate type <literal>long</literal>, "
#~ "<literal>integer</literal>, <literal>short</literal>, <literal>timestamp</"
#~ "literal> or <literal>calendar</literal>."
#~ msgstr ""
#~ "版本号必须是以下类型：<literal>long</literal>、<literal>integer</"
#~ "literal>、<literal>short</literal>、<literal>timestamp</literal> 或者 "
#~ "<literal>calendar</literal>。"

#~ msgid "Many-to-one"
#~ msgstr "多对一（many-to-one） "

#~ msgid ""
#~ "An ordinary association to another persistent class is declared using a "
#~ "<literal>many-to-one</literal> element. The relational model is a many-to-"
#~ "one association; a foreign key in one table is referencing the primary "
#~ "key column(s) of the target table."
#~ msgstr ""
#~ "通过 <literal>many-to-one</literal> 元素,可以定义一种常见的与另一个持久化"
#~ "类的关联。这种关系模型是多对一关联（实际上是一个对象引用－译注）：这个表的"
#~ "一个外键引用目标表的主键字段。 "

#~ msgid "One-to-one"
#~ msgstr "一对一 "

#~ msgid "There are two varieties of one-to-one associations:"
#~ msgstr "有两种不同的一对一关联： "

#~ msgid "primary key associations"
#~ msgstr "主键关联"

#~ msgid ""
#~ "Alternatively, a foreign key with a unique constraint, from "
#~ "<literal>Employee</literal> to <literal>Person</literal>, can be "
#~ "expressed as:"
#~ msgstr ""
#~ "另一种方式是一个外键和一个惟一关键字对应，上面的 <literal>Employee</"
#~ "literal> 和  <literal>Person</literal> 的例子，如果使用这种关联方式，可以"
#~ "表达成： "

#~ msgid ""
#~ "This association can be made bidirectional by adding the following to the "
#~ "<literal>Person</literal> mapping:"
#~ msgstr ""
#~ "如果在 <literal>Person</literal> 的映射加入下面几句，这种关联就是双向的： "

#~ msgid "Component and dynamic-component"
#~ msgstr "组件（component）和动态组件（dynamic-component） "

#~ msgid "Subclass"
#~ msgstr "子类（subclass） "

#~ msgid ""
#~ "A discriminator column is not required for this mapping strategy. Each "
#~ "subclass must, however, declare a table column holding the object "
#~ "identifier using the <literal>&lt;key&gt;</literal> element. The mapping "
#~ "at the start of the chapter would then be re-written as:"
#~ msgstr ""
#~ "这种映射策略不需要指定辨别标志（discriminator）字段。但是，每一个子类都必"
#~ "须使用 <literal>&lt;key&gt;</literal> 元素指定一个表字段来持有对象的标识"
#~ "符。本章开始的映射可以被用如下方式重写： "

#~ msgid "Union-subclass"
#~ msgstr "联合子类（union-subclass） "

#~ msgid "Join"
#~ msgstr "连接（join） "

#~ msgid ""
#~ "Using the <literal>&lt;join&gt;</literal> element, it is possible to map "
#~ "properties of one class to several tables that have a one-to-one "
#~ "relationship. For example:"
#~ msgstr ""
#~ "使用 <literal>&lt;join&gt;</literal> 元素，假若在表之间存在一对一关联,可以"
#~ "将一个类的属性映射到多张表中。 "

#~ msgid "Key"
#~ msgstr "Key"

#~ msgid "Any"
#~ msgstr "Any"

#~ msgid "<literal>class</literal>"
#~ msgstr "<literal>class</literal>"

#~ msgid "<literal>binary</literal>"
#~ msgstr "<literal>binary</literal>"

#~ msgid "<literal>text</literal>"
#~ msgstr "<literal>text</literal>"

#~ msgid "<literal>clob, blob</literal>"
#~ msgstr "<literal>clob, blob</literal>"

#~ msgid ""
#~ "XML does not suit all users so there are some alternative ways to define "
#~ "O/R mapping metadata in Hibernate."
#~ msgstr ""
#~ "XML 并不适用于所有人, 因此有其他定义 Hibernate O/R 映射元数据（metadata）"
#~ "的方法。 "

#~ msgid "Using XDoclet markup"
#~ msgstr "使用 XDoclet 标记"

#~ msgid ""
#~ "Many Hibernate users prefer to embed mapping information directly in "
#~ "sourcecode using XDoclet <literal>@hibernate.tags</literal>. We do not "
#~ "cover this approach in this reference guide since it is considered part "
#~ "of XDoclet. However, we include the following example of the "
#~ "<literal>Cat</literal> class with XDoclet mappings:"
#~ msgstr ""
#~ "很多 Hibernate 使用者更喜欢使用 XDoclet<literal>@hibernate.tags</literal> "
#~ "将映射信息直接嵌入到源代码中。我们不会在本文档中涉及这个方法，因为严格说"
#~ "来，这属于 XDoclet 的一部分。然而，我们包含了如下使用 XDoclet 映射的 "
#~ "<literal>Cat</literal> 类的例子。 "

#~ msgid ""
#~ "See the Hibernate website for more examples of XDoclet and Hibernate."
#~ msgstr "参考 Hibernate 网站更多的 Xdoclet 和 Hibernate 的例子。"

#~ msgid "Using JDK 5.0 Annotations"
#~ msgstr "使用 JDK 5.0 的注解（Annotation）"

#~ msgid ""
#~ "JDK 5.0 introduced XDoclet-style annotations at the language level that "
#~ "are type-safe and checked at compile time. This mechanism is more "
#~ "powerful than XDoclet annotations and better supported by tools and IDEs. "
#~ "IntelliJ IDEA, for example, supports auto-completion and syntax "
#~ "highlighting of JDK 5.0 annotations. The new revision of the EJB "
#~ "specification (JSR-220) uses JDK 5.0 annotations as the primary metadata "
#~ "mechanism for entity beans. Hibernate3 implements the "
#~ "<literal>EntityManager</literal> of JSR-220 (the persistence API). "
#~ "Support for mapping metadata is available via the <emphasis>Hibernate "
#~ "Annotations</emphasis> package as a separate download. Both EJB3 (JSR-"
#~ "220) and Hibernate3 metadata is supported."
#~ msgstr ""
#~ "JDK 5.0 在语言级别引入了 XDoclet 风格的标注，并且是类型安全的，在编译期进"
#~ "行检查。这一机制比 XDoclet 的注解更为强大，有更好的工具和 IDE 支持。例如，"
#~ "IntelliJ IDEA，支持 JDK 5.0 注解的自动完成和语法高亮 。EJB 规范的新修订版 "
#~ "(JSR-220) 使用 JDK 5.0 的注解作为entity beans的主要元数据（metadata）机"
#~ "制。Hibernate 3 实现了JSR-220(the persistence API) 的 "
#~ "<literal>EntityManager</literal>，支持通过 <emphasis>Hibernate "
#~ "Annotations</emphasis> 包定义映射元数据。这个包作为单独的部分下载，支持 "
#~ "EJB3(JSR-220) 和 Hibernate3 的元数据。 "

#~ msgid "This is an example of a POJO class annotated as an EJB entity bean:"
#~ msgstr "这是一个被注解为 EJB entity bean 的 POJO 类的例子"

#~ msgid ""
#~ "Support for JDK 5.0 Annotations (and JSR-220) is currently under "
#~ "development. Please refer to the Hibernate Annotations module for more "
#~ "details."
#~ msgstr ""
#~ "注意：对 JDK 5.0 注解（和 JSR-220)支持的工作仍然在进行中,并未完成。更多细"
#~ "节请参阅 Hibernate Annotations 模块。 "

#~ msgid ""
#~ "<![CDATA[<?xml version=\"1.0\"?>\n"
#~ "<!DOCTYPE hibernate-mapping PUBLIC\n"
#~ "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
#~ "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\" [\n"
#~ "    <!ENTITY types SYSTEM \"classpath://your/domain/types.xml\">\n"
#~ "]>\n"
#~ "\n"
#~ "<hibernate-mapping package=\"your.domain\">\n"
#~ "    <class name=\"MyEntity\">\n"
#~ "        <id name=\"id\" type=\"my-custom-id-type\">\n"
#~ "            ...\n"
#~ "        </id>\n"
#~ "    <class>\n"
#~ "    &types;\n"
#~ "</hibernate-mapping>]]>"
#~ msgstr ""
#~ "<![CDATA[<?xml version=\"1.0\"?>\n"
#~ "<!DOCTYPE hibernate-mapping PUBLIC\n"
#~ "        \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\"\n"
#~ "        \"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd\" [\n"
#~ "    <!ENTITY types SYSTEM \"classpath://your/domain/types.xml\">\n"
#~ "]>\n"
#~ "\n"
#~ "<hibernate-mapping package=\"your.domain\">\n"
#~ "    <class name=\"MyEntity\">\n"
#~ "        <id name=\"id\" type=\"my-custom-id-type\">\n"
#~ "            ...\n"
#~ "        </id>\n"
#~ "    <class>\n"
#~ "    &types;\n"
#~ "</hibernate-mapping>]]>"

#~ msgid ""
#~ "<![CDATA[<composite-id>\n"
#~ "        <key-property name=\"medicareNumber\"/>\n"
#~ "        <key-property name=\"dependent\"/>\n"
#~ "</composite-id>]]>"
#~ msgstr ""
#~ "<![CDATA[<composite-id>\n"
#~ "        <key-property name=\"medicareNumber\"/>\n"
#~ "        <key-property name=\"dependent\"/>\n"
#~ "</composite-id>]]>"

#~ msgid ""
#~ "<![CDATA[<composite-id class=\"MedicareId\" mapped=\"true\">\n"
#~ "        <key-property name=\"medicareNumber\"/>\n"
#~ "        <key-property name=\"dependent\"/>\n"
#~ "</composite-id>]]>"
#~ msgstr ""
#~ "<![CDATA[<composite-id class=\"MedicareId\" mapped=\"true\">\n"
#~ "        <key-property name=\"medicareNumber\"/>\n"
#~ "        <key-property name=\"dependent\"/>\n"
#~ "</composite-id>]]>"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<many-to-one name=\"person\" class=\"Person\" column=\"PERSON_ID"
#~ "\" unique=\"true\"/>]]>"
#~ msgstr ""
#~ "&lt;many-to-one name=\"person\" class=\"Person\" column=\"PERSON_ID\" "
#~ "unique=\"true\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[<one-to-one name=\"employee\" class=\"Employee\" property-ref="
#~ "\"person\"/>]]>"
#~ msgstr ""
#~ "&lt;one-to-one name\"employee\" class=\"Employee\" property-ref=\"person"
#~ "\"/&gt;"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[package eg;\n"
#~ "import java.util.Set;\n"
#~ "import java.util.Date;\n"
#~ "\n"
#~ "/**\n"
#~ " * @hibernate.class\n"
#~ " *  table=\"CATS\"\n"
#~ " */\n"
#~ "public class Cat {\n"
#~ "    private Long id; // identifier\n"
#~ "    private Date birthdate;\n"
#~ "    private Cat mother;\n"
#~ "    private Set kittens\n"
#~ "    private Color color;\n"
#~ "    private char sex;\n"
#~ "    private float weight;\n"
#~ "\n"
#~ "    /*\n"
#~ "     * @hibernate.id\n"
#~ "     *  generator-class=\"native\"\n"
#~ "     *  column=\"CAT_ID\"\n"
#~ "     */\n"
#~ "    public Long getId() {\n"
#~ "        return id;\n"
#~ "    }\n"
#~ "    private void setId(Long id) {\n"
#~ "        this.id=id;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.many-to-one\n"
#~ "     *  column=\"PARENT_ID\"\n"
#~ "     */\n"
#~ "    public Cat getMother() {\n"
#~ "        return mother;\n"
#~ "    }\n"
#~ "    void setMother(Cat mother) {\n"
#~ "        this.mother = mother;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"BIRTH_DATE\"\n"
#~ "     */\n"
#~ "    public Date getBirthdate() {\n"
#~ "        return birthdate;\n"
#~ "    }\n"
#~ "    void setBirthdate(Date date) {\n"
#~ "        birthdate = date;\n"
#~ "    }\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"WEIGHT\"\n"
#~ "     */\n"
#~ "    public float getWeight() {\n"
#~ "        return weight;\n"
#~ "    }\n"
#~ "    void setWeight(float weight) {\n"
#~ "        this.weight = weight;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"COLOR\"\n"
#~ "     *  not-null=\"true\"\n"
#~ "     */\n"
#~ "    public Color getColor() {\n"
#~ "        return color;\n"
#~ "    }\n"
#~ "    void setColor(Color color) {\n"
#~ "        this.color = color;\n"
#~ "    }\n"
#~ "    /**\n"
#~ "     * @hibernate.set\n"
#~ "     *  inverse=\"true\"\n"
#~ "     *  order-by=\"BIRTH_DATE\"\n"
#~ "     * @hibernate.collection-key\n"
#~ "     *  column=\"PARENT_ID\"\n"
#~ "     * @hibernate.collection-one-to-many\n"
#~ "     */\n"
#~ "    public Set getKittens() {\n"
#~ "        return kittens;\n"
#~ "    }\n"
#~ "    void setKittens(Set kittens) {\n"
#~ "        this.kittens = kittens;\n"
#~ "    }\n"
#~ "    // addKitten not needed by Hibernate\n"
#~ "    public void addKitten(Cat kitten) {\n"
#~ "        kittens.add(kitten);\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"SEX\"\n"
#~ "     *  not-null=\"true\"\n"
#~ "     *  update=\"false\"\n"
#~ "     */\n"
#~ "    public char getSex() {\n"
#~ "        return sex;\n"
#~ "    }\n"
#~ "    void setSex(char sex) {\n"
#~ "        this.sex=sex;\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "package eg;\n"
#~ "import java.util.Set;\n"
#~ "import java.util.Date;\n"
#~ "\n"
#~ "/**\n"
#~ " * @hibernate.class\n"
#~ " *  table=\"CATS\"\n"
#~ " */\n"
#~ "public class Cat {\n"
#~ "    private Long id; // identifier\n"
#~ "    private Date birthdate;\n"
#~ "    private Cat mother;\n"
#~ "    private Set kittens\n"
#~ "    private Color color;\n"
#~ "    private char sex;\n"
#~ "    private float weight;\n"
#~ "\n"
#~ "    /*\n"
#~ "     * @hibernate.id\n"
#~ "     *  generator-class=\"native\"\n"
#~ "     *  column=\"CAT_ID\"\n"
#~ "     */\n"
#~ "    public Long getId() {\n"
#~ "        return id;\n"
#~ "    }\n"
#~ "    private void setId(Long id) {\n"
#~ "        this.id=id;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.many-to-one\n"
#~ "     *  column=\"PARENT_ID\"\n"
#~ "     */\n"
#~ "    public Cat getMother() {\n"
#~ "        return mother;\n"
#~ "    }\n"
#~ "    void setMother(Cat mother) {\n"
#~ "        this.mother = mother;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"BIRTH_DATE\"\n"
#~ "     */\n"
#~ "    public Date getBirthdate() {\n"
#~ "        return birthdate;\n"
#~ "    }\n"
#~ "    void setBirthdate(Date date) {\n"
#~ "        birthdate = date;\n"
#~ "    }\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"WEIGHT\"\n"
#~ "     */\n"
#~ "    public float getWeight() {\n"
#~ "        return weight;\n"
#~ "    }\n"
#~ "    void setWeight(float weight) {\n"
#~ "        this.weight = weight;\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"COLOR\"\n"
#~ "     *  not-null=\"true\"\n"
#~ "     */\n"
#~ "    public Color getColor() {\n"
#~ "        return color;\n"
#~ "    }\n"
#~ "    void setColor(Color color) {\n"
#~ "        this.color = color;\n"
#~ "    }\n"
#~ "    /**\n"
#~ "     * @hibernate.set\n"
#~ "     *  inverse=\"true\"\n"
#~ "     *  order-by=\"BIRTH_DATE\"\n"
#~ "     * @hibernate.collection-key\n"
#~ "     *  column=\"PARENT_ID\"\n"
#~ "     * @hibernate.collection-one-to-many\n"
#~ "     */\n"
#~ "    public Set getKittens() {\n"
#~ "        return kittens;\n"
#~ "    }\n"
#~ "    void setKittens(Set kittens) {\n"
#~ "        this.kittens = kittens;\n"
#~ "    }\n"
#~ "    // addKitten not needed by Hibernate\n"
#~ "    public void addKitten(Cat kitten) {\n"
#~ "        kittens.add(kitten);\n"
#~ "    }\n"
#~ "\n"
#~ "    /**\n"
#~ "     * @hibernate.property\n"
#~ "     *  column=\"SEX\"\n"
#~ "     *  not-null=\"true\"\n"
#~ "     *  update=\"false\"\n"
#~ "     */\n"
#~ "    public char getSex() {\n"
#~ "        return sex;\n"
#~ "    }\n"
#~ "    void setSex(char sex) {\n"
#~ "        this.sex=sex;\n"
#~ "    }\n"
#~ "}"

#, fuzzy
#~ msgid ""
#~ "<![CDATA[@Entity(access = AccessType.FIELD)\n"
#~ "public class Customer implements Serializable {\n"
#~ "\n"
#~ "    @Id;\n"
#~ "    Long id;\n"
#~ "\n"
#~ "    String firstName;\n"
#~ "    String lastName;\n"
#~ "    Date birthday;\n"
#~ "\n"
#~ "    @Transient\n"
#~ "    Integer age;\n"
#~ "\n"
#~ "    @Embedded\n"
#~ "    private Address homeAddress;\n"
#~ "\n"
#~ "    @OneToMany(cascade=CascadeType.ALL)\n"
#~ "    @JoinColumn(name=\"CUSTOMER_ID\")\n"
#~ "    Set<Order> orders;\n"
#~ "\n"
#~ "    // Getter/setter and business methods\n"
#~ "}]]>"
#~ msgstr ""
#~ "@Entity(access = AccessType.FIELD)\n"
#~ "public class Customer implements Serializable {\n"
#~ "\n"
#~ "    @Id;\n"
#~ "    Long id;\n"
#~ "\n"
#~ "    String firstName;\n"
#~ "    String lastName;\n"
#~ "    Date birthday;\n"
#~ "\n"
#~ "    @Transient\n"
#~ "    Integer age;\n"
#~ "\n"
#~ "    @Embedded\n"
#~ "    private Address homeAddress;\n"
#~ "\n"
#~ "    @OneToMany(cascade=CascadeType.ALL)\n"
#~ "    @JoinColumn(name=\"CUSTOMER_ID\")\n"
#~ "    Set&lt;Order&gt; orders;\n"
#~ "\n"
#~ "    // Getter/setter and business methods\n"
#~ "}"
