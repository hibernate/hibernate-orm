# translation of persistent_classes.po to
# Xi Huang <xhuang@redhat.com>, 2006.
# Xi HUANG <xhuang@redhat.com>, 2007, 2009.
# translation of Collection_Mapping.po to
msgid ""
msgstr ""
"Project-Id-Version: persistent_classes\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2010-07-20 21:02+0000\n"
"PO-Revision-Date: 2010-03-16 10:00+1000\n"
"Last-Translator: Xi HUANG <xhuang@redhat.com>\n"
"Language-Team:  <en@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Generator: KBabel 1.11.4\n"

#. Tag: title
#: persistent_classes.xml:32
#, no-c-format
msgid "Persistent Classes"
msgstr "持久化类（Persistent Classes）"

#. Tag: para
#: persistent_classes.xml:34
#, fuzzy, no-c-format
msgid ""
"Persistent classes are classes in an application that implement the entities "
"of the business problem (e.g. Customer and Order in an E-commerce "
"application). The term \"persistent\" here means that the classes are able "
"to be persisted, not that they are in the persistent state (see <xref "
"linkend=\"objectstate-overview\"/> for discussion)."
msgstr ""
"在应用程序中，用来实现业务问题实体的（如，在电子商务应用程序中的 Customer 和 "
"Order）类就是持久化类。不能认为所有的持久化类的实例都是持久的状态 - 一个实例"
"的状态也可能是瞬时的或脱管的。"

#. Tag: para
#: persistent_classes.xml:41
#, fuzzy, no-c-format
msgid ""
"Hibernate works best if these classes follow some simple rules, also known "
"as the Plain Old Java Object (POJO) programming model. However, none of "
"these rules are hard requirements. Indeed, Hibernate assumes very little "
"about the nature of your persistent objects. You can express a domain model "
"in other ways (using trees of <interfacename>java.util.Map</interfacename> "
"instances, for example)."
msgstr ""
"如果这些持久化类遵循一些简单的规则，Hibernate 能够工作得更好，这些规则也被称"
"作简单传统 Java 对象（POJO:Plain Old Java Object）编程模型。但是这些规则并不"
"是必需的。 实际上，Hibernate3 对于你的持久化类几乎不做任何设想。你可以用其他"
"的方法来表达领域模型：比如，使用 <literal>Map</literal> 实例的树型结构。"

#. Tag: title
#: persistent_classes.xml:49
#, no-c-format
msgid "A simple POJO example"
msgstr "一个简单的 POJO 例子"

#. Tag: title
#: persistent_classes.xml:52
#, no-c-format
msgid "Simple POJO representing a cat"
msgstr ""

#. Tag: programlisting
#: persistent_classes.xml:53
#, fuzzy, no-c-format
msgid ""
"package eg;\n"
"import java.util.Set;\n"
"import java.util.Date;\n"
"\n"
"public class Cat {\n"
"private Long id; // identifier\n"
"\n"
"private Date birthdate;\n"
"private Color color;\n"
"private char sex;\n"
"private float weight;\n"
"    private int litterId;\n"
"\n"
"    private Cat mother;\n"
"    private Set kittens = new HashSet();\n"
"\n"
"    private void setId(Long id) {\n"
"        this.id=id;\n"
"    }\n"
"    public Long getId() {\n"
"        return id;\n"
"    }\n"
"\n"
"    void setBirthdate(Date date) {\n"
"        birthdate = date;\n"
"    }\n"
"    public Date getBirthdate() {\n"
"        return birthdate;\n"
"    }\n"
"\n"
"    void setWeight(float weight) {\n"
"        this.weight = weight;\n"
"    }\n"
"    public float getWeight() {\n"
"        return weight;\n"
"    }\n"
"\n"
"    public Color getColor() {\n"
"        return color;\n"
"    }\n"
"    void setColor(Color color) {\n"
"        this.color = color;\n"
"    }\n"
"\n"
"    void setSex(char sex) {\n"
"        this.sex=sex;\n"
"    }\n"
"    public char getSex() {\n"
"        return sex;\n"
"    }\n"
"\n"
"    void setLitterId(int id) {\n"
"        this.litterId = id;\n"
"    }\n"
"    public int getLitterId() {\n"
"        return litterId;\n"
"    }\n"
"\n"
"    void setMother(Cat mother) {\n"
"        this.mother = mother;\n"
"    }\n"
"    public Cat getMother() {\n"
"        return mother;\n"
"    }\n"
"    void setKittens(Set kittens) {\n"
"        this.kittens = kittens;\n"
"    }\n"
"    public Set getKittens() {\n"
"        return kittens;\n"
"    }\n"
"\n"
"    // addKitten not needed by Hibernate\n"
"    public void addKitten(Cat kitten) {\n"
"        kitten.setMother(this);\n"
"    kitten.setLitterId( kittens.size() );\n"
"        kittens.add(kitten);\n"
"    }\n"
"}"
msgstr ""
"<![CDATA[package eg;\n"
"import java.util.Set;\n"
"import java.util.Date;\n"
"\n"
"public class Cat {\n"
"    private Long id; // identifier\n"
"\n"
"    private Date birthdate;\n"
"    private Color color;\n"
"    private char sex;\n"
"    private float weight;\n"
"    private int litterId;\n"
"\n"
"    private Cat mother;\n"
"    private Set kittens = new HashSet();\n"
"\n"
"    private void setId(Long id) {\n"
"        this.id=id;\n"
"    }\n"
"    public Long getId() {\n"
"        return id;\n"
"    }\n"
"\n"
"    void setBirthdate(Date date) {\n"
"        birthdate = date;\n"
"    }\n"
"    public Date getBirthdate() {\n"
"        return birthdate;\n"
"    }\n"
"\n"
"    void setWeight(float weight) {\n"
"        this.weight = weight;\n"
"    }\n"
"    public float getWeight() {\n"
"        return weight;\n"
"    }\n"
"\n"
"    public Color getColor() {\n"
"        return color;\n"
"    }\n"
"    void setColor(Color color) {\n"
"        this.color = color;\n"
"    }\n"
"\n"
"    void setSex(char sex) {\n"
"        this.sex=sex;\n"
"    }\n"
"    public char getSex() {\n"
"        return sex;\n"
"    }\n"
"\n"
"    void setLitterId(int id) {\n"
"        this.litterId = id;\n"
"    }\n"
"    public int getLitterId() {\n"
"        return litterId;\n"
"    }\n"
"\n"
"    void setMother(Cat mother) {\n"
"        this.mother = mother;\n"
"    }\n"
"    public Cat getMother() {\n"
"        return mother;\n"
"    }\n"
"    void setKittens(Set kittens) {\n"
"        this.kittens = kittens;\n"
"    }\n"
"    public Set getKittens() {\n"
"        return kittens;\n"
"    }\n"
"    \n"
"    // addKitten not needed by Hibernate\n"
"    public void addKitten(Cat kitten) {\n"
"            kitten.setMother(this);\n"
"        kitten.setLitterId( kittens.size() ); \n"
"        kittens.add(kitten);\n"
"    }\n"
"}]]>"

#. Tag: para
#: persistent_classes.xml:57
#, no-c-format
msgid ""
"The four main rules of persistent classes are explored in more detail in the "
"following sections."
msgstr "在后续的章节里我们将介绍持久性类的 4 个主要规则的更多细节。"

#. Tag: title
#: persistent_classes.xml:62
#, no-c-format
msgid "Implement a no-argument constructor"
msgstr "实现一个默认的（即无参数的）构造方法（constructor）"

#. Tag: para
#: persistent_classes.xml:64
#, fuzzy, no-c-format
msgid ""
"<classname>Cat</classname> has a no-argument constructor. All persistent "
"classes must have a default constructor (which can be non-public) so that "
"Hibernate can instantiate them using <literal><classname>java.lang.reflect."
"Constructor</classname>.newInstance()</literal>. It is recommended that this "
"constructor be defined with at least <emphasis>package</emphasis> visibility "
"in order for runtime proxy generation to work properly."
msgstr ""
"<literal>Cat</literal> 有一个无参数的构造方法。所有的持久化类都必须有一个默认"
"的构造方法（可以不是 public 的），这样的话 Hibernate 就可以使用 "
"<literal>Constructor.newInstance(）</literal>来实例化它们。 我们强烈建议，在 "
"Hibernate 中，为了运行期代理的生成，构造方法至少是<emphasis>包（package）</"
"emphasis>内可见的。"

#. Tag: title
#: persistent_classes.xml:74
#, fuzzy, no-c-format
msgid "Provide an identifier property"
msgstr "提供一个标识属性（identifier property）（可选）"

#. Tag: para
#: persistent_classes.xml:77
#, no-c-format
msgid ""
"Historically this was considered option. While still not (yet) enforced, "
"this should be considered a deprecated feature as it will be completely "
"required to provide a identifier property in an upcoming release."
msgstr ""

#. Tag: para
#: persistent_classes.xml:84
#, no-c-format
msgid ""
"<classname>Cat</classname> has a property named <literal>id</literal>. This "
"property maps to the primary key column(s) of the underlying database table. "
"The type of the identifier property can be any \"basic\" type (see <xref "
"linkend=\"types.value.basic\"/>). See <xref linkend=\"components-compositeid"
"\"/> for information on mapping composite (multi-column) identifiers."
msgstr ""

#. Tag: para
#: persistent_classes.xml:92
#, no-c-format
msgid ""
"Identifiers do not necessarily need to identify column(s) in the database "
"physically defined as a primary key. They should just identify columns that "
"can be used to uniquely identify rows in the underlying table."
msgstr ""

#. Tag: para
#: persistent_classes.xml:99
#, no-c-format
msgid ""
"We recommend that you declare consistently-named identifier properties on "
"persistent classes and that you use a nullable (i.e., non-primitive) type."
msgstr ""
"我们建议你对持久化类声明命名一致的标识属性。我们还建议你使用一个可以为空（也"
"就是说，不是原始类型）的类型。 "

#. Tag: title
#: persistent_classes.xml:107
#, fuzzy, no-c-format
msgid "Prefer non-final classes (semi-optional)"
msgstr "使用非final的类（可选）"

#. Tag: para
#: persistent_classes.xml:109
#, no-c-format
msgid ""
"A central feature of Hibernate, <emphasis>proxies</emphasis> (lazy loading), "
"depends upon the persistent class being either non-final, or the "
"implementation of an interface that declares all public methods. You can "
"persist <literal>final</literal> classes that do not implement an interface "
"with Hibernate; you will not, however, be able to use proxies for lazy "
"association fetching which will ultimately limit your options for "
"performance tuning. To persist a <literal>final</literal> class which does "
"not implement a \"full\" interface you must disable proxy generation. See "
"<xref linkend=\"persistent-classes-pojo-final-example-disable-proxies-xml\"/"
"> and <xref linkend=\"persistent-classes-pojo-final-example-disable-proxies-"
"ann\"/>."
msgstr ""

#. Tag: title
#: persistent_classes.xml:121
#, no-c-format
msgid "Disabling proxies in <literal>hbm.xml</literal>"
msgstr ""

#. Tag: programlisting
#: persistent_classes.xml:122
#, no-c-format
msgid "<![CDATA[<class name=\"Cat\" lazy=\"false\"...>...</class>]]>"
msgstr ""

#. Tag: title
#: persistent_classes.xml:126
#, no-c-format
msgid "Disabling proxies in annotations"
msgstr ""

#. Tag: programlisting
#: persistent_classes.xml:127
#, no-c-format
msgid "<![CDATA[@Entity @Proxy(lazy=false) public class Cat { ... }]]>"
msgstr ""

#. Tag: para
#: persistent_classes.xml:130
#, no-c-format
msgid ""
"If the <literal>final</literal> class does implement a proper interface, you "
"could alternatively tell Hibernate to use the interface instead when "
"generating the proxies. See <xref linkend=\"persistent-classes-pojo-final-"
"example-proxy-interface-xml\"/> and <xref linkend=\"persistent-classes-pojo-"
"final-example-proxy-interface-ann\"/>."
msgstr ""

#. Tag: title
#: persistent_classes.xml:139
#, no-c-format
msgid "Proxying an interface in <literal>hbm.xml</literal>"
msgstr ""

#. Tag: programlisting
#: persistent_classes.xml:140
#, no-c-format
msgid "<![CDATA[<class name=\"Cat\" proxy=\"ICat\"...>...</class>]]>"
msgstr ""

#. Tag: title
#: persistent_classes.xml:144
#, no-c-format
msgid "Proxying an interface in annotations"
msgstr ""

#. Tag: programlisting
#: persistent_classes.xml:145
#, no-c-format
msgid ""
"<![CDATA[@Entity @Proxy(proxyClass=ICat.class) public class Cat implements "
"ICat { ... }]]>"
msgstr ""

#. Tag: para
#: persistent_classes.xml:148
#, fuzzy, no-c-format
msgid ""
"You should also avoid declaring <literal>public final</literal> methods as "
"this will again limit the ability to generate <emphasis>proxies</emphasis> "
"from this class. If you want to use a class with <literal>public final</"
"literal> methods, you must explicitly disable proxying. Again, see <xref "
"linkend=\"persistent-classes-pojo-final-example-disable-proxies-xml\"/> and "
"<xref linkend=\"persistent-classes-pojo-final-example-disable-proxies-ann\"/"
">."
msgstr ""
"你也应该避免在非 final 类中声明 <literal>public final</literal> 的方法。如果"
"你想使用一个有 <literal>public final</literal> 方法的类，你必须通过设置 "
"<literal>lazy=\"false\"</literal> 来明确地禁用代理。 "

#. Tag: title
#: persistent_classes.xml:158
#, no-c-format
msgid "Declare accessors and mutators for persistent fields (optional)"
msgstr ""
"为持久化字段声明访问器（accessors）和是否可变的标志（mutators）（可选）"

#. Tag: para
#: persistent_classes.xml:160
#, fuzzy, no-c-format
msgid ""
"<classname>Cat</classname> declares accessor methods for all its persistent "
"fields. Many other ORM tools directly persist instance variables. It is "
"better to provide an indirection between the relational schema and internal "
"data structures of the class. By default, Hibernate persists JavaBeans style "
"properties and recognizes method names of the form <literal>getFoo</"
"literal>, <literal>isFoo</literal> and <literal>setFoo</literal>. If "
"required, you can switch to direct field access for particular properties."
msgstr ""
"<literal>Cat</literal> 为它的所有持久化字段声明了访问方法。很多其他 ORM 工具"
"直接对实例变量进行持久化。我们相信，在关系数据库 schema 和类的内部数据结构之"
"间引入间接层（原文为\"非直接\"，indirection）会好一些。默认情况下 Hibernate "
"持久化 JavaBeans 风格的属性，认可  <literal>getFoo</literal>，"
"<literal>isFoo</literal> 和 <literal>setFoo</literal> 这种形式的方法名。如果"
"需要，你可以对某些特定属性实行直接字段访问。 "

#. Tag: para
#: persistent_classes.xml:169
#, fuzzy, no-c-format
msgid ""
"Properties need <emphasis>not</emphasis> be declared public. Hibernate can "
"persist a property declared with <literal>package</literal>, "
"<literal>protected</literal> or <literal>private</literal> visibility as "
"well."
msgstr ""
"属性<emphasis>不需要</emphasis>要声明为 public 的。Hibernate 可以持久化一个"
"有 <literal>default</literal>、<literal>protected</literal> 或 "
"<literal>private</literal> 的 get/set 方法对的属性进行持久化。"

#. Tag: title
#: persistent_classes.xml:178
#, no-c-format
msgid "Implementing inheritance"
msgstr "实现继承（Inheritance）"

#. Tag: para
#: persistent_classes.xml:180
#, no-c-format
msgid ""
"A subclass must also observe the first and second rules. It inherits its "
"identifier property from the superclass, <literal>Cat</literal>. For example:"
msgstr ""
"子类也必须遵守第一条和第二条规则。它从超类 <literal>Cat</literal> 继承了标识"
"属性。例如："

#. Tag: programlisting
#: persistent_classes.xml:184
#, fuzzy, no-c-format
msgid ""
"package eg;\n"
"\n"
"public class DomesticCat extends Cat {\n"
"        private String name;\n"
"\n"
"        public String getName() {\n"
"                return name;\n"
"        }\n"
"        protected void setName(String name) {\n"
"                this.name=name;\n"
"        }\n"
"}"
msgstr ""
"<![CDATA[package eg;\n"
"\n"
"public class DomesticCat extends Cat {\n"
"        private String name;\n"
"\n"
"        public String getName() {\n"
"                return name;\n"
"        }\n"
"        protected void setName(String name) {\n"
"                this.name=name;\n"
"        }\n"
"}]]>"

#. Tag: title
#: persistent_classes.xml:188
#, no-c-format
msgid ""
"Implementing <literal>equals()</literal> and <literal>hashCode()</literal>"
msgstr ""
"实现 <literal>equals()</literal> 和 <literal>hashCode()</literal> 方法："

#. Tag: para
#: persistent_classes.xml:191
#, no-c-format
msgid ""
"You have to override the <literal>equals()</literal> and <literal>hashCode()"
"</literal> methods if you:"
msgstr ""
"如果你有如下需求，你必须重载 <literal>equals()</literal> 和 <literal>hashCode"
"()</literal> 方法： "

#. Tag: para
#: persistent_classes.xml:196
#, no-c-format
msgid ""
"intend to put instances of persistent classes in a <literal>Set</literal> "
"(the recommended way to represent many-valued associations); <emphasis>and</"
"emphasis>"
msgstr ""
"想把持久类的实例放入 <literal>Set</literal> 中（当表示多值关联时，推荐这么"
"做），<emphasis>而且</emphasis>"

#. Tag: para
#: persistent_classes.xml:202
#, no-c-format
msgid "intend to use reattachment of detached instances"
msgstr "想重用脱管实例"

#. Tag: para
#: persistent_classes.xml:206
#, no-c-format
msgid ""
"Hibernate guarantees equivalence of persistent identity (database row) and "
"Java identity only inside a particular session scope. When you mix instances "
"retrieved in different sessions, you must implement <literal>equals()</"
"literal> and <literal>hashCode()</literal> if you wish to have meaningful "
"semantics for <literal>Set</literal>s."
msgstr ""
"Hibernate 保证，仅在特定会话范围内，持久化标识（数据库的行）和 Java 标识是等"
"价的。因此，一旦我们混合了从不同会话中获取的实例，如果希望 <literal>Set</"
"literal> 有明确的语义，就必须实现 <literal>equals()</literal> 和  "
"<literal>hashCode()</literal>。 "

#. Tag: para
#: persistent_classes.xml:212
#, no-c-format
msgid ""
"The most obvious way is to implement <literal>equals()</literal>/"
"<literal>hashCode()</literal> by comparing the identifier value of both "
"objects. If the value is the same, both must be the same database row, "
"because they are equal. If both are added to a <literal>Set</literal>, you "
"will only have one element in the <literal>Set</literal>). Unfortunately, "
"you cannot use that approach with generated identifiers. Hibernate will only "
"assign identifier values to objects that are persistent; a newly created "
"instance will not have any identifier value. Furthermore, if an instance is "
"unsaved and currently in a <literal>Set</literal>, saving it will assign an "
"identifier value to the object. If <literal>equals()</literal> and "
"<literal>hashCode()</literal> are based on the identifier value, the hash "
"code would change, breaking the contract of the <literal>Set</literal>. See "
"the Hibernate website for a full discussion of this problem. This is not a "
"Hibernate issue, but normal Java semantics of object identity and equality."
msgstr ""
"实现 <literal>equals()</literal>/<literal>hashCode()</literal> 最显而易见的方"
"法是比较两个对象 标识符的值。如果值相同，则两个对象对应于数据库的同一行，因此"
"它们是相等的（如果都被添加到 <literal>Set</literal>，则在 <literal>Set</"
"literal> 中只有一个元素）。不幸的是，对生成的标识不能 使用这种方法。"
"Hibernate 仅对那些持久化对象赋标识值，一个新创建的实例将不会有任何标识值。此"
"外， 如果一个实例没有被保存（unsaved），并且它当前正在一个 <literal>Set</"
"literal> 中，保存它将会给这个对象赋一个标识值。如果 <literal>equals()</"
"literal> 和 <literal>hashCode()</literal> 是基于标识值 实现的，则其哈希码将会"
"改变，这违反了 <literal>Set</literal> 的契约。建议去 Hibernate 的站点阅读关于"
"这个问题的全部讨论。注意，这不是 Hibernate 的问题，而是一般的 Java 对象标识"
"和 Java 对象等价的语义问题。 "

#. Tag: para
#: persistent_classes.xml:228
#, no-c-format
msgid ""
"It is recommended that you implement <literal>equals()</literal> and "
"<literal>hashCode()</literal> using <emphasis>Business key equality</"
"emphasis>. Business key equality means that the <literal>equals()</literal> "
"method compares only the properties that form the business key. It is a key "
"that would identify our instance in the real world (a <emphasis>natural</"
"emphasis> candidate key):"
msgstr ""
"我们建议使用<emphasis>业务键值相等（Business key equality）</emphasis>来实现 "
"<literal>equals()</literal> 和 <literal>hashCode()</literal>。业务键值相等的"
"意思是，<literal>equals()</literal> 方法仅仅比较形成业务键的属性，它能在现实"
"世界里标识我们的实例（是一个<emphasis>自然的</emphasis>候选码）。"

#. Tag: programlisting
#: persistent_classes.xml:235
#, fuzzy, no-c-format
msgid ""
"public class Cat {\n"
"\n"
"    ...\n"
"    public boolean equals(Object other) {\n"
"        if (this == other) return true;\n"
"        if ( !(other instanceof Cat) ) return false;\n"
"\n"
"        final Cat cat = (Cat) other;\n"
"\n"
"        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;\n"
"        if ( !cat.getMother().equals( getMother() ) ) return false;\n"
"\n"
"        return true;\n"
"    }\n"
"\n"
"    public int hashCode() {\n"
"        int result;\n"
"        result = getMother().hashCode();\n"
"        result = 29 * result + getLitterId();\n"
"        return result;\n"
"    }\n"
"\n"
"}"
msgstr ""
"<![CDATA[public class Cat {\n"
"\n"
"    ...\n"
"    public boolean equals(Object other) {\n"
"        if (this == other) return true;\n"
"        if ( !(other instanceof Cat) ) return false;\n"
"\n"
"        final Cat cat = (Cat) other;\n"
"\n"
"        if ( !cat.getLitterId().equals( getLitterId() ) ) return false;\n"
"        if ( !cat.getMother().equals( getMother() ) ) return false;\n"
"\n"
"        return true;\n"
"    }\n"
"\n"
"    public int hashCode() {\n"
"        int result;\n"
"        result = getMother().hashCode();\n"
"        result = 29 * result + getLitterId();\n"
"        return result;\n"
"    }\n"
"\n"
"}]]>"

#. Tag: para
#: persistent_classes.xml:237
#, fuzzy, no-c-format
msgid ""
"A business key does not have to be as solid as a database primary key "
"candidate (see <xref linkend=\"transactions-basics-identity\"/>). Immutable "
"or unique properties are usually good candidates for a business key."
msgstr ""
"注意，业务键不必像数据库的主键那样固定不变（参见 <xref linkend="
"\"transactions-basics-identity\"/>）。对业务键而言，不可变或唯一的属性是不错"
"的选择。"

#. Tag: title
#: persistent_classes.xml:244
#, no-c-format
msgid "Dynamic models"
msgstr "动态模型（Dynamic models）"

#. Tag: title
#: persistent_classes.xml:247
#, no-c-format
msgid "Note"
msgstr "注意"

#. Tag: emphasis
#: persistent_classes.xml:249
#, fuzzy, no-c-format
msgid ""
"The following features are currently considered experimental and may change "
"in the near future."
msgstr ""
"<emphasis>注意，以下特性在当前处于试验阶段，将来可能会有变化。</emphasis> "

#. Tag: para
#: persistent_classes.xml:253
#, no-c-format
msgid ""
"Persistent entities do not necessarily have to be represented as POJO "
"classes or as JavaBean objects at runtime. Hibernate also supports dynamic "
"models (using <literal>Map</literal>s of <literal>Map</literal>s at runtime) "
"and the representation of entities as DOM4J trees. With this approach, you "
"do not write persistent classes, only mapping files."
msgstr ""
"运行期的持久化实体没有必要一定表示为像 POJO 类或 JavaBean 对象那样的形式。"
"Hibernate 也支持动态模型 （在运行期使用 <literal>Map</literal> 的 "
"<literal>Map</literal>）和象 DOM4J 的树模型那样的实体表示。使用这种方法，你不"
"用写持久化类，只写映射文件就行了。 "

#. Tag: para
#: persistent_classes.xml:259
#, fuzzy, no-c-format
msgid ""
"By default, Hibernate works in normal POJO mode. You can set a default "
"entity representation mode for a particular <literal>SessionFactory</"
"literal> using the <literal>default_entity_mode</literal> configuration "
"option (see <xref linkend=\"configuration-optional-properties\"/>)."
msgstr ""
"Hibernate 默认工作在普通 POJO 模式。你可以使用配置选项 "
"<literal>default_entity_mode</literal>， 对特定的 <literal>SessionFactory</"
"literal>，设置一个默认的实体表示模式。（参见 <xref linkend=\"configuration-"
"optional-properties\"/>）。"

#. Tag: para
#: persistent_classes.xml:265
#, no-c-format
msgid ""
"The following examples demonstrate the representation using <literal>Map</"
"literal>s. First, in the mapping file an <literal>entity-name</literal> has "
"to be declared instead of, or in addition to, a class name:"
msgstr ""
"下面是用 <literal>Map</literal> 来表示的例子。首先，在映射文件中，要声明  "
"<literal>entity-name</literal> 来代替一个类名（或作为一种附属）。 "

#. Tag: programlisting
#: persistent_classes.xml:270
#, fuzzy, no-c-format
msgid ""
"&lt;hibernate-mapping&gt;\n"
"\n"
"    &lt;class entity-name=\"Customer\"&gt;\n"
"\n"
"        &lt;id name=\"id\"\n"
"            type=\"long\"\n"
"            column=\"ID\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"\n"
"        &lt;property name=\"name\"\n"
"            column=\"NAME\"\n"
"            type=\"string\"/&gt;\n"
"\n"
"        &lt;property name=\"address\"\n"
"            column=\"ADDRESS\"\n"
"            type=\"string\"/&gt;\n"
"\n"
"        &lt;many-to-one name=\"organization\"\n"
"            column=\"ORGANIZATION_ID\"\n"
"            class=\"Organization\"/&gt;\n"
"\n"
"        &lt;bag name=\"orders\"\n"
"            inverse=\"true\"\n"
"            lazy=\"false\"\n"
"            cascade=\"all\"&gt;\n"
"            &lt;key column=\"CUSTOMER_ID\"/&gt;\n"
"            &lt;one-to-many class=\"Order\"/&gt;\n"
"        &lt;/bag&gt;\n"
"\n"
"    &lt;/class&gt;\n"
"    \n"
"&lt;/hibernate-mapping&gt;"
msgstr ""
"<![CDATA[<hibernate-mapping>\n"
"\n"
"    <class entity-name=\"Customer\">\n"
"\n"
"        <id name=\"id\"\n"
"            type=\"long\"\n"
"            column=\"ID\">\n"
"            <generator class=\"sequence\"/>\n"
"        </id>\n"
"\n"
"        <property name=\"name\"\n"
"            column=\"NAME\"\n"
"            type=\"string\"/>\n"
"\n"
"        <property name=\"address\"\n"
"            column=\"ADDRESS\"\n"
"            type=\"string\"/>\n"
"\n"
"        <many-to-one name=\"organization\"\n"
"            column=\"ORGANIZATION_ID\"\n"
"            class=\"Organization\"/>\n"
"\n"
"        <bag name=\"orders\"\n"
"            inverse=\"true\"\n"
"            lazy=\"false\"\n"
"            cascade=\"all\">\n"
"            <key column=\"CUSTOMER_ID\"/>\n"
"            <one-to-many class=\"Order\"/>\n"
"        </bag>\n"
"\n"
"    </class>\n"
"    \n"
"</hibernate-mapping>]]>"

#. Tag: para
#: persistent_classes.xml:272
#, no-c-format
msgid ""
"Even though associations are declared using target class names, the target "
"type of associations can also be a dynamic entity instead of a POJO."
msgstr ""
"注意，虽然是用目标类名来声明关联的，但是关联的目标类型除了是 POJO 之外，也可"
"以是一个动态的实体。 "

#. Tag: para
#: persistent_classes.xml:276
#, no-c-format
msgid ""
"After setting the default entity mode to <literal>dynamic-map</literal> for "
"the <literal>SessionFactory</literal>, you can, at runtime, work with "
"<literal>Map</literal>s of <literal>Map</literal>s:"
msgstr ""
"在使用 <literal>dynamic-map</literal> 为 <literal>SessionFactory</literal> 设"
"置了默认的实体模式之后，可以在运行期使用 <literal>Map</literal> 的 "
"<literal>Map</literal>："

#. Tag: programlisting
#: persistent_classes.xml:281
#, fuzzy, no-c-format
msgid ""
"Session s = openSession();\n"
"Transaction tx = s.beginTransaction();\n"
"\n"
"// Create a customer\n"
"Map david = new HashMap();\n"
"david.put(\"name\", \"David\");\n"
"\n"
"// Create an organization\n"
"Map foobar = new HashMap();\n"
"foobar.put(\"name\", \"Foobar Inc.\");\n"
"\n"
"// Link both\n"
"david.put(\"organization\", foobar);\n"
"\n"
"// Save both\n"
"s.save(\"Customer\", david);\n"
"s.save(\"Organization\", foobar);\n"
"\n"
"tx.commit();\n"
"s.close();"
msgstr ""
"<![CDATA[Session s = openSession();\n"
"Transaction tx = s.beginTransaction();\n"
"Session s = openSession();\n"
"\n"
"// Create a customer\n"
"Map david = new HashMap();\n"
"david.put(\"name\", \"David\");\n"
"\n"
"// Create an organization\n"
"Map foobar = new HashMap();\n"
"foobar.put(\"name\", \"Foobar Inc.\");\n"
"\n"
"// Link both\n"
"david.put(\"organization\", foobar);\n"
"\n"
"// Save both\n"
"s.save(\"Customer\", david);\n"
"s.save(\"Organization\", foobar);\n"
"\n"
"tx.commit();\n"
"s.close();]]>"

#. Tag: para
#: persistent_classes.xml:283
#, no-c-format
msgid ""
"One of the main advantages of dynamic mapping is quick turnaround time for "
"prototyping, without the need for entity class implementation. However, you "
"lose compile-time type checking and will likely deal with many exceptions at "
"runtime. As a result of the Hibernate mapping, the database schema can "
"easily be normalized and sound, allowing to add a proper domain model "
"implementation on top later on."
msgstr ""
"动态映射的好处是，变化所需要的时间少了，因为原型不需要实现实体类。然而，你无"
"法进行编译期的类型检查，并可能由此会处理很多的运行期异常。幸亏有了 Hibernate "
"映射，它使得数据库的 schema 能容易的规格化和合理化，并允许稍后在此之上添加合"
"适的领域模型实现。 "

#. Tag: para
#: persistent_classes.xml:290
#, no-c-format
msgid ""
"Entity representation modes can also be set on a per <literal>Session</"
"literal> basis:"
msgstr "实体表示模式也能在每个 <literal>Session</literal> 的基础上设置："

#. Tag: programlisting
#: persistent_classes.xml:293
#, fuzzy, no-c-format
msgid ""
"Session dynamicSession = pojoSession.getSession(EntityMode.MAP);\n"
"\n"
"// Create a customer\n"
"Map david = new HashMap();\n"
"david.put(\"name\", \"David\");\n"
"dynamicSession.save(\"Customer\", david);\n"
"...\n"
"dynamicSession.flush();\n"
"dynamicSession.close()\n"
"...\n"
"// Continue on pojoSession"
msgstr ""
"<![CDATA[Session dynamicSession = pojoSession.getSession(EntityMode.MAP);\n"
"\n"
"// Create a customer\n"
"Map david = new HashMap();\n"
"david.put(\"name\", \"David\");\n"
"dynamicSession.save(\"Customer\", david);\n"
"...\n"
"dynamicSession.flush();\n"
"dynamicSession.close()\n"
"...\n"
"// Continue on pojoSession\n"
"]]>"

#. Tag: para
#: persistent_classes.xml:295
#, no-c-format
msgid ""
"Please note that the call to <literal>getSession()</literal> using an "
"<literal>EntityMode</literal> is on the <literal>Session</literal> API, not "
"the <literal>SessionFactory</literal>. That way, the new <literal>Session</"
"literal> shares the underlying JDBC connection, transaction, and other "
"context information. This means you do not have to call <literal>flush()</"
"literal> and <literal>close()</literal> on the secondary <literal>Session</"
"literal>, and also leave the transaction and connection handling to the "
"primary unit of work."
msgstr ""
"请注意，用 <literal>EntityMode</literal> 调用 <literal>getSession()</"
"literal> 是在 <literal>Session</literal> 的 API 中，而不是 "
"<literal>SessionFactory</literal>。 这样，新的 <literal>Session</literal> 共"
"享底层的 JDBC 连接，事务，和其他的上下文信息。这意味着，你不需要在第二个 "
"<literal>Session</literal> 中调用 <literal>flush()</literal> 和 "
"<literal>close()</literal>，同样的，把事务和连接的处理交给原来的工作单元。 "

#. Tag: para
#: persistent_classes.xml:304
#, fuzzy, no-c-format
msgid ""
"More information about the XML representation capabilities can be found in "
"<xref linkend=\"xml\"/>."
msgstr "关于 XML 表示能力的更多信息可以在 <xref linkend=\"xml\"/> 中找到。"

#. Tag: title
#: persistent_classes.xml:310
#, no-c-format
msgid "Tuplizers"
msgstr "元组片断映射（Tuplizers）"

#. Tag: para
#: persistent_classes.xml:312
#, fuzzy, no-c-format
msgid ""
"<interfacename>org.hibernate.tuple.Tuplizer</interfacename> and its sub-"
"interfaces are responsible for managing a particular representation of a "
"piece of data given that representation's <classname>org.hibernate."
"EntityMode</classname>. If a given piece of data is thought of as a data "
"structure, then a tuplizer is the thing that knows how to create such a data "
"structure, how to extract values from such a data structure and how to "
"inject values into such a data structure. For example, for the POJO entity "
"mode, the corresponding tuplizer knows how create the POJO through its "
"constructor. It also knows how to access the POJO properties using the "
"defined property accessors."
msgstr ""
"<literal>org.hibernate.tuple.Tuplizer</literal>，以及其子接口，负责根据给定的"
"<literal>org.hibernate.EntityMode</literal>，来复现片断数据。如果给定的片断数"
"据被认为其是一种数据结构，\"tuplizer\" 就是一个知道如何创建这样的数据结构，以"
"及如何给这个数据结构赋值的东西。比如说，对于 POJO 这种 Entity Mode，对应的 "
"tuplizer 知道通过其构造方法来创建一个 POJO，再通过其属性访问器来访问 POJO 属"
"性。有两大类高层 Tuplizer，分别是<literal>org.hibernate.tuple.entity."
"EntityTuplizer</literal> 和 <literal>org.hibernate.tuple.entity."
"ComponentTuplizer</literal> 接口。<literal>EntityTuplizer</literal> 负责管理"
"上面提到的实体的契约，而 <literal>ComponentTuplizer</literal> 则是针对组件"
"的。 "

#. Tag: para
#: persistent_classes.xml:322
#, no-c-format
msgid "There are two (high-level) types of Tuplizers:"
msgstr ""

#. Tag: para
#: persistent_classes.xml:326
#, no-c-format
msgid ""
"<interfacename>org.hibernate.tuple.entity.EntityTuplizer</interfacename> "
"which is responsible for managing the above mentioned contracts in regards "
"to entities"
msgstr ""

#. Tag: para
#: persistent_classes.xml:332
#, no-c-format
msgid ""
"<interfacename>org.hibernate.tuple.component.ComponentTuplizer</"
"interfacename> which does the same for components"
msgstr ""

#. Tag: para
#: persistent_classes.xml:340
#, fuzzy, no-c-format
msgid ""
"Users can also plug in their own tuplizers. Perhaps you require that "
"<interfacename>java.util.Map</interfacename> implementation other than "
"<classname>java.util.HashMap</classname> be used while in the dynamic-map "
"entity-mode. Or perhaps you need to define a different proxy generation "
"strategy than the one used by default. Both would be achieved by defining a "
"custom tuplizer implementation. Tuplizer definitions are attached to the "
"entity or component mapping they are meant to manage. Going back to the "
"example of our <classname>Customer</classname> entity, <xref linkend="
"\"example-specify-custom-tuplizer-ann\"/> shows how to specify a custom "
"<interfacename>org.hibernate.tuple.entity.EntityTuplizer</interfacename> "
"using annotations while <xref linkend=\"example-specify-custom-tuplizer-xml"
"\"/> shows how to do the same in <literal>hbm.xml</literal>"
msgstr ""
"用户也可以插入其自定义的 tuplizer。或许您需要一种不同于 dynamic-map entity-"
"mode 中使用的 <literal>java.util.HashMap</literal> 的 <literal>java.util."
"Map</literal> 实现；或许您需要与默认策略不同的代理生成策略（proxy generation "
"strategy）。通过自定义 tuplizer 实现，这两个目标您都可以达到。Tuplizer 定义被"
"附加到它们期望管理的 entity 或者 component 映射中。回到我们的 customer "
"entity 例子： "

#. Tag: title
#: persistent_classes.xml:353
#, no-c-format
msgid "Specify custom tuplizers in annotations"
msgstr ""

#. Tag: programlisting
#: persistent_classes.xml:354
#, no-c-format
msgid ""
"@Entity\n"
"@Tuplizer(impl = DynamicEntityTuplizer.class)\n"
"public interface Cuisine {\n"
"    @Id\n"
"    @GeneratedValue\n"
"    public Long getId();\n"
"    public void setId(Long id);\n"
"\n"
"    public String getName();\n"
"    public void setName(String name);\n"
"\n"
"    @Tuplizer(impl = DynamicComponentTuplizer.class)\n"
"    public Country getCountry();\n"
"    public void setCountry(Country country);\n"
"}"
msgstr ""

#. Tag: title
#: persistent_classes.xml:357
#, no-c-format
msgid "Specify custom tuplizers in <literal>hbm.xml</literal>"
msgstr ""

#. Tag: programlisting
#: persistent_classes.xml:358
#, no-c-format
msgid ""
"&lt;hibernate-mapping&gt;\n"
"    &lt;class entity-name=\"Customer\"&gt;\n"
"        &lt;!--\n"
"            Override the dynamic-map entity-mode\n"
"            tuplizer for the customer entity\n"
"        --&gt;\n"
"        &lt;tuplizer entity-mode=\"dynamic-map\"\n"
"                class=\"CustomMapTuplizerImpl\"/&gt;\n"
"\n"
"        &lt;id name=\"id\" type=\"long\" column=\"ID\"&gt;\n"
"            &lt;generator class=\"sequence\"/&gt;\n"
"        &lt;/id&gt;\n"
"\n"
"        &lt;!-- other properties --&gt;\n"
"        ...\n"
"    &lt;/class&gt;\n"
"&lt;/hibernate-mapping&gt;"
msgstr ""

#. Tag: title
#: persistent_classes.xml:363
#, no-c-format
msgid "EntityNameResolvers"
msgstr "EntityNameResolvers"

#. Tag: para
#: persistent_classes.xml:365
#, fuzzy, no-c-format
msgid ""
"<interfacename>org.hibernate.EntityNameResolver</interfacename> is a "
"contract for resolving the entity name of a given entity instance. The "
"interface defines a single method <methodname>resolveEntityName</methodname> "
"which is passed the entity instance and is expected to return the "
"appropriate entity name (null is allowed and would indicate that the "
"resolver does not know how to resolve the entity name of the given entity "
"instance). Generally speaking, an <interfacename>org.hibernate."
"EntityNameResolver</interfacename> is going to be most useful in the case of "
"dynamic models. One example might be using proxied interfaces as your domain "
"model. The hibernate test suite has an example of this exact style of usage "
"under the <package>org.hibernate.test.dynamicentity.tuplizer2</package>. "
"Here is some of the code from that package for illustration."
msgstr ""
"<interfacename>org.hibernate.EntityNameResolver</interfacename> 接口是一个解"
"析给定实体实例的实体名称的合约。这个接口定义了一个单一的方法 "
"<methodname>resolveEntityName</methodname>，它传递实体实例并预期返回合适的实"
"体名称（null 指明解析器不知道如何解析给定实体实例的实体名称）。一般说来，"
"<interfacename>org.hibernate.EntityNameResolver</interfacename> 在动态模型里"
"最为有用。其中的例子是把代理接口用作你的域模型。Hibernate Test Suite 在 "
"<package>org.hibernate.test.dynamicentity.tuplizer2</package> 下有具有完全相"
"同风格的例子。下面是该包里的一些代码："

#. Tag: programlisting
#: persistent_classes.xml:377
#, fuzzy, no-c-format
msgid ""
"/**\n"
" * A very trivial JDK Proxy InvocationHandler implementation where we proxy "
"an\n"
" * interface as the domain model and simply store persistent state in an "
"internal\n"
" * Map.  This is an extremely trivial example meant only for illustration.\n"
" */\n"
"public final class DataProxyHandler implements InvocationHandler {\n"
"        private String entityName;\n"
"        private HashMap data = new HashMap();\n"
"\n"
"        public DataProxyHandler(String entityName, Serializable id) {\n"
"                this.entityName = entityName;\n"
"                data.put( \"Id\", id );\n"
"        }\n"
"\n"
"        public Object invoke(Object proxy, Method method, Object[] args) "
"throws Throwable {\n"
"                String methodName = method.getName();\n"
"                if ( methodName.startsWith( \"set\" ) ) {\n"
"                        String propertyName = methodName.substring( 3 );\n"
"                        data.put( propertyName, args[0] );\n"
"                }\n"
"                else if ( methodName.startsWith( \"get\" ) ) {\n"
"                        String propertyName = methodName.substring( 3 );\n"
"                        return data.get( propertyName );\n"
"                }\n"
"                else if ( \"toString\".equals( methodName ) ) {\n"
"                        return entityName + \"#\" + data.get( \"Id\" );\n"
"                }\n"
"                else if ( \"hashCode\".equals( methodName ) ) {\n"
"                        return new Integer( this.hashCode() );\n"
"                }\n"
"                return null;\n"
"        }\n"
"\n"
"        public String getEntityName() {\n"
"                return entityName;\n"
"        }\n"
"\n"
"        public HashMap getData() {\n"
"                return data;\n"
"        }\n"
"}\n"
"\n"
"public class ProxyHelper {\n"
"    public static String extractEntityName(Object object) {\n"
"        // Our custom java.lang.reflect.Proxy instances actually bundle\n"
"        // their appropriate entity name, so we simply extract it from "
"there\n"
"        // if this represents one of our proxies; otherwise, we return null\n"
"        if ( Proxy.isProxyClass( object.getClass() ) ) {\n"
"            InvocationHandler handler = Proxy.getInvocationHandler"
"( object );\n"
"            if ( DataProxyHandler.class.isAssignableFrom( handler.getClass"
"() ) ) {\n"
"                DataProxyHandler myHandler = ( DataProxyHandler ) handler;\n"
"                return myHandler.getEntityName();\n"
"            }\n"
"        }\n"
"        return null;\n"
"    }\n"
"\n"
"    // various other utility methods ....\n"
"\n"
"}\n"
"\n"
"/**\n"
" * The EntityNameResolver implementation.\n"
" *\n"
" * IMPL NOTE : An EntityNameResolver really defines a strategy for how "
"entity names\n"
" * should be resolved.  Since this particular impl can handle resolution for "
"all of our\n"
" * entities we want to take advantage of the fact that SessionFactoryImpl "
"keeps these\n"
" * in a Set so that we only ever have one instance registered.  Why?  Well, "
"when it\n"
" * comes time to resolve an entity name, Hibernate must iterate over all the "
"registered\n"
" * resolvers.  So keeping that number down helps that process be as speedy "
"as possible.\n"
" * Hence the equals and hashCode implementations as is\n"
" */\n"
"public class MyEntityNameResolver implements EntityNameResolver {\n"
"    public static final MyEntityNameResolver INSTANCE = new "
"MyEntityNameResolver();\n"
"\n"
"    public String resolveEntityName(Object entity) {\n"
"        return ProxyHelper.extractEntityName( entity );\n"
"    }\n"
"\n"
"    public boolean equals(Object obj) {\n"
"        return getClass().equals( obj.getClass() );\n"
"    }\n"
"\n"
"    public int hashCode() {\n"
"        return getClass().hashCode();\n"
"    }\n"
"}\n"
"\n"
"public class MyEntityTuplizer extends PojoEntityTuplizer {\n"
"        public MyEntityTuplizer(EntityMetamodel entityMetamodel, "
"PersistentClass mappedEntity) {\n"
"                super( entityMetamodel, mappedEntity );\n"
"        }\n"
"\n"
"        public EntityNameResolver[] getEntityNameResolvers() {\n"
"                return new EntityNameResolver[] { MyEntityNameResolver."
"INSTANCE };\n"
"        }\n"
"\n"
"    public String determineConcreteSubclassEntityName(Object entityInstance, "
"SessionFactoryImplementor factory) {\n"
"        String entityName = ProxyHelper.extractEntityName"
"( entityInstance );\n"
"        if ( entityName == null ) {\n"
"            entityName = super.determineConcreteSubclassEntityName"
"( entityInstance, factory );\n"
"        }\n"
"        return entityName;\n"
"    }\n"
"\n"
"    ..."
msgstr ""
"/**\n"
" * A very trivial JDK Proxy InvocationHandler implementation where we proxy "
"an interface as\n"
" * the domain model and simply store persistent state in an internal Map.  "
"This is an extremely\n"
" * trivial example meant only for illustration.\n"
" */\n"
"public final class DataProxyHandler implements InvocationHandler {\n"
"        private String entityName;\n"
"        private HashMap data = new HashMap();\n"
"\n"
"        public DataProxyHandler(String entityName, Serializable id) {\n"
"                this.entityName = entityName;\n"
"                data.put( \"Id\", id );\n"
"        }\n"
"\n"
"        public Object invoke(Object proxy, Method method, Object[] args) "
"throws Throwable {\n"
"                String methodName = method.getName();\n"
"                if ( methodName.startsWith( \"set\" ) ) {\n"
"                        String propertyName = methodName.substring( 3 );\n"
"                        data.put( propertyName, args[0] );\n"
"                }\n"
"                else if ( methodName.startsWith( \"get\" ) ) {\n"
"                        String propertyName = methodName.substring( 3 );\n"
"                        return data.get( propertyName );\n"
"                }\n"
"                else if ( \"toString\".equals( methodName ) ) {\n"
"                        return entityName + \"#\" + data.get( \"Id\" );\n"
"                }\n"
"                else if ( \"hashCode\".equals( methodName ) ) {\n"
"                        return new Integer( this.hashCode() );\n"
"                }\n"
"                return null;\n"
"        }\n"
"\n"
"        public String getEntityName() {\n"
"                return entityName;\n"
"        }\n"
"\n"
"        public HashMap getData() {\n"
"                return data;\n"
"        }\n"
"}\n"
"\n"
"/**\n"
" *\n"
" */\n"
"public class ProxyHelper {\n"
"    public static String extractEntityName(Object object) {\n"
"        // Our custom java.lang.reflect.Proxy instances actually bundle\n"
"        // their appropriate entity name, so we simply extract it from "
"there\n"
"        // if this represents one of our proxies; otherwise, we return null\n"
"        if ( Proxy.isProxyClass( object.getClass() ) ) {\n"
"            InvocationHandler handler = Proxy.getInvocationHandler"
"( object );\n"
"            if ( DataProxyHandler.class.isAssignableFrom( handler.getClass"
"() ) ) {\n"
"                DataProxyHandler myHandler = ( DataProxyHandler ) handler;\n"
"                return myHandler.getEntityName();\n"
"            }\n"
"        }\n"
"        return null;\n"
"    }\n"
"\n"
"    // various other utility methods ....\n"
"\n"
"}\n"
"\n"
"/**\n"
" * The EntityNameResolver implementation.\n"
" * IMPL NOTE : An EntityNameResolver really defines a strategy for how "
"entity names should be\n"
" * resolved.  Since this particular impl can handle resolution for all of "
"our entities we want to\n"
" * take advantage of the fact that SessionFactoryImpl keeps these in a Set "
"so that we only ever\n"
" * have one instance registered.  Why?  Well, when it comes time to resolve "
"an entity name,\n"
" * Hibernate must iterate over all the registered resolvers.  So keeping "
"that number down\n"
" * helps that process be as speedy as possible.  Hence the equals and "
"hashCode impls\n"
" */\n"
"public class MyEntityNameResolver implements EntityNameResolver {\n"
"    public static final MyEntityNameResolver INSTANCE = new "
"MyEntityNameResolver();\n"
"\n"
"    public String resolveEntityName(Object entity) {\n"
"        return ProxyHelper.extractEntityName( entity );\n"
"    }\n"
"\n"
"    public boolean equals(Object obj) {\n"
"        return getClass().equals( obj.getClass() );\n"
"    }\n"
"\n"
"    public int hashCode() {\n"
"        return getClass().hashCode();\n"
"    }\n"
"}\n"
"\n"
"public class MyEntityTuplizer extends PojoEntityTuplizer {\n"
"        public MyEntityTuplizer(EntityMetamodel entityMetamodel, "
"PersistentClass mappedEntity) {\n"
"                super( entityMetamodel, mappedEntity );\n"
"        }\n"
"\n"
"        public EntityNameResolver[] getEntityNameResolvers() {\n"
"                return new EntityNameResolver[] { MyEntityNameResolver."
"INSTANCE };\n"
"        }\n"
"\n"
"    public String determineConcreteSubclassEntityName(Object entityInstance, "
"SessionFactoryImplementor factory) {\n"
"        String entityName = ProxyHelper.extractEntityName"
"( entityInstance );\n"
"        if ( entityName == null ) {\n"
"            entityName = super.determineConcreteSubclassEntityName"
"( entityInstance, factory );\n"
"        }\n"
"        return entityName;\n"
"    }\n"
"\n"
"    ...\n"
"}"

#. Tag: para
#: persistent_classes.xml:379
#, no-c-format
msgid ""
"In order to register an <interfacename>org.hibernate.EntityNameResolver</"
"interfacename> users must either:"
msgstr ""
"为了注册 <interfacename>org.hibernate.EntityNameResolver</interfacename>，用"
"户必须："

#. Tag: para
#: persistent_classes.xml:383
#, fuzzy, no-c-format
msgid ""
"Implement a custom tuplizer (see <xref linkend=\"persistent-classes-tuplizers"
"\"/>), implementing the <methodname>getEntityNameResolvers</methodname> "
"method"
msgstr ""
"实现自定义的 <link linkend=\"persistent-classes-tuplizers\">Tuplizer</link> "
"并实现 <methodname>getEntityNameResolvers</methodname> 方法。"

#. Tag: para
#: persistent_classes.xml:389
#, no-c-format
msgid ""
"Register it with the <classname>org.hibernate.impl.SessionFactoryImpl</"
"classname> (which is the implementation class for <interfacename>org."
"hibernate.SessionFactory</interfacename>) using the "
"<methodname>registerEntityNameResolver</methodname> method."
msgstr ""
"用 <methodname>registerEntityNameResolver</methodname> 方法注册到 "
"<classname>org.hibernate.impl.SessionFactoryImpl</classname>（它是 "
"<interfacename>org.hibernate.SessionFactory</interfacename> 的实现类）。"

#~ msgid ""
#~ "Most Java applications require a persistent class representing felines. "
#~ "For example:"
#~ msgstr "大多数 Java 程序需要用一个持久化类来表示猫科动物。例如："

#~ msgid ""
#~ "<literal>Cat</literal> has a property called <literal>id</literal>. This "
#~ "property maps to the primary key column of a database table. The property "
#~ "might have been called anything, and its type might have been any "
#~ "primitive type, any primitive \"wrapper\" type, <literal>java.lang."
#~ "String</literal> or <literal>java.util.Date</literal>. If your legacy "
#~ "database table has composite keys, you can use a user-defined class with "
#~ "properties of these types (see the section on composite identifiers later "
#~ "in the chapter.)"
#~ msgstr ""
#~ "<literal>Cat</literal> 有一个属性叫做 <literal>id</literal>。这个属性映射"
#~ "数据库表的主 键字段。这个属性可以叫任何名字，其类型可以是任何的原始类型、"
#~ "原始类型的包装类型、 <literal>java.lang.String</literal> 或者是 "
#~ "<literal>java.util.Date</literal>。（如果你的遗留数据库表有联合主键，你甚"
#~ "至可以用一个用户自定义的类，该类拥有这些类型的属性。参见后面的关于联合标识"
#~ "符的章节。）"

#~ msgid ""
#~ "The identifier property is strictly optional. You can leave them off and "
#~ "let Hibernate keep track of object identifiers internally. We do not "
#~ "recommend this, however."
#~ msgstr ""
#~ "标识符属性是可选的。可以不用管它，让 Hibernate 内部来追踪对象的识别。 但是"
#~ "我们并不推荐这样做。"

#~ msgid ""
#~ "In fact, some functionality is available only to classes that declare an "
#~ "identifier property:"
#~ msgstr "实际上，一些功能只对那些声明了标识符属性的类起作用： "

#~ msgid ""
#~ "Transitive reattachment for detached objects (cascade update or cascade "
#~ "merge) - see <xref linkend=\"objectstate-transitive\" />"
#~ msgstr ""
#~ "托管对象的传播性再连接（级联更新或级联合并）- 参阅 <xref linkend="
#~ "\"objectstate-transitive\"/>"

#~ msgid "<literal>Session.saveOrUpdate()</literal>"
#~ msgstr "<literal>Session.saveOrUpdate()</literal> "

#~ msgid "<literal>Session.merge()</literal>"
#~ msgstr "<literal>Session.merge()</literal> "

#~ msgid ""
#~ "A central feature of Hibernate, <emphasis>proxies</emphasis>, depends "
#~ "upon the persistent class being either non-final, or the implementation "
#~ "of an interface that declares all public methods."
#~ msgstr ""
#~ "<emphasis>代理（proxies）</emphasis>是 Hibernate 的一个重要的功能，它依赖"
#~ "的条件是，持久化类或者是非 final 的，或者是实现了一个所有方法都声明为 "
#~ "public 的接口。"

#~ msgid ""
#~ "You can persist <literal>final</literal> classes that do not implement an "
#~ "interface with Hibernate. You will not, however, be able to use proxies "
#~ "for lazy association fetching which will ultimately limit your options "
#~ "for performance tuning."
#~ msgstr ""
#~ "你可以用 Hibernate 持久化一个没有实现任何接口的 <literal>final</literal> "
#~ "类，但是你不能使用代理来延迟关联加载，这会限制你进行性能优化的选择。 "

#~ msgid ""
#~ "There are two high-level types of Tuplizers, represented by the "
#~ "<literal>org.hibernate.tuple.entity.EntityTuplizer</literal> and "
#~ "<literal>org.hibernate.tuple.component.ComponentTuplizer</literal> "
#~ "interfaces. <literal>EntityTuplizer</literal>s are responsible for "
#~ "managing the above mentioned contracts in regards to entities, while "
#~ "<literal>ComponentTuplizer</literal>s do the same for components."
#~ msgstr ""
#~ "有两种高层类型的 Tuplizer，分别由 <literal>org.hibernate.tuple.entity."
#~ "EntityTuplizer</literal> 和 <literal>org.hibernate.tuple.component."
#~ "ComponentTuplizer</literal> 接口代表。<literal>EntityTuplizer</literal> 负"
#~ "责管理和实体相关的上述合约，而<literal>ComponentTuplizer</literal> 则负责"
#~ "组件。"

#~ msgid ""
#~ "<![CDATA[<hibernate-mapping>\n"
#~ "    <class entity-name=\"Customer\">\n"
#~ "        <!--\n"
#~ "            Override the dynamic-map entity-mode\n"
#~ "            tuplizer for the customer entity\n"
#~ "        -->\n"
#~ "        <tuplizer entity-mode=\"dynamic-map\"\n"
#~ "                class=\"CustomMapTuplizerImpl\"/>\n"
#~ "\n"
#~ "        <id name=\"id\" type=\"long\" column=\"ID\">\n"
#~ "            <generator class=\"sequence\"/>\n"
#~ "        </id>\n"
#~ "\n"
#~ "        <!-- other properties -->\n"
#~ "        ...\n"
#~ "    </class>\n"
#~ "</hibernate-mapping>\n"
#~ "\n"
#~ "\n"
#~ "public class CustomMapTuplizerImpl\n"
#~ "        extends org.hibernate.tuple.entity.DynamicMapEntityTuplizer {\n"
#~ "    // override the buildInstantiator() method to plug in our custom "
#~ "map...\n"
#~ "    protected final Instantiator buildInstantiator(\n"
#~ "            org.hibernate.mapping.PersistentClass mappingInfo) {\n"
#~ "        return new CustomMapInstantiator( mappingInfo );\n"
#~ "    }\n"
#~ "\n"
#~ "    private static final class CustomMapInstantiator\n"
#~ "            extends org.hibernate.tuple.DynamicMapInstantitor {\n"
#~ "        // override the generateMap() method to return our custom map...\n"
#~ "            protected final Map generateMap() {\n"
#~ "                    return new CustomMap();\n"
#~ "            }\n"
#~ "    }\n"
#~ "}]]>"
#~ msgstr ""
#~ "<![CDATA[<hibernate-mapping>\n"
#~ "    <class entity-name=\"Customer\">\n"
#~ "        <!--\n"
#~ "            Override the dynamic-map entity-mode\n"
#~ "            tuplizer for the customer entity\n"
#~ "        -->\n"
#~ "        <tuplizer entity-mode=\"dynamic-map\"\n"
#~ "                class=\"CustomMapTuplizerImpl\"/>\n"
#~ "\n"
#~ "        <id name=\"id\" type=\"long\" column=\"ID\">\n"
#~ "            <generator class=\"sequence\"/>\n"
#~ "        </id>\n"
#~ "\n"
#~ "        <!-- other properties -->\n"
#~ "        ...\n"
#~ "    </class>\n"
#~ "</hibernate-mapping>\n"
#~ "\n"
#~ "\n"
#~ "public class CustomMapTuplizerImpl\n"
#~ "        extends org.hibernate.tuple.entity.DynamicMapEntityTuplizer {\n"
#~ "    // override the buildInstantiator() method to plug in our custom "
#~ "map...\n"
#~ "    protected final Instantiator buildInstantiator(\n"
#~ "            org.hibernate.mapping.PersistentClass mappingInfo) {\n"
#~ "        return new CustomMapInstantiator( mappingInfo );\n"
#~ "    }\n"
#~ "\n"
#~ "    private static final class CustomMapInstantiator\n"
#~ "            extends org.hibernate.tuple.DynamicMapInstantitor {\n"
#~ "        // override the generateMap() method to return our custom map...\n"
#~ "            protected final Map generateMap() {\n"
#~ "                    return new CustomMap();\n"
#~ "            }\n"
#~ "    }\n"
#~ "}]]>"
