/*
 * SPDX-License-Identifier: Apache-2.0
 * Copyright Red Hat Inc. and Hibernate Authors
 */

plugins {
    id "local.java-module"
    id "local.publishing"
    id "local.code-quality"
}

// Ideally this should be in `local.java-module.gradle`,
// but we need to skip this in hibernate-gradle-plugin.
def skipJacoco = project.hasProperty('skipJacoco') ? project.getProperty('skipJacoco').toBoolean() : false
if (!skipJacoco) {
    plugins.apply('jacoco')
}

configurations {
    javadocSources {
        description = "All Java sources for the project's Javadoc"
        canBeConsumed = true
        canBeResolved = false
        visible = false
    }
}

dependencies {
    javadocSources sourceSets.main.allJava.filter { file ->
        !(file.path.contains("/internal/")
                || file.path.contains("/org/hibernate/boot/jaxb/")
                || file.path.contains("/org/hibernate/tuple/")
                || file.path.contains("/org/hibernate/grammars/hql/")
        )
    }

    // align artifacts natively when consuming through Gradle
    api platform(project(":hibernate-platform"))
}

def moduleVersionAlignmentDependencies = configurations.dependencyScope("moduleVersionAlignmentDependencies") {
    dependencies.add(project.dependencies.create(project) { transitive = false })
    dependencies.add(project.dependencies.create(project.dependencies.platform(project(":hibernate-platform"))))
}
def moduleVersionAlignment = configurations.resolvable("moduleVersionAlignment") {
    extendsFrom(moduleVersionAlignmentDependencies.get())
}
def verifyModuleVersionAlignment = tasks.register("verifyModuleVersionAlignment") {
    group = "verification"
    description = "Verify module version alignment"

    def rootComponent = moduleVersionAlignment.flatMap {
        it.incoming.getResolutionResult().rootComponent
    }
    def projectPath = project.path

    doLast {
        if (!rootComponent
                .get()
                .dependencies
                .find {
                    it instanceof ResolvedDependencyResult &&
                            it.selected.id instanceof ProjectComponentIdentifier &&
                            it.selected.id.projectPath == ":hibernate-platform"
                }
                .selected
                .dependencies
                .any {
                    it instanceof ResolvedDependencyResult &&
                            it.constraint &&
                            it.selected.id instanceof ProjectComponentIdentifier &&
                            it.selected.id.projectPath == projectPath
                }) {
            throw new GradleException(":hibernate-platform is missing dependency on $projectPath")
        }
    }
}
tasks.named("check") {
    dependsOn(verifyModuleVersionAlignment)
}

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Publishing

var publishingExtension = project.getExtensions().getByType(PublishingExtension) as PublishingExtension
publishingExtension.publications.named("publishedArtifacts", MavenPublication) {
    // Add the Java component to the main publication
    from components.java
}


// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Releasing

def releasePrepareTask = tasks.register("releasePrepare") {
    group = "release"
    description = "See :release:releasePrepare for details.  Here we hook in testing and checks ensure publish-ability"

    dependsOn tasks.check
    dependsOn tasks.generateMetadataFileForPublishedArtifactsPublication
    dependsOn tasks.generatePomFileForPublishedArtifactsPublication
    // we depend on publishAllPublicationsToStagingRepository to make sure that the artifacts are "published" to a local staging directory
    // used by JReleaser during the release process
    dependsOn tasks.publishAllPublicationsToStagingRepository
}

// used from the h2 CI job
tasks.register("preVerifyRelease") {
    group = "release-prepare"
    description = "Delegates to `releasePrepare` task"

    dependsOn releasePrepareTask
}
