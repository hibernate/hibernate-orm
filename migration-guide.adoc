= 6.0 Migration Guide
:toc:

This guide discusses migration from Hibernate ORM version 5.2 to version 6.0.  For migration from
earlier versions, see any other pertinent migration guides as well.

== Background

6.0 introduces major changes, such as:

* refactoring Hibernate's Type contract to unify Hibernate ORM, JPA and SQM type systems
* migration to SQM for query interpretation/representation
** HQL/JPQL
** (JPA) criteria queries

Additionally, `hibernate-envers` has been made part of `hibernate-core` and better integrated
from an API perspective.


== Things that (might) make sense in a boot-only ServiceRegistry

* ClassmateContext
* Jandex/HCANN access
* BasicTypeProducerRegistry

At the moment this is being developed as `org.hibernate.boot.spi.BootstrapContext`.

A general theme to remember is that there are certain things we need during the bootstrap process,
but that we should unequivocally not hold reference to after:

* ClassmateContext
* BasicTypeProducerRegistry
* Jandex IndexView
* HCANN ReflectionManager, ClassLoaderDelegate, etc
* JPA "temp ClassLoader" (and ClassLoaderAccess?)
* Scanning / ArchiveDescriptor delegates
* List<CacheRegionDefinition> (this is an exposed collector)
* List<AttributeConverterDefinition>
* List<AuxiliaryDatabaseObject>

Some of these need to be exposed on the "BootstrapContext", some exposed on the
MetadataBuilder/MetadataBuildingOptions.  Remember though that MetadataBuildingOptions portion
of the MetadataBuilder/MetadataBuildingOptions combo is passed and held on the SessionFactory; so
anything that we should not hold reference to after bootstrap should not be defined on this contract.


== Misc

* removed `org.hibernate.type.TypeHelper` and `org.hibernate.type.TypeResolver`, as well as methods exposing
	access to them.  For the most part, replace with calls to `org.hibernate.Metamodel`
	and/or `org.hibernate.type.spi.TypeConfiguration`.
* removed `org.hibernate.type.TypeFactory` in favor of `TypeConfiguration`
*  I think SqlTypeDescriptor should have some say in determining the JdbcLiteralFormatter to use.  Currently this is
	defined on the mapper Type and the JavaTypeDescriptor.  But really its the fact that its a VARCHAR that dictates
	that a literal should be quoted, e.g.
* Moved `org.hibernate.jpa.event.spi.jpa.ExtendedBeanManager` to `org.hibernate.resource.cdi.spi.ExtendedBeanManager` although
	`org.hibernate.jpa.event.spi.jpa.ExtendedBeanManager` was left in placce as a shadow (deprecated, extending the new
	contract) to ease migrations


== todo

* need to split AttributeConverterDescriptor from AttributeConverterDefinition.  The former is the "bootstrap view" of
	an AttributeConverter, whereas the latter is the runtime view of it.  In the bootstrap view we want to minimize
	access to the AttributeConverter instance (unless we were handed an instance).  Also AttributeConverterDescriptor
	needs to define the shouldAutoApplyToXYZ methods whereas that would not be appropriate for the runtime view.
* merge `org.hibernate.jpa.AvailableSettings` into `org.hibernate.cfg.AvailableSettings`
* design appropriate "keys" into the various "query interpretation" caches based on SQM.
* ideally (perf wise) we'd "build and collect" ParameterMetadata as we build the SQM.  The alternative is to
 	build the SQM and then walk it to "build and collect" ParameterMetadata (extra walk).  This would mean either:
 	** collecting/storing and exposing the parameters on the SqmStatement itself
 	** passing an "ExpressionVisitor" into the SQM interpreter.
* there is really nothing SQM-specific in most of the `org.hibernate.sql.sqm.exec.spi` contracts.  Let's get
	them finished up, clean them up and consider moving to a new `org.hibernate.sql.exec.spi` package.  Much of
	this is usable from NativeQuery as well...