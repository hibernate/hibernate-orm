/*
 * Hibernate, Relational Persistence for Idiomatic Java
 *
 * License: GNU Lesser General Public License (LGPL), version 2.1 or later
 * See the lgpl.txt file in the root directory or http://www.gnu.org/licenses/lgpl-2.1.html
 */
package org.hibernate.orm.tooling.gradle;

import org.gradle.api.Action;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.Task;
import org.gradle.api.file.DirectoryProperty;
import org.gradle.api.plugins.JvmEcosystemPlugin;
import org.gradle.api.tasks.SourceSet;
import org.gradle.api.tasks.TaskProvider;
import org.gradle.api.tasks.compile.AbstractCompile;
import org.gradle.api.tasks.compile.JavaCompile;

import org.hibernate.orm.tooling.gradle.enhance.EnhancementHelper;
import org.hibernate.orm.tooling.gradle.metamodel.JpaMetamodelGenerationTask;

import static org.hibernate.orm.tooling.gradle.Helper.determineCompileSourceSetName;
import static org.hibernate.orm.tooling.gradle.HibernateOrmSpec.HIBERNATE;
import static org.hibernate.orm.tooling.gradle.metamodel.JpaMetamodelGenerationTask.COMPILE_META_TASK_NAME;
import static org.hibernate.orm.tooling.gradle.metamodel.JpaMetamodelGenerationTask.GEN_TASK_NAME;

/**
 * Hibernate ORM Gradle plugin
 */
public class HibernateOrmPlugin implements Plugin<Project> {
	@Override
	public void apply(Project project) {
		// for SourceSet support and other JVM goodies
		project.getPlugins().apply( JvmEcosystemPlugin.class );

		project.getLogger().debug( "Adding Hibernate extensions to the build [{}]", project.getPath() );
		final HibernateOrmSpec ormDsl = project.getExtensions().create( HibernateOrmSpec.DSL_NAME,  HibernateOrmSpec.class, project );

		prepareEnhancement( ormDsl, project );
		prepareModelGen( ormDsl, project );
		prepareHbmTransformation( ormDsl, project );


		//noinspection ConstantConditions
		project.getDependencies().add(
				"implementation",
				ormDsl.getUseSameVersion().map( (use) -> use
						? "org.hibernate.orm:hibernate-core:" + HibernateVersion.version
						: null
				)
		);
	}

	private void prepareEnhancement(HibernateOrmSpec ormDsl, Project project) {
		project.getGradle().getTaskGraph().whenReady( (graph) -> {
			if ( !ormDsl.isEnhancementEnabled() ) {
				return;
			}

			graph.getAllTasks().forEach( (task) -> {
				if ( task instanceof AbstractCompile ) {
					final SourceSet sourceSetLocal = ormDsl.getSourceSet().get();

					final String compiledSourceSetName = determineCompileSourceSetName( task.getName() );
					if ( !sourceSetLocal.getName().equals( compiledSourceSetName ) ) {
						return;
					}

					final AbstractCompile compileTask = (AbstractCompile) task;
					//noinspection Convert2Lambda,NullableProblems
					task.doLast( new Action<>() {
						@Override
						public void execute(Task t) {
							final DirectoryProperty classesDirectory = compileTask.getDestinationDirectory();
							final ClassLoader classLoader = Helper.toClassLoader( sourceSetLocal.getOutput().getClassesDirs() );

							EnhancementHelper.enhance( classesDirectory, classLoader, ormDsl, project );
						}
					} );
				}
			} );
		} );
	}

	private void prepareModelGen(HibernateOrmSpec ormDsl, Project project) {
		final TaskProvider<JavaCompile> modelCompileTaskRef = project.getTasks().register( COMPILE_META_TASK_NAME, JavaCompile.class, (modelCompileTask) -> {
			modelCompileTask.onlyIf( (t) -> ormDsl.isMetamodelGenerationEnabled() );

			modelCompileTask.setGroup( HIBERNATE );
			modelCompileTask.setDescription( "Compiles the JPA static metamodel generated by `" + GEN_TASK_NAME + "`" );
		} );

		project.getTasks().register( GEN_TASK_NAME, JpaMetamodelGenerationTask.class, (genTask) -> {
			genTask.onlyIf( (t) -> ormDsl.isMetamodelGenerationEnabled() );

			if ( !ormDsl.isMetamodelGenerationEnabled() ) {
				return;
			}

			genTask.injectSourceSet( ormDsl.getSourceSet() );
			genTask.getGenerationOutputDirectory().set( ormDsl.getJpaMetamodel().getGenerationOutputDirectory() );

			final JavaCompile modelCompileTask = modelCompileTaskRef.get();

			final SourceSet sourceSet = ormDsl.getSourceSet().get();
			sourceSet.getAllSource().minus( sourceSet.getAllSource() ).forEach( (dir) -> {
				final String language = dir.getName();
				final String languageCompileTaskName = sourceSet.getCompileTaskName( language );
				final AbstractCompile languageCompileTask = (AbstractCompile) project.getTasks().getByName( languageCompileTaskName );
				genTask.dependsOn( languageCompileTask );

				modelCompileTask.setSourceCompatibility( languageCompileTask.getSourceCompatibility() );
				modelCompileTask.setTargetCompatibility( languageCompileTask.getTargetCompatibility() );
				genTask.injectJavaVersion( languageCompileTask.getSourceCompatibility() );

				modelCompileTask.finalizedBy( modelCompileTask );
			} );

			genTask.dependsOn( sourceSet.getProcessResourcesTaskName() );

			genTask.finalizedBy( modelCompileTask );
			modelCompileTask.dependsOn( genTask );
			modelCompileTask.source( project.files( ormDsl.getJpaMetamodel().getGenerationOutputDirectory() ) );
			modelCompileTask.getDestinationDirectory().set( ormDsl.getJpaMetamodel().getCompileOutputDirectory() );

			modelCompileTask.setClasspath(
					project.getConfigurations().getByName( "runtimeClasspath" ).plus( sourceSet.getRuntimeClasspath() )
			);
		} );
	}

	private void prepareHbmTransformation(HibernateOrmSpec ormDsl, Project project) {

	}
}
